// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `webuimessages_steaminput.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CSteamInputService_ControllerButtonStateChanged_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamInputService_ControllerButtonStateChanged_Notification {
    // message fields
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.controller_index)
    pub controller_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.dpad_up)
    pub dpad_up: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.dpad_down)
    pub dpad_down: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.dpad_left)
    pub dpad_left: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.dpad_right)
    pub dpad_right: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.button_south)
    pub button_south: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.button_east)
    pub button_east: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.button_west)
    pub button_west: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.button_north)
    pub button_north: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.button_back_view)
    pub button_back_view: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.button_start_options)
    pub button_start_options: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.button_steam)
    pub button_steam: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.button_quick_access)
    pub button_quick_access: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.button_mute_capture)
    pub button_mute_capture: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.left_stick_click)
    pub left_stick_click: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.left_stick_touch)
    pub left_stick_touch: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.left_stick_deflect)
    pub left_stick_deflect: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.right_stick_click)
    pub right_stick_click: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.right_stick_touch)
    pub right_stick_touch: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.right_stick_deflect)
    pub right_stick_deflect: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.center_trackpad_touch)
    pub center_trackpad_touch: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.center_trackpad_click)
    pub center_trackpad_click: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.left_trackpad_touch)
    pub left_trackpad_touch: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.left_trackpad_click)
    pub left_trackpad_click: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.right_trackpad_touch)
    pub right_trackpad_touch: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.right_trackpad_click)
    pub right_trackpad_click: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.left_bumper)
    pub left_bumper: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.left_trigger)
    pub left_trigger: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.l4)
    pub l4: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.l5)
    pub l5: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.left_aux)
    pub left_aux: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.right_bumper)
    pub right_bumper: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.right_trigger)
    pub right_trigger: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.r4)
    pub r4: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.r5)
    pub r5: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerButtonStateChanged_Notification.right_aux)
    pub right_aux: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamInputService_ControllerButtonStateChanged_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamInputService_ControllerButtonStateChanged_Notification {
    fn default() -> &'a CSteamInputService_ControllerButtonStateChanged_Notification {
        <CSteamInputService_ControllerButtonStateChanged_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSteamInputService_ControllerButtonStateChanged_Notification {
    pub fn new() -> CSteamInputService_ControllerButtonStateChanged_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 controller_index = 1;

    pub fn controller_index(&self) -> u32 {
        self.controller_index.unwrap_or(0)
    }

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: u32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    // optional bool dpad_up = 2;

    pub fn dpad_up(&self) -> bool {
        self.dpad_up.unwrap_or(false)
    }

    pub fn clear_dpad_up(&mut self) {
        self.dpad_up = ::std::option::Option::None;
    }

    pub fn has_dpad_up(&self) -> bool {
        self.dpad_up.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpad_up(&mut self, v: bool) {
        self.dpad_up = ::std::option::Option::Some(v);
    }

    // optional bool dpad_down = 3;

    pub fn dpad_down(&self) -> bool {
        self.dpad_down.unwrap_or(false)
    }

    pub fn clear_dpad_down(&mut self) {
        self.dpad_down = ::std::option::Option::None;
    }

    pub fn has_dpad_down(&self) -> bool {
        self.dpad_down.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpad_down(&mut self, v: bool) {
        self.dpad_down = ::std::option::Option::Some(v);
    }

    // optional bool dpad_left = 4;

    pub fn dpad_left(&self) -> bool {
        self.dpad_left.unwrap_or(false)
    }

    pub fn clear_dpad_left(&mut self) {
        self.dpad_left = ::std::option::Option::None;
    }

    pub fn has_dpad_left(&self) -> bool {
        self.dpad_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpad_left(&mut self, v: bool) {
        self.dpad_left = ::std::option::Option::Some(v);
    }

    // optional bool dpad_right = 5;

    pub fn dpad_right(&self) -> bool {
        self.dpad_right.unwrap_or(false)
    }

    pub fn clear_dpad_right(&mut self) {
        self.dpad_right = ::std::option::Option::None;
    }

    pub fn has_dpad_right(&self) -> bool {
        self.dpad_right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dpad_right(&mut self, v: bool) {
        self.dpad_right = ::std::option::Option::Some(v);
    }

    // optional bool button_south = 6;

    pub fn button_south(&self) -> bool {
        self.button_south.unwrap_or(false)
    }

    pub fn clear_button_south(&mut self) {
        self.button_south = ::std::option::Option::None;
    }

    pub fn has_button_south(&self) -> bool {
        self.button_south.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button_south(&mut self, v: bool) {
        self.button_south = ::std::option::Option::Some(v);
    }

    // optional bool button_east = 7;

    pub fn button_east(&self) -> bool {
        self.button_east.unwrap_or(false)
    }

    pub fn clear_button_east(&mut self) {
        self.button_east = ::std::option::Option::None;
    }

    pub fn has_button_east(&self) -> bool {
        self.button_east.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button_east(&mut self, v: bool) {
        self.button_east = ::std::option::Option::Some(v);
    }

    // optional bool button_west = 8;

    pub fn button_west(&self) -> bool {
        self.button_west.unwrap_or(false)
    }

    pub fn clear_button_west(&mut self) {
        self.button_west = ::std::option::Option::None;
    }

    pub fn has_button_west(&self) -> bool {
        self.button_west.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button_west(&mut self, v: bool) {
        self.button_west = ::std::option::Option::Some(v);
    }

    // optional bool button_north = 9;

    pub fn button_north(&self) -> bool {
        self.button_north.unwrap_or(false)
    }

    pub fn clear_button_north(&mut self) {
        self.button_north = ::std::option::Option::None;
    }

    pub fn has_button_north(&self) -> bool {
        self.button_north.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button_north(&mut self, v: bool) {
        self.button_north = ::std::option::Option::Some(v);
    }

    // optional bool button_back_view = 10;

    pub fn button_back_view(&self) -> bool {
        self.button_back_view.unwrap_or(false)
    }

    pub fn clear_button_back_view(&mut self) {
        self.button_back_view = ::std::option::Option::None;
    }

    pub fn has_button_back_view(&self) -> bool {
        self.button_back_view.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button_back_view(&mut self, v: bool) {
        self.button_back_view = ::std::option::Option::Some(v);
    }

    // optional bool button_start_options = 11;

    pub fn button_start_options(&self) -> bool {
        self.button_start_options.unwrap_or(false)
    }

    pub fn clear_button_start_options(&mut self) {
        self.button_start_options = ::std::option::Option::None;
    }

    pub fn has_button_start_options(&self) -> bool {
        self.button_start_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button_start_options(&mut self, v: bool) {
        self.button_start_options = ::std::option::Option::Some(v);
    }

    // optional bool button_steam = 12;

    pub fn button_steam(&self) -> bool {
        self.button_steam.unwrap_or(false)
    }

    pub fn clear_button_steam(&mut self) {
        self.button_steam = ::std::option::Option::None;
    }

    pub fn has_button_steam(&self) -> bool {
        self.button_steam.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button_steam(&mut self, v: bool) {
        self.button_steam = ::std::option::Option::Some(v);
    }

    // optional bool button_quick_access = 13;

    pub fn button_quick_access(&self) -> bool {
        self.button_quick_access.unwrap_or(false)
    }

    pub fn clear_button_quick_access(&mut self) {
        self.button_quick_access = ::std::option::Option::None;
    }

    pub fn has_button_quick_access(&self) -> bool {
        self.button_quick_access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button_quick_access(&mut self, v: bool) {
        self.button_quick_access = ::std::option::Option::Some(v);
    }

    // optional bool button_mute_capture = 14;

    pub fn button_mute_capture(&self) -> bool {
        self.button_mute_capture.unwrap_or(false)
    }

    pub fn clear_button_mute_capture(&mut self) {
        self.button_mute_capture = ::std::option::Option::None;
    }

    pub fn has_button_mute_capture(&self) -> bool {
        self.button_mute_capture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button_mute_capture(&mut self, v: bool) {
        self.button_mute_capture = ::std::option::Option::Some(v);
    }

    // optional bool left_stick_click = 15;

    pub fn left_stick_click(&self) -> bool {
        self.left_stick_click.unwrap_or(false)
    }

    pub fn clear_left_stick_click(&mut self) {
        self.left_stick_click = ::std::option::Option::None;
    }

    pub fn has_left_stick_click(&self) -> bool {
        self.left_stick_click.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_stick_click(&mut self, v: bool) {
        self.left_stick_click = ::std::option::Option::Some(v);
    }

    // optional bool left_stick_touch = 16;

    pub fn left_stick_touch(&self) -> bool {
        self.left_stick_touch.unwrap_or(false)
    }

    pub fn clear_left_stick_touch(&mut self) {
        self.left_stick_touch = ::std::option::Option::None;
    }

    pub fn has_left_stick_touch(&self) -> bool {
        self.left_stick_touch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_stick_touch(&mut self, v: bool) {
        self.left_stick_touch = ::std::option::Option::Some(v);
    }

    // optional bool left_stick_deflect = 17;

    pub fn left_stick_deflect(&self) -> bool {
        self.left_stick_deflect.unwrap_or(false)
    }

    pub fn clear_left_stick_deflect(&mut self) {
        self.left_stick_deflect = ::std::option::Option::None;
    }

    pub fn has_left_stick_deflect(&self) -> bool {
        self.left_stick_deflect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_stick_deflect(&mut self, v: bool) {
        self.left_stick_deflect = ::std::option::Option::Some(v);
    }

    // optional bool right_stick_click = 18;

    pub fn right_stick_click(&self) -> bool {
        self.right_stick_click.unwrap_or(false)
    }

    pub fn clear_right_stick_click(&mut self) {
        self.right_stick_click = ::std::option::Option::None;
    }

    pub fn has_right_stick_click(&self) -> bool {
        self.right_stick_click.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right_stick_click(&mut self, v: bool) {
        self.right_stick_click = ::std::option::Option::Some(v);
    }

    // optional bool right_stick_touch = 19;

    pub fn right_stick_touch(&self) -> bool {
        self.right_stick_touch.unwrap_or(false)
    }

    pub fn clear_right_stick_touch(&mut self) {
        self.right_stick_touch = ::std::option::Option::None;
    }

    pub fn has_right_stick_touch(&self) -> bool {
        self.right_stick_touch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right_stick_touch(&mut self, v: bool) {
        self.right_stick_touch = ::std::option::Option::Some(v);
    }

    // optional bool right_stick_deflect = 20;

    pub fn right_stick_deflect(&self) -> bool {
        self.right_stick_deflect.unwrap_or(false)
    }

    pub fn clear_right_stick_deflect(&mut self) {
        self.right_stick_deflect = ::std::option::Option::None;
    }

    pub fn has_right_stick_deflect(&self) -> bool {
        self.right_stick_deflect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right_stick_deflect(&mut self, v: bool) {
        self.right_stick_deflect = ::std::option::Option::Some(v);
    }

    // optional bool center_trackpad_touch = 21;

    pub fn center_trackpad_touch(&self) -> bool {
        self.center_trackpad_touch.unwrap_or(false)
    }

    pub fn clear_center_trackpad_touch(&mut self) {
        self.center_trackpad_touch = ::std::option::Option::None;
    }

    pub fn has_center_trackpad_touch(&self) -> bool {
        self.center_trackpad_touch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_center_trackpad_touch(&mut self, v: bool) {
        self.center_trackpad_touch = ::std::option::Option::Some(v);
    }

    // optional bool center_trackpad_click = 22;

    pub fn center_trackpad_click(&self) -> bool {
        self.center_trackpad_click.unwrap_or(false)
    }

    pub fn clear_center_trackpad_click(&mut self) {
        self.center_trackpad_click = ::std::option::Option::None;
    }

    pub fn has_center_trackpad_click(&self) -> bool {
        self.center_trackpad_click.is_some()
    }

    // Param is passed by value, moved
    pub fn set_center_trackpad_click(&mut self, v: bool) {
        self.center_trackpad_click = ::std::option::Option::Some(v);
    }

    // optional bool left_trackpad_touch = 23;

    pub fn left_trackpad_touch(&self) -> bool {
        self.left_trackpad_touch.unwrap_or(false)
    }

    pub fn clear_left_trackpad_touch(&mut self) {
        self.left_trackpad_touch = ::std::option::Option::None;
    }

    pub fn has_left_trackpad_touch(&self) -> bool {
        self.left_trackpad_touch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_trackpad_touch(&mut self, v: bool) {
        self.left_trackpad_touch = ::std::option::Option::Some(v);
    }

    // optional bool left_trackpad_click = 24;

    pub fn left_trackpad_click(&self) -> bool {
        self.left_trackpad_click.unwrap_or(false)
    }

    pub fn clear_left_trackpad_click(&mut self) {
        self.left_trackpad_click = ::std::option::Option::None;
    }

    pub fn has_left_trackpad_click(&self) -> bool {
        self.left_trackpad_click.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_trackpad_click(&mut self, v: bool) {
        self.left_trackpad_click = ::std::option::Option::Some(v);
    }

    // optional bool right_trackpad_touch = 25;

    pub fn right_trackpad_touch(&self) -> bool {
        self.right_trackpad_touch.unwrap_or(false)
    }

    pub fn clear_right_trackpad_touch(&mut self) {
        self.right_trackpad_touch = ::std::option::Option::None;
    }

    pub fn has_right_trackpad_touch(&self) -> bool {
        self.right_trackpad_touch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right_trackpad_touch(&mut self, v: bool) {
        self.right_trackpad_touch = ::std::option::Option::Some(v);
    }

    // optional bool right_trackpad_click = 26;

    pub fn right_trackpad_click(&self) -> bool {
        self.right_trackpad_click.unwrap_or(false)
    }

    pub fn clear_right_trackpad_click(&mut self) {
        self.right_trackpad_click = ::std::option::Option::None;
    }

    pub fn has_right_trackpad_click(&self) -> bool {
        self.right_trackpad_click.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right_trackpad_click(&mut self, v: bool) {
        self.right_trackpad_click = ::std::option::Option::Some(v);
    }

    // optional bool left_bumper = 27;

    pub fn left_bumper(&self) -> bool {
        self.left_bumper.unwrap_or(false)
    }

    pub fn clear_left_bumper(&mut self) {
        self.left_bumper = ::std::option::Option::None;
    }

    pub fn has_left_bumper(&self) -> bool {
        self.left_bumper.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_bumper(&mut self, v: bool) {
        self.left_bumper = ::std::option::Option::Some(v);
    }

    // optional bool left_trigger = 28;

    pub fn left_trigger(&self) -> bool {
        self.left_trigger.unwrap_or(false)
    }

    pub fn clear_left_trigger(&mut self) {
        self.left_trigger = ::std::option::Option::None;
    }

    pub fn has_left_trigger(&self) -> bool {
        self.left_trigger.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_trigger(&mut self, v: bool) {
        self.left_trigger = ::std::option::Option::Some(v);
    }

    // optional bool l4 = 29;

    pub fn l4(&self) -> bool {
        self.l4.unwrap_or(false)
    }

    pub fn clear_l4(&mut self) {
        self.l4 = ::std::option::Option::None;
    }

    pub fn has_l4(&self) -> bool {
        self.l4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l4(&mut self, v: bool) {
        self.l4 = ::std::option::Option::Some(v);
    }

    // optional bool l5 = 30;

    pub fn l5(&self) -> bool {
        self.l5.unwrap_or(false)
    }

    pub fn clear_l5(&mut self) {
        self.l5 = ::std::option::Option::None;
    }

    pub fn has_l5(&self) -> bool {
        self.l5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l5(&mut self, v: bool) {
        self.l5 = ::std::option::Option::Some(v);
    }

    // optional bool left_aux = 31;

    pub fn left_aux(&self) -> bool {
        self.left_aux.unwrap_or(false)
    }

    pub fn clear_left_aux(&mut self) {
        self.left_aux = ::std::option::Option::None;
    }

    pub fn has_left_aux(&self) -> bool {
        self.left_aux.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_aux(&mut self, v: bool) {
        self.left_aux = ::std::option::Option::Some(v);
    }

    // optional bool right_bumper = 32;

    pub fn right_bumper(&self) -> bool {
        self.right_bumper.unwrap_or(false)
    }

    pub fn clear_right_bumper(&mut self) {
        self.right_bumper = ::std::option::Option::None;
    }

    pub fn has_right_bumper(&self) -> bool {
        self.right_bumper.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right_bumper(&mut self, v: bool) {
        self.right_bumper = ::std::option::Option::Some(v);
    }

    // optional bool right_trigger = 33;

    pub fn right_trigger(&self) -> bool {
        self.right_trigger.unwrap_or(false)
    }

    pub fn clear_right_trigger(&mut self) {
        self.right_trigger = ::std::option::Option::None;
    }

    pub fn has_right_trigger(&self) -> bool {
        self.right_trigger.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right_trigger(&mut self, v: bool) {
        self.right_trigger = ::std::option::Option::Some(v);
    }

    // optional bool r4 = 34;

    pub fn r4(&self) -> bool {
        self.r4.unwrap_or(false)
    }

    pub fn clear_r4(&mut self) {
        self.r4 = ::std::option::Option::None;
    }

    pub fn has_r4(&self) -> bool {
        self.r4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_r4(&mut self, v: bool) {
        self.r4 = ::std::option::Option::Some(v);
    }

    // optional bool r5 = 35;

    pub fn r5(&self) -> bool {
        self.r5.unwrap_or(false)
    }

    pub fn clear_r5(&mut self) {
        self.r5 = ::std::option::Option::None;
    }

    pub fn has_r5(&self) -> bool {
        self.r5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_r5(&mut self, v: bool) {
        self.r5 = ::std::option::Option::Some(v);
    }

    // optional bool right_aux = 36;

    pub fn right_aux(&self) -> bool {
        self.right_aux.unwrap_or(false)
    }

    pub fn clear_right_aux(&mut self) {
        self.right_aux = ::std::option::Option::None;
    }

    pub fn has_right_aux(&self) -> bool {
        self.right_aux.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right_aux(&mut self, v: bool) {
        self.right_aux = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSteamInputService_ControllerButtonStateChanged_Notification {
    const NAME: &'static str = "CSteamInputService_ControllerButtonStateChanged_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.controller_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.dpad_up = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.dpad_down = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.dpad_left = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.dpad_right = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.button_south = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.button_east = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.button_west = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.button_north = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.button_back_view = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.button_start_options = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.button_steam = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.button_quick_access = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.button_mute_capture = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.left_stick_click = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.left_stick_touch = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.left_stick_deflect = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.right_stick_click = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.right_stick_touch = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.right_stick_deflect = ::std::option::Option::Some(is.read_bool()?);
                },
                168 => {
                    self.center_trackpad_touch = ::std::option::Option::Some(is.read_bool()?);
                },
                176 => {
                    self.center_trackpad_click = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.left_trackpad_touch = ::std::option::Option::Some(is.read_bool()?);
                },
                192 => {
                    self.left_trackpad_click = ::std::option::Option::Some(is.read_bool()?);
                },
                200 => {
                    self.right_trackpad_touch = ::std::option::Option::Some(is.read_bool()?);
                },
                208 => {
                    self.right_trackpad_click = ::std::option::Option::Some(is.read_bool()?);
                },
                216 => {
                    self.left_bumper = ::std::option::Option::Some(is.read_bool()?);
                },
                224 => {
                    self.left_trigger = ::std::option::Option::Some(is.read_bool()?);
                },
                232 => {
                    self.l4 = ::std::option::Option::Some(is.read_bool()?);
                },
                240 => {
                    self.l5 = ::std::option::Option::Some(is.read_bool()?);
                },
                248 => {
                    self.left_aux = ::std::option::Option::Some(is.read_bool()?);
                },
                256 => {
                    self.right_bumper = ::std::option::Option::Some(is.read_bool()?);
                },
                264 => {
                    self.right_trigger = ::std::option::Option::Some(is.read_bool()?);
                },
                272 => {
                    self.r4 = ::std::option::Option::Some(is.read_bool()?);
                },
                280 => {
                    self.r5 = ::std::option::Option::Some(is.read_bool()?);
                },
                288 => {
                    self.right_aux = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.dpad_up {
            my_size += 1 + 1;
        }
        if let Some(v) = self.dpad_down {
            my_size += 1 + 1;
        }
        if let Some(v) = self.dpad_left {
            my_size += 1 + 1;
        }
        if let Some(v) = self.dpad_right {
            my_size += 1 + 1;
        }
        if let Some(v) = self.button_south {
            my_size += 1 + 1;
        }
        if let Some(v) = self.button_east {
            my_size += 1 + 1;
        }
        if let Some(v) = self.button_west {
            my_size += 1 + 1;
        }
        if let Some(v) = self.button_north {
            my_size += 1 + 1;
        }
        if let Some(v) = self.button_back_view {
            my_size += 1 + 1;
        }
        if let Some(v) = self.button_start_options {
            my_size += 1 + 1;
        }
        if let Some(v) = self.button_steam {
            my_size += 1 + 1;
        }
        if let Some(v) = self.button_quick_access {
            my_size += 1 + 1;
        }
        if let Some(v) = self.button_mute_capture {
            my_size += 1 + 1;
        }
        if let Some(v) = self.left_stick_click {
            my_size += 1 + 1;
        }
        if let Some(v) = self.left_stick_touch {
            my_size += 2 + 1;
        }
        if let Some(v) = self.left_stick_deflect {
            my_size += 2 + 1;
        }
        if let Some(v) = self.right_stick_click {
            my_size += 2 + 1;
        }
        if let Some(v) = self.right_stick_touch {
            my_size += 2 + 1;
        }
        if let Some(v) = self.right_stick_deflect {
            my_size += 2 + 1;
        }
        if let Some(v) = self.center_trackpad_touch {
            my_size += 2 + 1;
        }
        if let Some(v) = self.center_trackpad_click {
            my_size += 2 + 1;
        }
        if let Some(v) = self.left_trackpad_touch {
            my_size += 2 + 1;
        }
        if let Some(v) = self.left_trackpad_click {
            my_size += 2 + 1;
        }
        if let Some(v) = self.right_trackpad_touch {
            my_size += 2 + 1;
        }
        if let Some(v) = self.right_trackpad_click {
            my_size += 2 + 1;
        }
        if let Some(v) = self.left_bumper {
            my_size += 2 + 1;
        }
        if let Some(v) = self.left_trigger {
            my_size += 2 + 1;
        }
        if let Some(v) = self.l4 {
            my_size += 2 + 1;
        }
        if let Some(v) = self.l5 {
            my_size += 2 + 1;
        }
        if let Some(v) = self.left_aux {
            my_size += 2 + 1;
        }
        if let Some(v) = self.right_bumper {
            my_size += 2 + 1;
        }
        if let Some(v) = self.right_trigger {
            my_size += 2 + 1;
        }
        if let Some(v) = self.r4 {
            my_size += 2 + 1;
        }
        if let Some(v) = self.r5 {
            my_size += 2 + 1;
        }
        if let Some(v) = self.right_aux {
            my_size += 2 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.controller_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.dpad_up {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.dpad_down {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.dpad_left {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.dpad_right {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.button_south {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.button_east {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.button_west {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.button_north {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.button_back_view {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.button_start_options {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.button_steam {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.button_quick_access {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.button_mute_capture {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.left_stick_click {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.left_stick_touch {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.left_stick_deflect {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.right_stick_click {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.right_stick_touch {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.right_stick_deflect {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.center_trackpad_touch {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.center_trackpad_click {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.left_trackpad_touch {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.left_trackpad_click {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.right_trackpad_touch {
            os.write_bool(25, v)?;
        }
        if let Some(v) = self.right_trackpad_click {
            os.write_bool(26, v)?;
        }
        if let Some(v) = self.left_bumper {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.left_trigger {
            os.write_bool(28, v)?;
        }
        if let Some(v) = self.l4 {
            os.write_bool(29, v)?;
        }
        if let Some(v) = self.l5 {
            os.write_bool(30, v)?;
        }
        if let Some(v) = self.left_aux {
            os.write_bool(31, v)?;
        }
        if let Some(v) = self.right_bumper {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.right_trigger {
            os.write_bool(33, v)?;
        }
        if let Some(v) = self.r4 {
            os.write_bool(34, v)?;
        }
        if let Some(v) = self.r5 {
            os.write_bool(35, v)?;
        }
        if let Some(v) = self.right_aux {
            os.write_bool(36, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamInputService_ControllerButtonStateChanged_Notification {
        CSteamInputService_ControllerButtonStateChanged_Notification::new()
    }

    fn clear(&mut self) {
        self.controller_index = ::std::option::Option::None;
        self.dpad_up = ::std::option::Option::None;
        self.dpad_down = ::std::option::Option::None;
        self.dpad_left = ::std::option::Option::None;
        self.dpad_right = ::std::option::Option::None;
        self.button_south = ::std::option::Option::None;
        self.button_east = ::std::option::Option::None;
        self.button_west = ::std::option::Option::None;
        self.button_north = ::std::option::Option::None;
        self.button_back_view = ::std::option::Option::None;
        self.button_start_options = ::std::option::Option::None;
        self.button_steam = ::std::option::Option::None;
        self.button_quick_access = ::std::option::Option::None;
        self.button_mute_capture = ::std::option::Option::None;
        self.left_stick_click = ::std::option::Option::None;
        self.left_stick_touch = ::std::option::Option::None;
        self.left_stick_deflect = ::std::option::Option::None;
        self.right_stick_click = ::std::option::Option::None;
        self.right_stick_touch = ::std::option::Option::None;
        self.right_stick_deflect = ::std::option::Option::None;
        self.center_trackpad_touch = ::std::option::Option::None;
        self.center_trackpad_click = ::std::option::Option::None;
        self.left_trackpad_touch = ::std::option::Option::None;
        self.left_trackpad_click = ::std::option::Option::None;
        self.right_trackpad_touch = ::std::option::Option::None;
        self.right_trackpad_click = ::std::option::Option::None;
        self.left_bumper = ::std::option::Option::None;
        self.left_trigger = ::std::option::Option::None;
        self.l4 = ::std::option::Option::None;
        self.l5 = ::std::option::Option::None;
        self.left_aux = ::std::option::Option::None;
        self.right_bumper = ::std::option::Option::None;
        self.right_trigger = ::std::option::Option::None;
        self.r4 = ::std::option::Option::None;
        self.r5 = ::std::option::Option::None;
        self.right_aux = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamInputService_ControllerButtonStateChanged_Notification {
        static instance: CSteamInputService_ControllerButtonStateChanged_Notification = CSteamInputService_ControllerButtonStateChanged_Notification {
            controller_index: ::std::option::Option::None,
            dpad_up: ::std::option::Option::None,
            dpad_down: ::std::option::Option::None,
            dpad_left: ::std::option::Option::None,
            dpad_right: ::std::option::Option::None,
            button_south: ::std::option::Option::None,
            button_east: ::std::option::Option::None,
            button_west: ::std::option::Option::None,
            button_north: ::std::option::Option::None,
            button_back_view: ::std::option::Option::None,
            button_start_options: ::std::option::Option::None,
            button_steam: ::std::option::Option::None,
            button_quick_access: ::std::option::Option::None,
            button_mute_capture: ::std::option::Option::None,
            left_stick_click: ::std::option::Option::None,
            left_stick_touch: ::std::option::Option::None,
            left_stick_deflect: ::std::option::Option::None,
            right_stick_click: ::std::option::Option::None,
            right_stick_touch: ::std::option::Option::None,
            right_stick_deflect: ::std::option::Option::None,
            center_trackpad_touch: ::std::option::Option::None,
            center_trackpad_click: ::std::option::Option::None,
            left_trackpad_touch: ::std::option::Option::None,
            left_trackpad_click: ::std::option::Option::None,
            right_trackpad_touch: ::std::option::Option::None,
            right_trackpad_click: ::std::option::Option::None,
            left_bumper: ::std::option::Option::None,
            left_trigger: ::std::option::Option::None,
            l4: ::std::option::Option::None,
            l5: ::std::option::Option::None,
            left_aux: ::std::option::Option::None,
            right_bumper: ::std::option::Option::None,
            right_trigger: ::std::option::Option::None,
            r4: ::std::option::Option::None,
            r5: ::std::option::Option::None,
            right_aux: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:ControllerVector2)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ControllerVector2 {
    // message fields
    // @@protoc_insertion_point(field:ControllerVector2.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:ControllerVector2.y)
    pub y: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:ControllerVector2.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ControllerVector2 {
    fn default() -> &'a ControllerVector2 {
        <ControllerVector2 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl ControllerVector2 {
    pub fn new() -> ControllerVector2 {
        ::std::default::Default::default()
    }

    // optional float x = 1;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 2;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for ControllerVector2 {
    const NAME: &'static str = "ControllerVector2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ControllerVector2 {
        ControllerVector2::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ControllerVector2 {
        static instance: ControllerVector2 = ControllerVector2 {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:ControllerVector3)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ControllerVector3 {
    // message fields
    // @@protoc_insertion_point(field:ControllerVector3.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:ControllerVector3.y)
    pub y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:ControllerVector3.z)
    pub z: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:ControllerVector3.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ControllerVector3 {
    fn default() -> &'a ControllerVector3 {
        <ControllerVector3 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl ControllerVector3 {
    pub fn new() -> ControllerVector3 {
        ::std::default::Default::default()
    }

    // optional float x = 1;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 2;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional float z = 3;

    pub fn z(&self) -> f32 {
        self.z.unwrap_or(0.)
    }

    pub fn clear_z(&mut self) {
        self.z = ::std::option::Option::None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for ControllerVector3 {
    const NAME: &'static str = "ControllerVector3";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.z = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.z {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.z {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ControllerVector3 {
        ControllerVector3::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ControllerVector3 {
        static instance: ControllerVector3 = ControllerVector3 {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            z: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:ControllerQuaternion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ControllerQuaternion {
    // message fields
    // @@protoc_insertion_point(field:ControllerQuaternion.w)
    pub w: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:ControllerQuaternion.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:ControllerQuaternion.y)
    pub y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:ControllerQuaternion.z)
    pub z: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:ControllerQuaternion.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ControllerQuaternion {
    fn default() -> &'a ControllerQuaternion {
        <ControllerQuaternion as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl ControllerQuaternion {
    pub fn new() -> ControllerQuaternion {
        ::std::default::Default::default()
    }

    // optional float w = 1;

    pub fn w(&self) -> f32 {
        self.w.unwrap_or(0.)
    }

    pub fn clear_w(&mut self) {
        self.w = ::std::option::Option::None;
    }

    pub fn has_w(&self) -> bool {
        self.w.is_some()
    }

    // Param is passed by value, moved
    pub fn set_w(&mut self, v: f32) {
        self.w = ::std::option::Option::Some(v);
    }

    // optional float x = 2;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 3;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional float z = 4;

    pub fn z(&self) -> f32 {
        self.z.unwrap_or(0.)
    }

    pub fn clear_z(&mut self) {
        self.z = ::std::option::Option::None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for ControllerQuaternion {
    const NAME: &'static str = "ControllerQuaternion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.w = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.z = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.w {
            my_size += 1 + 4;
        }
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.z {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.w {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.z {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ControllerQuaternion {
        ControllerQuaternion::new()
    }

    fn clear(&mut self) {
        self.w = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ControllerQuaternion {
        static instance: ControllerQuaternion = ControllerQuaternion {
            w: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            z: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:ControllerGyroEulerAngles)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ControllerGyroEulerAngles {
    // message fields
    // @@protoc_insertion_point(field:ControllerGyroEulerAngles.pitch)
    pub pitch: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:ControllerGyroEulerAngles.yaw)
    pub yaw: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:ControllerGyroEulerAngles.roll)
    pub roll: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:ControllerGyroEulerAngles.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ControllerGyroEulerAngles {
    fn default() -> &'a ControllerGyroEulerAngles {
        <ControllerGyroEulerAngles as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl ControllerGyroEulerAngles {
    pub fn new() -> ControllerGyroEulerAngles {
        ::std::default::Default::default()
    }

    // optional float pitch = 1;

    pub fn pitch(&self) -> f32 {
        self.pitch.unwrap_or(0.)
    }

    pub fn clear_pitch(&mut self) {
        self.pitch = ::std::option::Option::None;
    }

    pub fn has_pitch(&self) -> bool {
        self.pitch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pitch(&mut self, v: f32) {
        self.pitch = ::std::option::Option::Some(v);
    }

    // optional float yaw = 2;

    pub fn yaw(&self) -> f32 {
        self.yaw.unwrap_or(0.)
    }

    pub fn clear_yaw(&mut self) {
        self.yaw = ::std::option::Option::None;
    }

    pub fn has_yaw(&self) -> bool {
        self.yaw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_yaw(&mut self, v: f32) {
        self.yaw = ::std::option::Option::Some(v);
    }

    // optional float roll = 3;

    pub fn roll(&self) -> f32 {
        self.roll.unwrap_or(0.)
    }

    pub fn clear_roll(&mut self) {
        self.roll = ::std::option::Option::None;
    }

    pub fn has_roll(&self) -> bool {
        self.roll.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roll(&mut self, v: f32) {
        self.roll = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for ControllerGyroEulerAngles {
    const NAME: &'static str = "ControllerGyroEulerAngles";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.pitch = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.yaw = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.roll = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pitch {
            my_size += 1 + 4;
        }
        if let Some(v) = self.yaw {
            my_size += 1 + 4;
        }
        if let Some(v) = self.roll {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.pitch {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.yaw {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.roll {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ControllerGyroEulerAngles {
        ControllerGyroEulerAngles::new()
    }

    fn clear(&mut self) {
        self.pitch = ::std::option::Option::None;
        self.yaw = ::std::option::Option::None;
        self.roll = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ControllerGyroEulerAngles {
        static instance: ControllerGyroEulerAngles = ControllerGyroEulerAngles {
            pitch: ::std::option::Option::None,
            yaw: ::std::option::Option::None,
            roll: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamInputService_ControllerAxesStateChange_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamInputService_ControllerAxesStateChange_Notification {
    // message fields
    // @@protoc_insertion_point(field:CSteamInputService_ControllerAxesStateChange_Notification.controller_index)
    pub controller_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerAxesStateChange_Notification.joystick_left)
    pub joystick_left: ::steam_vent_proto_common::protobuf::MessageField<ControllerVector2>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerAxesStateChange_Notification.joystick_right)
    pub joystick_right: ::steam_vent_proto_common::protobuf::MessageField<ControllerVector2>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerAxesStateChange_Notification.trackpad_left)
    pub trackpad_left: ::steam_vent_proto_common::protobuf::MessageField<ControllerVector2>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerAxesStateChange_Notification.trackpad_right)
    pub trackpad_right: ::steam_vent_proto_common::protobuf::MessageField<ControllerVector2>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerAxesStateChange_Notification.trackpad_center)
    pub trackpad_center: ::steam_vent_proto_common::protobuf::MessageField<ControllerVector2>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerAxesStateChange_Notification.trackpad_pressure_left)
    pub trackpad_pressure_left: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerAxesStateChange_Notification.trackpad_pressure_right)
    pub trackpad_pressure_right: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerAxesStateChange_Notification.trigger_left)
    pub trigger_left: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerAxesStateChange_Notification.trigger_right)
    pub trigger_right: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamInputService_ControllerAxesStateChange_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamInputService_ControllerAxesStateChange_Notification {
    fn default() -> &'a CSteamInputService_ControllerAxesStateChange_Notification {
        <CSteamInputService_ControllerAxesStateChange_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSteamInputService_ControllerAxesStateChange_Notification {
    pub fn new() -> CSteamInputService_ControllerAxesStateChange_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 controller_index = 1;

    pub fn controller_index(&self) -> u32 {
        self.controller_index.unwrap_or(0)
    }

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: u32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    // optional float trackpad_pressure_left = 7;

    pub fn trackpad_pressure_left(&self) -> f32 {
        self.trackpad_pressure_left.unwrap_or(0.)
    }

    pub fn clear_trackpad_pressure_left(&mut self) {
        self.trackpad_pressure_left = ::std::option::Option::None;
    }

    pub fn has_trackpad_pressure_left(&self) -> bool {
        self.trackpad_pressure_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trackpad_pressure_left(&mut self, v: f32) {
        self.trackpad_pressure_left = ::std::option::Option::Some(v);
    }

    // optional float trackpad_pressure_right = 8;

    pub fn trackpad_pressure_right(&self) -> f32 {
        self.trackpad_pressure_right.unwrap_or(0.)
    }

    pub fn clear_trackpad_pressure_right(&mut self) {
        self.trackpad_pressure_right = ::std::option::Option::None;
    }

    pub fn has_trackpad_pressure_right(&self) -> bool {
        self.trackpad_pressure_right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trackpad_pressure_right(&mut self, v: f32) {
        self.trackpad_pressure_right = ::std::option::Option::Some(v);
    }

    // optional float trigger_left = 9;

    pub fn trigger_left(&self) -> f32 {
        self.trigger_left.unwrap_or(0.)
    }

    pub fn clear_trigger_left(&mut self) {
        self.trigger_left = ::std::option::Option::None;
    }

    pub fn has_trigger_left(&self) -> bool {
        self.trigger_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trigger_left(&mut self, v: f32) {
        self.trigger_left = ::std::option::Option::Some(v);
    }

    // optional float trigger_right = 10;

    pub fn trigger_right(&self) -> f32 {
        self.trigger_right.unwrap_or(0.)
    }

    pub fn clear_trigger_right(&mut self) {
        self.trigger_right = ::std::option::Option::None;
    }

    pub fn has_trigger_right(&self) -> bool {
        self.trigger_right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trigger_right(&mut self, v: f32) {
        self.trigger_right = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSteamInputService_ControllerAxesStateChange_Notification {
    const NAME: &'static str = "CSteamInputService_ControllerAxesStateChange_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.controller_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.joystick_left)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.joystick_right)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.trackpad_left)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.trackpad_right)?;
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.trackpad_center)?;
                },
                61 => {
                    self.trackpad_pressure_left = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.trackpad_pressure_right = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.trigger_left = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.trigger_right = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.joystick_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.joystick_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.trackpad_left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.trackpad_right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.trackpad_center.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.trackpad_pressure_left {
            my_size += 1 + 4;
        }
        if let Some(v) = self.trackpad_pressure_right {
            my_size += 1 + 4;
        }
        if let Some(v) = self.trigger_left {
            my_size += 1 + 4;
        }
        if let Some(v) = self.trigger_right {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.controller_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.joystick_left.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.joystick_right.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.trackpad_left.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.trackpad_right.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.trackpad_center.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.trackpad_pressure_left {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.trackpad_pressure_right {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.trigger_left {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.trigger_right {
            os.write_float(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamInputService_ControllerAxesStateChange_Notification {
        CSteamInputService_ControllerAxesStateChange_Notification::new()
    }

    fn clear(&mut self) {
        self.controller_index = ::std::option::Option::None;
        self.joystick_left.clear();
        self.joystick_right.clear();
        self.trackpad_left.clear();
        self.trackpad_right.clear();
        self.trackpad_center.clear();
        self.trackpad_pressure_left = ::std::option::Option::None;
        self.trackpad_pressure_right = ::std::option::Option::None;
        self.trigger_left = ::std::option::Option::None;
        self.trigger_right = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamInputService_ControllerAxesStateChange_Notification {
        static instance: CSteamInputService_ControllerAxesStateChange_Notification = CSteamInputService_ControllerAxesStateChange_Notification {
            controller_index: ::std::option::Option::None,
            joystick_left: ::steam_vent_proto_common::protobuf::MessageField::none(),
            joystick_right: ::steam_vent_proto_common::protobuf::MessageField::none(),
            trackpad_left: ::steam_vent_proto_common::protobuf::MessageField::none(),
            trackpad_right: ::steam_vent_proto_common::protobuf::MessageField::none(),
            trackpad_center: ::steam_vent_proto_common::protobuf::MessageField::none(),
            trackpad_pressure_left: ::std::option::Option::None,
            trackpad_pressure_right: ::std::option::Option::None,
            trigger_left: ::std::option::Option::None,
            trigger_right: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamInputService_GyroQuaternionChanged_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamInputService_GyroQuaternionChanged_Notification {
    // message fields
    // @@protoc_insertion_point(field:CSteamInputService_GyroQuaternionChanged_Notification.controller_index)
    pub controller_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamInputService_GyroQuaternionChanged_Notification.imu_index)
    pub imu_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamInputService_GyroQuaternionChanged_Notification.gyro_raw_quaternion)
    pub gyro_raw_quaternion: ::steam_vent_proto_common::protobuf::MessageField<ControllerQuaternion>,
    // @@protoc_insertion_point(field:CSteamInputService_GyroQuaternionChanged_Notification.gyro_filtered_quaternion)
    pub gyro_filtered_quaternion: ::steam_vent_proto_common::protobuf::MessageField<ControllerQuaternion>,
    // @@protoc_insertion_point(field:CSteamInputService_GyroQuaternionChanged_Notification.imu_sensor_delta_time)
    pub imu_sensor_delta_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamInputService_GyroQuaternionChanged_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamInputService_GyroQuaternionChanged_Notification {
    fn default() -> &'a CSteamInputService_GyroQuaternionChanged_Notification {
        <CSteamInputService_GyroQuaternionChanged_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSteamInputService_GyroQuaternionChanged_Notification {
    pub fn new() -> CSteamInputService_GyroQuaternionChanged_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 controller_index = 1;

    pub fn controller_index(&self) -> u32 {
        self.controller_index.unwrap_or(0)
    }

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: u32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    // optional uint32 imu_index = 2;

    pub fn imu_index(&self) -> u32 {
        self.imu_index.unwrap_or(0)
    }

    pub fn clear_imu_index(&mut self) {
        self.imu_index = ::std::option::Option::None;
    }

    pub fn has_imu_index(&self) -> bool {
        self.imu_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imu_index(&mut self, v: u32) {
        self.imu_index = ::std::option::Option::Some(v);
    }

    // optional uint32 imu_sensor_delta_time = 5;

    pub fn imu_sensor_delta_time(&self) -> u32 {
        self.imu_sensor_delta_time.unwrap_or(0)
    }

    pub fn clear_imu_sensor_delta_time(&mut self) {
        self.imu_sensor_delta_time = ::std::option::Option::None;
    }

    pub fn has_imu_sensor_delta_time(&self) -> bool {
        self.imu_sensor_delta_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imu_sensor_delta_time(&mut self, v: u32) {
        self.imu_sensor_delta_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSteamInputService_GyroQuaternionChanged_Notification {
    const NAME: &'static str = "CSteamInputService_GyroQuaternionChanged_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.controller_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.imu_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.gyro_raw_quaternion)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.gyro_filtered_quaternion)?;
                },
                40 => {
                    self.imu_sensor_delta_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.imu_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.gyro_raw_quaternion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gyro_filtered_quaternion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.imu_sensor_delta_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.controller_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.imu_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.gyro_raw_quaternion.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.gyro_filtered_quaternion.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.imu_sensor_delta_time {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamInputService_GyroQuaternionChanged_Notification {
        CSteamInputService_GyroQuaternionChanged_Notification::new()
    }

    fn clear(&mut self) {
        self.controller_index = ::std::option::Option::None;
        self.imu_index = ::std::option::Option::None;
        self.gyro_raw_quaternion.clear();
        self.gyro_filtered_quaternion.clear();
        self.imu_sensor_delta_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamInputService_GyroQuaternionChanged_Notification {
        static instance: CSteamInputService_GyroQuaternionChanged_Notification = CSteamInputService_GyroQuaternionChanged_Notification {
            controller_index: ::std::option::Option::None,
            imu_index: ::std::option::Option::None,
            gyro_raw_quaternion: ::steam_vent_proto_common::protobuf::MessageField::none(),
            gyro_filtered_quaternion: ::steam_vent_proto_common::protobuf::MessageField::none(),
            imu_sensor_delta_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamInputService_GyroSpeedChanged_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamInputService_GyroSpeedChanged_Notification {
    // message fields
    // @@protoc_insertion_point(field:CSteamInputService_GyroSpeedChanged_Notification.controller_index)
    pub controller_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamInputService_GyroSpeedChanged_Notification.imu_index)
    pub imu_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamInputService_GyroSpeedChanged_Notification.gyro_raw_speed)
    pub gyro_raw_speed: ::steam_vent_proto_common::protobuf::MessageField<ControllerGyroEulerAngles>,
    // @@protoc_insertion_point(field:CSteamInputService_GyroSpeedChanged_Notification.gyro_filtered_speed)
    pub gyro_filtered_speed: ::steam_vent_proto_common::protobuf::MessageField<ControllerGyroEulerAngles>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamInputService_GyroSpeedChanged_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamInputService_GyroSpeedChanged_Notification {
    fn default() -> &'a CSteamInputService_GyroSpeedChanged_Notification {
        <CSteamInputService_GyroSpeedChanged_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSteamInputService_GyroSpeedChanged_Notification {
    pub fn new() -> CSteamInputService_GyroSpeedChanged_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 controller_index = 1;

    pub fn controller_index(&self) -> u32 {
        self.controller_index.unwrap_or(0)
    }

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: u32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    // optional uint32 imu_index = 2;

    pub fn imu_index(&self) -> u32 {
        self.imu_index.unwrap_or(0)
    }

    pub fn clear_imu_index(&mut self) {
        self.imu_index = ::std::option::Option::None;
    }

    pub fn has_imu_index(&self) -> bool {
        self.imu_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imu_index(&mut self, v: u32) {
        self.imu_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSteamInputService_GyroSpeedChanged_Notification {
    const NAME: &'static str = "CSteamInputService_GyroSpeedChanged_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.controller_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.imu_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.gyro_raw_speed)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.gyro_filtered_speed)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.imu_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.gyro_raw_speed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.gyro_filtered_speed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.controller_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.imu_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.gyro_raw_speed.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.gyro_filtered_speed.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamInputService_GyroSpeedChanged_Notification {
        CSteamInputService_GyroSpeedChanged_Notification::new()
    }

    fn clear(&mut self) {
        self.controller_index = ::std::option::Option::None;
        self.imu_index = ::std::option::Option::None;
        self.gyro_raw_speed.clear();
        self.gyro_filtered_speed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamInputService_GyroSpeedChanged_Notification {
        static instance: CSteamInputService_GyroSpeedChanged_Notification = CSteamInputService_GyroSpeedChanged_Notification {
            controller_index: ::std::option::Option::None,
            imu_index: ::std::option::Option::None,
            gyro_raw_speed: ::steam_vent_proto_common::protobuf::MessageField::none(),
            gyro_filtered_speed: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamInputService_GyroAccelerometerChanged_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamInputService_GyroAccelerometerChanged_Notification {
    // message fields
    // @@protoc_insertion_point(field:CSteamInputService_GyroAccelerometerChanged_Notification.controller_index)
    pub controller_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamInputService_GyroAccelerometerChanged_Notification.imu_index)
    pub imu_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamInputService_GyroAccelerometerChanged_Notification.acceleromter_1g)
    pub acceleromter_1g: ::steam_vent_proto_common::protobuf::MessageField<ControllerVector3>,
    // @@protoc_insertion_point(field:CSteamInputService_GyroAccelerometerChanged_Notification.trusted_gravity_1g)
    pub trusted_gravity_1g: ::steam_vent_proto_common::protobuf::MessageField<ControllerVector3>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamInputService_GyroAccelerometerChanged_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamInputService_GyroAccelerometerChanged_Notification {
    fn default() -> &'a CSteamInputService_GyroAccelerometerChanged_Notification {
        <CSteamInputService_GyroAccelerometerChanged_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSteamInputService_GyroAccelerometerChanged_Notification {
    pub fn new() -> CSteamInputService_GyroAccelerometerChanged_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 controller_index = 1;

    pub fn controller_index(&self) -> u32 {
        self.controller_index.unwrap_or(0)
    }

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: u32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    // optional uint32 imu_index = 2;

    pub fn imu_index(&self) -> u32 {
        self.imu_index.unwrap_or(0)
    }

    pub fn clear_imu_index(&mut self) {
        self.imu_index = ::std::option::Option::None;
    }

    pub fn has_imu_index(&self) -> bool {
        self.imu_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imu_index(&mut self, v: u32) {
        self.imu_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSteamInputService_GyroAccelerometerChanged_Notification {
    const NAME: &'static str = "CSteamInputService_GyroAccelerometerChanged_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.controller_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.imu_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.acceleromter_1g)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.trusted_gravity_1g)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.imu_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.acceleromter_1g.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.trusted_gravity_1g.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.controller_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.imu_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.acceleromter_1g.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.trusted_gravity_1g.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamInputService_GyroAccelerometerChanged_Notification {
        CSteamInputService_GyroAccelerometerChanged_Notification::new()
    }

    fn clear(&mut self) {
        self.controller_index = ::std::option::Option::None;
        self.imu_index = ::std::option::Option::None;
        self.acceleromter_1g.clear();
        self.trusted_gravity_1g.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamInputService_GyroAccelerometerChanged_Notification {
        static instance: CSteamInputService_GyroAccelerometerChanged_Notification = CSteamInputService_GyroAccelerometerChanged_Notification {
            controller_index: ::std::option::Option::None,
            imu_index: ::std::option::Option::None,
            acceleromter_1g: ::steam_vent_proto_common::protobuf::MessageField::none(),
            trusted_gravity_1g: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamInputService_GyroCalibration_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamInputService_GyroCalibration_Notification {
    // message fields
    // @@protoc_insertion_point(field:CSteamInputService_GyroCalibration_Notification.controller_index)
    pub controller_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamInputService_GyroCalibration_Notification.imu_index)
    pub imu_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamInputService_GyroCalibration_Notification.acceleromter_noise)
    pub acceleromter_noise: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSteamInputService_GyroCalibration_Notification.gyroscope_noise)
    pub gyroscope_noise: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSteamInputService_GyroCalibration_Notification.calibration_progress)
    pub calibration_progress: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamInputService_GyroCalibration_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamInputService_GyroCalibration_Notification {
    fn default() -> &'a CSteamInputService_GyroCalibration_Notification {
        <CSteamInputService_GyroCalibration_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSteamInputService_GyroCalibration_Notification {
    pub fn new() -> CSteamInputService_GyroCalibration_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 controller_index = 1;

    pub fn controller_index(&self) -> u32 {
        self.controller_index.unwrap_or(0)
    }

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: u32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    // optional uint32 imu_index = 2;

    pub fn imu_index(&self) -> u32 {
        self.imu_index.unwrap_or(0)
    }

    pub fn clear_imu_index(&mut self) {
        self.imu_index = ::std::option::Option::None;
    }

    pub fn has_imu_index(&self) -> bool {
        self.imu_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imu_index(&mut self, v: u32) {
        self.imu_index = ::std::option::Option::Some(v);
    }

    // optional float acceleromter_noise = 3;

    pub fn acceleromter_noise(&self) -> f32 {
        self.acceleromter_noise.unwrap_or(0.)
    }

    pub fn clear_acceleromter_noise(&mut self) {
        self.acceleromter_noise = ::std::option::Option::None;
    }

    pub fn has_acceleromter_noise(&self) -> bool {
        self.acceleromter_noise.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acceleromter_noise(&mut self, v: f32) {
        self.acceleromter_noise = ::std::option::Option::Some(v);
    }

    // optional float gyroscope_noise = 4;

    pub fn gyroscope_noise(&self) -> f32 {
        self.gyroscope_noise.unwrap_or(0.)
    }

    pub fn clear_gyroscope_noise(&mut self) {
        self.gyroscope_noise = ::std::option::Option::None;
    }

    pub fn has_gyroscope_noise(&self) -> bool {
        self.gyroscope_noise.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gyroscope_noise(&mut self, v: f32) {
        self.gyroscope_noise = ::std::option::Option::Some(v);
    }

    // optional float calibration_progress = 5;

    pub fn calibration_progress(&self) -> f32 {
        self.calibration_progress.unwrap_or(0.)
    }

    pub fn clear_calibration_progress(&mut self) {
        self.calibration_progress = ::std::option::Option::None;
    }

    pub fn has_calibration_progress(&self) -> bool {
        self.calibration_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_calibration_progress(&mut self, v: f32) {
        self.calibration_progress = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSteamInputService_GyroCalibration_Notification {
    const NAME: &'static str = "CSteamInputService_GyroCalibration_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.controller_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.imu_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.acceleromter_noise = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.gyroscope_noise = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.calibration_progress = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.imu_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.acceleromter_noise {
            my_size += 1 + 4;
        }
        if let Some(v) = self.gyroscope_noise {
            my_size += 1 + 4;
        }
        if let Some(v) = self.calibration_progress {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.controller_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.imu_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.acceleromter_noise {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.gyroscope_noise {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.calibration_progress {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamInputService_GyroCalibration_Notification {
        CSteamInputService_GyroCalibration_Notification::new()
    }

    fn clear(&mut self) {
        self.controller_index = ::std::option::Option::None;
        self.imu_index = ::std::option::Option::None;
        self.acceleromter_noise = ::std::option::Option::None;
        self.gyroscope_noise = ::std::option::Option::None;
        self.calibration_progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamInputService_GyroCalibration_Notification {
        static instance: CSteamInputService_GyroCalibration_Notification = CSteamInputService_GyroCalibration_Notification {
            controller_index: ::std::option::Option::None,
            imu_index: ::std::option::Option::None,
            acceleromter_noise: ::std::option::Option::None,
            gyroscope_noise: ::std::option::Option::None,
            calibration_progress: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamInputService_ControllerStateFlow_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamInputService_ControllerStateFlow_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamInputService_ControllerStateFlow_Request.controller_index)
    pub controller_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamInputService_ControllerStateFlow_Request.flow_mode)
    pub flow_mode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamInputService_ControllerStateFlow_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamInputService_ControllerStateFlow_Request {
    fn default() -> &'a CSteamInputService_ControllerStateFlow_Request {
        <CSteamInputService_ControllerStateFlow_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSteamInputService_ControllerStateFlow_Request {
    pub fn new() -> CSteamInputService_ControllerStateFlow_Request {
        ::std::default::Default::default()
    }

    // optional uint32 controller_index = 1;

    pub fn controller_index(&self) -> u32 {
        self.controller_index.unwrap_or(0)
    }

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: u32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    // optional uint32 flow_mode = 2;

    pub fn flow_mode(&self) -> u32 {
        self.flow_mode.unwrap_or(0)
    }

    pub fn clear_flow_mode(&mut self) {
        self.flow_mode = ::std::option::Option::None;
    }

    pub fn has_flow_mode(&self) -> bool {
        self.flow_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flow_mode(&mut self, v: u32) {
        self.flow_mode = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSteamInputService_ControllerStateFlow_Request {
    const NAME: &'static str = "CSteamInputService_ControllerStateFlow_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.controller_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.flow_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.flow_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.controller_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.flow_mode {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamInputService_ControllerStateFlow_Request {
        CSteamInputService_ControllerStateFlow_Request::new()
    }

    fn clear(&mut self) {
        self.controller_index = ::std::option::Option::None;
        self.flow_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamInputService_ControllerStateFlow_Request {
        static instance: CSteamInputService_ControllerStateFlow_Request = CSteamInputService_ControllerStateFlow_Request {
            controller_index: ::std::option::Option::None,
            flow_mode: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSteamInputService_ControllerStateFlow_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamInputService_ControllerStateFlow_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamInputService_ControllerStateFlow_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamInputService_ControllerStateFlow_Response {
    fn default() -> &'a CSteamInputService_ControllerStateFlow_Response {
        <CSteamInputService_ControllerStateFlow_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSteamInputService_ControllerStateFlow_Response {
    pub fn new() -> CSteamInputService_ControllerStateFlow_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSteamInputService_ControllerStateFlow_Response {
    const NAME: &'static str = "CSteamInputService_ControllerStateFlow_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamInputService_ControllerStateFlow_Response {
        CSteamInputService_ControllerStateFlow_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamInputService_ControllerStateFlow_Response {
        static instance: CSteamInputService_ControllerStateFlow_Response = CSteamInputService_ControllerStateFlow_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}


const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages_base::*;
#[allow(unused_imports)]
use crate::webuimessages_base::*;
impl ::steam_vent_proto_common::RpcMessage
for CSteamInputService_ControllerButtonStateChanged_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for ControllerVector2 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for ControllerVector3 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for ControllerQuaternion {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for ControllerGyroEulerAngles {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CSteamInputService_ControllerAxesStateChange_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CSteamInputService_GyroQuaternionChanged_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CSteamInputService_GyroSpeedChanged_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CSteamInputService_GyroAccelerometerChanged_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CSteamInputService_GyroCalibration_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CSteamInputService_ControllerStateFlow_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CSteamInputService_ControllerStateFlow_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
///
struct SteamInputManager {}
impl ::steam_vent_proto_common::RpcService for SteamInputManager {
    const SERVICE_NAME: &'static str = "SteamInputManager";
}
impl ::steam_vent_proto_common::RpcMethod
for CSteamInputService_ControllerAxesStateChange_Notification {
    const METHOD_NAME: &'static str = "SteamInputManager.NotifyAxesStateChanged#1";
    type Response = WebUINoResponse;
}
impl ::steam_vent_proto_common::RpcMethod
for CSteamInputService_ControllerButtonStateChanged_Notification {
    const METHOD_NAME: &'static str = "SteamInputManager.NotifyButtonStateChanged#1";
    type Response = WebUINoResponse;
}
impl ::steam_vent_proto_common::RpcMethod
for CSteamInputService_ControllerStateFlow_Request {
    const METHOD_NAME: &'static str = "SteamInputManager.StartControllerStateFlow#1";
    type Response = CSteamInputService_ControllerStateFlow_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CSteamInputService_GyroAccelerometerChanged_Notification {
    const METHOD_NAME: &'static str = "SteamInputManager.NotifyGyroAccelerometerStateChanged#1";
    type Response = WebUINoResponse;
}
impl ::steam_vent_proto_common::RpcMethod
for CSteamInputService_GyroCalibration_Notification {
    const METHOD_NAME: &'static str = "SteamInputManager.NotifyGyroCalibrationStateChanged#1";
    type Response = WebUINoResponse;
}
impl ::steam_vent_proto_common::RpcMethod
for CSteamInputService_GyroQuaternionChanged_Notification {
    const METHOD_NAME: &'static str = "SteamInputManager.NotifyGyroQuaternionStateChanged#1";
    type Response = WebUINoResponse;
}
impl ::steam_vent_proto_common::RpcMethod
for CSteamInputService_GyroSpeedChanged_Notification {
    const METHOD_NAME: &'static str = "SteamInputManager.NotifyGyroSpeedStateChanged#1";
    type Response = WebUINoResponse;
}
