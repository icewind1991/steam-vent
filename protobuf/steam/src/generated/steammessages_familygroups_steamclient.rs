// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_familygroups.steamclient.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CFamilyGroups_CreateFamilyGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_CreateFamilyGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_CreateFamilyGroup_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CFamilyGroups_CreateFamilyGroup_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_CreateFamilyGroup_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_CreateFamilyGroup_Request {
    fn default() -> &'a CFamilyGroups_CreateFamilyGroup_Request {
        <CFamilyGroups_CreateFamilyGroup_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_CreateFamilyGroup_Request {
    pub fn new() -> CFamilyGroups_CreateFamilyGroup_Request {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_CreateFamilyGroup_Request {
    const NAME: &'static str = "CFamilyGroups_CreateFamilyGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_CreateFamilyGroup_Request {
        CFamilyGroups_CreateFamilyGroup_Request::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_CreateFamilyGroup_Request {
        static instance: CFamilyGroups_CreateFamilyGroup_Request = CFamilyGroups_CreateFamilyGroup_Request {
            name: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_CreateFamilyGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_CreateFamilyGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_CreateFamilyGroup_Response.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_CreateFamilyGroup_Response.cooldown_skip_granted)
    pub cooldown_skip_granted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_CreateFamilyGroup_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_CreateFamilyGroup_Response {
    fn default() -> &'a CFamilyGroups_CreateFamilyGroup_Response {
        <CFamilyGroups_CreateFamilyGroup_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_CreateFamilyGroup_Response {
    pub fn new() -> CFamilyGroups_CreateFamilyGroup_Response {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional bool cooldown_skip_granted = 2;

    pub fn cooldown_skip_granted(&self) -> bool {
        self.cooldown_skip_granted.unwrap_or(false)
    }

    pub fn clear_cooldown_skip_granted(&mut self) {
        self.cooldown_skip_granted = ::std::option::Option::None;
    }

    pub fn has_cooldown_skip_granted(&self) -> bool {
        self.cooldown_skip_granted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_skip_granted(&mut self, v: bool) {
        self.cooldown_skip_granted = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_CreateFamilyGroup_Response {
    const NAME: &'static str = "CFamilyGroups_CreateFamilyGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.cooldown_skip_granted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.cooldown_skip_granted {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.cooldown_skip_granted {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_CreateFamilyGroup_Response {
        CFamilyGroups_CreateFamilyGroup_Response::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.cooldown_skip_granted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_CreateFamilyGroup_Response {
        static instance: CFamilyGroups_CreateFamilyGroup_Response = CFamilyGroups_CreateFamilyGroup_Response {
            family_groupid: ::std::option::Option::None,
            cooldown_skip_granted: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetFamilyGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetFamilyGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Request.send_running_apps)
    pub send_running_apps: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetFamilyGroup_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetFamilyGroup_Request {
    fn default() -> &'a CFamilyGroups_GetFamilyGroup_Request {
        <CFamilyGroups_GetFamilyGroup_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetFamilyGroup_Request {
    pub fn new() -> CFamilyGroups_GetFamilyGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional bool send_running_apps = 2;

    pub fn send_running_apps(&self) -> bool {
        self.send_running_apps.unwrap_or(false)
    }

    pub fn clear_send_running_apps(&mut self) {
        self.send_running_apps = ::std::option::Option::None;
    }

    pub fn has_send_running_apps(&self) -> bool {
        self.send_running_apps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_running_apps(&mut self, v: bool) {
        self.send_running_apps = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetFamilyGroup_Request {
    const NAME: &'static str = "CFamilyGroups_GetFamilyGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.send_running_apps = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.send_running_apps {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.send_running_apps {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetFamilyGroup_Request {
        CFamilyGroups_GetFamilyGroup_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.send_running_apps = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetFamilyGroup_Request {
        static instance: CFamilyGroups_GetFamilyGroup_Request = CFamilyGroups_GetFamilyGroup_Request {
            family_groupid: ::std::option::Option::None,
            send_running_apps: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:FamilyGroupMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FamilyGroupMember {
    // message fields
    // @@protoc_insertion_point(field:FamilyGroupMember.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:FamilyGroupMember.role)
    pub role: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EFamilyGroupRole>>,
    // @@protoc_insertion_point(field:FamilyGroupMember.time_joined)
    pub time_joined: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:FamilyGroupMember.cooldown_seconds_remaining)
    pub cooldown_seconds_remaining: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:FamilyGroupMember.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FamilyGroupMember {
    fn default() -> &'a FamilyGroupMember {
        <FamilyGroupMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl FamilyGroupMember {
    pub fn new() -> FamilyGroupMember {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional .EFamilyGroupRole role = 2;

    pub fn role(&self) -> EFamilyGroupRole {
        match self.role {
            Some(e) => e.enum_value_or(EFamilyGroupRole::k_EFamilyGroupRole_None),
            None => EFamilyGroupRole::k_EFamilyGroupRole_None,
        }
    }

    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: EFamilyGroupRole) {
        self.role = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 time_joined = 3;

    pub fn time_joined(&self) -> u32 {
        self.time_joined.unwrap_or(0)
    }

    pub fn clear_time_joined(&mut self) {
        self.time_joined = ::std::option::Option::None;
    }

    pub fn has_time_joined(&self) -> bool {
        self.time_joined.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_joined(&mut self, v: u32) {
        self.time_joined = ::std::option::Option::Some(v);
    }

    // optional uint32 cooldown_seconds_remaining = 4;

    pub fn cooldown_seconds_remaining(&self) -> u32 {
        self.cooldown_seconds_remaining.unwrap_or(0)
    }

    pub fn clear_cooldown_seconds_remaining(&mut self) {
        self.cooldown_seconds_remaining = ::std::option::Option::None;
    }

    pub fn has_cooldown_seconds_remaining(&self) -> bool {
        self.cooldown_seconds_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_seconds_remaining(&mut self, v: u32) {
        self.cooldown_seconds_remaining = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for FamilyGroupMember {
    const NAME: &'static str = "FamilyGroupMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.time_joined = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.cooldown_seconds_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.role {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.time_joined {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.cooldown_seconds_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.role {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.time_joined {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.cooldown_seconds_remaining {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FamilyGroupMember {
        FamilyGroupMember::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.role = ::std::option::Option::None;
        self.time_joined = ::std::option::Option::None;
        self.cooldown_seconds_remaining = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FamilyGroupMember {
        static instance: FamilyGroupMember = FamilyGroupMember {
            steamid: ::std::option::Option::None,
            role: ::std::option::Option::None,
            time_joined: ::std::option::Option::None,
            cooldown_seconds_remaining: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:FamilyGroupPendingInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FamilyGroupPendingInvite {
    // message fields
    // @@protoc_insertion_point(field:FamilyGroupPendingInvite.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:FamilyGroupPendingInvite.role)
    pub role: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EFamilyGroupRole>>,
    // special fields
    // @@protoc_insertion_point(special_field:FamilyGroupPendingInvite.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FamilyGroupPendingInvite {
    fn default() -> &'a FamilyGroupPendingInvite {
        <FamilyGroupPendingInvite as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl FamilyGroupPendingInvite {
    pub fn new() -> FamilyGroupPendingInvite {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional .EFamilyGroupRole role = 2;

    pub fn role(&self) -> EFamilyGroupRole {
        match self.role {
            Some(e) => e.enum_value_or(EFamilyGroupRole::k_EFamilyGroupRole_None),
            None => EFamilyGroupRole::k_EFamilyGroupRole_None,
        }
    }

    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: EFamilyGroupRole) {
        self.role = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for FamilyGroupPendingInvite {
    const NAME: &'static str = "FamilyGroupPendingInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.role {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.role {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FamilyGroupPendingInvite {
        FamilyGroupPendingInvite::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.role = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FamilyGroupPendingInvite {
        static instance: FamilyGroupPendingInvite = FamilyGroupPendingInvite {
            steamid: ::std::option::Option::None,
            role: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:FamilyGroupFormerMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FamilyGroupFormerMember {
    // message fields
    // @@protoc_insertion_point(field:FamilyGroupFormerMember.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:FamilyGroupFormerMember.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FamilyGroupFormerMember {
    fn default() -> &'a FamilyGroupFormerMember {
        <FamilyGroupFormerMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl FamilyGroupFormerMember {
    pub fn new() -> FamilyGroupFormerMember {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for FamilyGroupFormerMember {
    const NAME: &'static str = "FamilyGroupFormerMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FamilyGroupFormerMember {
        FamilyGroupFormerMember::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FamilyGroupFormerMember {
        static instance: FamilyGroupFormerMember = FamilyGroupFormerMember {
            steamid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetFamilyGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetFamilyGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Response.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Response.members)
    pub members: ::std::vec::Vec<FamilyGroupMember>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Response.pending_invites)
    pub pending_invites: ::std::vec::Vec<FamilyGroupPendingInvite>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Response.free_spots)
    pub free_spots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Response.country)
    pub country: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Response.slot_cooldown_remaining_seconds)
    pub slot_cooldown_remaining_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Response.former_members)
    pub former_members: ::std::vec::Vec<FamilyGroupFormerMember>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroup_Response.slot_cooldown_overrides)
    pub slot_cooldown_overrides: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetFamilyGroup_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetFamilyGroup_Response {
    fn default() -> &'a CFamilyGroups_GetFamilyGroup_Response {
        <CFamilyGroups_GetFamilyGroup_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetFamilyGroup_Response {
    pub fn new() -> CFamilyGroups_GetFamilyGroup_Response {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 free_spots = 4;

    pub fn free_spots(&self) -> u32 {
        self.free_spots.unwrap_or(0)
    }

    pub fn clear_free_spots(&mut self) {
        self.free_spots = ::std::option::Option::None;
    }

    pub fn has_free_spots(&self) -> bool {
        self.free_spots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_free_spots(&mut self, v: u32) {
        self.free_spots = ::std::option::Option::Some(v);
    }

    // optional string country = 5;

    pub fn country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country(&mut self) {
        self.country = ::std::option::Option::None;
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 slot_cooldown_remaining_seconds = 6;

    pub fn slot_cooldown_remaining_seconds(&self) -> u32 {
        self.slot_cooldown_remaining_seconds.unwrap_or(0)
    }

    pub fn clear_slot_cooldown_remaining_seconds(&mut self) {
        self.slot_cooldown_remaining_seconds = ::std::option::Option::None;
    }

    pub fn has_slot_cooldown_remaining_seconds(&self) -> bool {
        self.slot_cooldown_remaining_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_cooldown_remaining_seconds(&mut self, v: u32) {
        self.slot_cooldown_remaining_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_cooldown_overrides = 8;

    pub fn slot_cooldown_overrides(&self) -> u32 {
        self.slot_cooldown_overrides.unwrap_or(0)
    }

    pub fn clear_slot_cooldown_overrides(&mut self) {
        self.slot_cooldown_overrides = ::std::option::Option::None;
    }

    pub fn has_slot_cooldown_overrides(&self) -> bool {
        self.slot_cooldown_overrides.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_cooldown_overrides(&mut self, v: u32) {
        self.slot_cooldown_overrides = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetFamilyGroup_Response {
    const NAME: &'static str = "CFamilyGroups_GetFamilyGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.members.push(is.read_message()?);
                },
                26 => {
                    self.pending_invites.push(is.read_message()?);
                },
                32 => {
                    self.free_spots = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.country = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.slot_cooldown_remaining_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.former_members.push(is.read_message()?);
                },
                64 => {
                    self.slot_cooldown_overrides = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.pending_invites {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.free_spots {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.country.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.slot_cooldown_remaining_seconds {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        for value in &self.former_members {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.slot_cooldown_overrides {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.pending_invites {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.free_spots {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.country.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.slot_cooldown_remaining_seconds {
            os.write_uint32(6, v)?;
        }
        for v in &self.former_members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.slot_cooldown_overrides {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetFamilyGroup_Response {
        CFamilyGroups_GetFamilyGroup_Response::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.members.clear();
        self.pending_invites.clear();
        self.free_spots = ::std::option::Option::None;
        self.country = ::std::option::Option::None;
        self.slot_cooldown_remaining_seconds = ::std::option::Option::None;
        self.former_members.clear();
        self.slot_cooldown_overrides = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetFamilyGroup_Response {
        static instance: CFamilyGroups_GetFamilyGroup_Response = CFamilyGroups_GetFamilyGroup_Response {
            name: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            pending_invites: ::std::vec::Vec::new(),
            free_spots: ::std::option::Option::None,
            country: ::std::option::Option::None,
            slot_cooldown_remaining_seconds: ::std::option::Option::None,
            former_members: ::std::vec::Vec::new(),
            slot_cooldown_overrides: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetFamilyGroupForUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetFamilyGroupForUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Request.include_family_group_response)
    pub include_family_group_response: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetFamilyGroupForUser_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetFamilyGroupForUser_Request {
    fn default() -> &'a CFamilyGroups_GetFamilyGroupForUser_Request {
        <CFamilyGroups_GetFamilyGroupForUser_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetFamilyGroupForUser_Request {
    pub fn new() -> CFamilyGroups_GetFamilyGroupForUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool include_family_group_response = 2;

    pub fn include_family_group_response(&self) -> bool {
        self.include_family_group_response.unwrap_or(false)
    }

    pub fn clear_include_family_group_response(&mut self) {
        self.include_family_group_response = ::std::option::Option::None;
    }

    pub fn has_include_family_group_response(&self) -> bool {
        self.include_family_group_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_family_group_response(&mut self, v: bool) {
        self.include_family_group_response = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetFamilyGroupForUser_Request {
    const NAME: &'static str = "CFamilyGroups_GetFamilyGroupForUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.include_family_group_response = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.include_family_group_response {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.include_family_group_response {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetFamilyGroupForUser_Request {
        CFamilyGroups_GetFamilyGroupForUser_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.include_family_group_response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetFamilyGroupForUser_Request {
        static instance: CFamilyGroups_GetFamilyGroupForUser_Request = CFamilyGroups_GetFamilyGroupForUser_Request {
            steamid: ::std::option::Option::None,
            include_family_group_response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:FamilyGroupPendingInviteForUser)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FamilyGroupPendingInviteForUser {
    // message fields
    // @@protoc_insertion_point(field:FamilyGroupPendingInviteForUser.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:FamilyGroupPendingInviteForUser.role)
    pub role: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EFamilyGroupRole>>,
    // @@protoc_insertion_point(field:FamilyGroupPendingInviteForUser.inviter_steamid)
    pub inviter_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:FamilyGroupPendingInviteForUser.awaiting_2fa)
    pub awaiting_2fa: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:FamilyGroupPendingInviteForUser.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FamilyGroupPendingInviteForUser {
    fn default() -> &'a FamilyGroupPendingInviteForUser {
        <FamilyGroupPendingInviteForUser as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl FamilyGroupPendingInviteForUser {
    pub fn new() -> FamilyGroupPendingInviteForUser {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional .EFamilyGroupRole role = 2;

    pub fn role(&self) -> EFamilyGroupRole {
        match self.role {
            Some(e) => e.enum_value_or(EFamilyGroupRole::k_EFamilyGroupRole_None),
            None => EFamilyGroupRole::k_EFamilyGroupRole_None,
        }
    }

    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: EFamilyGroupRole) {
        self.role = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 inviter_steamid = 3;

    pub fn inviter_steamid(&self) -> u64 {
        self.inviter_steamid.unwrap_or(0)
    }

    pub fn clear_inviter_steamid(&mut self) {
        self.inviter_steamid = ::std::option::Option::None;
    }

    pub fn has_inviter_steamid(&self) -> bool {
        self.inviter_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviter_steamid(&mut self, v: u64) {
        self.inviter_steamid = ::std::option::Option::Some(v);
    }

    // optional bool awaiting_2fa = 4;

    pub fn awaiting_2fa(&self) -> bool {
        self.awaiting_2fa.unwrap_or(false)
    }

    pub fn clear_awaiting_2fa(&mut self) {
        self.awaiting_2fa = ::std::option::Option::None;
    }

    pub fn has_awaiting_2fa(&self) -> bool {
        self.awaiting_2fa.is_some()
    }

    // Param is passed by value, moved
    pub fn set_awaiting_2fa(&mut self, v: bool) {
        self.awaiting_2fa = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for FamilyGroupPendingInviteForUser {
    const NAME: &'static str = "FamilyGroupPendingInviteForUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                25 => {
                    self.inviter_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.awaiting_2fa = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.inviter_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.awaiting_2fa {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.inviter_steamid {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.awaiting_2fa {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FamilyGroupPendingInviteForUser {
        FamilyGroupPendingInviteForUser::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.role = ::std::option::Option::None;
        self.inviter_steamid = ::std::option::Option::None;
        self.awaiting_2fa = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FamilyGroupPendingInviteForUser {
        static instance: FamilyGroupPendingInviteForUser = FamilyGroupPendingInviteForUser {
            family_groupid: ::std::option::Option::None,
            role: ::std::option::Option::None,
            inviter_steamid: ::std::option::Option::None,
            awaiting_2fa: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetFamilyGroupForUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetFamilyGroupForUser_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Response.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Response.is_not_member_of_any_group)
    pub is_not_member_of_any_group: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Response.latest_time_joined)
    pub latest_time_joined: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Response.latest_joined_family_groupid)
    pub latest_joined_family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Response.pending_group_invites)
    pub pending_group_invites: ::std::vec::Vec<FamilyGroupPendingInviteForUser>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Response.role)
    pub role: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Response.cooldown_seconds_remaining)
    pub cooldown_seconds_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Response.family_group)
    pub family_group: ::steam_vent_proto_common::protobuf::MessageField<CFamilyGroups_GetFamilyGroup_Response>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetFamilyGroupForUser_Response.can_undelete_last_joined_family)
    pub can_undelete_last_joined_family: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetFamilyGroupForUser_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetFamilyGroupForUser_Response {
    fn default() -> &'a CFamilyGroups_GetFamilyGroupForUser_Response {
        <CFamilyGroups_GetFamilyGroupForUser_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetFamilyGroupForUser_Response {
    pub fn new() -> CFamilyGroups_GetFamilyGroupForUser_Response {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional bool is_not_member_of_any_group = 2;

    pub fn is_not_member_of_any_group(&self) -> bool {
        self.is_not_member_of_any_group.unwrap_or(false)
    }

    pub fn clear_is_not_member_of_any_group(&mut self) {
        self.is_not_member_of_any_group = ::std::option::Option::None;
    }

    pub fn has_is_not_member_of_any_group(&self) -> bool {
        self.is_not_member_of_any_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_not_member_of_any_group(&mut self, v: bool) {
        self.is_not_member_of_any_group = ::std::option::Option::Some(v);
    }

    // optional uint32 latest_time_joined = 3;

    pub fn latest_time_joined(&self) -> u32 {
        self.latest_time_joined.unwrap_or(0)
    }

    pub fn clear_latest_time_joined(&mut self) {
        self.latest_time_joined = ::std::option::Option::None;
    }

    pub fn has_latest_time_joined(&self) -> bool {
        self.latest_time_joined.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_time_joined(&mut self, v: u32) {
        self.latest_time_joined = ::std::option::Option::Some(v);
    }

    // optional uint64 latest_joined_family_groupid = 4;

    pub fn latest_joined_family_groupid(&self) -> u64 {
        self.latest_joined_family_groupid.unwrap_or(0)
    }

    pub fn clear_latest_joined_family_groupid(&mut self) {
        self.latest_joined_family_groupid = ::std::option::Option::None;
    }

    pub fn has_latest_joined_family_groupid(&self) -> bool {
        self.latest_joined_family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_joined_family_groupid(&mut self, v: u64) {
        self.latest_joined_family_groupid = ::std::option::Option::Some(v);
    }

    // optional uint32 role = 6;

    pub fn role(&self) -> u32 {
        self.role.unwrap_or(0)
    }

    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: u32) {
        self.role = ::std::option::Option::Some(v);
    }

    // optional uint32 cooldown_seconds_remaining = 7;

    pub fn cooldown_seconds_remaining(&self) -> u32 {
        self.cooldown_seconds_remaining.unwrap_or(0)
    }

    pub fn clear_cooldown_seconds_remaining(&mut self) {
        self.cooldown_seconds_remaining = ::std::option::Option::None;
    }

    pub fn has_cooldown_seconds_remaining(&self) -> bool {
        self.cooldown_seconds_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_seconds_remaining(&mut self, v: u32) {
        self.cooldown_seconds_remaining = ::std::option::Option::Some(v);
    }

    // optional bool can_undelete_last_joined_family = 9;

    pub fn can_undelete_last_joined_family(&self) -> bool {
        self.can_undelete_last_joined_family.unwrap_or(false)
    }

    pub fn clear_can_undelete_last_joined_family(&mut self) {
        self.can_undelete_last_joined_family = ::std::option::Option::None;
    }

    pub fn has_can_undelete_last_joined_family(&self) -> bool {
        self.can_undelete_last_joined_family.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_undelete_last_joined_family(&mut self, v: bool) {
        self.can_undelete_last_joined_family = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetFamilyGroupForUser_Response {
    const NAME: &'static str = "CFamilyGroups_GetFamilyGroupForUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.is_not_member_of_any_group = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.latest_time_joined = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.latest_joined_family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.pending_group_invites.push(is.read_message()?);
                },
                48 => {
                    self.role = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.cooldown_seconds_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.family_group)?;
                },
                72 => {
                    self.can_undelete_last_joined_family = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.is_not_member_of_any_group {
            my_size += 1 + 1;
        }
        if let Some(v) = self.latest_time_joined {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.latest_joined_family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        for value in &self.pending_group_invites {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.role {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.cooldown_seconds_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.family_group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.can_undelete_last_joined_family {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.is_not_member_of_any_group {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.latest_time_joined {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.latest_joined_family_groupid {
            os.write_uint64(4, v)?;
        }
        for v in &self.pending_group_invites {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.role {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.cooldown_seconds_remaining {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.family_group.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.can_undelete_last_joined_family {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetFamilyGroupForUser_Response {
        CFamilyGroups_GetFamilyGroupForUser_Response::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.is_not_member_of_any_group = ::std::option::Option::None;
        self.latest_time_joined = ::std::option::Option::None;
        self.latest_joined_family_groupid = ::std::option::Option::None;
        self.pending_group_invites.clear();
        self.role = ::std::option::Option::None;
        self.cooldown_seconds_remaining = ::std::option::Option::None;
        self.family_group.clear();
        self.can_undelete_last_joined_family = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetFamilyGroupForUser_Response {
        static instance: CFamilyGroups_GetFamilyGroupForUser_Response = CFamilyGroups_GetFamilyGroupForUser_Response {
            family_groupid: ::std::option::Option::None,
            is_not_member_of_any_group: ::std::option::Option::None,
            latest_time_joined: ::std::option::Option::None,
            latest_joined_family_groupid: ::std::option::Option::None,
            pending_group_invites: ::std::vec::Vec::new(),
            role: ::std::option::Option::None,
            cooldown_seconds_remaining: ::std::option::Option::None,
            family_group: ::steam_vent_proto_common::protobuf::MessageField::none(),
            can_undelete_last_joined_family: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_ModifyFamilyGroupDetails_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_ModifyFamilyGroupDetails_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_ModifyFamilyGroupDetails_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_ModifyFamilyGroupDetails_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_ModifyFamilyGroupDetails_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_ModifyFamilyGroupDetails_Request {
    fn default() -> &'a CFamilyGroups_ModifyFamilyGroupDetails_Request {
        <CFamilyGroups_ModifyFamilyGroupDetails_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_ModifyFamilyGroupDetails_Request {
    pub fn new() -> CFamilyGroups_ModifyFamilyGroupDetails_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_ModifyFamilyGroupDetails_Request {
    const NAME: &'static str = "CFamilyGroups_ModifyFamilyGroupDetails_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_ModifyFamilyGroupDetails_Request {
        CFamilyGroups_ModifyFamilyGroupDetails_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_ModifyFamilyGroupDetails_Request {
        static instance: CFamilyGroups_ModifyFamilyGroupDetails_Request = CFamilyGroups_ModifyFamilyGroupDetails_Request {
            family_groupid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_ModifyFamilyGroupDetails_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_ModifyFamilyGroupDetails_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_ModifyFamilyGroupDetails_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_ModifyFamilyGroupDetails_Response {
    fn default() -> &'a CFamilyGroups_ModifyFamilyGroupDetails_Response {
        <CFamilyGroups_ModifyFamilyGroupDetails_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_ModifyFamilyGroupDetails_Response {
    pub fn new() -> CFamilyGroups_ModifyFamilyGroupDetails_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_ModifyFamilyGroupDetails_Response {
    const NAME: &'static str = "CFamilyGroups_ModifyFamilyGroupDetails_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_ModifyFamilyGroupDetails_Response {
        CFamilyGroups_ModifyFamilyGroupDetails_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_ModifyFamilyGroupDetails_Response {
        static instance: CFamilyGroups_ModifyFamilyGroupDetails_Response = CFamilyGroups_ModifyFamilyGroupDetails_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_InviteToFamilyGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_InviteToFamilyGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_InviteToFamilyGroup_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_InviteToFamilyGroup_Request.receiver_steamid)
    pub receiver_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_InviteToFamilyGroup_Request.receiver_role)
    pub receiver_role: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EFamilyGroupRole>>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_InviteToFamilyGroup_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_InviteToFamilyGroup_Request {
    fn default() -> &'a CFamilyGroups_InviteToFamilyGroup_Request {
        <CFamilyGroups_InviteToFamilyGroup_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_InviteToFamilyGroup_Request {
    pub fn new() -> CFamilyGroups_InviteToFamilyGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 receiver_steamid = 2;

    pub fn receiver_steamid(&self) -> u64 {
        self.receiver_steamid.unwrap_or(0)
    }

    pub fn clear_receiver_steamid(&mut self) {
        self.receiver_steamid = ::std::option::Option::None;
    }

    pub fn has_receiver_steamid(&self) -> bool {
        self.receiver_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_steamid(&mut self, v: u64) {
        self.receiver_steamid = ::std::option::Option::Some(v);
    }

    // optional .EFamilyGroupRole receiver_role = 3;

    pub fn receiver_role(&self) -> EFamilyGroupRole {
        match self.receiver_role {
            Some(e) => e.enum_value_or(EFamilyGroupRole::k_EFamilyGroupRole_None),
            None => EFamilyGroupRole::k_EFamilyGroupRole_None,
        }
    }

    pub fn clear_receiver_role(&mut self) {
        self.receiver_role = ::std::option::Option::None;
    }

    pub fn has_receiver_role(&self) -> bool {
        self.receiver_role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_role(&mut self, v: EFamilyGroupRole) {
        self.receiver_role = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_InviteToFamilyGroup_Request {
    const NAME: &'static str = "CFamilyGroups_InviteToFamilyGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.receiver_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.receiver_role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.receiver_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.receiver_role {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.receiver_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.receiver_role {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_InviteToFamilyGroup_Request {
        CFamilyGroups_InviteToFamilyGroup_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.receiver_steamid = ::std::option::Option::None;
        self.receiver_role = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_InviteToFamilyGroup_Request {
        static instance: CFamilyGroups_InviteToFamilyGroup_Request = CFamilyGroups_InviteToFamilyGroup_Request {
            family_groupid: ::std::option::Option::None,
            receiver_steamid: ::std::option::Option::None,
            receiver_role: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_InviteToFamilyGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_InviteToFamilyGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_InviteToFamilyGroup_Response.invite_id)
    pub invite_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_InviteToFamilyGroup_Response.two_factor_method)
    pub two_factor_method: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EFamilyGroupsTwoFactorMethod>>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_InviteToFamilyGroup_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_InviteToFamilyGroup_Response {
    fn default() -> &'a CFamilyGroups_InviteToFamilyGroup_Response {
        <CFamilyGroups_InviteToFamilyGroup_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_InviteToFamilyGroup_Response {
    pub fn new() -> CFamilyGroups_InviteToFamilyGroup_Response {
        ::std::default::Default::default()
    }

    // optional uint64 invite_id = 1;

    pub fn invite_id(&self) -> u64 {
        self.invite_id.unwrap_or(0)
    }

    pub fn clear_invite_id(&mut self) {
        self.invite_id = ::std::option::Option::None;
    }

    pub fn has_invite_id(&self) -> bool {
        self.invite_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_id(&mut self, v: u64) {
        self.invite_id = ::std::option::Option::Some(v);
    }

    // optional .EFamilyGroupsTwoFactorMethod two_factor_method = 2;

    pub fn two_factor_method(&self) -> EFamilyGroupsTwoFactorMethod {
        match self.two_factor_method {
            Some(e) => e.enum_value_or(EFamilyGroupsTwoFactorMethod::k_EFamilyGroupsTwoFactorMethodNone),
            None => EFamilyGroupsTwoFactorMethod::k_EFamilyGroupsTwoFactorMethodNone,
        }
    }

    pub fn clear_two_factor_method(&mut self) {
        self.two_factor_method = ::std::option::Option::None;
    }

    pub fn has_two_factor_method(&self) -> bool {
        self.two_factor_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_two_factor_method(&mut self, v: EFamilyGroupsTwoFactorMethod) {
        self.two_factor_method = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_InviteToFamilyGroup_Response {
    const NAME: &'static str = "CFamilyGroups_InviteToFamilyGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.invite_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.two_factor_method = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.invite_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.two_factor_method {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.invite_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.two_factor_method {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_InviteToFamilyGroup_Response {
        CFamilyGroups_InviteToFamilyGroup_Response::new()
    }

    fn clear(&mut self) {
        self.invite_id = ::std::option::Option::None;
        self.two_factor_method = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_InviteToFamilyGroup_Response {
        static instance: CFamilyGroups_InviteToFamilyGroup_Response = CFamilyGroups_InviteToFamilyGroup_Response {
            invite_id: ::std::option::Option::None,
            two_factor_method: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_ConfirmInviteToFamilyGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_ConfirmInviteToFamilyGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_ConfirmInviteToFamilyGroup_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_ConfirmInviteToFamilyGroup_Request.invite_id)
    pub invite_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_ConfirmInviteToFamilyGroup_Request.nonce)
    pub nonce: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_ConfirmInviteToFamilyGroup_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_ConfirmInviteToFamilyGroup_Request {
    fn default() -> &'a CFamilyGroups_ConfirmInviteToFamilyGroup_Request {
        <CFamilyGroups_ConfirmInviteToFamilyGroup_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_ConfirmInviteToFamilyGroup_Request {
    pub fn new() -> CFamilyGroups_ConfirmInviteToFamilyGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional uint64 invite_id = 2;

    pub fn invite_id(&self) -> u64 {
        self.invite_id.unwrap_or(0)
    }

    pub fn clear_invite_id(&mut self) {
        self.invite_id = ::std::option::Option::None;
    }

    pub fn has_invite_id(&self) -> bool {
        self.invite_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_id(&mut self, v: u64) {
        self.invite_id = ::std::option::Option::Some(v);
    }

    // optional uint64 nonce = 3;

    pub fn nonce(&self) -> u64 {
        self.nonce.unwrap_or(0)
    }

    pub fn clear_nonce(&mut self) {
        self.nonce = ::std::option::Option::None;
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u64) {
        self.nonce = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_ConfirmInviteToFamilyGroup_Request {
    const NAME: &'static str = "CFamilyGroups_ConfirmInviteToFamilyGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.invite_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.nonce = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.invite_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.nonce {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.invite_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.nonce {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_ConfirmInviteToFamilyGroup_Request {
        CFamilyGroups_ConfirmInviteToFamilyGroup_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.invite_id = ::std::option::Option::None;
        self.nonce = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_ConfirmInviteToFamilyGroup_Request {
        static instance: CFamilyGroups_ConfirmInviteToFamilyGroup_Request = CFamilyGroups_ConfirmInviteToFamilyGroup_Request {
            family_groupid: ::std::option::Option::None,
            invite_id: ::std::option::Option::None,
            nonce: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_ConfirmInviteToFamilyGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_ConfirmInviteToFamilyGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_ConfirmInviteToFamilyGroup_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_ConfirmInviteToFamilyGroup_Response {
    fn default() -> &'a CFamilyGroups_ConfirmInviteToFamilyGroup_Response {
        <CFamilyGroups_ConfirmInviteToFamilyGroup_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_ConfirmInviteToFamilyGroup_Response {
    pub fn new() -> CFamilyGroups_ConfirmInviteToFamilyGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_ConfirmInviteToFamilyGroup_Response {
    const NAME: &'static str = "CFamilyGroups_ConfirmInviteToFamilyGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_ConfirmInviteToFamilyGroup_Response {
        CFamilyGroups_ConfirmInviteToFamilyGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_ConfirmInviteToFamilyGroup_Response {
        static instance: CFamilyGroups_ConfirmInviteToFamilyGroup_Response = CFamilyGroups_ConfirmInviteToFamilyGroup_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_ResendInvitationToFamilyGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_ResendInvitationToFamilyGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_ResendInvitationToFamilyGroup_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_ResendInvitationToFamilyGroup_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_ResendInvitationToFamilyGroup_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_ResendInvitationToFamilyGroup_Request {
    fn default() -> &'a CFamilyGroups_ResendInvitationToFamilyGroup_Request {
        <CFamilyGroups_ResendInvitationToFamilyGroup_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_ResendInvitationToFamilyGroup_Request {
    pub fn new() -> CFamilyGroups_ResendInvitationToFamilyGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional uint64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_ResendInvitationToFamilyGroup_Request {
    const NAME: &'static str = "CFamilyGroups_ResendInvitationToFamilyGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_ResendInvitationToFamilyGroup_Request {
        CFamilyGroups_ResendInvitationToFamilyGroup_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_ResendInvitationToFamilyGroup_Request {
        static instance: CFamilyGroups_ResendInvitationToFamilyGroup_Request = CFamilyGroups_ResendInvitationToFamilyGroup_Request {
            family_groupid: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_ResendInvitationToFamilyGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_ResendInvitationToFamilyGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_ResendInvitationToFamilyGroup_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_ResendInvitationToFamilyGroup_Response {
    fn default() -> &'a CFamilyGroups_ResendInvitationToFamilyGroup_Response {
        <CFamilyGroups_ResendInvitationToFamilyGroup_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_ResendInvitationToFamilyGroup_Response {
    pub fn new() -> CFamilyGroups_ResendInvitationToFamilyGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_ResendInvitationToFamilyGroup_Response {
    const NAME: &'static str = "CFamilyGroups_ResendInvitationToFamilyGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_ResendInvitationToFamilyGroup_Response {
        CFamilyGroups_ResendInvitationToFamilyGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_ResendInvitationToFamilyGroup_Response {
        static instance: CFamilyGroups_ResendInvitationToFamilyGroup_Response = CFamilyGroups_ResendInvitationToFamilyGroup_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_JoinFamilyGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_JoinFamilyGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_JoinFamilyGroup_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_JoinFamilyGroup_Request.nonce)
    pub nonce: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_JoinFamilyGroup_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_JoinFamilyGroup_Request {
    fn default() -> &'a CFamilyGroups_JoinFamilyGroup_Request {
        <CFamilyGroups_JoinFamilyGroup_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_JoinFamilyGroup_Request {
    pub fn new() -> CFamilyGroups_JoinFamilyGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional uint64 nonce = 2;

    pub fn nonce(&self) -> u64 {
        self.nonce.unwrap_or(0)
    }

    pub fn clear_nonce(&mut self) {
        self.nonce = ::std::option::Option::None;
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u64) {
        self.nonce = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_JoinFamilyGroup_Request {
    const NAME: &'static str = "CFamilyGroups_JoinFamilyGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.nonce = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.nonce {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.nonce {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_JoinFamilyGroup_Request {
        CFamilyGroups_JoinFamilyGroup_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.nonce = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_JoinFamilyGroup_Request {
        static instance: CFamilyGroups_JoinFamilyGroup_Request = CFamilyGroups_JoinFamilyGroup_Request {
            family_groupid: ::std::option::Option::None,
            nonce: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_JoinFamilyGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_JoinFamilyGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_JoinFamilyGroup_Response.two_factor_method)
    pub two_factor_method: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EFamilyGroupsTwoFactorMethod>>,
    // @@protoc_insertion_point(field:CFamilyGroups_JoinFamilyGroup_Response.cooldown_skip_granted)
    pub cooldown_skip_granted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CFamilyGroups_JoinFamilyGroup_Response.invite_already_accepted)
    pub invite_already_accepted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_JoinFamilyGroup_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_JoinFamilyGroup_Response {
    fn default() -> &'a CFamilyGroups_JoinFamilyGroup_Response {
        <CFamilyGroups_JoinFamilyGroup_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_JoinFamilyGroup_Response {
    pub fn new() -> CFamilyGroups_JoinFamilyGroup_Response {
        ::std::default::Default::default()
    }

    // optional .EFamilyGroupsTwoFactorMethod two_factor_method = 2;

    pub fn two_factor_method(&self) -> EFamilyGroupsTwoFactorMethod {
        match self.two_factor_method {
            Some(e) => e.enum_value_or(EFamilyGroupsTwoFactorMethod::k_EFamilyGroupsTwoFactorMethodNone),
            None => EFamilyGroupsTwoFactorMethod::k_EFamilyGroupsTwoFactorMethodNone,
        }
    }

    pub fn clear_two_factor_method(&mut self) {
        self.two_factor_method = ::std::option::Option::None;
    }

    pub fn has_two_factor_method(&self) -> bool {
        self.two_factor_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_two_factor_method(&mut self, v: EFamilyGroupsTwoFactorMethod) {
        self.two_factor_method = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool cooldown_skip_granted = 3;

    pub fn cooldown_skip_granted(&self) -> bool {
        self.cooldown_skip_granted.unwrap_or(false)
    }

    pub fn clear_cooldown_skip_granted(&mut self) {
        self.cooldown_skip_granted = ::std::option::Option::None;
    }

    pub fn has_cooldown_skip_granted(&self) -> bool {
        self.cooldown_skip_granted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_skip_granted(&mut self, v: bool) {
        self.cooldown_skip_granted = ::std::option::Option::Some(v);
    }

    // optional bool invite_already_accepted = 4;

    pub fn invite_already_accepted(&self) -> bool {
        self.invite_already_accepted.unwrap_or(false)
    }

    pub fn clear_invite_already_accepted(&mut self) {
        self.invite_already_accepted = ::std::option::Option::None;
    }

    pub fn has_invite_already_accepted(&self) -> bool {
        self.invite_already_accepted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_already_accepted(&mut self, v: bool) {
        self.invite_already_accepted = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_JoinFamilyGroup_Response {
    const NAME: &'static str = "CFamilyGroups_JoinFamilyGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.two_factor_method = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.cooldown_skip_granted = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.invite_already_accepted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.two_factor_method {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.cooldown_skip_granted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.invite_already_accepted {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.two_factor_method {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.cooldown_skip_granted {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.invite_already_accepted {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_JoinFamilyGroup_Response {
        CFamilyGroups_JoinFamilyGroup_Response::new()
    }

    fn clear(&mut self) {
        self.two_factor_method = ::std::option::Option::None;
        self.cooldown_skip_granted = ::std::option::Option::None;
        self.invite_already_accepted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_JoinFamilyGroup_Response {
        static instance: CFamilyGroups_JoinFamilyGroup_Response = CFamilyGroups_JoinFamilyGroup_Response {
            two_factor_method: ::std::option::Option::None,
            cooldown_skip_granted: ::std::option::Option::None,
            invite_already_accepted: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_ConfirmJoinFamilyGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_ConfirmJoinFamilyGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_ConfirmJoinFamilyGroup_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_ConfirmJoinFamilyGroup_Request.invite_id)
    pub invite_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_ConfirmJoinFamilyGroup_Request.nonce)
    pub nonce: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_ConfirmJoinFamilyGroup_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_ConfirmJoinFamilyGroup_Request {
    fn default() -> &'a CFamilyGroups_ConfirmJoinFamilyGroup_Request {
        <CFamilyGroups_ConfirmJoinFamilyGroup_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_ConfirmJoinFamilyGroup_Request {
    pub fn new() -> CFamilyGroups_ConfirmJoinFamilyGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional uint64 invite_id = 2;

    pub fn invite_id(&self) -> u64 {
        self.invite_id.unwrap_or(0)
    }

    pub fn clear_invite_id(&mut self) {
        self.invite_id = ::std::option::Option::None;
    }

    pub fn has_invite_id(&self) -> bool {
        self.invite_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_id(&mut self, v: u64) {
        self.invite_id = ::std::option::Option::Some(v);
    }

    // optional uint64 nonce = 3;

    pub fn nonce(&self) -> u64 {
        self.nonce.unwrap_or(0)
    }

    pub fn clear_nonce(&mut self) {
        self.nonce = ::std::option::Option::None;
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u64) {
        self.nonce = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_ConfirmJoinFamilyGroup_Request {
    const NAME: &'static str = "CFamilyGroups_ConfirmJoinFamilyGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.invite_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.nonce = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.invite_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.nonce {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.invite_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.nonce {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_ConfirmJoinFamilyGroup_Request {
        CFamilyGroups_ConfirmJoinFamilyGroup_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.invite_id = ::std::option::Option::None;
        self.nonce = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_ConfirmJoinFamilyGroup_Request {
        static instance: CFamilyGroups_ConfirmJoinFamilyGroup_Request = CFamilyGroups_ConfirmJoinFamilyGroup_Request {
            family_groupid: ::std::option::Option::None,
            invite_id: ::std::option::Option::None,
            nonce: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_ConfirmJoinFamilyGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_ConfirmJoinFamilyGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_ConfirmJoinFamilyGroup_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_ConfirmJoinFamilyGroup_Response {
    fn default() -> &'a CFamilyGroups_ConfirmJoinFamilyGroup_Response {
        <CFamilyGroups_ConfirmJoinFamilyGroup_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_ConfirmJoinFamilyGroup_Response {
    pub fn new() -> CFamilyGroups_ConfirmJoinFamilyGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_ConfirmJoinFamilyGroup_Response {
    const NAME: &'static str = "CFamilyGroups_ConfirmJoinFamilyGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_ConfirmJoinFamilyGroup_Response {
        CFamilyGroups_ConfirmJoinFamilyGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_ConfirmJoinFamilyGroup_Response {
        static instance: CFamilyGroups_ConfirmJoinFamilyGroup_Response = CFamilyGroups_ConfirmJoinFamilyGroup_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_RemoveFromFamilyGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_RemoveFromFamilyGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_RemoveFromFamilyGroup_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_RemoveFromFamilyGroup_Request.steamid_to_remove)
    pub steamid_to_remove: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_RemoveFromFamilyGroup_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_RemoveFromFamilyGroup_Request {
    fn default() -> &'a CFamilyGroups_RemoveFromFamilyGroup_Request {
        <CFamilyGroups_RemoveFromFamilyGroup_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_RemoveFromFamilyGroup_Request {
    pub fn new() -> CFamilyGroups_RemoveFromFamilyGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_to_remove = 2;

    pub fn steamid_to_remove(&self) -> u64 {
        self.steamid_to_remove.unwrap_or(0)
    }

    pub fn clear_steamid_to_remove(&mut self) {
        self.steamid_to_remove = ::std::option::Option::None;
    }

    pub fn has_steamid_to_remove(&self) -> bool {
        self.steamid_to_remove.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_to_remove(&mut self, v: u64) {
        self.steamid_to_remove = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_RemoveFromFamilyGroup_Request {
    const NAME: &'static str = "CFamilyGroups_RemoveFromFamilyGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid_to_remove = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid_to_remove {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid_to_remove {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_RemoveFromFamilyGroup_Request {
        CFamilyGroups_RemoveFromFamilyGroup_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.steamid_to_remove = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_RemoveFromFamilyGroup_Request {
        static instance: CFamilyGroups_RemoveFromFamilyGroup_Request = CFamilyGroups_RemoveFromFamilyGroup_Request {
            family_groupid: ::std::option::Option::None,
            steamid_to_remove: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_RemoveFromFamilyGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_RemoveFromFamilyGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_RemoveFromFamilyGroup_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_RemoveFromFamilyGroup_Response {
    fn default() -> &'a CFamilyGroups_RemoveFromFamilyGroup_Response {
        <CFamilyGroups_RemoveFromFamilyGroup_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_RemoveFromFamilyGroup_Response {
    pub fn new() -> CFamilyGroups_RemoveFromFamilyGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_RemoveFromFamilyGroup_Response {
    const NAME: &'static str = "CFamilyGroups_RemoveFromFamilyGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_RemoveFromFamilyGroup_Response {
        CFamilyGroups_RemoveFromFamilyGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_RemoveFromFamilyGroup_Response {
        static instance: CFamilyGroups_RemoveFromFamilyGroup_Response = CFamilyGroups_RemoveFromFamilyGroup_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_CancelFamilyGroupInvite_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_CancelFamilyGroupInvite_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_CancelFamilyGroupInvite_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_CancelFamilyGroupInvite_Request.steamid_to_cancel)
    pub steamid_to_cancel: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_CancelFamilyGroupInvite_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_CancelFamilyGroupInvite_Request {
    fn default() -> &'a CFamilyGroups_CancelFamilyGroupInvite_Request {
        <CFamilyGroups_CancelFamilyGroupInvite_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_CancelFamilyGroupInvite_Request {
    pub fn new() -> CFamilyGroups_CancelFamilyGroupInvite_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_to_cancel = 2;

    pub fn steamid_to_cancel(&self) -> u64 {
        self.steamid_to_cancel.unwrap_or(0)
    }

    pub fn clear_steamid_to_cancel(&mut self) {
        self.steamid_to_cancel = ::std::option::Option::None;
    }

    pub fn has_steamid_to_cancel(&self) -> bool {
        self.steamid_to_cancel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_to_cancel(&mut self, v: u64) {
        self.steamid_to_cancel = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_CancelFamilyGroupInvite_Request {
    const NAME: &'static str = "CFamilyGroups_CancelFamilyGroupInvite_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid_to_cancel = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid_to_cancel {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid_to_cancel {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_CancelFamilyGroupInvite_Request {
        CFamilyGroups_CancelFamilyGroupInvite_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.steamid_to_cancel = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_CancelFamilyGroupInvite_Request {
        static instance: CFamilyGroups_CancelFamilyGroupInvite_Request = CFamilyGroups_CancelFamilyGroupInvite_Request {
            family_groupid: ::std::option::Option::None,
            steamid_to_cancel: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_CancelFamilyGroupInvite_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_CancelFamilyGroupInvite_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_CancelFamilyGroupInvite_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_CancelFamilyGroupInvite_Response {
    fn default() -> &'a CFamilyGroups_CancelFamilyGroupInvite_Response {
        <CFamilyGroups_CancelFamilyGroupInvite_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_CancelFamilyGroupInvite_Response {
    pub fn new() -> CFamilyGroups_CancelFamilyGroupInvite_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_CancelFamilyGroupInvite_Response {
    const NAME: &'static str = "CFamilyGroups_CancelFamilyGroupInvite_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_CancelFamilyGroupInvite_Response {
        CFamilyGroups_CancelFamilyGroupInvite_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_CancelFamilyGroupInvite_Response {
        static instance: CFamilyGroups_CancelFamilyGroupInvite_Response = CFamilyGroups_CancelFamilyGroupInvite_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetUsersSharingDevice_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetUsersSharingDevice_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetUsersSharingDevice_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetUsersSharingDevice_Request.client_instance_id)
    pub client_instance_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetUsersSharingDevice_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetUsersSharingDevice_Request {
    fn default() -> &'a CFamilyGroups_GetUsersSharingDevice_Request {
        <CFamilyGroups_GetUsersSharingDevice_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetUsersSharingDevice_Request {
    pub fn new() -> CFamilyGroups_GetUsersSharingDevice_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional uint64 client_instance_id = 2;

    pub fn client_instance_id(&self) -> u64 {
        self.client_instance_id.unwrap_or(0)
    }

    pub fn clear_client_instance_id(&mut self) {
        self.client_instance_id = ::std::option::Option::None;
    }

    pub fn has_client_instance_id(&self) -> bool {
        self.client_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_instance_id(&mut self, v: u64) {
        self.client_instance_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetUsersSharingDevice_Request {
    const NAME: &'static str = "CFamilyGroups_GetUsersSharingDevice_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.client_instance_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.client_instance_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.client_instance_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetUsersSharingDevice_Request {
        CFamilyGroups_GetUsersSharingDevice_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.client_instance_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetUsersSharingDevice_Request {
        static instance: CFamilyGroups_GetUsersSharingDevice_Request = CFamilyGroups_GetUsersSharingDevice_Request {
            family_groupid: ::std::option::Option::None,
            client_instance_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetUsersSharingDevice_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetUsersSharingDevice_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetUsersSharingDevice_Response.users)
    pub users: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetUsersSharingDevice_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetUsersSharingDevice_Response {
    fn default() -> &'a CFamilyGroups_GetUsersSharingDevice_Response {
        <CFamilyGroups_GetUsersSharingDevice_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetUsersSharingDevice_Response {
    pub fn new() -> CFamilyGroups_GetUsersSharingDevice_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetUsersSharingDevice_Response {
    const NAME: &'static str = "CFamilyGroups_GetUsersSharingDevice_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.users)?;
                },
                9 => {
                    self.users.push(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.users.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.users {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetUsersSharingDevice_Response {
        CFamilyGroups_GetUsersSharingDevice_Response::new()
    }

    fn clear(&mut self) {
        self.users.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetUsersSharingDevice_Response {
        static instance: CFamilyGroups_GetUsersSharingDevice_Response = CFamilyGroups_GetUsersSharingDevice_Response {
            users: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_DeleteFamilyGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_DeleteFamilyGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_DeleteFamilyGroup_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_DeleteFamilyGroup_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_DeleteFamilyGroup_Request {
    fn default() -> &'a CFamilyGroups_DeleteFamilyGroup_Request {
        <CFamilyGroups_DeleteFamilyGroup_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_DeleteFamilyGroup_Request {
    pub fn new() -> CFamilyGroups_DeleteFamilyGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_DeleteFamilyGroup_Request {
    const NAME: &'static str = "CFamilyGroups_DeleteFamilyGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_DeleteFamilyGroup_Request {
        CFamilyGroups_DeleteFamilyGroup_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_DeleteFamilyGroup_Request {
        static instance: CFamilyGroups_DeleteFamilyGroup_Request = CFamilyGroups_DeleteFamilyGroup_Request {
            family_groupid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_DeleteFamilyGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_DeleteFamilyGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_DeleteFamilyGroup_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_DeleteFamilyGroup_Response {
    fn default() -> &'a CFamilyGroups_DeleteFamilyGroup_Response {
        <CFamilyGroups_DeleteFamilyGroup_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_DeleteFamilyGroup_Response {
    pub fn new() -> CFamilyGroups_DeleteFamilyGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_DeleteFamilyGroup_Response {
    const NAME: &'static str = "CFamilyGroups_DeleteFamilyGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_DeleteFamilyGroup_Response {
        CFamilyGroups_DeleteFamilyGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_DeleteFamilyGroup_Response {
        static instance: CFamilyGroups_DeleteFamilyGroup_Response = CFamilyGroups_DeleteFamilyGroup_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_UndeleteFamilyGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_UndeleteFamilyGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_UndeleteFamilyGroup_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_UndeleteFamilyGroup_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_UndeleteFamilyGroup_Request {
    fn default() -> &'a CFamilyGroups_UndeleteFamilyGroup_Request {
        <CFamilyGroups_UndeleteFamilyGroup_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_UndeleteFamilyGroup_Request {
    pub fn new() -> CFamilyGroups_UndeleteFamilyGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_UndeleteFamilyGroup_Request {
    const NAME: &'static str = "CFamilyGroups_UndeleteFamilyGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_UndeleteFamilyGroup_Request {
        CFamilyGroups_UndeleteFamilyGroup_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_UndeleteFamilyGroup_Request {
        static instance: CFamilyGroups_UndeleteFamilyGroup_Request = CFamilyGroups_UndeleteFamilyGroup_Request {
            family_groupid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_UndeleteFamilyGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_UndeleteFamilyGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_UndeleteFamilyGroup_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_UndeleteFamilyGroup_Response {
    fn default() -> &'a CFamilyGroups_UndeleteFamilyGroup_Response {
        <CFamilyGroups_UndeleteFamilyGroup_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_UndeleteFamilyGroup_Response {
    pub fn new() -> CFamilyGroups_UndeleteFamilyGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_UndeleteFamilyGroup_Response {
    const NAME: &'static str = "CFamilyGroups_UndeleteFamilyGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_UndeleteFamilyGroup_Response {
        CFamilyGroups_UndeleteFamilyGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_UndeleteFamilyGroup_Response {
        static instance: CFamilyGroups_UndeleteFamilyGroup_Response = CFamilyGroups_UndeleteFamilyGroup_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetPlaytimeSummary_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetPlaytimeSummary_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetPlaytimeSummary_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetPlaytimeSummary_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetPlaytimeSummary_Request {
    fn default() -> &'a CFamilyGroups_GetPlaytimeSummary_Request {
        <CFamilyGroups_GetPlaytimeSummary_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetPlaytimeSummary_Request {
    pub fn new() -> CFamilyGroups_GetPlaytimeSummary_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetPlaytimeSummary_Request {
    const NAME: &'static str = "CFamilyGroups_GetPlaytimeSummary_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetPlaytimeSummary_Request {
        CFamilyGroups_GetPlaytimeSummary_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetPlaytimeSummary_Request {
        static instance: CFamilyGroups_GetPlaytimeSummary_Request = CFamilyGroups_GetPlaytimeSummary_Request {
            family_groupid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_PlaytimeEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_PlaytimeEntry {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_PlaytimeEntry.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_PlaytimeEntry.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_PlaytimeEntry.first_played)
    pub first_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_PlaytimeEntry.latest_played)
    pub latest_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_PlaytimeEntry.seconds_played)
    pub seconds_played: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_PlaytimeEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_PlaytimeEntry {
    fn default() -> &'a CFamilyGroups_PlaytimeEntry {
        <CFamilyGroups_PlaytimeEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_PlaytimeEntry {
    pub fn new() -> CFamilyGroups_PlaytimeEntry {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 first_played = 3;

    pub fn first_played(&self) -> u32 {
        self.first_played.unwrap_or(0)
    }

    pub fn clear_first_played(&mut self) {
        self.first_played = ::std::option::Option::None;
    }

    pub fn has_first_played(&self) -> bool {
        self.first_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_played(&mut self, v: u32) {
        self.first_played = ::std::option::Option::Some(v);
    }

    // optional uint32 latest_played = 4;

    pub fn latest_played(&self) -> u32 {
        self.latest_played.unwrap_or(0)
    }

    pub fn clear_latest_played(&mut self) {
        self.latest_played = ::std::option::Option::None;
    }

    pub fn has_latest_played(&self) -> bool {
        self.latest_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_played(&mut self, v: u32) {
        self.latest_played = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_played = 5;

    pub fn seconds_played(&self) -> u32 {
        self.seconds_played.unwrap_or(0)
    }

    pub fn clear_seconds_played(&mut self) {
        self.seconds_played = ::std::option::Option::None;
    }

    pub fn has_seconds_played(&self) -> bool {
        self.seconds_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_played(&mut self, v: u32) {
        self.seconds_played = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_PlaytimeEntry {
    const NAME: &'static str = "CFamilyGroups_PlaytimeEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.first_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.latest_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.seconds_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.first_played {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.latest_played {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.seconds_played {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.first_played {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.latest_played {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.seconds_played {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_PlaytimeEntry {
        CFamilyGroups_PlaytimeEntry::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.first_played = ::std::option::Option::None;
        self.latest_played = ::std::option::Option::None;
        self.seconds_played = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_PlaytimeEntry {
        static instance: CFamilyGroups_PlaytimeEntry = CFamilyGroups_PlaytimeEntry {
            steamid: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            first_played: ::std::option::Option::None,
            latest_played: ::std::option::Option::None,
            seconds_played: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetPlaytimeSummary_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetPlaytimeSummary_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetPlaytimeSummary_Response.entries)
    pub entries: ::std::vec::Vec<CFamilyGroups_PlaytimeEntry>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetPlaytimeSummary_Response.entries_by_owner)
    pub entries_by_owner: ::std::vec::Vec<CFamilyGroups_PlaytimeEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetPlaytimeSummary_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetPlaytimeSummary_Response {
    fn default() -> &'a CFamilyGroups_GetPlaytimeSummary_Response {
        <CFamilyGroups_GetPlaytimeSummary_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetPlaytimeSummary_Response {
    pub fn new() -> CFamilyGroups_GetPlaytimeSummary_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetPlaytimeSummary_Response {
    const NAME: &'static str = "CFamilyGroups_GetPlaytimeSummary_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                18 => {
                    self.entries_by_owner.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.entries_by_owner {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.entries {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.entries_by_owner {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetPlaytimeSummary_Response {
        CFamilyGroups_GetPlaytimeSummary_Response::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.entries_by_owner.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetPlaytimeSummary_Response {
        static instance: CFamilyGroups_GetPlaytimeSummary_Response = CFamilyGroups_GetPlaytimeSummary_Response {
            entries: ::std::vec::Vec::new(),
            entries_by_owner: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_RequestPurchase_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_RequestPurchase_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_RequestPurchase_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_RequestPurchase_Request.gidshoppingcart)
    pub gidshoppingcart: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_RequestPurchase_Request.store_country_code)
    pub store_country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CFamilyGroups_RequestPurchase_Request.use_account_cart)
    pub use_account_cart: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_RequestPurchase_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_RequestPurchase_Request {
    fn default() -> &'a CFamilyGroups_RequestPurchase_Request {
        <CFamilyGroups_RequestPurchase_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_RequestPurchase_Request {
    pub fn new() -> CFamilyGroups_RequestPurchase_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional uint64 gidshoppingcart = 2;

    pub fn gidshoppingcart(&self) -> u64 {
        self.gidshoppingcart.unwrap_or(0)
    }

    pub fn clear_gidshoppingcart(&mut self) {
        self.gidshoppingcart = ::std::option::Option::None;
    }

    pub fn has_gidshoppingcart(&self) -> bool {
        self.gidshoppingcart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidshoppingcart(&mut self, v: u64) {
        self.gidshoppingcart = ::std::option::Option::Some(v);
    }

    // optional string store_country_code = 3;

    pub fn store_country_code(&self) -> &str {
        match self.store_country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_store_country_code(&mut self) {
        self.store_country_code = ::std::option::Option::None;
    }

    pub fn has_store_country_code(&self) -> bool {
        self.store_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_country_code(&mut self, v: ::std::string::String) {
        self.store_country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_store_country_code(&mut self) -> &mut ::std::string::String {
        if self.store_country_code.is_none() {
            self.store_country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.store_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_store_country_code(&mut self) -> ::std::string::String {
        self.store_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool use_account_cart = 4;

    pub fn use_account_cart(&self) -> bool {
        self.use_account_cart.unwrap_or(false)
    }

    pub fn clear_use_account_cart(&mut self) {
        self.use_account_cart = ::std::option::Option::None;
    }

    pub fn has_use_account_cart(&self) -> bool {
        self.use_account_cart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_account_cart(&mut self, v: bool) {
        self.use_account_cart = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_RequestPurchase_Request {
    const NAME: &'static str = "CFamilyGroups_RequestPurchase_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.gidshoppingcart = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.store_country_code = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.use_account_cart = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.gidshoppingcart {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.store_country_code.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.use_account_cart {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.gidshoppingcart {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.store_country_code.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.use_account_cart {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_RequestPurchase_Request {
        CFamilyGroups_RequestPurchase_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.gidshoppingcart = ::std::option::Option::None;
        self.store_country_code = ::std::option::Option::None;
        self.use_account_cart = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_RequestPurchase_Request {
        static instance: CFamilyGroups_RequestPurchase_Request = CFamilyGroups_RequestPurchase_Request {
            family_groupid: ::std::option::Option::None,
            gidshoppingcart: ::std::option::Option::None,
            store_country_code: ::std::option::Option::None,
            use_account_cart: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_RequestPurchase_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_RequestPurchase_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_RequestPurchase_Response.gidshoppingcart)
    pub gidshoppingcart: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_RequestPurchase_Response.request_id)
    pub request_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_RequestPurchase_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_RequestPurchase_Response {
    fn default() -> &'a CFamilyGroups_RequestPurchase_Response {
        <CFamilyGroups_RequestPurchase_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_RequestPurchase_Response {
    pub fn new() -> CFamilyGroups_RequestPurchase_Response {
        ::std::default::Default::default()
    }

    // optional uint64 gidshoppingcart = 1;

    pub fn gidshoppingcart(&self) -> u64 {
        self.gidshoppingcart.unwrap_or(0)
    }

    pub fn clear_gidshoppingcart(&mut self) {
        self.gidshoppingcart = ::std::option::Option::None;
    }

    pub fn has_gidshoppingcart(&self) -> bool {
        self.gidshoppingcart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidshoppingcart(&mut self, v: u64) {
        self.gidshoppingcart = ::std::option::Option::Some(v);
    }

    // optional uint64 request_id = 2;

    pub fn request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_RequestPurchase_Response {
    const NAME: &'static str = "CFamilyGroups_RequestPurchase_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gidshoppingcart = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gidshoppingcart {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.request_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.gidshoppingcart {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_RequestPurchase_Response {
        CFamilyGroups_RequestPurchase_Response::new()
    }

    fn clear(&mut self) {
        self.gidshoppingcart = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_RequestPurchase_Response {
        static instance: CFamilyGroups_RequestPurchase_Response = CFamilyGroups_RequestPurchase_Response {
            gidshoppingcart: ::std::option::Option::None,
            request_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetPurchaseRequests_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetPurchaseRequests_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetPurchaseRequests_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetPurchaseRequests_Request.request_ids)
    pub request_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetPurchaseRequests_Request.rt_include_completed_since)
    pub rt_include_completed_since: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetPurchaseRequests_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetPurchaseRequests_Request {
    fn default() -> &'a CFamilyGroups_GetPurchaseRequests_Request {
        <CFamilyGroups_GetPurchaseRequests_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetPurchaseRequests_Request {
    pub fn new() -> CFamilyGroups_GetPurchaseRequests_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional uint32 rt_include_completed_since = 4;

    pub fn rt_include_completed_since(&self) -> u32 {
        self.rt_include_completed_since.unwrap_or(0)
    }

    pub fn clear_rt_include_completed_since(&mut self) {
        self.rt_include_completed_since = ::std::option::Option::None;
    }

    pub fn has_rt_include_completed_since(&self) -> bool {
        self.rt_include_completed_since.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rt_include_completed_since(&mut self, v: u32) {
        self.rt_include_completed_since = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetPurchaseRequests_Request {
    const NAME: &'static str = "CFamilyGroups_GetPurchaseRequests_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.request_ids)?;
                },
                24 => {
                    self.request_ids.push(is.read_uint64()?);
                },
                32 => {
                    self.rt_include_completed_since = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.request_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, *value);
        };
        if let Some(v) = self.rt_include_completed_since {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        for v in &self.request_ids {
            os.write_uint64(3, *v)?;
        };
        if let Some(v) = self.rt_include_completed_since {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetPurchaseRequests_Request {
        CFamilyGroups_GetPurchaseRequests_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.request_ids.clear();
        self.rt_include_completed_since = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetPurchaseRequests_Request {
        static instance: CFamilyGroups_GetPurchaseRequests_Request = CFamilyGroups_GetPurchaseRequests_Request {
            family_groupid: ::std::option::Option::None,
            request_ids: ::std::vec::Vec::new(),
            rt_include_completed_since: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:PurchaseRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PurchaseRequest {
    // message fields
    // @@protoc_insertion_point(field:PurchaseRequest.requester_steamid)
    pub requester_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:PurchaseRequest.gidshoppingcart)
    pub gidshoppingcart: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:PurchaseRequest.time_requested)
    pub time_requested: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PurchaseRequest.time_responded)
    pub time_responded: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PurchaseRequest.responder_steamid)
    pub responder_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:PurchaseRequest.response_action)
    pub response_action: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EPurchaseRequestAction>>,
    // @@protoc_insertion_point(field:PurchaseRequest.is_completed)
    pub is_completed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:PurchaseRequest.request_id)
    pub request_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:PurchaseRequest.requested_packageids)
    pub requested_packageids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:PurchaseRequest.purchased_packageids)
    pub purchased_packageids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:PurchaseRequest.requested_bundleids)
    pub requested_bundleids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:PurchaseRequest.purchased_bundleids)
    pub purchased_bundleids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:PurchaseRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PurchaseRequest {
    fn default() -> &'a PurchaseRequest {
        <PurchaseRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl PurchaseRequest {
    pub fn new() -> PurchaseRequest {
        ::std::default::Default::default()
    }

    // optional fixed64 requester_steamid = 1;

    pub fn requester_steamid(&self) -> u64 {
        self.requester_steamid.unwrap_or(0)
    }

    pub fn clear_requester_steamid(&mut self) {
        self.requester_steamid = ::std::option::Option::None;
    }

    pub fn has_requester_steamid(&self) -> bool {
        self.requester_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requester_steamid(&mut self, v: u64) {
        self.requester_steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 gidshoppingcart = 2;

    pub fn gidshoppingcart(&self) -> u64 {
        self.gidshoppingcart.unwrap_or(0)
    }

    pub fn clear_gidshoppingcart(&mut self) {
        self.gidshoppingcart = ::std::option::Option::None;
    }

    pub fn has_gidshoppingcart(&self) -> bool {
        self.gidshoppingcart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidshoppingcart(&mut self, v: u64) {
        self.gidshoppingcart = ::std::option::Option::Some(v);
    }

    // optional uint32 time_requested = 3;

    pub fn time_requested(&self) -> u32 {
        self.time_requested.unwrap_or(0)
    }

    pub fn clear_time_requested(&mut self) {
        self.time_requested = ::std::option::Option::None;
    }

    pub fn has_time_requested(&self) -> bool {
        self.time_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_requested(&mut self, v: u32) {
        self.time_requested = ::std::option::Option::Some(v);
    }

    // optional uint32 time_responded = 4;

    pub fn time_responded(&self) -> u32 {
        self.time_responded.unwrap_or(0)
    }

    pub fn clear_time_responded(&mut self) {
        self.time_responded = ::std::option::Option::None;
    }

    pub fn has_time_responded(&self) -> bool {
        self.time_responded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_responded(&mut self, v: u32) {
        self.time_responded = ::std::option::Option::Some(v);
    }

    // optional fixed64 responder_steamid = 5;

    pub fn responder_steamid(&self) -> u64 {
        self.responder_steamid.unwrap_or(0)
    }

    pub fn clear_responder_steamid(&mut self) {
        self.responder_steamid = ::std::option::Option::None;
    }

    pub fn has_responder_steamid(&self) -> bool {
        self.responder_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_responder_steamid(&mut self, v: u64) {
        self.responder_steamid = ::std::option::Option::Some(v);
    }

    // optional .EPurchaseRequestAction response_action = 6;

    pub fn response_action(&self) -> EPurchaseRequestAction {
        match self.response_action {
            Some(e) => e.enum_value_or(EPurchaseRequestAction::k_EPurchaseRequestAction_None),
            None => EPurchaseRequestAction::k_EPurchaseRequestAction_None,
        }
    }

    pub fn clear_response_action(&mut self) {
        self.response_action = ::std::option::Option::None;
    }

    pub fn has_response_action(&self) -> bool {
        self.response_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_action(&mut self, v: EPurchaseRequestAction) {
        self.response_action = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool is_completed = 7;

    pub fn is_completed(&self) -> bool {
        self.is_completed.unwrap_or(false)
    }

    pub fn clear_is_completed(&mut self) {
        self.is_completed = ::std::option::Option::None;
    }

    pub fn has_is_completed(&self) -> bool {
        self.is_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_completed(&mut self, v: bool) {
        self.is_completed = ::std::option::Option::Some(v);
    }

    // optional uint64 request_id = 8;

    pub fn request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for PurchaseRequest {
    const NAME: &'static str = "PurchaseRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.requester_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.gidshoppingcart = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.time_requested = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.time_responded = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.responder_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                48 => {
                    self.response_action = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.is_completed = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.requested_packageids)?;
                },
                72 => {
                    self.requested_packageids.push(is.read_uint32()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.purchased_packageids)?;
                },
                80 => {
                    self.purchased_packageids.push(is.read_uint32()?);
                },
                90 => {
                    is.read_repeated_packed_uint32_into(&mut self.requested_bundleids)?;
                },
                88 => {
                    self.requested_bundleids.push(is.read_uint32()?);
                },
                98 => {
                    is.read_repeated_packed_uint32_into(&mut self.purchased_bundleids)?;
                },
                96 => {
                    self.purchased_bundleids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.requester_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gidshoppingcart {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.time_requested {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.time_responded {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.responder_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.response_action {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.is_completed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.request_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(8, v);
        }
        for value in &self.requested_packageids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, *value);
        };
        for value in &self.purchased_packageids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, *value);
        };
        for value in &self.requested_bundleids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, *value);
        };
        for value in &self.purchased_bundleids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.requester_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.gidshoppingcart {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.time_requested {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.time_responded {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.responder_steamid {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.response_action {
            os.write_enum(6, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.is_completed {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(8, v)?;
        }
        for v in &self.requested_packageids {
            os.write_uint32(9, *v)?;
        };
        for v in &self.purchased_packageids {
            os.write_uint32(10, *v)?;
        };
        for v in &self.requested_bundleids {
            os.write_uint32(11, *v)?;
        };
        for v in &self.purchased_bundleids {
            os.write_uint32(12, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PurchaseRequest {
        PurchaseRequest::new()
    }

    fn clear(&mut self) {
        self.requester_steamid = ::std::option::Option::None;
        self.gidshoppingcart = ::std::option::Option::None;
        self.time_requested = ::std::option::Option::None;
        self.time_responded = ::std::option::Option::None;
        self.responder_steamid = ::std::option::Option::None;
        self.response_action = ::std::option::Option::None;
        self.is_completed = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.requested_packageids.clear();
        self.purchased_packageids.clear();
        self.requested_bundleids.clear();
        self.purchased_bundleids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PurchaseRequest {
        static instance: PurchaseRequest = PurchaseRequest {
            requester_steamid: ::std::option::Option::None,
            gidshoppingcart: ::std::option::Option::None,
            time_requested: ::std::option::Option::None,
            time_responded: ::std::option::Option::None,
            responder_steamid: ::std::option::Option::None,
            response_action: ::std::option::Option::None,
            is_completed: ::std::option::Option::None,
            request_id: ::std::option::Option::None,
            requested_packageids: ::std::vec::Vec::new(),
            purchased_packageids: ::std::vec::Vec::new(),
            requested_bundleids: ::std::vec::Vec::new(),
            purchased_bundleids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetPurchaseRequests_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetPurchaseRequests_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetPurchaseRequests_Response.requests)
    pub requests: ::std::vec::Vec<PurchaseRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetPurchaseRequests_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetPurchaseRequests_Response {
    fn default() -> &'a CFamilyGroups_GetPurchaseRequests_Response {
        <CFamilyGroups_GetPurchaseRequests_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetPurchaseRequests_Response {
    pub fn new() -> CFamilyGroups_GetPurchaseRequests_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetPurchaseRequests_Response {
    const NAME: &'static str = "CFamilyGroups_GetPurchaseRequests_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.requests.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.requests {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.requests {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetPurchaseRequests_Response {
        CFamilyGroups_GetPurchaseRequests_Response::new()
    }

    fn clear(&mut self) {
        self.requests.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetPurchaseRequests_Response {
        static instance: CFamilyGroups_GetPurchaseRequests_Response = CFamilyGroups_GetPurchaseRequests_Response {
            requests: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_RespondToRequestedPurchase_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_RespondToRequestedPurchase_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_RespondToRequestedPurchase_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_RespondToRequestedPurchase_Request.action)
    pub action: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EPurchaseRequestAction>>,
    // @@protoc_insertion_point(field:CFamilyGroups_RespondToRequestedPurchase_Request.request_id)
    pub request_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_RespondToRequestedPurchase_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_RespondToRequestedPurchase_Request {
    fn default() -> &'a CFamilyGroups_RespondToRequestedPurchase_Request {
        <CFamilyGroups_RespondToRequestedPurchase_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_RespondToRequestedPurchase_Request {
    pub fn new() -> CFamilyGroups_RespondToRequestedPurchase_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional .EPurchaseRequestAction action = 3;

    pub fn action(&self) -> EPurchaseRequestAction {
        match self.action {
            Some(e) => e.enum_value_or(EPurchaseRequestAction::k_EPurchaseRequestAction_None),
            None => EPurchaseRequestAction::k_EPurchaseRequestAction_None,
        }
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: EPurchaseRequestAction) {
        self.action = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 request_id = 4;

    pub fn request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_RespondToRequestedPurchase_Request {
    const NAME: &'static str = "CFamilyGroups_RespondToRequestedPurchase_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.action = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.action {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.request_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.action {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_RespondToRequestedPurchase_Request {
        CFamilyGroups_RespondToRequestedPurchase_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_RespondToRequestedPurchase_Request {
        static instance: CFamilyGroups_RespondToRequestedPurchase_Request = CFamilyGroups_RespondToRequestedPurchase_Request {
            family_groupid: ::std::option::Option::None,
            action: ::std::option::Option::None,
            request_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_RespondToRequestedPurchase_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_RespondToRequestedPurchase_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_RespondToRequestedPurchase_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_RespondToRequestedPurchase_Response {
    fn default() -> &'a CFamilyGroups_RespondToRequestedPurchase_Response {
        <CFamilyGroups_RespondToRequestedPurchase_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_RespondToRequestedPurchase_Response {
    pub fn new() -> CFamilyGroups_RespondToRequestedPurchase_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_RespondToRequestedPurchase_Response {
    const NAME: &'static str = "CFamilyGroups_RespondToRequestedPurchase_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_RespondToRequestedPurchase_Response {
        CFamilyGroups_RespondToRequestedPurchase_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_RespondToRequestedPurchase_Response {
        static instance: CFamilyGroups_RespondToRequestedPurchase_Response = CFamilyGroups_RespondToRequestedPurchase_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetChangeLog_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetChangeLog_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetChangeLog_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetChangeLog_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetChangeLog_Request {
    fn default() -> &'a CFamilyGroups_GetChangeLog_Request {
        <CFamilyGroups_GetChangeLog_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetChangeLog_Request {
    pub fn new() -> CFamilyGroups_GetChangeLog_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetChangeLog_Request {
    const NAME: &'static str = "CFamilyGroups_GetChangeLog_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetChangeLog_Request {
        CFamilyGroups_GetChangeLog_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetChangeLog_Request {
        static instance: CFamilyGroups_GetChangeLog_Request = CFamilyGroups_GetChangeLog_Request {
            family_groupid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetChangeLog_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetChangeLog_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetChangeLog_Response.changes)
    pub changes: ::std::vec::Vec<cfamily_groups_get_change_log_response::Change>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetChangeLog_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetChangeLog_Response {
    fn default() -> &'a CFamilyGroups_GetChangeLog_Response {
        <CFamilyGroups_GetChangeLog_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetChangeLog_Response {
    pub fn new() -> CFamilyGroups_GetChangeLog_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetChangeLog_Response {
    const NAME: &'static str = "CFamilyGroups_GetChangeLog_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.changes.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.changes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.changes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetChangeLog_Response {
        CFamilyGroups_GetChangeLog_Response::new()
    }

    fn clear(&mut self) {
        self.changes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetChangeLog_Response {
        static instance: CFamilyGroups_GetChangeLog_Response = CFamilyGroups_GetChangeLog_Response {
            changes: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CFamilyGroups_GetChangeLog_Response`
pub mod cfamily_groups_get_change_log_response {
    // @@protoc_insertion_point(message:CFamilyGroups_GetChangeLog_Response.Change)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Change {
        // message fields
        // @@protoc_insertion_point(field:CFamilyGroups_GetChangeLog_Response.Change.timestamp)
        pub timestamp: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetChangeLog_Response.Change.actor_steamid)
        pub actor_steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetChangeLog_Response.Change.type)
        pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::EFamilyGroupChangeLogType>>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetChangeLog_Response.Change.body)
        pub body: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetChangeLog_Response.Change.by_support)
        pub by_support: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CFamilyGroups_GetChangeLog_Response.Change.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Change {
        fn default() -> &'a Change {
            <Change as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Change {
        pub fn new() -> Change {
            ::std::default::Default::default()
        }

        // optional fixed64 timestamp = 1;

        pub fn timestamp(&self) -> u64 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u64) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional fixed64 actor_steamid = 2;

        pub fn actor_steamid(&self) -> u64 {
            self.actor_steamid.unwrap_or(0)
        }

        pub fn clear_actor_steamid(&mut self) {
            self.actor_steamid = ::std::option::Option::None;
        }

        pub fn has_actor_steamid(&self) -> bool {
            self.actor_steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_actor_steamid(&mut self, v: u64) {
            self.actor_steamid = ::std::option::Option::Some(v);
        }

        // optional .EFamilyGroupChangeLogType type = 3;

        pub fn type_(&self) -> super::EFamilyGroupChangeLogType {
            match self.type_ {
                Some(e) => e.enum_value_or(super::EFamilyGroupChangeLogType::k_InvalidChangeType),
                None => super::EFamilyGroupChangeLogType::k_InvalidChangeType,
            }
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: super::EFamilyGroupChangeLogType) {
            self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional string body = 4;

        pub fn body(&self) -> &str {
            match self.body.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_body(&mut self) {
            self.body = ::std::option::Option::None;
        }

        pub fn has_body(&self) -> bool {
            self.body.is_some()
        }

        // Param is passed by value, moved
        pub fn set_body(&mut self, v: ::std::string::String) {
            self.body = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_body(&mut self) -> &mut ::std::string::String {
            if self.body.is_none() {
                self.body = ::std::option::Option::Some(::std::string::String::new());
            }
            self.body.as_mut().unwrap()
        }

        // Take field
        pub fn take_body(&mut self) -> ::std::string::String {
            self.body.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool by_support = 5;

        pub fn by_support(&self) -> bool {
            self.by_support.unwrap_or(false)
        }

        pub fn clear_by_support(&mut self) {
            self.by_support = ::std::option::Option::None;
        }

        pub fn has_by_support(&self) -> bool {
            self.by_support.is_some()
        }

        // Param is passed by value, moved
        pub fn set_by_support(&mut self, v: bool) {
            self.by_support = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Change {
        const NAME: &'static str = "Change";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.timestamp = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    17 => {
                        self.actor_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    24 => {
                        self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    34 => {
                        self.body = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.by_support = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.timestamp {
                my_size += 1 + 8;
            }
            if let Some(v) = self.actor_steamid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.body.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.by_support {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.timestamp {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.actor_steamid {
                os.write_fixed64(2, v)?;
            }
            if let Some(v) = self.type_ {
                os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.body.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.by_support {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Change {
            Change::new()
        }

        fn clear(&mut self) {
            self.timestamp = ::std::option::Option::None;
            self.actor_steamid = ::std::option::Option::None;
            self.type_ = ::std::option::Option::None;
            self.body = ::std::option::Option::None;
            self.by_support = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Change {
            static instance: Change = Change {
                timestamp: ::std::option::Option::None,
                actor_steamid: ::std::option::Option::None,
                type_: ::std::option::Option::None,
                body: ::std::option::Option::None,
                by_support: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_SetFamilyCooldownOverrides_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_SetFamilyCooldownOverrides_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_SetFamilyCooldownOverrides_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_SetFamilyCooldownOverrides_Request.cooldown_count)
    pub cooldown_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_SetFamilyCooldownOverrides_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_SetFamilyCooldownOverrides_Request {
    fn default() -> &'a CFamilyGroups_SetFamilyCooldownOverrides_Request {
        <CFamilyGroups_SetFamilyCooldownOverrides_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_SetFamilyCooldownOverrides_Request {
    pub fn new() -> CFamilyGroups_SetFamilyCooldownOverrides_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional uint32 cooldown_count = 2;

    pub fn cooldown_count(&self) -> u32 {
        self.cooldown_count.unwrap_or(0)
    }

    pub fn clear_cooldown_count(&mut self) {
        self.cooldown_count = ::std::option::Option::None;
    }

    pub fn has_cooldown_count(&self) -> bool {
        self.cooldown_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_count(&mut self, v: u32) {
        self.cooldown_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_SetFamilyCooldownOverrides_Request {
    const NAME: &'static str = "CFamilyGroups_SetFamilyCooldownOverrides_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.cooldown_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.cooldown_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.cooldown_count {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_SetFamilyCooldownOverrides_Request {
        CFamilyGroups_SetFamilyCooldownOverrides_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.cooldown_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_SetFamilyCooldownOverrides_Request {
        static instance: CFamilyGroups_SetFamilyCooldownOverrides_Request = CFamilyGroups_SetFamilyCooldownOverrides_Request {
            family_groupid: ::std::option::Option::None,
            cooldown_count: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_SetFamilyCooldownOverrides_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_SetFamilyCooldownOverrides_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_SetFamilyCooldownOverrides_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_SetFamilyCooldownOverrides_Response {
    fn default() -> &'a CFamilyGroups_SetFamilyCooldownOverrides_Response {
        <CFamilyGroups_SetFamilyCooldownOverrides_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_SetFamilyCooldownOverrides_Response {
    pub fn new() -> CFamilyGroups_SetFamilyCooldownOverrides_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_SetFamilyCooldownOverrides_Response {
    const NAME: &'static str = "CFamilyGroups_SetFamilyCooldownOverrides_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_SetFamilyCooldownOverrides_Response {
        CFamilyGroups_SetFamilyCooldownOverrides_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_SetFamilyCooldownOverrides_Response {
        static instance: CFamilyGroups_SetFamilyCooldownOverrides_Response = CFamilyGroups_SetFamilyCooldownOverrides_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetSharedLibraryApps_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetSharedLibraryApps_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Request.include_own)
    pub include_own: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Request.include_excluded)
    pub include_excluded: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Request.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Request.max_apps)
    pub max_apps: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Request.include_non_games)
    pub include_non_games: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetSharedLibraryApps_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetSharedLibraryApps_Request {
    fn default() -> &'a CFamilyGroups_GetSharedLibraryApps_Request {
        <CFamilyGroups_GetSharedLibraryApps_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetSharedLibraryApps_Request {
    pub fn new() -> CFamilyGroups_GetSharedLibraryApps_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional bool include_own = 2;

    pub fn include_own(&self) -> bool {
        self.include_own.unwrap_or(false)
    }

    pub fn clear_include_own(&mut self) {
        self.include_own = ::std::option::Option::None;
    }

    pub fn has_include_own(&self) -> bool {
        self.include_own.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_own(&mut self, v: bool) {
        self.include_own = ::std::option::Option::Some(v);
    }

    // optional bool include_excluded = 3;

    pub fn include_excluded(&self) -> bool {
        self.include_excluded.unwrap_or(false)
    }

    pub fn clear_include_excluded(&mut self) {
        self.include_excluded = ::std::option::Option::None;
    }

    pub fn has_include_excluded(&self) -> bool {
        self.include_excluded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_excluded(&mut self, v: bool) {
        self.include_excluded = ::std::option::Option::Some(v);
    }

    // optional string language = 5;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 max_apps = 6;

    pub fn max_apps(&self) -> u32 {
        self.max_apps.unwrap_or(0)
    }

    pub fn clear_max_apps(&mut self) {
        self.max_apps = ::std::option::Option::None;
    }

    pub fn has_max_apps(&self) -> bool {
        self.max_apps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_apps(&mut self, v: u32) {
        self.max_apps = ::std::option::Option::Some(v);
    }

    // optional bool include_non_games = 7;

    pub fn include_non_games(&self) -> bool {
        self.include_non_games.unwrap_or(false)
    }

    pub fn clear_include_non_games(&mut self) {
        self.include_non_games = ::std::option::Option::None;
    }

    pub fn has_include_non_games(&self) -> bool {
        self.include_non_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_non_games(&mut self, v: bool) {
        self.include_non_games = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 8;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetSharedLibraryApps_Request {
    const NAME: &'static str = "CFamilyGroups_GetSharedLibraryApps_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.include_own = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.include_excluded = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.max_apps = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.include_non_games = ::std::option::Option::Some(is.read_bool()?);
                },
                65 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.include_own {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_excluded {
            my_size += 1 + 1;
        }
        if let Some(v) = self.language.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.max_apps {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.include_non_games {
            my_size += 1 + 1;
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.include_own {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.include_excluded {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.max_apps {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.include_non_games {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetSharedLibraryApps_Request {
        CFamilyGroups_GetSharedLibraryApps_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.include_own = ::std::option::Option::None;
        self.include_excluded = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.max_apps = ::std::option::Option::None;
        self.include_non_games = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetSharedLibraryApps_Request {
        static instance: CFamilyGroups_GetSharedLibraryApps_Request = CFamilyGroups_GetSharedLibraryApps_Request {
            family_groupid: ::std::option::Option::None,
            include_own: ::std::option::Option::None,
            include_excluded: ::std::option::Option::None,
            language: ::std::option::Option::None,
            max_apps: ::std::option::Option::None,
            include_non_games: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetSharedLibraryApps_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetSharedLibraryApps_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.apps)
    pub apps: ::std::vec::Vec<cfamily_groups_get_shared_library_apps_response::SharedApp>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.owner_steamid)
    pub owner_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetSharedLibraryApps_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetSharedLibraryApps_Response {
    fn default() -> &'a CFamilyGroups_GetSharedLibraryApps_Response {
        <CFamilyGroups_GetSharedLibraryApps_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetSharedLibraryApps_Response {
    pub fn new() -> CFamilyGroups_GetSharedLibraryApps_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 owner_steamid = 2;

    pub fn owner_steamid(&self) -> u64 {
        self.owner_steamid.unwrap_or(0)
    }

    pub fn clear_owner_steamid(&mut self) {
        self.owner_steamid = ::std::option::Option::None;
    }

    pub fn has_owner_steamid(&self) -> bool {
        self.owner_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steamid(&mut self, v: u64) {
        self.owner_steamid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetSharedLibraryApps_Response {
    const NAME: &'static str = "CFamilyGroups_GetSharedLibraryApps_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apps.push(is.read_message()?);
                },
                17 => {
                    self.owner_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.owner_steamid {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.apps {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.owner_steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetSharedLibraryApps_Response {
        CFamilyGroups_GetSharedLibraryApps_Response::new()
    }

    fn clear(&mut self) {
        self.apps.clear();
        self.owner_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetSharedLibraryApps_Response {
        static instance: CFamilyGroups_GetSharedLibraryApps_Response = CFamilyGroups_GetSharedLibraryApps_Response {
            apps: ::std::vec::Vec::new(),
            owner_steamid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CFamilyGroups_GetSharedLibraryApps_Response`
pub mod cfamily_groups_get_shared_library_apps_response {
    // @@protoc_insertion_point(message:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SharedApp {
        // message fields
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.owner_steamids)
        pub owner_steamids: ::std::vec::Vec<u64>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.sort_as)
        pub sort_as: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.capsule_filename)
        pub capsule_filename: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.img_icon_hash)
        pub img_icon_hash: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.exclude_reason)
        pub exclude_reason: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::ESharedLibraryExcludeReason>>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.rt_time_acquired)
        pub rt_time_acquired: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.rt_last_played)
        pub rt_last_played: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.rt_playtime)
        pub rt_playtime: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.app_type)
        pub app_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::enums::EProtoAppType>>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.content_descriptors)
        pub content_descriptors: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CFamilyGroups_GetSharedLibraryApps_Response.SharedApp.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SharedApp {
        fn default() -> &'a SharedApp {
            <SharedApp as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SharedApp {
        pub fn new() -> SharedApp {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional string name = 6;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string sort_as = 7;

        pub fn sort_as(&self) -> &str {
            match self.sort_as.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_sort_as(&mut self) {
            self.sort_as = ::std::option::Option::None;
        }

        pub fn has_sort_as(&self) -> bool {
            self.sort_as.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sort_as(&mut self, v: ::std::string::String) {
            self.sort_as = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sort_as(&mut self) -> &mut ::std::string::String {
            if self.sort_as.is_none() {
                self.sort_as = ::std::option::Option::Some(::std::string::String::new());
            }
            self.sort_as.as_mut().unwrap()
        }

        // Take field
        pub fn take_sort_as(&mut self) -> ::std::string::String {
            self.sort_as.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string capsule_filename = 8;

        pub fn capsule_filename(&self) -> &str {
            match self.capsule_filename.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_capsule_filename(&mut self) {
            self.capsule_filename = ::std::option::Option::None;
        }

        pub fn has_capsule_filename(&self) -> bool {
            self.capsule_filename.is_some()
        }

        // Param is passed by value, moved
        pub fn set_capsule_filename(&mut self, v: ::std::string::String) {
            self.capsule_filename = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_capsule_filename(&mut self) -> &mut ::std::string::String {
            if self.capsule_filename.is_none() {
                self.capsule_filename = ::std::option::Option::Some(::std::string::String::new());
            }
            self.capsule_filename.as_mut().unwrap()
        }

        // Take field
        pub fn take_capsule_filename(&mut self) -> ::std::string::String {
            self.capsule_filename.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string img_icon_hash = 9;

        pub fn img_icon_hash(&self) -> &str {
            match self.img_icon_hash.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_img_icon_hash(&mut self) {
            self.img_icon_hash = ::std::option::Option::None;
        }

        pub fn has_img_icon_hash(&self) -> bool {
            self.img_icon_hash.is_some()
        }

        // Param is passed by value, moved
        pub fn set_img_icon_hash(&mut self, v: ::std::string::String) {
            self.img_icon_hash = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_img_icon_hash(&mut self) -> &mut ::std::string::String {
            if self.img_icon_hash.is_none() {
                self.img_icon_hash = ::std::option::Option::Some(::std::string::String::new());
            }
            self.img_icon_hash.as_mut().unwrap()
        }

        // Take field
        pub fn take_img_icon_hash(&mut self) -> ::std::string::String {
            self.img_icon_hash.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .ESharedLibraryExcludeReason exclude_reason = 10;

        pub fn exclude_reason(&self) -> super::ESharedLibraryExcludeReason {
            match self.exclude_reason {
                Some(e) => e.enum_value_or(super::ESharedLibraryExcludeReason::k_ESharedLibrary_Included),
                None => super::ESharedLibraryExcludeReason::k_ESharedLibrary_Included,
            }
        }

        pub fn clear_exclude_reason(&mut self) {
            self.exclude_reason = ::std::option::Option::None;
        }

        pub fn has_exclude_reason(&self) -> bool {
            self.exclude_reason.is_some()
        }

        // Param is passed by value, moved
        pub fn set_exclude_reason(&mut self, v: super::ESharedLibraryExcludeReason) {
            self.exclude_reason = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 rt_time_acquired = 11;

        pub fn rt_time_acquired(&self) -> u32 {
            self.rt_time_acquired.unwrap_or(0)
        }

        pub fn clear_rt_time_acquired(&mut self) {
            self.rt_time_acquired = ::std::option::Option::None;
        }

        pub fn has_rt_time_acquired(&self) -> bool {
            self.rt_time_acquired.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rt_time_acquired(&mut self, v: u32) {
            self.rt_time_acquired = ::std::option::Option::Some(v);
        }

        // optional uint32 rt_last_played = 12;

        pub fn rt_last_played(&self) -> u32 {
            self.rt_last_played.unwrap_or(0)
        }

        pub fn clear_rt_last_played(&mut self) {
            self.rt_last_played = ::std::option::Option::None;
        }

        pub fn has_rt_last_played(&self) -> bool {
            self.rt_last_played.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rt_last_played(&mut self, v: u32) {
            self.rt_last_played = ::std::option::Option::Some(v);
        }

        // optional uint32 rt_playtime = 13;

        pub fn rt_playtime(&self) -> u32 {
            self.rt_playtime.unwrap_or(0)
        }

        pub fn clear_rt_playtime(&mut self) {
            self.rt_playtime = ::std::option::Option::None;
        }

        pub fn has_rt_playtime(&self) -> bool {
            self.rt_playtime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rt_playtime(&mut self, v: u32) {
            self.rt_playtime = ::std::option::Option::Some(v);
        }

        // optional .EProtoAppType app_type = 14;

        pub fn app_type(&self) -> super::super::enums::EProtoAppType {
            match self.app_type {
                Some(e) => e.enum_value_or(super::super::enums::EProtoAppType::k_EAppTypeGame),
                None => super::super::enums::EProtoAppType::k_EAppTypeGame,
            }
        }

        pub fn clear_app_type(&mut self) {
            self.app_type = ::std::option::Option::None;
        }

        pub fn has_app_type(&self) -> bool {
            self.app_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_type(&mut self, v: super::super::enums::EProtoAppType) {
            self.app_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SharedApp {
        const NAME: &'static str = "SharedApp";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        is.read_repeated_packed_fixed64_into(&mut self.owner_steamids)?;
                    },
                    17 => {
                        self.owner_steamids.push(is.read_fixed64()?);
                    },
                    50 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        self.sort_as = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.capsule_filename = ::std::option::Option::Some(is.read_string()?);
                    },
                    74 => {
                        self.img_icon_hash = ::std::option::Option::Some(is.read_string()?);
                    },
                    80 => {
                        self.exclude_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    88 => {
                        self.rt_time_acquired = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.rt_last_played = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.rt_playtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.app_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    122 => {
                        is.read_repeated_packed_uint32_into(&mut self.content_descriptors)?;
                    },
                    120 => {
                        self.content_descriptors.push(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            my_size += 9 * self.owner_steamids.len() as u64;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.sort_as.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.capsule_filename.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.img_icon_hash.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(9, &v);
            }
            if let Some(v) = self.exclude_reason {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v.value());
            }
            if let Some(v) = self.rt_time_acquired {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.rt_last_played {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.rt_playtime {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.app_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v.value());
            }
            for value in &self.content_descriptors {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, *value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            for v in &self.owner_steamids {
                os.write_fixed64(2, *v)?;
            };
            if let Some(v) = self.name.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.sort_as.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.capsule_filename.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.img_icon_hash.as_ref() {
                os.write_string(9, v)?;
            }
            if let Some(v) = self.exclude_reason {
                os.write_enum(10, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.rt_time_acquired {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.rt_last_played {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.rt_playtime {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.app_type {
                os.write_enum(14, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            for v in &self.content_descriptors {
                os.write_uint32(15, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SharedApp {
            SharedApp::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.owner_steamids.clear();
            self.name = ::std::option::Option::None;
            self.sort_as = ::std::option::Option::None;
            self.capsule_filename = ::std::option::Option::None;
            self.img_icon_hash = ::std::option::Option::None;
            self.exclude_reason = ::std::option::Option::None;
            self.rt_time_acquired = ::std::option::Option::None;
            self.rt_last_played = ::std::option::Option::None;
            self.rt_playtime = ::std::option::Option::None;
            self.app_type = ::std::option::Option::None;
            self.content_descriptors.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SharedApp {
            static instance: SharedApp = SharedApp {
                appid: ::std::option::Option::None,
                owner_steamids: ::std::vec::Vec::new(),
                name: ::std::option::Option::None,
                sort_as: ::std::option::Option::None,
                capsule_filename: ::std::option::Option::None,
                img_icon_hash: ::std::option::Option::None,
                exclude_reason: ::std::option::Option::None,
                rt_time_acquired: ::std::option::Option::None,
                rt_last_played: ::std::option::Option::None,
                rt_playtime: ::std::option::Option::None,
                app_type: ::std::option::Option::None,
                content_descriptors: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_SetPreferredLender_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_SetPreferredLender_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_SetPreferredLender_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_SetPreferredLender_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFamilyGroups_SetPreferredLender_Request.lender_steamid)
    pub lender_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_SetPreferredLender_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_SetPreferredLender_Request {
    fn default() -> &'a CFamilyGroups_SetPreferredLender_Request {
        <CFamilyGroups_SetPreferredLender_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_SetPreferredLender_Request {
    pub fn new() -> CFamilyGroups_SetPreferredLender_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional fixed64 lender_steamid = 3;

    pub fn lender_steamid(&self) -> u64 {
        self.lender_steamid.unwrap_or(0)
    }

    pub fn clear_lender_steamid(&mut self) {
        self.lender_steamid = ::std::option::Option::None;
    }

    pub fn has_lender_steamid(&self) -> bool {
        self.lender_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lender_steamid(&mut self, v: u64) {
        self.lender_steamid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_SetPreferredLender_Request {
    const NAME: &'static str = "CFamilyGroups_SetPreferredLender_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                25 => {
                    self.lender_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.lender_steamid {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.lender_steamid {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_SetPreferredLender_Request {
        CFamilyGroups_SetPreferredLender_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.lender_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_SetPreferredLender_Request {
        static instance: CFamilyGroups_SetPreferredLender_Request = CFamilyGroups_SetPreferredLender_Request {
            family_groupid: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            lender_steamid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_SetPreferredLender_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_SetPreferredLender_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_SetPreferredLender_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_SetPreferredLender_Response {
    fn default() -> &'a CFamilyGroups_SetPreferredLender_Response {
        <CFamilyGroups_SetPreferredLender_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_SetPreferredLender_Response {
    pub fn new() -> CFamilyGroups_SetPreferredLender_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_SetPreferredLender_Response {
    const NAME: &'static str = "CFamilyGroups_SetPreferredLender_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_SetPreferredLender_Response {
        CFamilyGroups_SetPreferredLender_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_SetPreferredLender_Response {
        static instance: CFamilyGroups_SetPreferredLender_Response = CFamilyGroups_SetPreferredLender_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetPreferredLenders_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetPreferredLenders_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetPreferredLenders_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetPreferredLenders_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetPreferredLenders_Request {
    fn default() -> &'a CFamilyGroups_GetPreferredLenders_Request {
        <CFamilyGroups_GetPreferredLenders_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetPreferredLenders_Request {
    pub fn new() -> CFamilyGroups_GetPreferredLenders_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetPreferredLenders_Request {
    const NAME: &'static str = "CFamilyGroups_GetPreferredLenders_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetPreferredLenders_Request {
        CFamilyGroups_GetPreferredLenders_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetPreferredLenders_Request {
        static instance: CFamilyGroups_GetPreferredLenders_Request = CFamilyGroups_GetPreferredLenders_Request {
            family_groupid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetPreferredLenders_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetPreferredLenders_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetPreferredLenders_Response.members)
    pub members: ::std::vec::Vec<cfamily_groups_get_preferred_lenders_response::FamilyMember>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetPreferredLenders_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetPreferredLenders_Response {
    fn default() -> &'a CFamilyGroups_GetPreferredLenders_Response {
        <CFamilyGroups_GetPreferredLenders_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetPreferredLenders_Response {
    pub fn new() -> CFamilyGroups_GetPreferredLenders_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetPreferredLenders_Response {
    const NAME: &'static str = "CFamilyGroups_GetPreferredLenders_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.members.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetPreferredLenders_Response {
        CFamilyGroups_GetPreferredLenders_Response::new()
    }

    fn clear(&mut self) {
        self.members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetPreferredLenders_Response {
        static instance: CFamilyGroups_GetPreferredLenders_Response = CFamilyGroups_GetPreferredLenders_Response {
            members: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CFamilyGroups_GetPreferredLenders_Response`
pub mod cfamily_groups_get_preferred_lenders_response {
    // @@protoc_insertion_point(message:CFamilyGroups_GetPreferredLenders_Response.FamilyMember)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FamilyMember {
        // message fields
        // @@protoc_insertion_point(field:CFamilyGroups_GetPreferredLenders_Response.FamilyMember.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CFamilyGroups_GetPreferredLenders_Response.FamilyMember.preferred_appids)
        pub preferred_appids: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CFamilyGroups_GetPreferredLenders_Response.FamilyMember.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FamilyMember {
        fn default() -> &'a FamilyMember {
            <FamilyMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl FamilyMember {
        pub fn new() -> FamilyMember {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for FamilyMember {
        const NAME: &'static str = "FamilyMember";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    18 => {
                        is.read_repeated_packed_uint32_into(&mut self.preferred_appids)?;
                    },
                    16 => {
                        self.preferred_appids.push(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            for value in &self.preferred_appids {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            for v in &self.preferred_appids {
                os.write_uint32(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FamilyMember {
            FamilyMember::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.preferred_appids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FamilyMember {
            static instance: FamilyMember = FamilyMember {
                steamid: ::std::option::Option::None,
                preferred_appids: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_ForceAcceptInvite_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_ForceAcceptInvite_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_ForceAcceptInvite_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_ForceAcceptInvite_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_ForceAcceptInvite_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_ForceAcceptInvite_Request {
    fn default() -> &'a CFamilyGroups_ForceAcceptInvite_Request {
        <CFamilyGroups_ForceAcceptInvite_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_ForceAcceptInvite_Request {
    pub fn new() -> CFamilyGroups_ForceAcceptInvite_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_ForceAcceptInvite_Request {
    const NAME: &'static str = "CFamilyGroups_ForceAcceptInvite_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_ForceAcceptInvite_Request {
        CFamilyGroups_ForceAcceptInvite_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_ForceAcceptInvite_Request {
        static instance: CFamilyGroups_ForceAcceptInvite_Request = CFamilyGroups_ForceAcceptInvite_Request {
            family_groupid: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_ForceAcceptInvite_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_ForceAcceptInvite_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_ForceAcceptInvite_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_ForceAcceptInvite_Response {
    fn default() -> &'a CFamilyGroups_ForceAcceptInvite_Response {
        <CFamilyGroups_ForceAcceptInvite_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_ForceAcceptInvite_Response {
    pub fn new() -> CFamilyGroups_ForceAcceptInvite_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_ForceAcceptInvite_Response {
    const NAME: &'static str = "CFamilyGroups_ForceAcceptInvite_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_ForceAcceptInvite_Response {
        CFamilyGroups_ForceAcceptInvite_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_ForceAcceptInvite_Response {
        static instance: CFamilyGroups_ForceAcceptInvite_Response = CFamilyGroups_ForceAcceptInvite_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetInviteCheckResults_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetInviteCheckResults_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetInviteCheckResults_Request.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetInviteCheckResults_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetInviteCheckResults_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetInviteCheckResults_Request {
    fn default() -> &'a CFamilyGroups_GetInviteCheckResults_Request {
        <CFamilyGroups_GetInviteCheckResults_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetInviteCheckResults_Request {
    pub fn new() -> CFamilyGroups_GetInviteCheckResults_Request {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetInviteCheckResults_Request {
    const NAME: &'static str = "CFamilyGroups_GetInviteCheckResults_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetInviteCheckResults_Request {
        CFamilyGroups_GetInviteCheckResults_Request::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetInviteCheckResults_Request {
        static instance: CFamilyGroups_GetInviteCheckResults_Request = CFamilyGroups_GetInviteCheckResults_Request {
            family_groupid: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_GetInviteCheckResults_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_GetInviteCheckResults_Response {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_GetInviteCheckResults_Response.wallet_country_matches)
    pub wallet_country_matches: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetInviteCheckResults_Response.ip_match)
    pub ip_match: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CFamilyGroups_GetInviteCheckResults_Response.join_restriction)
    pub join_restriction: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_GetInviteCheckResults_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_GetInviteCheckResults_Response {
    fn default() -> &'a CFamilyGroups_GetInviteCheckResults_Response {
        <CFamilyGroups_GetInviteCheckResults_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_GetInviteCheckResults_Response {
    pub fn new() -> CFamilyGroups_GetInviteCheckResults_Response {
        ::std::default::Default::default()
    }

    // optional bool wallet_country_matches = 1;

    pub fn wallet_country_matches(&self) -> bool {
        self.wallet_country_matches.unwrap_or(false)
    }

    pub fn clear_wallet_country_matches(&mut self) {
        self.wallet_country_matches = ::std::option::Option::None;
    }

    pub fn has_wallet_country_matches(&self) -> bool {
        self.wallet_country_matches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wallet_country_matches(&mut self, v: bool) {
        self.wallet_country_matches = ::std::option::Option::Some(v);
    }

    // optional bool ip_match = 2;

    pub fn ip_match(&self) -> bool {
        self.ip_match.unwrap_or(false)
    }

    pub fn clear_ip_match(&mut self) {
        self.ip_match = ::std::option::Option::None;
    }

    pub fn has_ip_match(&self) -> bool {
        self.ip_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_match(&mut self, v: bool) {
        self.ip_match = ::std::option::Option::Some(v);
    }

    // optional uint32 join_restriction = 3;

    pub fn join_restriction(&self) -> u32 {
        self.join_restriction.unwrap_or(0)
    }

    pub fn clear_join_restriction(&mut self) {
        self.join_restriction = ::std::option::Option::None;
    }

    pub fn has_join_restriction(&self) -> bool {
        self.join_restriction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_restriction(&mut self, v: u32) {
        self.join_restriction = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_GetInviteCheckResults_Response {
    const NAME: &'static str = "CFamilyGroups_GetInviteCheckResults_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.wallet_country_matches = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.ip_match = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.join_restriction = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.wallet_country_matches {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ip_match {
            my_size += 1 + 1;
        }
        if let Some(v) = self.join_restriction {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.wallet_country_matches {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.ip_match {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.join_restriction {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_GetInviteCheckResults_Response {
        CFamilyGroups_GetInviteCheckResults_Response::new()
    }

    fn clear(&mut self) {
        self.wallet_country_matches = ::std::option::Option::None;
        self.ip_match = ::std::option::Option::None;
        self.join_restriction = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_GetInviteCheckResults_Response {
        static instance: CFamilyGroups_GetInviteCheckResults_Response = CFamilyGroups_GetInviteCheckResults_Response {
            wallet_country_matches: ::std::option::Option::None,
            ip_match: ::std::option::Option::None,
            join_restriction: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_ClearCooldownSkip_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_ClearCooldownSkip_Request {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroups_ClearCooldownSkip_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroups_ClearCooldownSkip_Request.invite_id)
    pub invite_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_ClearCooldownSkip_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_ClearCooldownSkip_Request {
    fn default() -> &'a CFamilyGroups_ClearCooldownSkip_Request {
        <CFamilyGroups_ClearCooldownSkip_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_ClearCooldownSkip_Request {
    pub fn new() -> CFamilyGroups_ClearCooldownSkip_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 invite_id = 2;

    pub fn invite_id(&self) -> u64 {
        self.invite_id.unwrap_or(0)
    }

    pub fn clear_invite_id(&mut self) {
        self.invite_id = ::std::option::Option::None;
    }

    pub fn has_invite_id(&self) -> bool {
        self.invite_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_id(&mut self, v: u64) {
        self.invite_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_ClearCooldownSkip_Request {
    const NAME: &'static str = "CFamilyGroups_ClearCooldownSkip_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.invite_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.invite_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.invite_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_ClearCooldownSkip_Request {
        CFamilyGroups_ClearCooldownSkip_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.invite_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_ClearCooldownSkip_Request {
        static instance: CFamilyGroups_ClearCooldownSkip_Request = CFamilyGroups_ClearCooldownSkip_Request {
            steamid: ::std::option::Option::None,
            invite_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroups_ClearCooldownSkip_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroups_ClearCooldownSkip_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroups_ClearCooldownSkip_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroups_ClearCooldownSkip_Response {
    fn default() -> &'a CFamilyGroups_ClearCooldownSkip_Response {
        <CFamilyGroups_ClearCooldownSkip_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroups_ClearCooldownSkip_Response {
    pub fn new() -> CFamilyGroups_ClearCooldownSkip_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroups_ClearCooldownSkip_Response {
    const NAME: &'static str = "CFamilyGroups_ClearCooldownSkip_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroups_ClearCooldownSkip_Response {
        CFamilyGroups_ClearCooldownSkip_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroups_ClearCooldownSkip_Response {
        static instance: CFamilyGroups_ClearCooldownSkip_Response = CFamilyGroups_ClearCooldownSkip_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroupsClient_NotifyRunningApps_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroupsClient_NotifyRunningApps_Notification {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroupsClient_NotifyRunningApps_Notification.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CFamilyGroupsClient_NotifyRunningApps_Notification.running_apps)
    pub running_apps: ::std::vec::Vec<cfamily_groups_client_notify_running_apps_notification::RunningApp>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroupsClient_NotifyRunningApps_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroupsClient_NotifyRunningApps_Notification {
    fn default() -> &'a CFamilyGroupsClient_NotifyRunningApps_Notification {
        <CFamilyGroupsClient_NotifyRunningApps_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroupsClient_NotifyRunningApps_Notification {
    pub fn new() -> CFamilyGroupsClient_NotifyRunningApps_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroupsClient_NotifyRunningApps_Notification {
    const NAME: &'static str = "CFamilyGroupsClient_NotifyRunningApps_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.running_apps.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.running_apps {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        for v in &self.running_apps {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroupsClient_NotifyRunningApps_Notification {
        CFamilyGroupsClient_NotifyRunningApps_Notification::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.running_apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroupsClient_NotifyRunningApps_Notification {
        static instance: CFamilyGroupsClient_NotifyRunningApps_Notification = CFamilyGroupsClient_NotifyRunningApps_Notification {
            family_groupid: ::std::option::Option::None,
            running_apps: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CFamilyGroupsClient_NotifyRunningApps_Notification`
pub mod cfamily_groups_client_notify_running_apps_notification {
    // @@protoc_insertion_point(message:CFamilyGroupsClient_NotifyRunningApps_Notification.PlayingMember)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayingMember {
        // message fields
        // @@protoc_insertion_point(field:CFamilyGroupsClient_NotifyRunningApps_Notification.PlayingMember.member_steamid)
        pub member_steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CFamilyGroupsClient_NotifyRunningApps_Notification.PlayingMember.owner_steamid)
        pub owner_steamid: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CFamilyGroupsClient_NotifyRunningApps_Notification.PlayingMember.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayingMember {
        fn default() -> &'a PlayingMember {
            <PlayingMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayingMember {
        pub fn new() -> PlayingMember {
            ::std::default::Default::default()
        }

        // optional fixed64 member_steamid = 1;

        pub fn member_steamid(&self) -> u64 {
            self.member_steamid.unwrap_or(0)
        }

        pub fn clear_member_steamid(&mut self) {
            self.member_steamid = ::std::option::Option::None;
        }

        pub fn has_member_steamid(&self) -> bool {
            self.member_steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_member_steamid(&mut self, v: u64) {
            self.member_steamid = ::std::option::Option::Some(v);
        }

        // optional fixed64 owner_steamid = 2;

        pub fn owner_steamid(&self) -> u64 {
            self.owner_steamid.unwrap_or(0)
        }

        pub fn clear_owner_steamid(&mut self) {
            self.owner_steamid = ::std::option::Option::None;
        }

        pub fn has_owner_steamid(&self) -> bool {
            self.owner_steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_steamid(&mut self, v: u64) {
            self.owner_steamid = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayingMember {
        const NAME: &'static str = "PlayingMember";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.member_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    17 => {
                        self.owner_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.member_steamid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.owner_steamid {
                my_size += 1 + 8;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.member_steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.owner_steamid {
                os.write_fixed64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayingMember {
            PlayingMember::new()
        }

        fn clear(&mut self) {
            self.member_steamid = ::std::option::Option::None;
            self.owner_steamid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayingMember {
            static instance: PlayingMember = PlayingMember {
                member_steamid: ::std::option::Option::None,
                owner_steamid: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CFamilyGroupsClient_NotifyRunningApps_Notification.RunningApp)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RunningApp {
        // message fields
        // @@protoc_insertion_point(field:CFamilyGroupsClient_NotifyRunningApps_Notification.RunningApp.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CFamilyGroupsClient_NotifyRunningApps_Notification.RunningApp.playing_members)
        pub playing_members: ::std::vec::Vec<PlayingMember>,
        // special fields
        // @@protoc_insertion_point(special_field:CFamilyGroupsClient_NotifyRunningApps_Notification.RunningApp.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RunningApp {
        fn default() -> &'a RunningApp {
            <RunningApp as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl RunningApp {
        pub fn new() -> RunningApp {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for RunningApp {
        const NAME: &'static str = "RunningApp";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.playing_members.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.playing_members {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            for v in &self.playing_members {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RunningApp {
            RunningApp::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.playing_members.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RunningApp {
            static instance: RunningApp = RunningApp {
                appid: ::std::option::Option::None,
                playing_members: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CFamilyGroupsClient_InviteStatus_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroupsClient_InviteStatus_Notification {
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroupsClient_InviteStatus_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroupsClient_InviteStatus_Notification {
    fn default() -> &'a CFamilyGroupsClient_InviteStatus_Notification {
        <CFamilyGroupsClient_InviteStatus_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroupsClient_InviteStatus_Notification {
    pub fn new() -> CFamilyGroupsClient_InviteStatus_Notification {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroupsClient_InviteStatus_Notification {
    const NAME: &'static str = "CFamilyGroupsClient_InviteStatus_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroupsClient_InviteStatus_Notification {
        CFamilyGroupsClient_InviteStatus_Notification::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroupsClient_InviteStatus_Notification {
        static instance: CFamilyGroupsClient_InviteStatus_Notification = CFamilyGroupsClient_InviteStatus_Notification {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CFamilyGroupsClient_GroupChanged_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFamilyGroupsClient_GroupChanged_Notification {
    // message fields
    // @@protoc_insertion_point(field:CFamilyGroupsClient_GroupChanged_Notification.family_groupid)
    pub family_groupid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CFamilyGroupsClient_GroupChanged_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFamilyGroupsClient_GroupChanged_Notification {
    fn default() -> &'a CFamilyGroupsClient_GroupChanged_Notification {
        <CFamilyGroupsClient_GroupChanged_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CFamilyGroupsClient_GroupChanged_Notification {
    pub fn new() -> CFamilyGroupsClient_GroupChanged_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 family_groupid = 1;

    pub fn family_groupid(&self) -> u64 {
        self.family_groupid.unwrap_or(0)
    }

    pub fn clear_family_groupid(&mut self) {
        self.family_groupid = ::std::option::Option::None;
    }

    pub fn has_family_groupid(&self) -> bool {
        self.family_groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family_groupid(&mut self, v: u64) {
        self.family_groupid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CFamilyGroupsClient_GroupChanged_Notification {
    const NAME: &'static str = "CFamilyGroupsClient_GroupChanged_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.family_groupid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.family_groupid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.family_groupid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFamilyGroupsClient_GroupChanged_Notification {
        CFamilyGroupsClient_GroupChanged_Notification::new()
    }

    fn clear(&mut self) {
        self.family_groupid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFamilyGroupsClient_GroupChanged_Notification {
        static instance: CFamilyGroupsClient_GroupChanged_Notification = CFamilyGroupsClient_GroupChanged_Notification {
            family_groupid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EFamilyGroupRole)
pub enum EFamilyGroupRole {
    // @@protoc_insertion_point(enum_value:EFamilyGroupRole.k_EFamilyGroupRole_None)
    k_EFamilyGroupRole_None = 0,
    // @@protoc_insertion_point(enum_value:EFamilyGroupRole.k_EFamilyGroupRole_Adult)
    k_EFamilyGroupRole_Adult = 1,
    // @@protoc_insertion_point(enum_value:EFamilyGroupRole.k_EFamilyGroupRole_Child)
    k_EFamilyGroupRole_Child = 2,
    // @@protoc_insertion_point(enum_value:EFamilyGroupRole.k_EFamilyGroupRole_MAX)
    k_EFamilyGroupRole_MAX = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for EFamilyGroupRole {
    const NAME: &'static str = "EFamilyGroupRole";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EFamilyGroupRole> {
        match value {
            0 => ::std::option::Option::Some(EFamilyGroupRole::k_EFamilyGroupRole_None),
            1 => ::std::option::Option::Some(EFamilyGroupRole::k_EFamilyGroupRole_Adult),
            2 => ::std::option::Option::Some(EFamilyGroupRole::k_EFamilyGroupRole_Child),
            3 => ::std::option::Option::Some(EFamilyGroupRole::k_EFamilyGroupRole_MAX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EFamilyGroupRole> {
        match str {
            "k_EFamilyGroupRole_None" => ::std::option::Option::Some(EFamilyGroupRole::k_EFamilyGroupRole_None),
            "k_EFamilyGroupRole_Adult" => ::std::option::Option::Some(EFamilyGroupRole::k_EFamilyGroupRole_Adult),
            "k_EFamilyGroupRole_Child" => ::std::option::Option::Some(EFamilyGroupRole::k_EFamilyGroupRole_Child),
            "k_EFamilyGroupRole_MAX" => ::std::option::Option::Some(EFamilyGroupRole::k_EFamilyGroupRole_MAX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EFamilyGroupRole] = &[
        EFamilyGroupRole::k_EFamilyGroupRole_None,
        EFamilyGroupRole::k_EFamilyGroupRole_Adult,
        EFamilyGroupRole::k_EFamilyGroupRole_Child,
        EFamilyGroupRole::k_EFamilyGroupRole_MAX,
    ];
}

impl ::std::default::Default for EFamilyGroupRole {
    fn default() -> Self {
        EFamilyGroupRole::k_EFamilyGroupRole_None
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EFamilyGroupsTwoFactorMethod)
pub enum EFamilyGroupsTwoFactorMethod {
    // @@protoc_insertion_point(enum_value:EFamilyGroupsTwoFactorMethod.k_EFamilyGroupsTwoFactorMethodNone)
    k_EFamilyGroupsTwoFactorMethodNone = 0,
    // @@protoc_insertion_point(enum_value:EFamilyGroupsTwoFactorMethod.k_EFamilyGroupsTwoFactorMethodMobile)
    k_EFamilyGroupsTwoFactorMethodMobile = 1,
    // @@protoc_insertion_point(enum_value:EFamilyGroupsTwoFactorMethod.k_EFamilyGroupsTwoFactorMethodEmail)
    k_EFamilyGroupsTwoFactorMethodEmail = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EFamilyGroupsTwoFactorMethod {
    const NAME: &'static str = "EFamilyGroupsTwoFactorMethod";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EFamilyGroupsTwoFactorMethod> {
        match value {
            0 => ::std::option::Option::Some(EFamilyGroupsTwoFactorMethod::k_EFamilyGroupsTwoFactorMethodNone),
            1 => ::std::option::Option::Some(EFamilyGroupsTwoFactorMethod::k_EFamilyGroupsTwoFactorMethodMobile),
            2 => ::std::option::Option::Some(EFamilyGroupsTwoFactorMethod::k_EFamilyGroupsTwoFactorMethodEmail),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EFamilyGroupsTwoFactorMethod> {
        match str {
            "k_EFamilyGroupsTwoFactorMethodNone" => ::std::option::Option::Some(EFamilyGroupsTwoFactorMethod::k_EFamilyGroupsTwoFactorMethodNone),
            "k_EFamilyGroupsTwoFactorMethodMobile" => ::std::option::Option::Some(EFamilyGroupsTwoFactorMethod::k_EFamilyGroupsTwoFactorMethodMobile),
            "k_EFamilyGroupsTwoFactorMethodEmail" => ::std::option::Option::Some(EFamilyGroupsTwoFactorMethod::k_EFamilyGroupsTwoFactorMethodEmail),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EFamilyGroupsTwoFactorMethod] = &[
        EFamilyGroupsTwoFactorMethod::k_EFamilyGroupsTwoFactorMethodNone,
        EFamilyGroupsTwoFactorMethod::k_EFamilyGroupsTwoFactorMethodMobile,
        EFamilyGroupsTwoFactorMethod::k_EFamilyGroupsTwoFactorMethodEmail,
    ];
}

impl ::std::default::Default for EFamilyGroupsTwoFactorMethod {
    fn default() -> Self {
        EFamilyGroupsTwoFactorMethod::k_EFamilyGroupsTwoFactorMethodNone
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPurchaseRequestAction)
pub enum EPurchaseRequestAction {
    // @@protoc_insertion_point(enum_value:EPurchaseRequestAction.k_EPurchaseRequestAction_None)
    k_EPurchaseRequestAction_None = 0,
    // @@protoc_insertion_point(enum_value:EPurchaseRequestAction.k_EPurchaseRequestAction_Decline)
    k_EPurchaseRequestAction_Decline = 1,
    // @@protoc_insertion_point(enum_value:EPurchaseRequestAction.k_EPurchaseRequestAction_Purchased)
    k_EPurchaseRequestAction_Purchased = 2,
    // @@protoc_insertion_point(enum_value:EPurchaseRequestAction.k_EPurchaseRequestAction_Abandoned)
    k_EPurchaseRequestAction_Abandoned = 3,
    // @@protoc_insertion_point(enum_value:EPurchaseRequestAction.k_EPurchaseRequestAction_Cancel)
    k_EPurchaseRequestAction_Cancel = 4,
    // @@protoc_insertion_point(enum_value:EPurchaseRequestAction.k_EPurchaseRequestAction_MAX)
    k_EPurchaseRequestAction_MAX = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for EPurchaseRequestAction {
    const NAME: &'static str = "EPurchaseRequestAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPurchaseRequestAction> {
        match value {
            0 => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_None),
            1 => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_Decline),
            2 => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_Purchased),
            3 => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_Abandoned),
            4 => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_Cancel),
            5 => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_MAX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPurchaseRequestAction> {
        match str {
            "k_EPurchaseRequestAction_None" => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_None),
            "k_EPurchaseRequestAction_Decline" => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_Decline),
            "k_EPurchaseRequestAction_Purchased" => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_Purchased),
            "k_EPurchaseRequestAction_Abandoned" => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_Abandoned),
            "k_EPurchaseRequestAction_Cancel" => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_Cancel),
            "k_EPurchaseRequestAction_MAX" => ::std::option::Option::Some(EPurchaseRequestAction::k_EPurchaseRequestAction_MAX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPurchaseRequestAction] = &[
        EPurchaseRequestAction::k_EPurchaseRequestAction_None,
        EPurchaseRequestAction::k_EPurchaseRequestAction_Decline,
        EPurchaseRequestAction::k_EPurchaseRequestAction_Purchased,
        EPurchaseRequestAction::k_EPurchaseRequestAction_Abandoned,
        EPurchaseRequestAction::k_EPurchaseRequestAction_Cancel,
        EPurchaseRequestAction::k_EPurchaseRequestAction_MAX,
    ];
}

impl ::std::default::Default for EPurchaseRequestAction {
    fn default() -> Self {
        EPurchaseRequestAction::k_EPurchaseRequestAction_None
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EFamilyGroupChangeLogType)
pub enum EFamilyGroupChangeLogType {
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_InvalidChangeType)
    k_InvalidChangeType = 0,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_FamilyGroupCreated)
    k_FamilyGroupCreated = 1,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_FamilyGroupModified)
    k_FamilyGroupModified = 2,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_FamilyGroupDeleted)
    k_FamilyGroupDeleted = 3,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_AccountInvited)
    k_AccountInvited = 4,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_InviteDeniedByGroupSize)
    k_InviteDeniedByGroupSize = 5,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_JoinedFamilyGroup)
    k_JoinedFamilyGroup = 6,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_JoinDeniedByRegionMismatch)
    k_JoinDeniedByRegionMismatch = 7,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_JoinDeniedByMissingIpAddress)
    k_JoinDeniedByMissingIpAddress = 8,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_JoinDeniedByFamilyCooldown)
    k_JoinDeniedByFamilyCooldown = 9,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_JoinDeniedByUserCooldown)
    k_JoinDeniedByUserCooldown = 10,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_JoinDeniedByOtherGroup)
    k_JoinDeniedByOtherGroup = 11,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_AccountRemoved)
    k_AccountRemoved = 12,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_InviteCanceled)
    k_InviteCanceled = 13,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_PurchaseRequested)
    k_PurchaseRequested = 14,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_ParentalSettingsEnabled)
    k_ParentalSettingsEnabled = 15,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_ParentalSettingsDisabled)
    k_ParentalSettingsDisabled = 16,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_ParentalSettingsChanged)
    k_ParentalSettingsChanged = 17,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_FamilyCooldownOverridesChanged)
    k_FamilyCooldownOverridesChanged = 18,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_PurchaseRequestCanceled)
    k_PurchaseRequestCanceled = 19,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_PurchaseRequestApproved)
    k_PurchaseRequestApproved = 20,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_PurchaseRequestDeclined)
    k_PurchaseRequestDeclined = 21,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_CooldownSkipConsumed)
    k_CooldownSkipConsumed = 22,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_FamilyGroupRestored)
    k_FamilyGroupRestored = 23,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_JoinDenied)
    k_JoinDenied = 24,
    // @@protoc_insertion_point(enum_value:EFamilyGroupChangeLogType.k_SupportForceAcceptedInvite)
    k_SupportForceAcceptedInvite = 25,
}

impl ::steam_vent_proto_common::protobuf::Enum for EFamilyGroupChangeLogType {
    const NAME: &'static str = "EFamilyGroupChangeLogType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EFamilyGroupChangeLogType> {
        match value {
            0 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_InvalidChangeType),
            1 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyGroupCreated),
            2 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyGroupModified),
            3 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyGroupDeleted),
            4 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_AccountInvited),
            5 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_InviteDeniedByGroupSize),
            6 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinedFamilyGroup),
            7 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByRegionMismatch),
            8 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByMissingIpAddress),
            9 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByFamilyCooldown),
            10 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByUserCooldown),
            11 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByOtherGroup),
            12 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_AccountRemoved),
            13 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_InviteCanceled),
            14 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_PurchaseRequested),
            15 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_ParentalSettingsEnabled),
            16 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_ParentalSettingsDisabled),
            17 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_ParentalSettingsChanged),
            18 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyCooldownOverridesChanged),
            19 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_PurchaseRequestCanceled),
            20 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_PurchaseRequestApproved),
            21 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_PurchaseRequestDeclined),
            22 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_CooldownSkipConsumed),
            23 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyGroupRestored),
            24 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDenied),
            25 => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_SupportForceAcceptedInvite),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EFamilyGroupChangeLogType> {
        match str {
            "k_InvalidChangeType" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_InvalidChangeType),
            "k_FamilyGroupCreated" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyGroupCreated),
            "k_FamilyGroupModified" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyGroupModified),
            "k_FamilyGroupDeleted" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyGroupDeleted),
            "k_AccountInvited" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_AccountInvited),
            "k_InviteDeniedByGroupSize" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_InviteDeniedByGroupSize),
            "k_JoinedFamilyGroup" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinedFamilyGroup),
            "k_JoinDeniedByRegionMismatch" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByRegionMismatch),
            "k_JoinDeniedByMissingIpAddress" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByMissingIpAddress),
            "k_JoinDeniedByFamilyCooldown" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByFamilyCooldown),
            "k_JoinDeniedByUserCooldown" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByUserCooldown),
            "k_JoinDeniedByOtherGroup" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDeniedByOtherGroup),
            "k_AccountRemoved" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_AccountRemoved),
            "k_InviteCanceled" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_InviteCanceled),
            "k_PurchaseRequested" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_PurchaseRequested),
            "k_ParentalSettingsEnabled" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_ParentalSettingsEnabled),
            "k_ParentalSettingsDisabled" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_ParentalSettingsDisabled),
            "k_ParentalSettingsChanged" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_ParentalSettingsChanged),
            "k_FamilyCooldownOverridesChanged" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyCooldownOverridesChanged),
            "k_PurchaseRequestCanceled" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_PurchaseRequestCanceled),
            "k_PurchaseRequestApproved" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_PurchaseRequestApproved),
            "k_PurchaseRequestDeclined" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_PurchaseRequestDeclined),
            "k_CooldownSkipConsumed" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_CooldownSkipConsumed),
            "k_FamilyGroupRestored" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_FamilyGroupRestored),
            "k_JoinDenied" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_JoinDenied),
            "k_SupportForceAcceptedInvite" => ::std::option::Option::Some(EFamilyGroupChangeLogType::k_SupportForceAcceptedInvite),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EFamilyGroupChangeLogType] = &[
        EFamilyGroupChangeLogType::k_InvalidChangeType,
        EFamilyGroupChangeLogType::k_FamilyGroupCreated,
        EFamilyGroupChangeLogType::k_FamilyGroupModified,
        EFamilyGroupChangeLogType::k_FamilyGroupDeleted,
        EFamilyGroupChangeLogType::k_AccountInvited,
        EFamilyGroupChangeLogType::k_InviteDeniedByGroupSize,
        EFamilyGroupChangeLogType::k_JoinedFamilyGroup,
        EFamilyGroupChangeLogType::k_JoinDeniedByRegionMismatch,
        EFamilyGroupChangeLogType::k_JoinDeniedByMissingIpAddress,
        EFamilyGroupChangeLogType::k_JoinDeniedByFamilyCooldown,
        EFamilyGroupChangeLogType::k_JoinDeniedByUserCooldown,
        EFamilyGroupChangeLogType::k_JoinDeniedByOtherGroup,
        EFamilyGroupChangeLogType::k_AccountRemoved,
        EFamilyGroupChangeLogType::k_InviteCanceled,
        EFamilyGroupChangeLogType::k_PurchaseRequested,
        EFamilyGroupChangeLogType::k_ParentalSettingsEnabled,
        EFamilyGroupChangeLogType::k_ParentalSettingsDisabled,
        EFamilyGroupChangeLogType::k_ParentalSettingsChanged,
        EFamilyGroupChangeLogType::k_FamilyCooldownOverridesChanged,
        EFamilyGroupChangeLogType::k_PurchaseRequestCanceled,
        EFamilyGroupChangeLogType::k_PurchaseRequestApproved,
        EFamilyGroupChangeLogType::k_PurchaseRequestDeclined,
        EFamilyGroupChangeLogType::k_CooldownSkipConsumed,
        EFamilyGroupChangeLogType::k_FamilyGroupRestored,
        EFamilyGroupChangeLogType::k_JoinDenied,
        EFamilyGroupChangeLogType::k_SupportForceAcceptedInvite,
    ];
}

impl ::std::default::Default for EFamilyGroupChangeLogType {
    fn default() -> Self {
        EFamilyGroupChangeLogType::k_InvalidChangeType
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESharedLibraryExcludeReason)
pub enum ESharedLibraryExcludeReason {
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_Included)
    k_ESharedLibrary_Included = 0,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_AppExcluded_ByPartner)
    k_ESharedLibrary_AppExcluded_ByPartner = 1,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_LicenseExcluded)
    k_ESharedLibrary_LicenseExcluded = 2,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_FreeGame)
    k_ESharedLibrary_FreeGame = 3,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_LicensePrivate)
    k_ESharedLibrary_LicensePrivate = 4,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_AppExcluded_WrongAppType)
    k_ESharedLibrary_AppExcluded_WrongAppType = 6,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_AppExcluded_NonrefundableDLC)
    k_ESharedLibrary_AppExcluded_NonrefundableDLC = 7,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_AppExcluded_UnreleasedApp)
    k_ESharedLibrary_AppExcluded_UnreleasedApp = 8,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_AppExcluded_ParentAppExcluded)
    k_ESharedLibrary_AppExcluded_ParentAppExcluded = 9,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_PackageExcluded_ByPartner)
    k_ESharedLibrary_PackageExcluded_ByPartner = 10,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_PackageExcluded_Special)
    k_ESharedLibrary_PackageExcluded_Special = 11,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_PackageExcluded_Dev)
    k_ESharedLibrary_PackageExcluded_Dev = 12,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_PackageExcluded_FreeWeekend)
    k_ESharedLibrary_PackageExcluded_FreeWeekend = 13,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_PackageExcluded_Invalid)
    k_ESharedLibrary_PackageExcluded_Invalid = 15,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_PackageExcluded_RecurringLicense)
    k_ESharedLibrary_PackageExcluded_RecurringLicense = 16,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_PackageExcluded_WrongLicenseType)
    k_ESharedLibrary_PackageExcluded_WrongLicenseType = 17,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_PackageExcluded_MasterSub)
    k_ESharedLibrary_PackageExcluded_MasterSub = 18,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_PackageExcluded_NoShareableApps)
    k_ESharedLibrary_PackageExcluded_NoShareableApps = 19,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_LicenseExcluded_PaymentMasterSub)
    k_ESharedLibrary_LicenseExcluded_PaymentMasterSub = 20,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_LicenseExcluded_PaymentFamilyGroup)
    k_ESharedLibrary_LicenseExcluded_PaymentFamilyGroup = 21,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_LicenseExcluded_PaymentAuthorizedDevice)
    k_ESharedLibrary_LicenseExcluded_PaymentAuthorizedDevice = 22,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_LicenseExcluded_PaymentAutoGrant)
    k_ESharedLibrary_LicenseExcluded_PaymentAutoGrant = 23,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_LicenseExcluded_FlagPending)
    k_ESharedLibrary_LicenseExcluded_FlagPending = 24,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_LicenseExcluded_FlagPendingRefund)
    k_ESharedLibrary_LicenseExcluded_FlagPendingRefund = 25,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_LicenseExcluded_FlagBorrowed)
    k_ESharedLibrary_LicenseExcluded_FlagBorrowed = 26,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_LicenseExcluded_FlagAutoGrant)
    k_ESharedLibrary_LicenseExcluded_FlagAutoGrant = 27,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_LicenseExcluded_FlagTimedTrial)
    k_ESharedLibrary_LicenseExcluded_FlagTimedTrial = 28,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_LicenseExcluded_FreeSub)
    k_ESharedLibrary_LicenseExcluded_FreeSub = 29,
    // @@protoc_insertion_point(enum_value:ESharedLibraryExcludeReason.k_ESharedLibrary_LicenseExcluded_Inactive)
    k_ESharedLibrary_LicenseExcluded_Inactive = 30,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESharedLibraryExcludeReason {
    const NAME: &'static str = "ESharedLibraryExcludeReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESharedLibraryExcludeReason> {
        match value {
            0 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_Included),
            1 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded_ByPartner),
            2 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded),
            3 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_FreeGame),
            4 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicensePrivate),
            6 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded_WrongAppType),
            7 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded_NonrefundableDLC),
            8 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded_UnreleasedApp),
            9 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded_ParentAppExcluded),
            10 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_ByPartner),
            11 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_Special),
            12 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_Dev),
            13 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_FreeWeekend),
            15 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_Invalid),
            16 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_RecurringLicense),
            17 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_WrongLicenseType),
            18 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_MasterSub),
            19 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_NoShareableApps),
            20 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_PaymentMasterSub),
            21 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_PaymentFamilyGroup),
            22 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_PaymentAuthorizedDevice),
            23 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_PaymentAutoGrant),
            24 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FlagPending),
            25 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FlagPendingRefund),
            26 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FlagBorrowed),
            27 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FlagAutoGrant),
            28 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FlagTimedTrial),
            29 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FreeSub),
            30 => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_Inactive),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESharedLibraryExcludeReason> {
        match str {
            "k_ESharedLibrary_Included" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_Included),
            "k_ESharedLibrary_AppExcluded_ByPartner" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded_ByPartner),
            "k_ESharedLibrary_LicenseExcluded" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded),
            "k_ESharedLibrary_FreeGame" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_FreeGame),
            "k_ESharedLibrary_LicensePrivate" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicensePrivate),
            "k_ESharedLibrary_AppExcluded_WrongAppType" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded_WrongAppType),
            "k_ESharedLibrary_AppExcluded_NonrefundableDLC" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded_NonrefundableDLC),
            "k_ESharedLibrary_AppExcluded_UnreleasedApp" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded_UnreleasedApp),
            "k_ESharedLibrary_AppExcluded_ParentAppExcluded" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded_ParentAppExcluded),
            "k_ESharedLibrary_PackageExcluded_ByPartner" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_ByPartner),
            "k_ESharedLibrary_PackageExcluded_Special" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_Special),
            "k_ESharedLibrary_PackageExcluded_Dev" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_Dev),
            "k_ESharedLibrary_PackageExcluded_FreeWeekend" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_FreeWeekend),
            "k_ESharedLibrary_PackageExcluded_Invalid" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_Invalid),
            "k_ESharedLibrary_PackageExcluded_RecurringLicense" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_RecurringLicense),
            "k_ESharedLibrary_PackageExcluded_WrongLicenseType" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_WrongLicenseType),
            "k_ESharedLibrary_PackageExcluded_MasterSub" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_MasterSub),
            "k_ESharedLibrary_PackageExcluded_NoShareableApps" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_NoShareableApps),
            "k_ESharedLibrary_LicenseExcluded_PaymentMasterSub" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_PaymentMasterSub),
            "k_ESharedLibrary_LicenseExcluded_PaymentFamilyGroup" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_PaymentFamilyGroup),
            "k_ESharedLibrary_LicenseExcluded_PaymentAuthorizedDevice" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_PaymentAuthorizedDevice),
            "k_ESharedLibrary_LicenseExcluded_PaymentAutoGrant" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_PaymentAutoGrant),
            "k_ESharedLibrary_LicenseExcluded_FlagPending" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FlagPending),
            "k_ESharedLibrary_LicenseExcluded_FlagPendingRefund" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FlagPendingRefund),
            "k_ESharedLibrary_LicenseExcluded_FlagBorrowed" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FlagBorrowed),
            "k_ESharedLibrary_LicenseExcluded_FlagAutoGrant" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FlagAutoGrant),
            "k_ESharedLibrary_LicenseExcluded_FlagTimedTrial" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FlagTimedTrial),
            "k_ESharedLibrary_LicenseExcluded_FreeSub" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FreeSub),
            "k_ESharedLibrary_LicenseExcluded_Inactive" => ::std::option::Option::Some(ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_Inactive),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESharedLibraryExcludeReason] = &[
        ESharedLibraryExcludeReason::k_ESharedLibrary_Included,
        ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded_ByPartner,
        ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded,
        ESharedLibraryExcludeReason::k_ESharedLibrary_FreeGame,
        ESharedLibraryExcludeReason::k_ESharedLibrary_LicensePrivate,
        ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded_WrongAppType,
        ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded_NonrefundableDLC,
        ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded_UnreleasedApp,
        ESharedLibraryExcludeReason::k_ESharedLibrary_AppExcluded_ParentAppExcluded,
        ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_ByPartner,
        ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_Special,
        ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_Dev,
        ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_FreeWeekend,
        ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_Invalid,
        ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_RecurringLicense,
        ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_WrongLicenseType,
        ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_MasterSub,
        ESharedLibraryExcludeReason::k_ESharedLibrary_PackageExcluded_NoShareableApps,
        ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_PaymentMasterSub,
        ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_PaymentFamilyGroup,
        ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_PaymentAuthorizedDevice,
        ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_PaymentAutoGrant,
        ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FlagPending,
        ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FlagPendingRefund,
        ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FlagBorrowed,
        ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FlagAutoGrant,
        ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FlagTimedTrial,
        ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_FreeSub,
        ESharedLibraryExcludeReason::k_ESharedLibrary_LicenseExcluded_Inactive,
    ];
}

impl ::std::default::Default for ESharedLibraryExcludeReason {
    fn default() -> Self {
        ESharedLibraryExcludeReason::k_ESharedLibrary_Included
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages_base::*;
#[allow(unused_imports)]
use crate::steammessages_unified_base_steamclient::*;
#[allow(unused_imports)]
use crate::enums::*;
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_CreateFamilyGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_CreateFamilyGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_GetFamilyGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for FamilyGroupMember {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for FamilyGroupPendingInvite {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for FamilyGroupFormerMember {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_GetFamilyGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_GetFamilyGroupForUser_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for FamilyGroupPendingInviteForUser {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_GetFamilyGroupForUser_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_ModifyFamilyGroupDetails_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_ModifyFamilyGroupDetails_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_InviteToFamilyGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_InviteToFamilyGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_ConfirmInviteToFamilyGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_ConfirmInviteToFamilyGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_ResendInvitationToFamilyGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_ResendInvitationToFamilyGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_JoinFamilyGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_JoinFamilyGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_ConfirmJoinFamilyGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_ConfirmJoinFamilyGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_RemoveFromFamilyGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_RemoveFromFamilyGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_CancelFamilyGroupInvite_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_CancelFamilyGroupInvite_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_GetUsersSharingDevice_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_GetUsersSharingDevice_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_DeleteFamilyGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_DeleteFamilyGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_UndeleteFamilyGroup_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_UndeleteFamilyGroup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_GetPlaytimeSummary_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_PlaytimeEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_GetPlaytimeSummary_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_RequestPurchase_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_RequestPurchase_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_GetPurchaseRequests_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for PurchaseRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_GetPurchaseRequests_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_RespondToRequestedPurchase_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_RespondToRequestedPurchase_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_GetChangeLog_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_GetChangeLog_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_SetFamilyCooldownOverrides_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_SetFamilyCooldownOverrides_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_GetSharedLibraryApps_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_GetSharedLibraryApps_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_SetPreferredLender_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_SetPreferredLender_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_GetPreferredLenders_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_GetPreferredLenders_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_ForceAcceptInvite_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_ForceAcceptInvite_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_GetInviteCheckResults_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroups_GetInviteCheckResults_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_ClearCooldownSkip_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CFamilyGroups_ClearCooldownSkip_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroupsClient_NotifyRunningApps_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroupsClient_InviteStatus_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CFamilyGroupsClient_GroupChanged_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
///
struct FamilyGroups {}
impl ::steam_vent_proto_common::RpcService for FamilyGroups {
    const SERVICE_NAME: &'static str = "FamilyGroups";
}
///
struct FamilyGroupsClient {}
impl ::steam_vent_proto_common::RpcService for FamilyGroupsClient {
    const SERVICE_NAME: &'static str = "FamilyGroupsClient";
}
impl ::steam_vent_proto_common::RpcMethod
for CFamilyGroupsClient_GroupChanged_Notification {
    const METHOD_NAME: &'static str = "FamilyGroupsClient.NotifyGroupChanged#1";
    type Response = ();
}
impl ::steam_vent_proto_common::RpcMethod
for CFamilyGroupsClient_InviteStatus_Notification {
    const METHOD_NAME: &'static str = "FamilyGroupsClient.NotifyInviteStatus#1";
    type Response = ();
}
impl ::steam_vent_proto_common::RpcMethod
for CFamilyGroupsClient_NotifyRunningApps_Notification {
    const METHOD_NAME: &'static str = "FamilyGroupsClient.NotifyRunningApps#1";
    type Response = ();
}
impl ::steam_vent_proto_common::RpcMethod
for CFamilyGroups_CancelFamilyGroupInvite_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.CancelFamilyGroupInvite#1";
    type Response = CFamilyGroups_CancelFamilyGroupInvite_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CFamilyGroups_ClearCooldownSkip_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.ClearCooldownSkip#1";
    type Response = CFamilyGroups_ClearCooldownSkip_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CFamilyGroups_ConfirmInviteToFamilyGroup_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.ConfirmInviteToFamilyGroup#1";
    type Response = CFamilyGroups_ConfirmInviteToFamilyGroup_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CFamilyGroups_ConfirmJoinFamilyGroup_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.ConfirmJoinFamilyGroup#1";
    type Response = CFamilyGroups_ConfirmJoinFamilyGroup_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CFamilyGroups_CreateFamilyGroup_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.CreateFamilyGroup#1";
    type Response = CFamilyGroups_CreateFamilyGroup_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CFamilyGroups_DeleteFamilyGroup_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.DeleteFamilyGroup#1";
    type Response = CFamilyGroups_DeleteFamilyGroup_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CFamilyGroups_ForceAcceptInvite_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.ForceAcceptInvite#1";
    type Response = CFamilyGroups_ForceAcceptInvite_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CFamilyGroups_GetChangeLog_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.GetChangeLog#1";
    type Response = CFamilyGroups_GetChangeLog_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CFamilyGroups_GetFamilyGroupForUser_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.GetFamilyGroupForUser#1";
    type Response = CFamilyGroups_GetFamilyGroupForUser_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CFamilyGroups_GetFamilyGroup_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.GetFamilyGroup#1";
    type Response = CFamilyGroups_GetFamilyGroup_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CFamilyGroups_GetInviteCheckResults_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.GetInviteCheckResults#1";
    type Response = CFamilyGroups_GetInviteCheckResults_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CFamilyGroups_GetPlaytimeSummary_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.GetPlaytimeSummary#1";
    type Response = CFamilyGroups_GetPlaytimeSummary_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CFamilyGroups_GetPreferredLenders_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.GetPreferredLenders#1";
    type Response = CFamilyGroups_GetPreferredLenders_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CFamilyGroups_GetPurchaseRequests_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.GetPurchaseRequests#1";
    type Response = CFamilyGroups_GetPurchaseRequests_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CFamilyGroups_GetSharedLibraryApps_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.GetSharedLibraryApps#1";
    type Response = CFamilyGroups_GetSharedLibraryApps_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CFamilyGroups_GetUsersSharingDevice_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.GetUsersSharingDevice#1";
    type Response = CFamilyGroups_GetUsersSharingDevice_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CFamilyGroups_InviteToFamilyGroup_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.InviteToFamilyGroup#1";
    type Response = CFamilyGroups_InviteToFamilyGroup_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CFamilyGroups_JoinFamilyGroup_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.JoinFamilyGroup#1";
    type Response = CFamilyGroups_JoinFamilyGroup_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CFamilyGroups_ModifyFamilyGroupDetails_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.ModifyFamilyGroupDetails#1";
    type Response = CFamilyGroups_ModifyFamilyGroupDetails_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CFamilyGroups_RemoveFromFamilyGroup_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.RemoveFromFamilyGroup#1";
    type Response = CFamilyGroups_RemoveFromFamilyGroup_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CFamilyGroups_RequestPurchase_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.RequestPurchase#1";
    type Response = CFamilyGroups_RequestPurchase_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CFamilyGroups_ResendInvitationToFamilyGroup_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.ResendInvitationToFamilyGroup#1";
    type Response = CFamilyGroups_ResendInvitationToFamilyGroup_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CFamilyGroups_RespondToRequestedPurchase_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.RespondToRequestedPurchase#1";
    type Response = CFamilyGroups_RespondToRequestedPurchase_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CFamilyGroups_SetFamilyCooldownOverrides_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.SetFamilyCooldownOverrides#1";
    type Response = CFamilyGroups_SetFamilyCooldownOverrides_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CFamilyGroups_SetPreferredLender_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.SetPreferredLender#1";
    type Response = CFamilyGroups_SetPreferredLender_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CFamilyGroups_UndeleteFamilyGroup_Request {
    const METHOD_NAME: &'static str = "FamilyGroups.UndeleteFamilyGroup#1";
    type Response = CFamilyGroups_UndeleteFamilyGroup_Response;
}
