// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_community.steamclient.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CCommunity_GetApps_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetApps_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetApps_Request.appids)
    pub appids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CCommunity_GetApps_Request.language)
    pub language: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetApps_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetApps_Request {
    fn default() -> &'a CCommunity_GetApps_Request {
        <CCommunity_GetApps_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetApps_Request {
    pub fn new() -> CCommunity_GetApps_Request {
        ::std::default::Default::default()
    }

    // optional uint32 language = 2;

    pub fn language(&self) -> u32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: u32) {
        self.language = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetApps_Request {
    const NAME: &'static str = "CCommunity_GetApps_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.appids)?;
                },
                8 => {
                    self.appids.push(is.read_int32()?);
                },
                16 => {
                    self.language = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.appids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
        };
        if let Some(v) = self.language {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.appids {
            os.write_int32(1, *v)?;
        };
        if let Some(v) = self.language {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetApps_Request {
        CCommunity_GetApps_Request::new()
    }

    fn clear(&mut self) {
        self.appids.clear();
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetApps_Request {
        static instance: CCommunity_GetApps_Request = CCommunity_GetApps_Request {
            appids: ::std::vec::Vec::new(),
            language: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetApps_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetApps_Response {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetApps_Response.apps)
    pub apps: ::std::vec::Vec<super::steammessages_base::CCDDBAppDetailCommon>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetApps_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetApps_Response {
    fn default() -> &'a CCommunity_GetApps_Response {
        <CCommunity_GetApps_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetApps_Response {
    pub fn new() -> CCommunity_GetApps_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetApps_Response {
    const NAME: &'static str = "CCommunity_GetApps_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.apps.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.apps {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetApps_Response {
        CCommunity_GetApps_Response::new()
    }

    fn clear(&mut self) {
        self.apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetApps_Response {
        static instance: CCommunity_GetApps_Response = CCommunity_GetApps_Response {
            apps: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetAppRichPresenceLocalization_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetAppRichPresenceLocalization_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetAppRichPresenceLocalization_Request.appid)
    pub appid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_GetAppRichPresenceLocalization_Request.language)
    pub language: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetAppRichPresenceLocalization_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetAppRichPresenceLocalization_Request {
    fn default() -> &'a CCommunity_GetAppRichPresenceLocalization_Request {
        <CCommunity_GetAppRichPresenceLocalization_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetAppRichPresenceLocalization_Request {
    pub fn new() -> CCommunity_GetAppRichPresenceLocalization_Request {
        ::std::default::Default::default()
    }

    // optional int32 appid = 1;

    pub fn appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string language = 2;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetAppRichPresenceLocalization_Request {
    const NAME: &'static str = "CCommunity_GetAppRichPresenceLocalization_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.language.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetAppRichPresenceLocalization_Request {
        CCommunity_GetAppRichPresenceLocalization_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetAppRichPresenceLocalization_Request {
        static instance: CCommunity_GetAppRichPresenceLocalization_Request = CCommunity_GetAppRichPresenceLocalization_Request {
            appid: ::std::option::Option::None,
            language: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetAppRichPresenceLocalization_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetAppRichPresenceLocalization_Response {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetAppRichPresenceLocalization_Response.appid)
    pub appid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_GetAppRichPresenceLocalization_Response.token_lists)
    pub token_lists: ::std::vec::Vec<ccommunity_get_app_rich_presence_localization_response::TokenList>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetAppRichPresenceLocalization_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetAppRichPresenceLocalization_Response {
    fn default() -> &'a CCommunity_GetAppRichPresenceLocalization_Response {
        <CCommunity_GetAppRichPresenceLocalization_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetAppRichPresenceLocalization_Response {
    pub fn new() -> CCommunity_GetAppRichPresenceLocalization_Response {
        ::std::default::Default::default()
    }

    // optional int32 appid = 1;

    pub fn appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetAppRichPresenceLocalization_Response {
    const NAME: &'static str = "CCommunity_GetAppRichPresenceLocalization_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.token_lists.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        for value in &self.token_lists {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_int32(1, v)?;
        }
        for v in &self.token_lists {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetAppRichPresenceLocalization_Response {
        CCommunity_GetAppRichPresenceLocalization_Response::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.token_lists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetAppRichPresenceLocalization_Response {
        static instance: CCommunity_GetAppRichPresenceLocalization_Response = CCommunity_GetAppRichPresenceLocalization_Response {
            appid: ::std::option::Option::None,
            token_lists: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CCommunity_GetAppRichPresenceLocalization_Response`
pub mod ccommunity_get_app_rich_presence_localization_response {
    // @@protoc_insertion_point(message:CCommunity_GetAppRichPresenceLocalization_Response.Token)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Token {
        // message fields
        // @@protoc_insertion_point(field:CCommunity_GetAppRichPresenceLocalization_Response.Token.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CCommunity_GetAppRichPresenceLocalization_Response.Token.value)
        pub value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CCommunity_GetAppRichPresenceLocalization_Response.Token.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Token {
        fn default() -> &'a Token {
            <Token as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Token {
        pub fn new() -> Token {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Token {
        const NAME: &'static str = "Token";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Token {
            Token::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Token {
            static instance: Token = Token {
                name: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CCommunity_GetAppRichPresenceLocalization_Response.TokenList)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TokenList {
        // message fields
        // @@protoc_insertion_point(field:CCommunity_GetAppRichPresenceLocalization_Response.TokenList.language)
        pub language: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CCommunity_GetAppRichPresenceLocalization_Response.TokenList.tokens)
        pub tokens: ::std::vec::Vec<Token>,
        // special fields
        // @@protoc_insertion_point(special_field:CCommunity_GetAppRichPresenceLocalization_Response.TokenList.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TokenList {
        fn default() -> &'a TokenList {
            <TokenList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TokenList {
        pub fn new() -> TokenList {
            ::std::default::Default::default()
        }

        // optional string language = 1;

        pub fn language(&self) -> &str {
            match self.language.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_language(&mut self) {
            self.language = ::std::option::Option::None;
        }

        pub fn has_language(&self) -> bool {
            self.language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language(&mut self, v: ::std::string::String) {
            self.language = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_language(&mut self) -> &mut ::std::string::String {
            if self.language.is_none() {
                self.language = ::std::option::Option::Some(::std::string::String::new());
            }
            self.language.as_mut().unwrap()
        }

        // Take field
        pub fn take_language(&mut self) -> ::std::string::String {
            self.language.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TokenList {
        const NAME: &'static str = "TokenList";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.language = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.tokens.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.language.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            for value in &self.tokens {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.language.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.tokens {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TokenList {
            TokenList::new()
        }

        fn clear(&mut self) {
            self.language = ::std::option::Option::None;
            self.tokens.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TokenList {
            static instance: TokenList = TokenList {
                language: ::std::option::Option::None,
                tokens: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CCommunity_GetCommentThread_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetCommentThread_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Request.comment_thread_type)
    pub comment_thread_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::enums::ECommentThreadType>>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Request.gidfeature)
    pub gidfeature: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Request.gidfeature2)
    pub gidfeature2: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Request.commentthreadid)
    pub commentthreadid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Request.start)
    pub start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Request.count)
    pub count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Request.upvoters)
    pub upvoters: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Request.include_deleted)
    pub include_deleted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Request.gidcomment)
    pub gidcomment: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Request.time_oldest)
    pub time_oldest: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Request.oldest_first)
    pub oldest_first: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetCommentThread_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetCommentThread_Request {
    fn default() -> &'a CCommunity_GetCommentThread_Request {
        <CCommunity_GetCommentThread_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetCommentThread_Request {
    pub fn new() -> CCommunity_GetCommentThread_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional .ECommentThreadType comment_thread_type = 2;

    pub fn comment_thread_type(&self) -> super::enums::ECommentThreadType {
        match self.comment_thread_type {
            Some(e) => e.enum_value_or(super::enums::ECommentThreadType::k_ECommentThreadTypeInvalid),
            None => super::enums::ECommentThreadType::k_ECommentThreadTypeInvalid,
        }
    }

    pub fn clear_comment_thread_type(&mut self) {
        self.comment_thread_type = ::std::option::Option::None;
    }

    pub fn has_comment_thread_type(&self) -> bool {
        self.comment_thread_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment_thread_type(&mut self, v: super::enums::ECommentThreadType) {
        self.comment_thread_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 gidfeature = 3;

    pub fn gidfeature(&self) -> u64 {
        self.gidfeature.unwrap_or(0)
    }

    pub fn clear_gidfeature(&mut self) {
        self.gidfeature = ::std::option::Option::None;
    }

    pub fn has_gidfeature(&self) -> bool {
        self.gidfeature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidfeature(&mut self, v: u64) {
        self.gidfeature = ::std::option::Option::Some(v);
    }

    // optional fixed64 gidfeature2 = 4;

    pub fn gidfeature2(&self) -> u64 {
        self.gidfeature2.unwrap_or(0)
    }

    pub fn clear_gidfeature2(&mut self) {
        self.gidfeature2 = ::std::option::Option::None;
    }

    pub fn has_gidfeature2(&self) -> bool {
        self.gidfeature2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidfeature2(&mut self, v: u64) {
        self.gidfeature2 = ::std::option::Option::Some(v);
    }

    // optional fixed64 commentthreadid = 5;

    pub fn commentthreadid(&self) -> u64 {
        self.commentthreadid.unwrap_or(0)
    }

    pub fn clear_commentthreadid(&mut self) {
        self.commentthreadid = ::std::option::Option::None;
    }

    pub fn has_commentthreadid(&self) -> bool {
        self.commentthreadid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commentthreadid(&mut self, v: u64) {
        self.commentthreadid = ::std::option::Option::Some(v);
    }

    // optional int32 start = 6;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional int32 count = 7;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional int32 upvoters = 8;

    pub fn upvoters(&self) -> i32 {
        self.upvoters.unwrap_or(0)
    }

    pub fn clear_upvoters(&mut self) {
        self.upvoters = ::std::option::Option::None;
    }

    pub fn has_upvoters(&self) -> bool {
        self.upvoters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upvoters(&mut self, v: i32) {
        self.upvoters = ::std::option::Option::Some(v);
    }

    // optional bool include_deleted = 9;

    pub fn include_deleted(&self) -> bool {
        self.include_deleted.unwrap_or(false)
    }

    pub fn clear_include_deleted(&mut self) {
        self.include_deleted = ::std::option::Option::None;
    }

    pub fn has_include_deleted(&self) -> bool {
        self.include_deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_deleted(&mut self, v: bool) {
        self.include_deleted = ::std::option::Option::Some(v);
    }

    // optional fixed64 gidcomment = 10;

    pub fn gidcomment(&self) -> u64 {
        self.gidcomment.unwrap_or(0)
    }

    pub fn clear_gidcomment(&mut self) {
        self.gidcomment = ::std::option::Option::None;
    }

    pub fn has_gidcomment(&self) -> bool {
        self.gidcomment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidcomment(&mut self, v: u64) {
        self.gidcomment = ::std::option::Option::Some(v);
    }

    // optional uint32 time_oldest = 11;

    pub fn time_oldest(&self) -> u32 {
        self.time_oldest.unwrap_or(0)
    }

    pub fn clear_time_oldest(&mut self) {
        self.time_oldest = ::std::option::Option::None;
    }

    pub fn has_time_oldest(&self) -> bool {
        self.time_oldest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_oldest(&mut self, v: u32) {
        self.time_oldest = ::std::option::Option::Some(v);
    }

    // optional bool oldest_first = 12;

    pub fn oldest_first(&self) -> bool {
        self.oldest_first.unwrap_or(false)
    }

    pub fn clear_oldest_first(&mut self) {
        self.oldest_first = ::std::option::Option::None;
    }

    pub fn has_oldest_first(&self) -> bool {
        self.oldest_first.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldest_first(&mut self, v: bool) {
        self.oldest_first = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetCommentThread_Request {
    const NAME: &'static str = "CCommunity_GetCommentThread_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.comment_thread_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                25 => {
                    self.gidfeature = ::std::option::Option::Some(is.read_fixed64()?);
                },
                33 => {
                    self.gidfeature2 = ::std::option::Option::Some(is.read_fixed64()?);
                },
                41 => {
                    self.commentthreadid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                48 => {
                    self.start = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.upvoters = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.include_deleted = ::std::option::Option::Some(is.read_bool()?);
                },
                81 => {
                    self.gidcomment = ::std::option::Option::Some(is.read_fixed64()?);
                },
                88 => {
                    self.time_oldest = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.oldest_first = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.comment_thread_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.gidfeature {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gidfeature2 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.commentthreadid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.start {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.upvoters {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.include_deleted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.gidcomment {
            my_size += 1 + 8;
        }
        if let Some(v) = self.time_oldest {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.oldest_first {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.comment_thread_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.gidfeature {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.gidfeature2 {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.commentthreadid {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.start {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.upvoters {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.include_deleted {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.gidcomment {
            os.write_fixed64(10, v)?;
        }
        if let Some(v) = self.time_oldest {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.oldest_first {
            os.write_bool(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetCommentThread_Request {
        CCommunity_GetCommentThread_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.comment_thread_type = ::std::option::Option::None;
        self.gidfeature = ::std::option::Option::None;
        self.gidfeature2 = ::std::option::Option::None;
        self.commentthreadid = ::std::option::Option::None;
        self.start = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.upvoters = ::std::option::Option::None;
        self.include_deleted = ::std::option::Option::None;
        self.gidcomment = ::std::option::Option::None;
        self.time_oldest = ::std::option::Option::None;
        self.oldest_first = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetCommentThread_Request {
        static instance: CCommunity_GetCommentThread_Request = CCommunity_GetCommentThread_Request {
            steamid: ::std::option::Option::None,
            comment_thread_type: ::std::option::Option::None,
            gidfeature: ::std::option::Option::None,
            gidfeature2: ::std::option::Option::None,
            commentthreadid: ::std::option::Option::None,
            start: ::std::option::Option::None,
            count: ::std::option::Option::None,
            upvoters: ::std::option::Option::None,
            include_deleted: ::std::option::Option::None,
            gidcomment: ::std::option::Option::None,
            time_oldest: ::std::option::Option::None,
            oldest_first: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_Comment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_Comment {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_Comment.gidcomment)
    pub gidcomment: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_Comment.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_Comment.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_Comment.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_Comment.upvotes)
    pub upvotes: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_Comment.hidden)
    pub hidden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_Comment.hidden_by_user)
    pub hidden_by_user: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_Comment.deleted)
    pub deleted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_Comment.ipaddress)
    pub ipaddress: ::steam_vent_proto_common::protobuf::MessageField<super::steammessages_base::CMsgIPAddress>,
    // @@protoc_insertion_point(field:CCommunity_Comment.total_hidden)
    pub total_hidden: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_Comment.upvoted_by_user)
    pub upvoted_by_user: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_Comment.reactions)
    pub reactions: ::std::vec::Vec<ccommunity_comment::Reaction>,
    // @@protoc_insertion_point(field:CCommunity_Comment.gidparentcomment)
    pub gidparentcomment: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_Comment.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_Comment {
    fn default() -> &'a CCommunity_Comment {
        <CCommunity_Comment as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_Comment {
    pub fn new() -> CCommunity_Comment {
        ::std::default::Default::default()
    }

    // optional fixed64 gidcomment = 1;

    pub fn gidcomment(&self) -> u64 {
        self.gidcomment.unwrap_or(0)
    }

    pub fn clear_gidcomment(&mut self) {
        self.gidcomment = ::std::option::Option::None;
    }

    pub fn has_gidcomment(&self) -> bool {
        self.gidcomment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidcomment(&mut self, v: u64) {
        self.gidcomment = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 3;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional string text = 4;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 upvotes = 5;

    pub fn upvotes(&self) -> i32 {
        self.upvotes.unwrap_or(0)
    }

    pub fn clear_upvotes(&mut self) {
        self.upvotes = ::std::option::Option::None;
    }

    pub fn has_upvotes(&self) -> bool {
        self.upvotes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upvotes(&mut self, v: i32) {
        self.upvotes = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 6;

    pub fn hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }

    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }

    // optional bool hidden_by_user = 7;

    pub fn hidden_by_user(&self) -> bool {
        self.hidden_by_user.unwrap_or(false)
    }

    pub fn clear_hidden_by_user(&mut self) {
        self.hidden_by_user = ::std::option::Option::None;
    }

    pub fn has_hidden_by_user(&self) -> bool {
        self.hidden_by_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden_by_user(&mut self, v: bool) {
        self.hidden_by_user = ::std::option::Option::Some(v);
    }

    // optional bool deleted = 8;

    pub fn deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }

    pub fn clear_deleted(&mut self) {
        self.deleted = ::std::option::Option::None;
    }

    pub fn has_deleted(&self) -> bool {
        self.deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = ::std::option::Option::Some(v);
    }

    // optional int32 total_hidden = 10;

    pub fn total_hidden(&self) -> i32 {
        self.total_hidden.unwrap_or(0)
    }

    pub fn clear_total_hidden(&mut self) {
        self.total_hidden = ::std::option::Option::None;
    }

    pub fn has_total_hidden(&self) -> bool {
        self.total_hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_hidden(&mut self, v: i32) {
        self.total_hidden = ::std::option::Option::Some(v);
    }

    // optional bool upvoted_by_user = 11;

    pub fn upvoted_by_user(&self) -> bool {
        self.upvoted_by_user.unwrap_or(false)
    }

    pub fn clear_upvoted_by_user(&mut self) {
        self.upvoted_by_user = ::std::option::Option::None;
    }

    pub fn has_upvoted_by_user(&self) -> bool {
        self.upvoted_by_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upvoted_by_user(&mut self, v: bool) {
        self.upvoted_by_user = ::std::option::Option::Some(v);
    }

    // optional fixed64 gidparentcomment = 13;

    pub fn gidparentcomment(&self) -> u64 {
        self.gidparentcomment.unwrap_or(0)
    }

    pub fn clear_gidparentcomment(&mut self) {
        self.gidparentcomment = ::std::option::Option::None;
    }

    pub fn has_gidparentcomment(&self) -> bool {
        self.gidparentcomment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidparentcomment(&mut self, v: u64) {
        self.gidparentcomment = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_Comment {
    const NAME: &'static str = "CCommunity_Comment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gidcomment = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.upvotes = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.hidden_by_user = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.deleted = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.ipaddress)?;
                },
                80 => {
                    self.total_hidden = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.upvoted_by_user = ::std::option::Option::Some(is.read_bool()?);
                },
                98 => {
                    self.reactions.push(is.read_message()?);
                },
                105 => {
                    self.gidparentcomment = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gidcomment {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.upvotes {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.hidden {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hidden_by_user {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deleted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ipaddress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.total_hidden {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.upvoted_by_user {
            my_size += 1 + 1;
        }
        for value in &self.reactions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.gidparentcomment {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.gidcomment {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.upvotes {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.hidden_by_user {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.ipaddress.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.total_hidden {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.upvoted_by_user {
            os.write_bool(11, v)?;
        }
        for v in &self.reactions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if let Some(v) = self.gidparentcomment {
            os.write_fixed64(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_Comment {
        CCommunity_Comment::new()
    }

    fn clear(&mut self) {
        self.gidcomment = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.upvotes = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.hidden_by_user = ::std::option::Option::None;
        self.deleted = ::std::option::Option::None;
        self.ipaddress.clear();
        self.total_hidden = ::std::option::Option::None;
        self.upvoted_by_user = ::std::option::Option::None;
        self.reactions.clear();
        self.gidparentcomment = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_Comment {
        static instance: CCommunity_Comment = CCommunity_Comment {
            gidcomment: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            text: ::std::option::Option::None,
            upvotes: ::std::option::Option::None,
            hidden: ::std::option::Option::None,
            hidden_by_user: ::std::option::Option::None,
            deleted: ::std::option::Option::None,
            ipaddress: ::steam_vent_proto_common::protobuf::MessageField::none(),
            total_hidden: ::std::option::Option::None,
            upvoted_by_user: ::std::option::Option::None,
            reactions: ::std::vec::Vec::new(),
            gidparentcomment: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CCommunity_Comment`
pub mod ccommunity_comment {
    // @@protoc_insertion_point(message:CCommunity_Comment.Reaction)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Reaction {
        // message fields
        // @@protoc_insertion_point(field:CCommunity_Comment.Reaction.reactionid)
        pub reactionid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CCommunity_Comment.Reaction.count)
        pub count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCommunity_Comment.Reaction.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Reaction {
        fn default() -> &'a Reaction {
            <Reaction as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Reaction {
        pub fn new() -> Reaction {
            ::std::default::Default::default()
        }

        // optional uint32 reactionid = 1;

        pub fn reactionid(&self) -> u32 {
            self.reactionid.unwrap_or(0)
        }

        pub fn clear_reactionid(&mut self) {
            self.reactionid = ::std::option::Option::None;
        }

        pub fn has_reactionid(&self) -> bool {
            self.reactionid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reactionid(&mut self, v: u32) {
            self.reactionid = ::std::option::Option::Some(v);
        }

        // optional uint32 count = 2;

        pub fn count(&self) -> u32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: u32) {
            self.count = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Reaction {
        const NAME: &'static str = "Reaction";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.reactionid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.reactionid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.reactionid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Reaction {
            Reaction::new()
        }

        fn clear(&mut self) {
            self.reactionid = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Reaction {
            static instance: Reaction = Reaction {
                reactionid: ::std::option::Option::None,
                count: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CCommunity_GetCommentThread_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetCommentThread_Response {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.comments)
    pub comments: ::std::vec::Vec<CCommunity_Comment>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.deleted_comments)
    pub deleted_comments: ::std::vec::Vec<CCommunity_Comment>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.commentthreadid)
    pub commentthreadid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.start)
    pub start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.count)
    pub count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.total_count)
    pub total_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.upvotes)
    pub upvotes: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.upvoters)
    pub upvoters: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.user_subscribed)
    pub user_subscribed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.user_upvoted)
    pub user_upvoted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.answer_commentid)
    pub answer_commentid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.answer_actor)
    pub answer_actor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.answer_actor_rank)
    pub answer_actor_rank: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.can_post)
    pub can_post: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.comment_thread_type)
    pub comment_thread_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.gidfeature)
    pub gidfeature: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThread_Response.gidfeature2)
    pub gidfeature2: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetCommentThread_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetCommentThread_Response {
    fn default() -> &'a CCommunity_GetCommentThread_Response {
        <CCommunity_GetCommentThread_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetCommentThread_Response {
    pub fn new() -> CCommunity_GetCommentThread_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 3;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 commentthreadid = 4;

    pub fn commentthreadid(&self) -> u64 {
        self.commentthreadid.unwrap_or(0)
    }

    pub fn clear_commentthreadid(&mut self) {
        self.commentthreadid = ::std::option::Option::None;
    }

    pub fn has_commentthreadid(&self) -> bool {
        self.commentthreadid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commentthreadid(&mut self, v: u64) {
        self.commentthreadid = ::std::option::Option::Some(v);
    }

    // optional int32 start = 5;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional int32 count = 6;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional int32 total_count = 7;

    pub fn total_count(&self) -> i32 {
        self.total_count.unwrap_or(0)
    }

    pub fn clear_total_count(&mut self) {
        self.total_count = ::std::option::Option::None;
    }

    pub fn has_total_count(&self) -> bool {
        self.total_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_count(&mut self, v: i32) {
        self.total_count = ::std::option::Option::Some(v);
    }

    // optional int32 upvotes = 8;

    pub fn upvotes(&self) -> i32 {
        self.upvotes.unwrap_or(0)
    }

    pub fn clear_upvotes(&mut self) {
        self.upvotes = ::std::option::Option::None;
    }

    pub fn has_upvotes(&self) -> bool {
        self.upvotes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upvotes(&mut self, v: i32) {
        self.upvotes = ::std::option::Option::Some(v);
    }

    // optional bool user_subscribed = 10;

    pub fn user_subscribed(&self) -> bool {
        self.user_subscribed.unwrap_or(false)
    }

    pub fn clear_user_subscribed(&mut self) {
        self.user_subscribed = ::std::option::Option::None;
    }

    pub fn has_user_subscribed(&self) -> bool {
        self.user_subscribed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_subscribed(&mut self, v: bool) {
        self.user_subscribed = ::std::option::Option::Some(v);
    }

    // optional bool user_upvoted = 11;

    pub fn user_upvoted(&self) -> bool {
        self.user_upvoted.unwrap_or(false)
    }

    pub fn clear_user_upvoted(&mut self) {
        self.user_upvoted = ::std::option::Option::None;
    }

    pub fn has_user_upvoted(&self) -> bool {
        self.user_upvoted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_upvoted(&mut self, v: bool) {
        self.user_upvoted = ::std::option::Option::Some(v);
    }

    // optional fixed64 answer_commentid = 12;

    pub fn answer_commentid(&self) -> u64 {
        self.answer_commentid.unwrap_or(0)
    }

    pub fn clear_answer_commentid(&mut self) {
        self.answer_commentid = ::std::option::Option::None;
    }

    pub fn has_answer_commentid(&self) -> bool {
        self.answer_commentid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_commentid(&mut self, v: u64) {
        self.answer_commentid = ::std::option::Option::Some(v);
    }

    // optional uint32 answer_actor = 13;

    pub fn answer_actor(&self) -> u32 {
        self.answer_actor.unwrap_or(0)
    }

    pub fn clear_answer_actor(&mut self) {
        self.answer_actor = ::std::option::Option::None;
    }

    pub fn has_answer_actor(&self) -> bool {
        self.answer_actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_actor(&mut self, v: u32) {
        self.answer_actor = ::std::option::Option::Some(v);
    }

    // optional int32 answer_actor_rank = 14;

    pub fn answer_actor_rank(&self) -> i32 {
        self.answer_actor_rank.unwrap_or(0)
    }

    pub fn clear_answer_actor_rank(&mut self) {
        self.answer_actor_rank = ::std::option::Option::None;
    }

    pub fn has_answer_actor_rank(&self) -> bool {
        self.answer_actor_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_actor_rank(&mut self, v: i32) {
        self.answer_actor_rank = ::std::option::Option::Some(v);
    }

    // optional bool can_post = 15;

    pub fn can_post(&self) -> bool {
        self.can_post.unwrap_or(false)
    }

    pub fn clear_can_post(&mut self) {
        self.can_post = ::std::option::Option::None;
    }

    pub fn has_can_post(&self) -> bool {
        self.can_post.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_post(&mut self, v: bool) {
        self.can_post = ::std::option::Option::Some(v);
    }

    // optional uint32 comment_thread_type = 16;

    pub fn comment_thread_type(&self) -> u32 {
        self.comment_thread_type.unwrap_or(0)
    }

    pub fn clear_comment_thread_type(&mut self) {
        self.comment_thread_type = ::std::option::Option::None;
    }

    pub fn has_comment_thread_type(&self) -> bool {
        self.comment_thread_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment_thread_type(&mut self, v: u32) {
        self.comment_thread_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 gidfeature = 17;

    pub fn gidfeature(&self) -> u64 {
        self.gidfeature.unwrap_or(0)
    }

    pub fn clear_gidfeature(&mut self) {
        self.gidfeature = ::std::option::Option::None;
    }

    pub fn has_gidfeature(&self) -> bool {
        self.gidfeature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidfeature(&mut self, v: u64) {
        self.gidfeature = ::std::option::Option::Some(v);
    }

    // optional fixed64 gidfeature2 = 18;

    pub fn gidfeature2(&self) -> u64 {
        self.gidfeature2.unwrap_or(0)
    }

    pub fn clear_gidfeature2(&mut self) {
        self.gidfeature2 = ::std::option::Option::None;
    }

    pub fn has_gidfeature2(&self) -> bool {
        self.gidfeature2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidfeature2(&mut self, v: u64) {
        self.gidfeature2 = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetCommentThread_Response {
    const NAME: &'static str = "CCommunity_GetCommentThread_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.comments.push(is.read_message()?);
                },
                18 => {
                    self.deleted_comments.push(is.read_message()?);
                },
                25 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                33 => {
                    self.commentthreadid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.start = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.total_count = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.upvotes = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.upvoters)?;
                },
                72 => {
                    self.upvoters.push(is.read_uint32()?);
                },
                80 => {
                    self.user_subscribed = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.user_upvoted = ::std::option::Option::Some(is.read_bool()?);
                },
                97 => {
                    self.answer_commentid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                104 => {
                    self.answer_actor = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.answer_actor_rank = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.can_post = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.comment_thread_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                137 => {
                    self.gidfeature = ::std::option::Option::Some(is.read_fixed64()?);
                },
                145 => {
                    self.gidfeature2 = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.comments {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.deleted_comments {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.commentthreadid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.start {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.total_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.upvotes {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
        }
        for value in &self.upvoters {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, *value);
        };
        if let Some(v) = self.user_subscribed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.user_upvoted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.answer_commentid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.answer_actor {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.answer_actor_rank {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.can_post {
            my_size += 1 + 1;
        }
        if let Some(v) = self.comment_thread_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.gidfeature {
            my_size += 2 + 8;
        }
        if let Some(v) = self.gidfeature2 {
            my_size += 2 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.comments {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.deleted_comments {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.steamid {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.commentthreadid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.start {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.total_count {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.upvotes {
            os.write_int32(8, v)?;
        }
        for v in &self.upvoters {
            os.write_uint32(9, *v)?;
        };
        if let Some(v) = self.user_subscribed {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.user_upvoted {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.answer_commentid {
            os.write_fixed64(12, v)?;
        }
        if let Some(v) = self.answer_actor {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.answer_actor_rank {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.can_post {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.comment_thread_type {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.gidfeature {
            os.write_fixed64(17, v)?;
        }
        if let Some(v) = self.gidfeature2 {
            os.write_fixed64(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetCommentThread_Response {
        CCommunity_GetCommentThread_Response::new()
    }

    fn clear(&mut self) {
        self.comments.clear();
        self.deleted_comments.clear();
        self.steamid = ::std::option::Option::None;
        self.commentthreadid = ::std::option::Option::None;
        self.start = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.total_count = ::std::option::Option::None;
        self.upvotes = ::std::option::Option::None;
        self.upvoters.clear();
        self.user_subscribed = ::std::option::Option::None;
        self.user_upvoted = ::std::option::Option::None;
        self.answer_commentid = ::std::option::Option::None;
        self.answer_actor = ::std::option::Option::None;
        self.answer_actor_rank = ::std::option::Option::None;
        self.can_post = ::std::option::Option::None;
        self.comment_thread_type = ::std::option::Option::None;
        self.gidfeature = ::std::option::Option::None;
        self.gidfeature2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetCommentThread_Response {
        static instance: CCommunity_GetCommentThread_Response = CCommunity_GetCommentThread_Response {
            comments: ::std::vec::Vec::new(),
            deleted_comments: ::std::vec::Vec::new(),
            steamid: ::std::option::Option::None,
            commentthreadid: ::std::option::Option::None,
            start: ::std::option::Option::None,
            count: ::std::option::Option::None,
            total_count: ::std::option::Option::None,
            upvotes: ::std::option::Option::None,
            upvoters: ::std::vec::Vec::new(),
            user_subscribed: ::std::option::Option::None,
            user_upvoted: ::std::option::Option::None,
            answer_commentid: ::std::option::Option::None,
            answer_actor: ::std::option::Option::None,
            answer_actor_rank: ::std::option::Option::None,
            can_post: ::std::option::Option::None,
            comment_thread_type: ::std::option::Option::None,
            gidfeature: ::std::option::Option::None,
            gidfeature2: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_PostCommentToThread_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_PostCommentToThread_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_PostCommentToThread_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_PostCommentToThread_Request.comment_thread_type)
    pub comment_thread_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::enums::ECommentThreadType>>,
    // @@protoc_insertion_point(field:CCommunity_PostCommentToThread_Request.gidfeature)
    pub gidfeature: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_PostCommentToThread_Request.gidfeature2)
    pub gidfeature2: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_PostCommentToThread_Request.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_PostCommentToThread_Request.gidparentcomment)
    pub gidparentcomment: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_PostCommentToThread_Request.suppress_notifications)
    pub suppress_notifications: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_PostCommentToThread_Request.is_report)
    pub is_report: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_PostCommentToThread_Request.start_hidden)
    pub start_hidden: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_PostCommentToThread_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_PostCommentToThread_Request {
    fn default() -> &'a CCommunity_PostCommentToThread_Request {
        <CCommunity_PostCommentToThread_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_PostCommentToThread_Request {
    pub fn new() -> CCommunity_PostCommentToThread_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional .ECommentThreadType comment_thread_type = 2;

    pub fn comment_thread_type(&self) -> super::enums::ECommentThreadType {
        match self.comment_thread_type {
            Some(e) => e.enum_value_or(super::enums::ECommentThreadType::k_ECommentThreadTypeInvalid),
            None => super::enums::ECommentThreadType::k_ECommentThreadTypeInvalid,
        }
    }

    pub fn clear_comment_thread_type(&mut self) {
        self.comment_thread_type = ::std::option::Option::None;
    }

    pub fn has_comment_thread_type(&self) -> bool {
        self.comment_thread_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment_thread_type(&mut self, v: super::enums::ECommentThreadType) {
        self.comment_thread_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 gidfeature = 3;

    pub fn gidfeature(&self) -> u64 {
        self.gidfeature.unwrap_or(0)
    }

    pub fn clear_gidfeature(&mut self) {
        self.gidfeature = ::std::option::Option::None;
    }

    pub fn has_gidfeature(&self) -> bool {
        self.gidfeature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidfeature(&mut self, v: u64) {
        self.gidfeature = ::std::option::Option::Some(v);
    }

    // optional fixed64 gidfeature2 = 4;

    pub fn gidfeature2(&self) -> u64 {
        self.gidfeature2.unwrap_or(0)
    }

    pub fn clear_gidfeature2(&mut self) {
        self.gidfeature2 = ::std::option::Option::None;
    }

    pub fn has_gidfeature2(&self) -> bool {
        self.gidfeature2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidfeature2(&mut self, v: u64) {
        self.gidfeature2 = ::std::option::Option::Some(v);
    }

    // optional string text = 6;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 gidparentcomment = 7;

    pub fn gidparentcomment(&self) -> u64 {
        self.gidparentcomment.unwrap_or(0)
    }

    pub fn clear_gidparentcomment(&mut self) {
        self.gidparentcomment = ::std::option::Option::None;
    }

    pub fn has_gidparentcomment(&self) -> bool {
        self.gidparentcomment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidparentcomment(&mut self, v: u64) {
        self.gidparentcomment = ::std::option::Option::Some(v);
    }

    // optional bool suppress_notifications = 8;

    pub fn suppress_notifications(&self) -> bool {
        self.suppress_notifications.unwrap_or(false)
    }

    pub fn clear_suppress_notifications(&mut self) {
        self.suppress_notifications = ::std::option::Option::None;
    }

    pub fn has_suppress_notifications(&self) -> bool {
        self.suppress_notifications.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suppress_notifications(&mut self, v: bool) {
        self.suppress_notifications = ::std::option::Option::Some(v);
    }

    // optional bool is_report = 9;

    pub fn is_report(&self) -> bool {
        self.is_report.unwrap_or(false)
    }

    pub fn clear_is_report(&mut self) {
        self.is_report = ::std::option::Option::None;
    }

    pub fn has_is_report(&self) -> bool {
        self.is_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_report(&mut self, v: bool) {
        self.is_report = ::std::option::Option::Some(v);
    }

    // optional bool start_hidden = 10;

    pub fn start_hidden(&self) -> bool {
        self.start_hidden.unwrap_or(false)
    }

    pub fn clear_start_hidden(&mut self) {
        self.start_hidden = ::std::option::Option::None;
    }

    pub fn has_start_hidden(&self) -> bool {
        self.start_hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_hidden(&mut self, v: bool) {
        self.start_hidden = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_PostCommentToThread_Request {
    const NAME: &'static str = "CCommunity_PostCommentToThread_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.comment_thread_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                25 => {
                    self.gidfeature = ::std::option::Option::Some(is.read_fixed64()?);
                },
                33 => {
                    self.gidfeature2 = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                57 => {
                    self.gidparentcomment = ::std::option::Option::Some(is.read_fixed64()?);
                },
                64 => {
                    self.suppress_notifications = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.is_report = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.start_hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.comment_thread_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.gidfeature {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gidfeature2 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.gidparentcomment {
            my_size += 1 + 8;
        }
        if let Some(v) = self.suppress_notifications {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_report {
            my_size += 1 + 1;
        }
        if let Some(v) = self.start_hidden {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.comment_thread_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.gidfeature {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.gidfeature2 {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.gidparentcomment {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.suppress_notifications {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.is_report {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.start_hidden {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_PostCommentToThread_Request {
        CCommunity_PostCommentToThread_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.comment_thread_type = ::std::option::Option::None;
        self.gidfeature = ::std::option::Option::None;
        self.gidfeature2 = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.gidparentcomment = ::std::option::Option::None;
        self.suppress_notifications = ::std::option::Option::None;
        self.is_report = ::std::option::Option::None;
        self.start_hidden = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_PostCommentToThread_Request {
        static instance: CCommunity_PostCommentToThread_Request = CCommunity_PostCommentToThread_Request {
            steamid: ::std::option::Option::None,
            comment_thread_type: ::std::option::Option::None,
            gidfeature: ::std::option::Option::None,
            gidfeature2: ::std::option::Option::None,
            text: ::std::option::Option::None,
            gidparentcomment: ::std::option::Option::None,
            suppress_notifications: ::std::option::Option::None,
            is_report: ::std::option::Option::None,
            start_hidden: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_PostCommentToThread_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_PostCommentToThread_Response {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_PostCommentToThread_Response.gidcomment)
    pub gidcomment: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_PostCommentToThread_Response.commentthreadid)
    pub commentthreadid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_PostCommentToThread_Response.count)
    pub count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_PostCommentToThread_Response.upvotes)
    pub upvotes: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_PostCommentToThread_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_PostCommentToThread_Response {
    fn default() -> &'a CCommunity_PostCommentToThread_Response {
        <CCommunity_PostCommentToThread_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_PostCommentToThread_Response {
    pub fn new() -> CCommunity_PostCommentToThread_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 gidcomment = 1;

    pub fn gidcomment(&self) -> u64 {
        self.gidcomment.unwrap_or(0)
    }

    pub fn clear_gidcomment(&mut self) {
        self.gidcomment = ::std::option::Option::None;
    }

    pub fn has_gidcomment(&self) -> bool {
        self.gidcomment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidcomment(&mut self, v: u64) {
        self.gidcomment = ::std::option::Option::Some(v);
    }

    // optional fixed64 commentthreadid = 2;

    pub fn commentthreadid(&self) -> u64 {
        self.commentthreadid.unwrap_or(0)
    }

    pub fn clear_commentthreadid(&mut self) {
        self.commentthreadid = ::std::option::Option::None;
    }

    pub fn has_commentthreadid(&self) -> bool {
        self.commentthreadid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commentthreadid(&mut self, v: u64) {
        self.commentthreadid = ::std::option::Option::Some(v);
    }

    // optional int32 count = 3;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional int32 upvotes = 4;

    pub fn upvotes(&self) -> i32 {
        self.upvotes.unwrap_or(0)
    }

    pub fn clear_upvotes(&mut self) {
        self.upvotes = ::std::option::Option::None;
    }

    pub fn has_upvotes(&self) -> bool {
        self.upvotes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upvotes(&mut self, v: i32) {
        self.upvotes = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_PostCommentToThread_Response {
    const NAME: &'static str = "CCommunity_PostCommentToThread_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gidcomment = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.commentthreadid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.upvotes = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gidcomment {
            my_size += 1 + 8;
        }
        if let Some(v) = self.commentthreadid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.upvotes {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.gidcomment {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.commentthreadid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.upvotes {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_PostCommentToThread_Response {
        CCommunity_PostCommentToThread_Response::new()
    }

    fn clear(&mut self) {
        self.gidcomment = ::std::option::Option::None;
        self.commentthreadid = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.upvotes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_PostCommentToThread_Response {
        static instance: CCommunity_PostCommentToThread_Response = CCommunity_PostCommentToThread_Response {
            gidcomment: ::std::option::Option::None,
            commentthreadid: ::std::option::Option::None,
            count: ::std::option::Option::None,
            upvotes: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_DeleteCommentFromThread_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_DeleteCommentFromThread_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_DeleteCommentFromThread_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_DeleteCommentFromThread_Request.comment_thread_type)
    pub comment_thread_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::enums::ECommentThreadType>>,
    // @@protoc_insertion_point(field:CCommunity_DeleteCommentFromThread_Request.gidfeature)
    pub gidfeature: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_DeleteCommentFromThread_Request.gidfeature2)
    pub gidfeature2: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_DeleteCommentFromThread_Request.gidcomment)
    pub gidcomment: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_DeleteCommentFromThread_Request.undelete)
    pub undelete: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_DeleteCommentFromThread_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_DeleteCommentFromThread_Request {
    fn default() -> &'a CCommunity_DeleteCommentFromThread_Request {
        <CCommunity_DeleteCommentFromThread_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_DeleteCommentFromThread_Request {
    pub fn new() -> CCommunity_DeleteCommentFromThread_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional .ECommentThreadType comment_thread_type = 2;

    pub fn comment_thread_type(&self) -> super::enums::ECommentThreadType {
        match self.comment_thread_type {
            Some(e) => e.enum_value_or(super::enums::ECommentThreadType::k_ECommentThreadTypeInvalid),
            None => super::enums::ECommentThreadType::k_ECommentThreadTypeInvalid,
        }
    }

    pub fn clear_comment_thread_type(&mut self) {
        self.comment_thread_type = ::std::option::Option::None;
    }

    pub fn has_comment_thread_type(&self) -> bool {
        self.comment_thread_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment_thread_type(&mut self, v: super::enums::ECommentThreadType) {
        self.comment_thread_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 gidfeature = 3;

    pub fn gidfeature(&self) -> u64 {
        self.gidfeature.unwrap_or(0)
    }

    pub fn clear_gidfeature(&mut self) {
        self.gidfeature = ::std::option::Option::None;
    }

    pub fn has_gidfeature(&self) -> bool {
        self.gidfeature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidfeature(&mut self, v: u64) {
        self.gidfeature = ::std::option::Option::Some(v);
    }

    // optional fixed64 gidfeature2 = 4;

    pub fn gidfeature2(&self) -> u64 {
        self.gidfeature2.unwrap_or(0)
    }

    pub fn clear_gidfeature2(&mut self) {
        self.gidfeature2 = ::std::option::Option::None;
    }

    pub fn has_gidfeature2(&self) -> bool {
        self.gidfeature2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidfeature2(&mut self, v: u64) {
        self.gidfeature2 = ::std::option::Option::Some(v);
    }

    // optional fixed64 gidcomment = 5;

    pub fn gidcomment(&self) -> u64 {
        self.gidcomment.unwrap_or(0)
    }

    pub fn clear_gidcomment(&mut self) {
        self.gidcomment = ::std::option::Option::None;
    }

    pub fn has_gidcomment(&self) -> bool {
        self.gidcomment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidcomment(&mut self, v: u64) {
        self.gidcomment = ::std::option::Option::Some(v);
    }

    // optional bool undelete = 6;

    pub fn undelete(&self) -> bool {
        self.undelete.unwrap_or(false)
    }

    pub fn clear_undelete(&mut self) {
        self.undelete = ::std::option::Option::None;
    }

    pub fn has_undelete(&self) -> bool {
        self.undelete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_undelete(&mut self, v: bool) {
        self.undelete = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_DeleteCommentFromThread_Request {
    const NAME: &'static str = "CCommunity_DeleteCommentFromThread_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.comment_thread_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                25 => {
                    self.gidfeature = ::std::option::Option::Some(is.read_fixed64()?);
                },
                33 => {
                    self.gidfeature2 = ::std::option::Option::Some(is.read_fixed64()?);
                },
                41 => {
                    self.gidcomment = ::std::option::Option::Some(is.read_fixed64()?);
                },
                48 => {
                    self.undelete = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.comment_thread_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.gidfeature {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gidfeature2 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gidcomment {
            my_size += 1 + 8;
        }
        if let Some(v) = self.undelete {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.comment_thread_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.gidfeature {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.gidfeature2 {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.gidcomment {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.undelete {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_DeleteCommentFromThread_Request {
        CCommunity_DeleteCommentFromThread_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.comment_thread_type = ::std::option::Option::None;
        self.gidfeature = ::std::option::Option::None;
        self.gidfeature2 = ::std::option::Option::None;
        self.gidcomment = ::std::option::Option::None;
        self.undelete = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_DeleteCommentFromThread_Request {
        static instance: CCommunity_DeleteCommentFromThread_Request = CCommunity_DeleteCommentFromThread_Request {
            steamid: ::std::option::Option::None,
            comment_thread_type: ::std::option::Option::None,
            gidfeature: ::std::option::Option::None,
            gidfeature2: ::std::option::Option::None,
            gidcomment: ::std::option::Option::None,
            undelete: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_DeleteCommentFromThread_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_DeleteCommentFromThread_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_DeleteCommentFromThread_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_DeleteCommentFromThread_Response {
    fn default() -> &'a CCommunity_DeleteCommentFromThread_Response {
        <CCommunity_DeleteCommentFromThread_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_DeleteCommentFromThread_Response {
    pub fn new() -> CCommunity_DeleteCommentFromThread_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_DeleteCommentFromThread_Response {
    const NAME: &'static str = "CCommunity_DeleteCommentFromThread_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_DeleteCommentFromThread_Response {
        CCommunity_DeleteCommentFromThread_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_DeleteCommentFromThread_Response {
        static instance: CCommunity_DeleteCommentFromThread_Response = CCommunity_DeleteCommentFromThread_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_RateCommentThread_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_RateCommentThread_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_RateCommentThread_Request.commentthreadtype)
    pub commentthreadtype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_RateCommentThread_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_RateCommentThread_Request.gidfeature)
    pub gidfeature: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_RateCommentThread_Request.gidfeature2)
    pub gidfeature2: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_RateCommentThread_Request.gidcomment)
    pub gidcomment: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_RateCommentThread_Request.rate_up)
    pub rate_up: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_RateCommentThread_Request.suppress_notifications)
    pub suppress_notifications: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_RateCommentThread_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_RateCommentThread_Request {
    fn default() -> &'a CCommunity_RateCommentThread_Request {
        <CCommunity_RateCommentThread_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_RateCommentThread_Request {
    pub fn new() -> CCommunity_RateCommentThread_Request {
        ::std::default::Default::default()
    }

    // optional string commentthreadtype = 1;

    pub fn commentthreadtype(&self) -> &str {
        match self.commentthreadtype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_commentthreadtype(&mut self) {
        self.commentthreadtype = ::std::option::Option::None;
    }

    pub fn has_commentthreadtype(&self) -> bool {
        self.commentthreadtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commentthreadtype(&mut self, v: ::std::string::String) {
        self.commentthreadtype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commentthreadtype(&mut self) -> &mut ::std::string::String {
        if self.commentthreadtype.is_none() {
            self.commentthreadtype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.commentthreadtype.as_mut().unwrap()
    }

    // Take field
    pub fn take_commentthreadtype(&mut self) -> ::std::string::String {
        self.commentthreadtype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 gidfeature = 3;

    pub fn gidfeature(&self) -> u64 {
        self.gidfeature.unwrap_or(0)
    }

    pub fn clear_gidfeature(&mut self) {
        self.gidfeature = ::std::option::Option::None;
    }

    pub fn has_gidfeature(&self) -> bool {
        self.gidfeature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidfeature(&mut self, v: u64) {
        self.gidfeature = ::std::option::Option::Some(v);
    }

    // optional uint64 gidfeature2 = 4;

    pub fn gidfeature2(&self) -> u64 {
        self.gidfeature2.unwrap_or(0)
    }

    pub fn clear_gidfeature2(&mut self) {
        self.gidfeature2 = ::std::option::Option::None;
    }

    pub fn has_gidfeature2(&self) -> bool {
        self.gidfeature2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidfeature2(&mut self, v: u64) {
        self.gidfeature2 = ::std::option::Option::Some(v);
    }

    // optional uint64 gidcomment = 5;

    pub fn gidcomment(&self) -> u64 {
        self.gidcomment.unwrap_or(0)
    }

    pub fn clear_gidcomment(&mut self) {
        self.gidcomment = ::std::option::Option::None;
    }

    pub fn has_gidcomment(&self) -> bool {
        self.gidcomment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidcomment(&mut self, v: u64) {
        self.gidcomment = ::std::option::Option::Some(v);
    }

    // optional bool rate_up = 6;

    pub fn rate_up(&self) -> bool {
        self.rate_up.unwrap_or(false)
    }

    pub fn clear_rate_up(&mut self) {
        self.rate_up = ::std::option::Option::None;
    }

    pub fn has_rate_up(&self) -> bool {
        self.rate_up.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rate_up(&mut self, v: bool) {
        self.rate_up = ::std::option::Option::Some(v);
    }

    // optional bool suppress_notifications = 7;

    pub fn suppress_notifications(&self) -> bool {
        self.suppress_notifications.unwrap_or(false)
    }

    pub fn clear_suppress_notifications(&mut self) {
        self.suppress_notifications = ::std::option::Option::None;
    }

    pub fn has_suppress_notifications(&self) -> bool {
        self.suppress_notifications.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suppress_notifications(&mut self, v: bool) {
        self.suppress_notifications = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_RateCommentThread_Request {
    const NAME: &'static str = "CCommunity_RateCommentThread_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.commentthreadtype = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.gidfeature = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.gidfeature2 = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.gidcomment = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.rate_up = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.suppress_notifications = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.commentthreadtype.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.steamid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.gidfeature {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.gidfeature2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.gidcomment {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.rate_up {
            my_size += 1 + 1;
        }
        if let Some(v) = self.suppress_notifications {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.commentthreadtype.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.gidfeature {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.gidfeature2 {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.gidcomment {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.rate_up {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.suppress_notifications {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_RateCommentThread_Request {
        CCommunity_RateCommentThread_Request::new()
    }

    fn clear(&mut self) {
        self.commentthreadtype = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.gidfeature = ::std::option::Option::None;
        self.gidfeature2 = ::std::option::Option::None;
        self.gidcomment = ::std::option::Option::None;
        self.rate_up = ::std::option::Option::None;
        self.suppress_notifications = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_RateCommentThread_Request {
        static instance: CCommunity_RateCommentThread_Request = CCommunity_RateCommentThread_Request {
            commentthreadtype: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            gidfeature: ::std::option::Option::None,
            gidfeature2: ::std::option::Option::None,
            gidcomment: ::std::option::Option::None,
            rate_up: ::std::option::Option::None,
            suppress_notifications: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_RateCommentThread_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_RateCommentThread_Response {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_RateCommentThread_Response.gidcomment)
    pub gidcomment: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_RateCommentThread_Response.commentthreadid)
    pub commentthreadid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_RateCommentThread_Response.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_RateCommentThread_Response.upvotes)
    pub upvotes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_RateCommentThread_Response.has_upvoted)
    pub has_upvoted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_RateCommentThread_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_RateCommentThread_Response {
    fn default() -> &'a CCommunity_RateCommentThread_Response {
        <CCommunity_RateCommentThread_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_RateCommentThread_Response {
    pub fn new() -> CCommunity_RateCommentThread_Response {
        ::std::default::Default::default()
    }

    // optional uint64 gidcomment = 1;

    pub fn gidcomment(&self) -> u64 {
        self.gidcomment.unwrap_or(0)
    }

    pub fn clear_gidcomment(&mut self) {
        self.gidcomment = ::std::option::Option::None;
    }

    pub fn has_gidcomment(&self) -> bool {
        self.gidcomment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidcomment(&mut self, v: u64) {
        self.gidcomment = ::std::option::Option::Some(v);
    }

    // optional uint64 commentthreadid = 2;

    pub fn commentthreadid(&self) -> u64 {
        self.commentthreadid.unwrap_or(0)
    }

    pub fn clear_commentthreadid(&mut self) {
        self.commentthreadid = ::std::option::Option::None;
    }

    pub fn has_commentthreadid(&self) -> bool {
        self.commentthreadid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commentthreadid(&mut self, v: u64) {
        self.commentthreadid = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 3;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 upvotes = 4;

    pub fn upvotes(&self) -> u32 {
        self.upvotes.unwrap_or(0)
    }

    pub fn clear_upvotes(&mut self) {
        self.upvotes = ::std::option::Option::None;
    }

    pub fn has_upvotes(&self) -> bool {
        self.upvotes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upvotes(&mut self, v: u32) {
        self.upvotes = ::std::option::Option::Some(v);
    }

    // optional bool has_upvoted = 5;

    pub fn has_upvoted(&self) -> bool {
        self.has_upvoted.unwrap_or(false)
    }

    pub fn clear_has_upvoted(&mut self) {
        self.has_upvoted = ::std::option::Option::None;
    }

    pub fn has_has_upvoted(&self) -> bool {
        self.has_upvoted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_upvoted(&mut self, v: bool) {
        self.has_upvoted = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_RateCommentThread_Response {
    const NAME: &'static str = "CCommunity_RateCommentThread_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gidcomment = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.commentthreadid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.upvotes = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.has_upvoted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gidcomment {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.commentthreadid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.upvotes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.has_upvoted {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.gidcomment {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.commentthreadid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.upvotes {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.has_upvoted {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_RateCommentThread_Response {
        CCommunity_RateCommentThread_Response::new()
    }

    fn clear(&mut self) {
        self.gidcomment = ::std::option::Option::None;
        self.commentthreadid = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.upvotes = ::std::option::Option::None;
        self.has_upvoted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_RateCommentThread_Response {
        static instance: CCommunity_RateCommentThread_Response = CCommunity_RateCommentThread_Response {
            gidcomment: ::std::option::Option::None,
            commentthreadid: ::std::option::Option::None,
            count: ::std::option::Option::None,
            upvotes: ::std::option::Option::None,
            has_upvoted: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetCommentThreadRatings_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetCommentThreadRatings_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetCommentThreadRatings_Request.commentthreadtype)
    pub commentthreadtype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThreadRatings_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThreadRatings_Request.gidfeature)
    pub gidfeature: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThreadRatings_Request.gidfeature2)
    pub gidfeature2: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThreadRatings_Request.gidcomment)
    pub gidcomment: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThreadRatings_Request.max_results)
    pub max_results: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetCommentThreadRatings_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetCommentThreadRatings_Request {
    fn default() -> &'a CCommunity_GetCommentThreadRatings_Request {
        <CCommunity_GetCommentThreadRatings_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetCommentThreadRatings_Request {
    pub fn new() -> CCommunity_GetCommentThreadRatings_Request {
        ::std::default::Default::default()
    }

    // optional string commentthreadtype = 1;

    pub fn commentthreadtype(&self) -> &str {
        match self.commentthreadtype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_commentthreadtype(&mut self) {
        self.commentthreadtype = ::std::option::Option::None;
    }

    pub fn has_commentthreadtype(&self) -> bool {
        self.commentthreadtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commentthreadtype(&mut self, v: ::std::string::String) {
        self.commentthreadtype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commentthreadtype(&mut self) -> &mut ::std::string::String {
        if self.commentthreadtype.is_none() {
            self.commentthreadtype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.commentthreadtype.as_mut().unwrap()
    }

    // Take field
    pub fn take_commentthreadtype(&mut self) -> ::std::string::String {
        self.commentthreadtype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 gidfeature = 3;

    pub fn gidfeature(&self) -> u64 {
        self.gidfeature.unwrap_or(0)
    }

    pub fn clear_gidfeature(&mut self) {
        self.gidfeature = ::std::option::Option::None;
    }

    pub fn has_gidfeature(&self) -> bool {
        self.gidfeature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidfeature(&mut self, v: u64) {
        self.gidfeature = ::std::option::Option::Some(v);
    }

    // optional uint64 gidfeature2 = 4;

    pub fn gidfeature2(&self) -> u64 {
        self.gidfeature2.unwrap_or(0)
    }

    pub fn clear_gidfeature2(&mut self) {
        self.gidfeature2 = ::std::option::Option::None;
    }

    pub fn has_gidfeature2(&self) -> bool {
        self.gidfeature2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidfeature2(&mut self, v: u64) {
        self.gidfeature2 = ::std::option::Option::Some(v);
    }

    // optional uint64 gidcomment = 5;

    pub fn gidcomment(&self) -> u64 {
        self.gidcomment.unwrap_or(0)
    }

    pub fn clear_gidcomment(&mut self) {
        self.gidcomment = ::std::option::Option::None;
    }

    pub fn has_gidcomment(&self) -> bool {
        self.gidcomment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidcomment(&mut self, v: u64) {
        self.gidcomment = ::std::option::Option::Some(v);
    }

    // optional uint32 max_results = 6;

    pub fn max_results(&self) -> u32 {
        self.max_results.unwrap_or(0)
    }

    pub fn clear_max_results(&mut self) {
        self.max_results = ::std::option::Option::None;
    }

    pub fn has_max_results(&self) -> bool {
        self.max_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_results(&mut self, v: u32) {
        self.max_results = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetCommentThreadRatings_Request {
    const NAME: &'static str = "CCommunity_GetCommentThreadRatings_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.commentthreadtype = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.gidfeature = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.gidfeature2 = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.gidcomment = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.max_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.commentthreadtype.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.steamid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.gidfeature {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.gidfeature2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.gidcomment {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.max_results {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.commentthreadtype.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.gidfeature {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.gidfeature2 {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.gidcomment {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.max_results {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetCommentThreadRatings_Request {
        CCommunity_GetCommentThreadRatings_Request::new()
    }

    fn clear(&mut self) {
        self.commentthreadtype = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.gidfeature = ::std::option::Option::None;
        self.gidfeature2 = ::std::option::Option::None;
        self.gidcomment = ::std::option::Option::None;
        self.max_results = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetCommentThreadRatings_Request {
        static instance: CCommunity_GetCommentThreadRatings_Request = CCommunity_GetCommentThreadRatings_Request {
            commentthreadtype: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            gidfeature: ::std::option::Option::None,
            gidfeature2: ::std::option::Option::None,
            gidcomment: ::std::option::Option::None,
            max_results: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetCommentThreadRatings_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetCommentThreadRatings_Response {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetCommentThreadRatings_Response.commentthreadid)
    pub commentthreadid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThreadRatings_Response.gidcomment)
    pub gidcomment: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThreadRatings_Response.upvotes)
    pub upvotes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThreadRatings_Response.has_upvoted)
    pub has_upvoted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_GetCommentThreadRatings_Response.upvoter_accountids)
    pub upvoter_accountids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetCommentThreadRatings_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetCommentThreadRatings_Response {
    fn default() -> &'a CCommunity_GetCommentThreadRatings_Response {
        <CCommunity_GetCommentThreadRatings_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetCommentThreadRatings_Response {
    pub fn new() -> CCommunity_GetCommentThreadRatings_Response {
        ::std::default::Default::default()
    }

    // optional uint64 commentthreadid = 1;

    pub fn commentthreadid(&self) -> u64 {
        self.commentthreadid.unwrap_or(0)
    }

    pub fn clear_commentthreadid(&mut self) {
        self.commentthreadid = ::std::option::Option::None;
    }

    pub fn has_commentthreadid(&self) -> bool {
        self.commentthreadid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commentthreadid(&mut self, v: u64) {
        self.commentthreadid = ::std::option::Option::Some(v);
    }

    // optional uint64 gidcomment = 2;

    pub fn gidcomment(&self) -> u64 {
        self.gidcomment.unwrap_or(0)
    }

    pub fn clear_gidcomment(&mut self) {
        self.gidcomment = ::std::option::Option::None;
    }

    pub fn has_gidcomment(&self) -> bool {
        self.gidcomment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gidcomment(&mut self, v: u64) {
        self.gidcomment = ::std::option::Option::Some(v);
    }

    // optional uint32 upvotes = 3;

    pub fn upvotes(&self) -> u32 {
        self.upvotes.unwrap_or(0)
    }

    pub fn clear_upvotes(&mut self) {
        self.upvotes = ::std::option::Option::None;
    }

    pub fn has_upvotes(&self) -> bool {
        self.upvotes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upvotes(&mut self, v: u32) {
        self.upvotes = ::std::option::Option::Some(v);
    }

    // optional bool has_upvoted = 4;

    pub fn has_upvoted(&self) -> bool {
        self.has_upvoted.unwrap_or(false)
    }

    pub fn clear_has_upvoted(&mut self) {
        self.has_upvoted = ::std::option::Option::None;
    }

    pub fn has_has_upvoted(&self) -> bool {
        self.has_upvoted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_upvoted(&mut self, v: bool) {
        self.has_upvoted = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetCommentThreadRatings_Response {
    const NAME: &'static str = "CCommunity_GetCommentThreadRatings_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.commentthreadid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.gidcomment = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.upvotes = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.has_upvoted = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.upvoter_accountids)?;
                },
                40 => {
                    self.upvoter_accountids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.commentthreadid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.gidcomment {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.upvotes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.has_upvoted {
            my_size += 1 + 1;
        }
        for value in &self.upvoter_accountids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.commentthreadid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.gidcomment {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.upvotes {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.has_upvoted {
            os.write_bool(4, v)?;
        }
        for v in &self.upvoter_accountids {
            os.write_uint32(5, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetCommentThreadRatings_Response {
        CCommunity_GetCommentThreadRatings_Response::new()
    }

    fn clear(&mut self) {
        self.commentthreadid = ::std::option::Option::None;
        self.gidcomment = ::std::option::Option::None;
        self.upvotes = ::std::option::Option::None;
        self.has_upvoted = ::std::option::Option::None;
        self.upvoter_accountids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetCommentThreadRatings_Response {
        static instance: CCommunity_GetCommentThreadRatings_Response = CCommunity_GetCommentThreadRatings_Response {
            commentthreadid: ::std::option::Option::None,
            gidcomment: ::std::option::Option::None,
            upvotes: ::std::option::Option::None,
            has_upvoted: ::std::option::Option::None,
            upvoter_accountids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_RateClanAnnouncement_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_RateClanAnnouncement_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_RateClanAnnouncement_Request.announcementid)
    pub announcementid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_RateClanAnnouncement_Request.vote_up)
    pub vote_up: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_RateClanAnnouncement_Request.clan_accountid)
    pub clan_accountid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_RateClanAnnouncement_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_RateClanAnnouncement_Request {
    fn default() -> &'a CCommunity_RateClanAnnouncement_Request {
        <CCommunity_RateClanAnnouncement_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_RateClanAnnouncement_Request {
    pub fn new() -> CCommunity_RateClanAnnouncement_Request {
        ::std::default::Default::default()
    }

    // optional uint64 announcementid = 1;

    pub fn announcementid(&self) -> u64 {
        self.announcementid.unwrap_or(0)
    }

    pub fn clear_announcementid(&mut self) {
        self.announcementid = ::std::option::Option::None;
    }

    pub fn has_announcementid(&self) -> bool {
        self.announcementid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcementid(&mut self, v: u64) {
        self.announcementid = ::std::option::Option::Some(v);
    }

    // optional bool vote_up = 2;

    pub fn vote_up(&self) -> bool {
        self.vote_up.unwrap_or(false)
    }

    pub fn clear_vote_up(&mut self) {
        self.vote_up = ::std::option::Option::None;
    }

    pub fn has_vote_up(&self) -> bool {
        self.vote_up.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_up(&mut self, v: bool) {
        self.vote_up = ::std::option::Option::Some(v);
    }

    // optional uint32 clan_accountid = 3;

    pub fn clan_accountid(&self) -> u32 {
        self.clan_accountid.unwrap_or(0)
    }

    pub fn clear_clan_accountid(&mut self) {
        self.clan_accountid = ::std::option::Option::None;
    }

    pub fn has_clan_accountid(&self) -> bool {
        self.clan_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_accountid(&mut self, v: u32) {
        self.clan_accountid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_RateClanAnnouncement_Request {
    const NAME: &'static str = "CCommunity_RateClanAnnouncement_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.announcementid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.vote_up = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.clan_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.announcementid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.vote_up {
            my_size += 1 + 1;
        }
        if let Some(v) = self.clan_accountid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.announcementid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.vote_up {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.clan_accountid {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_RateClanAnnouncement_Request {
        CCommunity_RateClanAnnouncement_Request::new()
    }

    fn clear(&mut self) {
        self.announcementid = ::std::option::Option::None;
        self.vote_up = ::std::option::Option::None;
        self.clan_accountid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_RateClanAnnouncement_Request {
        static instance: CCommunity_RateClanAnnouncement_Request = CCommunity_RateClanAnnouncement_Request {
            announcementid: ::std::option::Option::None,
            vote_up: ::std::option::Option::None,
            clan_accountid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_RateClanAnnouncement_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_RateClanAnnouncement_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_RateClanAnnouncement_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_RateClanAnnouncement_Response {
    fn default() -> &'a CCommunity_RateClanAnnouncement_Response {
        <CCommunity_RateClanAnnouncement_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_RateClanAnnouncement_Response {
    pub fn new() -> CCommunity_RateClanAnnouncement_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_RateClanAnnouncement_Response {
    const NAME: &'static str = "CCommunity_RateClanAnnouncement_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_RateClanAnnouncement_Response {
        CCommunity_RateClanAnnouncement_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_RateClanAnnouncement_Response {
        static instance: CCommunity_RateClanAnnouncement_Response = CCommunity_RateClanAnnouncement_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetClanAnnouncementVoteForUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetClanAnnouncementVoteForUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncementVoteForUser_Request.announcementid)
    pub announcementid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetClanAnnouncementVoteForUser_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetClanAnnouncementVoteForUser_Request {
    fn default() -> &'a CCommunity_GetClanAnnouncementVoteForUser_Request {
        <CCommunity_GetClanAnnouncementVoteForUser_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetClanAnnouncementVoteForUser_Request {
    pub fn new() -> CCommunity_GetClanAnnouncementVoteForUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 announcementid = 1;

    pub fn announcementid(&self) -> u64 {
        self.announcementid.unwrap_or(0)
    }

    pub fn clear_announcementid(&mut self) {
        self.announcementid = ::std::option::Option::None;
    }

    pub fn has_announcementid(&self) -> bool {
        self.announcementid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcementid(&mut self, v: u64) {
        self.announcementid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetClanAnnouncementVoteForUser_Request {
    const NAME: &'static str = "CCommunity_GetClanAnnouncementVoteForUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.announcementid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.announcementid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.announcementid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetClanAnnouncementVoteForUser_Request {
        CCommunity_GetClanAnnouncementVoteForUser_Request::new()
    }

    fn clear(&mut self) {
        self.announcementid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetClanAnnouncementVoteForUser_Request {
        static instance: CCommunity_GetClanAnnouncementVoteForUser_Request = CCommunity_GetClanAnnouncementVoteForUser_Request {
            announcementid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetClanAnnouncementVoteForUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetClanAnnouncementVoteForUser_Response {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncementVoteForUser_Response.voted_up)
    pub voted_up: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_GetClanAnnouncementVoteForUser_Response.voted_down)
    pub voted_down: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetClanAnnouncementVoteForUser_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetClanAnnouncementVoteForUser_Response {
    fn default() -> &'a CCommunity_GetClanAnnouncementVoteForUser_Response {
        <CCommunity_GetClanAnnouncementVoteForUser_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetClanAnnouncementVoteForUser_Response {
    pub fn new() -> CCommunity_GetClanAnnouncementVoteForUser_Response {
        ::std::default::Default::default()
    }

    // optional bool voted_up = 1;

    pub fn voted_up(&self) -> bool {
        self.voted_up.unwrap_or(false)
    }

    pub fn clear_voted_up(&mut self) {
        self.voted_up = ::std::option::Option::None;
    }

    pub fn has_voted_up(&self) -> bool {
        self.voted_up.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voted_up(&mut self, v: bool) {
        self.voted_up = ::std::option::Option::Some(v);
    }

    // optional bool voted_down = 2;

    pub fn voted_down(&self) -> bool {
        self.voted_down.unwrap_or(false)
    }

    pub fn clear_voted_down(&mut self) {
        self.voted_down = ::std::option::Option::None;
    }

    pub fn has_voted_down(&self) -> bool {
        self.voted_down.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voted_down(&mut self, v: bool) {
        self.voted_down = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetClanAnnouncementVoteForUser_Response {
    const NAME: &'static str = "CCommunity_GetClanAnnouncementVoteForUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.voted_up = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.voted_down = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.voted_up {
            my_size += 1 + 1;
        }
        if let Some(v) = self.voted_down {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.voted_up {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.voted_down {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetClanAnnouncementVoteForUser_Response {
        CCommunity_GetClanAnnouncementVoteForUser_Response::new()
    }

    fn clear(&mut self) {
        self.voted_up = ::std::option::Option::None;
        self.voted_down = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetClanAnnouncementVoteForUser_Response {
        static instance: CCommunity_GetClanAnnouncementVoteForUser_Response = CCommunity_GetClanAnnouncementVoteForUser_Response {
            voted_up: ::std::option::Option::None,
            voted_down: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetAvatarHistory_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetAvatarHistory_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetAvatarHistory_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetAvatarHistory_Request.filter_user_uploaded_only)
    pub filter_user_uploaded_only: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetAvatarHistory_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetAvatarHistory_Request {
    fn default() -> &'a CCommunity_GetAvatarHistory_Request {
        <CCommunity_GetAvatarHistory_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetAvatarHistory_Request {
    pub fn new() -> CCommunity_GetAvatarHistory_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool filter_user_uploaded_only = 2;

    pub fn filter_user_uploaded_only(&self) -> bool {
        self.filter_user_uploaded_only.unwrap_or(false)
    }

    pub fn clear_filter_user_uploaded_only(&mut self) {
        self.filter_user_uploaded_only = ::std::option::Option::None;
    }

    pub fn has_filter_user_uploaded_only(&self) -> bool {
        self.filter_user_uploaded_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_user_uploaded_only(&mut self, v: bool) {
        self.filter_user_uploaded_only = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetAvatarHistory_Request {
    const NAME: &'static str = "CCommunity_GetAvatarHistory_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.filter_user_uploaded_only = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.filter_user_uploaded_only {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.filter_user_uploaded_only {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetAvatarHistory_Request {
        CCommunity_GetAvatarHistory_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.filter_user_uploaded_only = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetAvatarHistory_Request {
        static instance: CCommunity_GetAvatarHistory_Request = CCommunity_GetAvatarHistory_Request {
            steamid: ::std::option::Option::None,
            filter_user_uploaded_only: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetAvatarHistory_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetAvatarHistory_Response {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetAvatarHistory_Response.avatars)
    pub avatars: ::std::vec::Vec<ccommunity_get_avatar_history_response::AvatarData>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetAvatarHistory_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetAvatarHistory_Response {
    fn default() -> &'a CCommunity_GetAvatarHistory_Response {
        <CCommunity_GetAvatarHistory_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetAvatarHistory_Response {
    pub fn new() -> CCommunity_GetAvatarHistory_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetAvatarHistory_Response {
    const NAME: &'static str = "CCommunity_GetAvatarHistory_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.avatars.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.avatars {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.avatars {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetAvatarHistory_Response {
        CCommunity_GetAvatarHistory_Response::new()
    }

    fn clear(&mut self) {
        self.avatars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetAvatarHistory_Response {
        static instance: CCommunity_GetAvatarHistory_Response = CCommunity_GetAvatarHistory_Response {
            avatars: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CCommunity_GetAvatarHistory_Response`
pub mod ccommunity_get_avatar_history_response {
    // @@protoc_insertion_point(message:CCommunity_GetAvatarHistory_Response.AvatarData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AvatarData {
        // message fields
        // @@protoc_insertion_point(field:CCommunity_GetAvatarHistory_Response.AvatarData.avatar_sha1)
        pub avatar_sha1: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CCommunity_GetAvatarHistory_Response.AvatarData.user_uploaded)
        pub user_uploaded: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CCommunity_GetAvatarHistory_Response.AvatarData.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCommunity_GetAvatarHistory_Response.AvatarData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AvatarData {
        fn default() -> &'a AvatarData {
            <AvatarData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl AvatarData {
        pub fn new() -> AvatarData {
            ::std::default::Default::default()
        }

        // optional string avatar_sha1 = 1;

        pub fn avatar_sha1(&self) -> &str {
            match self.avatar_sha1.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_avatar_sha1(&mut self) {
            self.avatar_sha1 = ::std::option::Option::None;
        }

        pub fn has_avatar_sha1(&self) -> bool {
            self.avatar_sha1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avatar_sha1(&mut self, v: ::std::string::String) {
            self.avatar_sha1 = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_avatar_sha1(&mut self) -> &mut ::std::string::String {
            if self.avatar_sha1.is_none() {
                self.avatar_sha1 = ::std::option::Option::Some(::std::string::String::new());
            }
            self.avatar_sha1.as_mut().unwrap()
        }

        // Take field
        pub fn take_avatar_sha1(&mut self) -> ::std::string::String {
            self.avatar_sha1.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool user_uploaded = 2;

        pub fn user_uploaded(&self) -> bool {
            self.user_uploaded.unwrap_or(false)
        }

        pub fn clear_user_uploaded(&mut self) {
            self.user_uploaded = ::std::option::Option::None;
        }

        pub fn has_user_uploaded(&self) -> bool {
            self.user_uploaded.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_uploaded(&mut self, v: bool) {
            self.user_uploaded = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 3;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for AvatarData {
        const NAME: &'static str = "AvatarData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.avatar_sha1 = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.user_uploaded = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.avatar_sha1.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.user_uploaded {
                my_size += 1 + 1;
            }
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.avatar_sha1.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.user_uploaded {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AvatarData {
            AvatarData::new()
        }

        fn clear(&mut self) {
            self.avatar_sha1 = ::std::option::Option::None;
            self.user_uploaded = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AvatarData {
            static instance: AvatarData = AvatarData {
                avatar_sha1: ::std::option::Option::None,
                user_uploaded: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CAppPriority)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAppPriority {
    // message fields
    // @@protoc_insertion_point(field:CAppPriority.priority)
    pub priority: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAppPriority.appid)
    pub appid: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CAppPriority.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAppPriority {
    fn default() -> &'a CAppPriority {
        <CAppPriority as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CAppPriority {
    pub fn new() -> CAppPriority {
        ::std::default::Default::default()
    }

    // optional uint32 priority = 1;

    pub fn priority(&self) -> u32 {
        self.priority.unwrap_or(0)
    }

    pub fn clear_priority(&mut self) {
        self.priority = ::std::option::Option::None;
    }

    pub fn has_priority(&self) -> bool {
        self.priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: u32) {
        self.priority = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CAppPriority {
    const NAME: &'static str = "CAppPriority";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.priority = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.appid)?;
                },
                16 => {
                    self.appid.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.priority {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.priority {
            os.write_uint32(1, v)?;
        }
        for v in &self.appid {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAppPriority {
        CAppPriority::new()
    }

    fn clear(&mut self) {
        self.priority = ::std::option::Option::None;
        self.appid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAppPriority {
        static instance: CAppPriority = CAppPriority {
            priority: ::std::option::Option::None,
            appid: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetUserPartnerEventNews_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetUserPartnerEventNews_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventNews_Request.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventNews_Request.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventNews_Request.rtime32_start_time)
    pub rtime32_start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventNews_Request.rtime32_end_time)
    pub rtime32_end_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventNews_Request.language_preference)
    pub language_preference: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventNews_Request.filter_event_type)
    pub filter_event_type: ::std::vec::Vec<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::steammessages_base::EProtoClanEventType>>,
    // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventNews_Request.filter_to_appid)
    pub filter_to_appid: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventNews_Request.app_list)
    pub app_list: ::std::vec::Vec<CAppPriority>,
    // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventNews_Request.count_after)
    pub count_after: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventNews_Request.count_before)
    pub count_before: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetUserPartnerEventNews_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetUserPartnerEventNews_Request {
    fn default() -> &'a CCommunity_GetUserPartnerEventNews_Request {
        <CCommunity_GetUserPartnerEventNews_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetUserPartnerEventNews_Request {
    pub fn new() -> CCommunity_GetUserPartnerEventNews_Request {
        ::std::default::Default::default()
    }

    // optional uint32 count = 1;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 2;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_start_time = 3;

    pub fn rtime32_start_time(&self) -> u32 {
        self.rtime32_start_time.unwrap_or(0)
    }

    pub fn clear_rtime32_start_time(&mut self) {
        self.rtime32_start_time = ::std::option::Option::None;
    }

    pub fn has_rtime32_start_time(&self) -> bool {
        self.rtime32_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_start_time(&mut self, v: u32) {
        self.rtime32_start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_end_time = 4;

    pub fn rtime32_end_time(&self) -> u32 {
        self.rtime32_end_time.unwrap_or(0)
    }

    pub fn clear_rtime32_end_time(&mut self) {
        self.rtime32_end_time = ::std::option::Option::None;
    }

    pub fn has_rtime32_end_time(&self) -> bool {
        self.rtime32_end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_end_time(&mut self, v: u32) {
        self.rtime32_end_time = ::std::option::Option::Some(v);
    }

    // optional bool filter_to_appid = 7;

    pub fn filter_to_appid(&self) -> bool {
        self.filter_to_appid.unwrap_or(false)
    }

    pub fn clear_filter_to_appid(&mut self) {
        self.filter_to_appid = ::std::option::Option::None;
    }

    pub fn has_filter_to_appid(&self) -> bool {
        self.filter_to_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_to_appid(&mut self, v: bool) {
        self.filter_to_appid = ::std::option::Option::Some(v);
    }

    // optional uint32 count_after = 9;

    pub fn count_after(&self) -> u32 {
        self.count_after.unwrap_or(0u32)
    }

    pub fn clear_count_after(&mut self) {
        self.count_after = ::std::option::Option::None;
    }

    pub fn has_count_after(&self) -> bool {
        self.count_after.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_after(&mut self, v: u32) {
        self.count_after = ::std::option::Option::Some(v);
    }

    // optional uint32 count_before = 10;

    pub fn count_before(&self) -> u32 {
        self.count_before.unwrap_or(0u32)
    }

    pub fn clear_count_before(&mut self) {
        self.count_before = ::std::option::Option::None;
    }

    pub fn has_count_before(&self) -> bool {
        self.count_before.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_before(&mut self, v: u32) {
        self.count_before = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetUserPartnerEventNews_Request {
    const NAME: &'static str = "CCommunity_GetUserPartnerEventNews_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.rtime32_start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.rtime32_end_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.language_preference)?;
                },
                40 => {
                    self.language_preference.push(is.read_uint32()?);
                },
                48 => {
                    self.filter_event_type.push(is.read_enum_or_unknown()?);
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.filter_event_type)?
                },
                56 => {
                    self.filter_to_appid = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    self.app_list.push(is.read_message()?);
                },
                72 => {
                    self.count_after = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.count_before = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.offset {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.rtime32_start_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.rtime32_end_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.language_preference {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, *value);
        };
        for value in &self.filter_event_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, value.value());
        };
        if let Some(v) = self.filter_to_appid {
            my_size += 1 + 1;
        }
        for value in &self.app_list {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.count_after {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.count_before {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.count {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rtime32_start_time {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rtime32_end_time {
            os.write_uint32(4, v)?;
        }
        for v in &self.language_preference {
            os.write_uint32(5, *v)?;
        };
        for v in &self.filter_event_type {
            os.write_enum(6, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.filter_to_appid {
            os.write_bool(7, v)?;
        }
        for v in &self.app_list {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.count_after {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.count_before {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetUserPartnerEventNews_Request {
        CCommunity_GetUserPartnerEventNews_Request::new()
    }

    fn clear(&mut self) {
        self.count = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.rtime32_start_time = ::std::option::Option::None;
        self.rtime32_end_time = ::std::option::Option::None;
        self.language_preference.clear();
        self.filter_event_type.clear();
        self.filter_to_appid = ::std::option::Option::None;
        self.app_list.clear();
        self.count_after = ::std::option::Option::None;
        self.count_before = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetUserPartnerEventNews_Request {
        static instance: CCommunity_GetUserPartnerEventNews_Request = CCommunity_GetUserPartnerEventNews_Request {
            count: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            rtime32_start_time: ::std::option::Option::None,
            rtime32_end_time: ::std::option::Option::None,
            language_preference: ::std::vec::Vec::new(),
            filter_event_type: ::std::vec::Vec::new(),
            filter_to_appid: ::std::option::Option::None,
            app_list: ::std::vec::Vec::new(),
            count_after: ::std::option::Option::None,
            count_before: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetUserPartnerEventNews_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetUserPartnerEventNews_Response {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventNews_Response.results)
    pub results: ::std::vec::Vec<super::steammessages_base::CClanMatchEventByRange>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetUserPartnerEventNews_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetUserPartnerEventNews_Response {
    fn default() -> &'a CCommunity_GetUserPartnerEventNews_Response {
        <CCommunity_GetUserPartnerEventNews_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetUserPartnerEventNews_Response {
    pub fn new() -> CCommunity_GetUserPartnerEventNews_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetUserPartnerEventNews_Response {
    const NAME: &'static str = "CCommunity_GetUserPartnerEventNews_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.results {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetUserPartnerEventNews_Response {
        CCommunity_GetUserPartnerEventNews_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetUserPartnerEventNews_Response {
        static instance: CCommunity_GetUserPartnerEventNews_Response = CCommunity_GetUserPartnerEventNews_Response {
            results: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetBestEventsForUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetBestEventsForUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetBestEventsForUser_Request.include_steam_blog)
    pub include_steam_blog: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_GetBestEventsForUser_Request.filter_to_played_within_days)
    pub filter_to_played_within_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_GetBestEventsForUser_Request.include_only_game_updates)
    pub include_only_game_updates: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetBestEventsForUser_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetBestEventsForUser_Request {
    fn default() -> &'a CCommunity_GetBestEventsForUser_Request {
        <CCommunity_GetBestEventsForUser_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetBestEventsForUser_Request {
    pub fn new() -> CCommunity_GetBestEventsForUser_Request {
        ::std::default::Default::default()
    }

    // optional bool include_steam_blog = 1;

    pub fn include_steam_blog(&self) -> bool {
        self.include_steam_blog.unwrap_or(false)
    }

    pub fn clear_include_steam_blog(&mut self) {
        self.include_steam_blog = ::std::option::Option::None;
    }

    pub fn has_include_steam_blog(&self) -> bool {
        self.include_steam_blog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_steam_blog(&mut self, v: bool) {
        self.include_steam_blog = ::std::option::Option::Some(v);
    }

    // optional uint32 filter_to_played_within_days = 2;

    pub fn filter_to_played_within_days(&self) -> u32 {
        self.filter_to_played_within_days.unwrap_or(0)
    }

    pub fn clear_filter_to_played_within_days(&mut self) {
        self.filter_to_played_within_days = ::std::option::Option::None;
    }

    pub fn has_filter_to_played_within_days(&self) -> bool {
        self.filter_to_played_within_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_to_played_within_days(&mut self, v: u32) {
        self.filter_to_played_within_days = ::std::option::Option::Some(v);
    }

    // optional bool include_only_game_updates = 3;

    pub fn include_only_game_updates(&self) -> bool {
        self.include_only_game_updates.unwrap_or(false)
    }

    pub fn clear_include_only_game_updates(&mut self) {
        self.include_only_game_updates = ::std::option::Option::None;
    }

    pub fn has_include_only_game_updates(&self) -> bool {
        self.include_only_game_updates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_only_game_updates(&mut self, v: bool) {
        self.include_only_game_updates = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetBestEventsForUser_Request {
    const NAME: &'static str = "CCommunity_GetBestEventsForUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.include_steam_blog = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.filter_to_played_within_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.include_only_game_updates = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.include_steam_blog {
            my_size += 1 + 1;
        }
        if let Some(v) = self.filter_to_played_within_days {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.include_only_game_updates {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.include_steam_blog {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.filter_to_played_within_days {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.include_only_game_updates {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetBestEventsForUser_Request {
        CCommunity_GetBestEventsForUser_Request::new()
    }

    fn clear(&mut self) {
        self.include_steam_blog = ::std::option::Option::None;
        self.filter_to_played_within_days = ::std::option::Option::None;
        self.include_only_game_updates = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetBestEventsForUser_Request {
        static instance: CCommunity_GetBestEventsForUser_Request = CCommunity_GetBestEventsForUser_Request {
            include_steam_blog: ::std::option::Option::None,
            filter_to_played_within_days: ::std::option::Option::None,
            include_only_game_updates: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_PartnerEventResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_PartnerEventResult {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_PartnerEventResult.clanid)
    pub clanid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_PartnerEventResult.event_gid)
    pub event_gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_PartnerEventResult.announcement_gid)
    pub announcement_gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_PartnerEventResult.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_PartnerEventResult.possible_takeover)
    pub possible_takeover: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_PartnerEventResult.rtime32_last_modified)
    pub rtime32_last_modified: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_PartnerEventResult.user_app_priority)
    pub user_app_priority: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_PartnerEventResult.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_PartnerEventResult {
    fn default() -> &'a CCommunity_PartnerEventResult {
        <CCommunity_PartnerEventResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_PartnerEventResult {
    pub fn new() -> CCommunity_PartnerEventResult {
        ::std::default::Default::default()
    }

    // optional uint32 clanid = 1;

    pub fn clanid(&self) -> u32 {
        self.clanid.unwrap_or(0)
    }

    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u32) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional fixed64 event_gid = 2;

    pub fn event_gid(&self) -> u64 {
        self.event_gid.unwrap_or(0)
    }

    pub fn clear_event_gid(&mut self) {
        self.event_gid = ::std::option::Option::None;
    }

    pub fn has_event_gid(&self) -> bool {
        self.event_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_gid(&mut self, v: u64) {
        self.event_gid = ::std::option::Option::Some(v);
    }

    // optional fixed64 announcement_gid = 3;

    pub fn announcement_gid(&self) -> u64 {
        self.announcement_gid.unwrap_or(0)
    }

    pub fn clear_announcement_gid(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
    }

    pub fn has_announcement_gid(&self) -> bool {
        self.announcement_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_gid(&mut self, v: u64) {
        self.announcement_gid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 4;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bool possible_takeover = 5;

    pub fn possible_takeover(&self) -> bool {
        self.possible_takeover.unwrap_or(false)
    }

    pub fn clear_possible_takeover(&mut self) {
        self.possible_takeover = ::std::option::Option::None;
    }

    pub fn has_possible_takeover(&self) -> bool {
        self.possible_takeover.is_some()
    }

    // Param is passed by value, moved
    pub fn set_possible_takeover(&mut self, v: bool) {
        self.possible_takeover = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_last_modified = 6;

    pub fn rtime32_last_modified(&self) -> u32 {
        self.rtime32_last_modified.unwrap_or(0u32)
    }

    pub fn clear_rtime32_last_modified(&mut self) {
        self.rtime32_last_modified = ::std::option::Option::None;
    }

    pub fn has_rtime32_last_modified(&self) -> bool {
        self.rtime32_last_modified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_last_modified(&mut self, v: u32) {
        self.rtime32_last_modified = ::std::option::Option::Some(v);
    }

    // optional int32 user_app_priority = 7;

    pub fn user_app_priority(&self) -> i32 {
        self.user_app_priority.unwrap_or(0)
    }

    pub fn clear_user_app_priority(&mut self) {
        self.user_app_priority = ::std::option::Option::None;
    }

    pub fn has_user_app_priority(&self) -> bool {
        self.user_app_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_priority(&mut self, v: i32) {
        self.user_app_priority = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_PartnerEventResult {
    const NAME: &'static str = "CCommunity_PartnerEventResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.clanid = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.event_gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.announcement_gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.possible_takeover = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.rtime32_last_modified = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.user_app_priority = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clanid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.announcement_gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.possible_takeover {
            my_size += 1 + 1;
        }
        if let Some(v) = self.rtime32_last_modified {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.user_app_priority {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.clanid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_gid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.announcement_gid {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.possible_takeover {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.rtime32_last_modified {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.user_app_priority {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_PartnerEventResult {
        CCommunity_PartnerEventResult::new()
    }

    fn clear(&mut self) {
        self.clanid = ::std::option::Option::None;
        self.event_gid = ::std::option::Option::None;
        self.announcement_gid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.possible_takeover = ::std::option::Option::None;
        self.rtime32_last_modified = ::std::option::Option::None;
        self.user_app_priority = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_PartnerEventResult {
        static instance: CCommunity_PartnerEventResult = CCommunity_PartnerEventResult {
            clanid: ::std::option::Option::None,
            event_gid: ::std::option::Option::None,
            announcement_gid: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            possible_takeover: ::std::option::Option::None,
            rtime32_last_modified: ::std::option::Option::None,
            user_app_priority: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetBestEventsForUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetBestEventsForUser_Response {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetBestEventsForUser_Response.results)
    pub results: ::std::vec::Vec<CCommunity_PartnerEventResult>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetBestEventsForUser_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetBestEventsForUser_Response {
    fn default() -> &'a CCommunity_GetBestEventsForUser_Response {
        <CCommunity_GetBestEventsForUser_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetBestEventsForUser_Response {
    pub fn new() -> CCommunity_GetBestEventsForUser_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetBestEventsForUser_Response {
    const NAME: &'static str = "CCommunity_GetBestEventsForUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.results {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetBestEventsForUser_Response {
        CCommunity_GetBestEventsForUser_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetBestEventsForUser_Response {
        static instance: CCommunity_GetBestEventsForUser_Response = CCommunity_GetBestEventsForUser_Response {
            results: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_MarkPartnerEventsForUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_MarkPartnerEventsForUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_MarkPartnerEventsForUser_Request.markings)
    pub markings: ::std::vec::Vec<ccommunity_mark_partner_events_for_user_request::PartnerEventMarking>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_MarkPartnerEventsForUser_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_MarkPartnerEventsForUser_Request {
    fn default() -> &'a CCommunity_MarkPartnerEventsForUser_Request {
        <CCommunity_MarkPartnerEventsForUser_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_MarkPartnerEventsForUser_Request {
    pub fn new() -> CCommunity_MarkPartnerEventsForUser_Request {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_MarkPartnerEventsForUser_Request {
    const NAME: &'static str = "CCommunity_MarkPartnerEventsForUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.markings.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.markings {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.markings {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_MarkPartnerEventsForUser_Request {
        CCommunity_MarkPartnerEventsForUser_Request::new()
    }

    fn clear(&mut self) {
        self.markings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_MarkPartnerEventsForUser_Request {
        static instance: CCommunity_MarkPartnerEventsForUser_Request = CCommunity_MarkPartnerEventsForUser_Request {
            markings: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CCommunity_MarkPartnerEventsForUser_Request`
pub mod ccommunity_mark_partner_events_for_user_request {
    // @@protoc_insertion_point(message:CCommunity_MarkPartnerEventsForUser_Request.PartnerEventMarking)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PartnerEventMarking {
        // message fields
        // @@protoc_insertion_point(field:CCommunity_MarkPartnerEventsForUser_Request.PartnerEventMarking.clanid)
        pub clanid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CCommunity_MarkPartnerEventsForUser_Request.PartnerEventMarking.event_gid)
        pub event_gid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CCommunity_MarkPartnerEventsForUser_Request.PartnerEventMarking.display_location)
        pub display_location: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::EPartnerEventDisplayLocation>>,
        // @@protoc_insertion_point(field:CCommunity_MarkPartnerEventsForUser_Request.PartnerEventMarking.mark_shown)
        pub mark_shown: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CCommunity_MarkPartnerEventsForUser_Request.PartnerEventMarking.mark_read)
        pub mark_read: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CCommunity_MarkPartnerEventsForUser_Request.PartnerEventMarking.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PartnerEventMarking {
        fn default() -> &'a PartnerEventMarking {
            <PartnerEventMarking as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PartnerEventMarking {
        pub fn new() -> PartnerEventMarking {
            ::std::default::Default::default()
        }

        // optional uint32 clanid = 1;

        pub fn clanid(&self) -> u32 {
            self.clanid.unwrap_or(0)
        }

        pub fn clear_clanid(&mut self) {
            self.clanid = ::std::option::Option::None;
        }

        pub fn has_clanid(&self) -> bool {
            self.clanid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clanid(&mut self, v: u32) {
            self.clanid = ::std::option::Option::Some(v);
        }

        // optional fixed64 event_gid = 2;

        pub fn event_gid(&self) -> u64 {
            self.event_gid.unwrap_or(0)
        }

        pub fn clear_event_gid(&mut self) {
            self.event_gid = ::std::option::Option::None;
        }

        pub fn has_event_gid(&self) -> bool {
            self.event_gid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_gid(&mut self, v: u64) {
            self.event_gid = ::std::option::Option::Some(v);
        }

        // optional .EPartnerEventDisplayLocation display_location = 3;

        pub fn display_location(&self) -> super::EPartnerEventDisplayLocation {
            match self.display_location {
                Some(e) => e.enum_value_or(super::EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_Invalid),
                None => super::EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_Invalid,
            }
        }

        pub fn clear_display_location(&mut self) {
            self.display_location = ::std::option::Option::None;
        }

        pub fn has_display_location(&self) -> bool {
            self.display_location.is_some()
        }

        // Param is passed by value, moved
        pub fn set_display_location(&mut self, v: super::EPartnerEventDisplayLocation) {
            self.display_location = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional bool mark_shown = 4;

        pub fn mark_shown(&self) -> bool {
            self.mark_shown.unwrap_or(false)
        }

        pub fn clear_mark_shown(&mut self) {
            self.mark_shown = ::std::option::Option::None;
        }

        pub fn has_mark_shown(&self) -> bool {
            self.mark_shown.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mark_shown(&mut self, v: bool) {
            self.mark_shown = ::std::option::Option::Some(v);
        }

        // optional bool mark_read = 5;

        pub fn mark_read(&self) -> bool {
            self.mark_read.unwrap_or(false)
        }

        pub fn clear_mark_read(&mut self) {
            self.mark_read = ::std::option::Option::None;
        }

        pub fn has_mark_read(&self) -> bool {
            self.mark_read.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mark_read(&mut self, v: bool) {
            self.mark_read = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PartnerEventMarking {
        const NAME: &'static str = "PartnerEventMarking";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.clanid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    17 => {
                        self.event_gid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    24 => {
                        self.display_location = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    32 => {
                        self.mark_shown = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.mark_read = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.clanid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.event_gid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.display_location {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.mark_shown {
                my_size += 1 + 1;
            }
            if let Some(v) = self.mark_read {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.clanid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.event_gid {
                os.write_fixed64(2, v)?;
            }
            if let Some(v) = self.display_location {
                os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.mark_shown {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.mark_read {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PartnerEventMarking {
            PartnerEventMarking::new()
        }

        fn clear(&mut self) {
            self.clanid = ::std::option::Option::None;
            self.event_gid = ::std::option::Option::None;
            self.display_location = ::std::option::Option::None;
            self.mark_shown = ::std::option::Option::None;
            self.mark_read = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PartnerEventMarking {
            static instance: PartnerEventMarking = PartnerEventMarking {
                clanid: ::std::option::Option::None,
                event_gid: ::std::option::Option::None,
                display_location: ::std::option::Option::None,
                mark_shown: ::std::option::Option::None,
                mark_read: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CCommunity_MarkPartnerEventsForUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_MarkPartnerEventsForUser_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_MarkPartnerEventsForUser_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_MarkPartnerEventsForUser_Response {
    fn default() -> &'a CCommunity_MarkPartnerEventsForUser_Response {
        <CCommunity_MarkPartnerEventsForUser_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_MarkPartnerEventsForUser_Response {
    pub fn new() -> CCommunity_MarkPartnerEventsForUser_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_MarkPartnerEventsForUser_Response {
    const NAME: &'static str = "CCommunity_MarkPartnerEventsForUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_MarkPartnerEventsForUser_Response {
        CCommunity_MarkPartnerEventsForUser_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_MarkPartnerEventsForUser_Response {
        static instance: CCommunity_MarkPartnerEventsForUser_Response = CCommunity_MarkPartnerEventsForUser_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetUserPartnerEventViewStatus_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetUserPartnerEventViewStatus_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventViewStatus_Request.event_gids)
    pub event_gids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventViewStatus_Request.include_read_events_only)
    pub include_read_events_only: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetUserPartnerEventViewStatus_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetUserPartnerEventViewStatus_Request {
    fn default() -> &'a CCommunity_GetUserPartnerEventViewStatus_Request {
        <CCommunity_GetUserPartnerEventViewStatus_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetUserPartnerEventViewStatus_Request {
    pub fn new() -> CCommunity_GetUserPartnerEventViewStatus_Request {
        ::std::default::Default::default()
    }

    // optional bool include_read_events_only = 2;

    pub fn include_read_events_only(&self) -> bool {
        self.include_read_events_only.unwrap_or(false)
    }

    pub fn clear_include_read_events_only(&mut self) {
        self.include_read_events_only = ::std::option::Option::None;
    }

    pub fn has_include_read_events_only(&self) -> bool {
        self.include_read_events_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_read_events_only(&mut self, v: bool) {
        self.include_read_events_only = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetUserPartnerEventViewStatus_Request {
    const NAME: &'static str = "CCommunity_GetUserPartnerEventViewStatus_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.event_gids)?;
                },
                9 => {
                    self.event_gids.push(is.read_fixed64()?);
                },
                16 => {
                    self.include_read_events_only = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.event_gids.len() as u64;
        if let Some(v) = self.include_read_events_only {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.event_gids {
            os.write_fixed64(1, *v)?;
        };
        if let Some(v) = self.include_read_events_only {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetUserPartnerEventViewStatus_Request {
        CCommunity_GetUserPartnerEventViewStatus_Request::new()
    }

    fn clear(&mut self) {
        self.event_gids.clear();
        self.include_read_events_only = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetUserPartnerEventViewStatus_Request {
        static instance: CCommunity_GetUserPartnerEventViewStatus_Request = CCommunity_GetUserPartnerEventViewStatus_Request {
            event_gids: ::std::vec::Vec::new(),
            include_read_events_only: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetUserPartnerEventViewStatus_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetUserPartnerEventViewStatus_Response {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventViewStatus_Response.events)
    pub events: ::std::vec::Vec<ccommunity_get_user_partner_event_view_status_response::PartnerEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetUserPartnerEventViewStatus_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetUserPartnerEventViewStatus_Response {
    fn default() -> &'a CCommunity_GetUserPartnerEventViewStatus_Response {
        <CCommunity_GetUserPartnerEventViewStatus_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetUserPartnerEventViewStatus_Response {
    pub fn new() -> CCommunity_GetUserPartnerEventViewStatus_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetUserPartnerEventViewStatus_Response {
    const NAME: &'static str = "CCommunity_GetUserPartnerEventViewStatus_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.events {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetUserPartnerEventViewStatus_Response {
        CCommunity_GetUserPartnerEventViewStatus_Response::new()
    }

    fn clear(&mut self) {
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetUserPartnerEventViewStatus_Response {
        static instance: CCommunity_GetUserPartnerEventViewStatus_Response = CCommunity_GetUserPartnerEventViewStatus_Response {
            events: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CCommunity_GetUserPartnerEventViewStatus_Response`
pub mod ccommunity_get_user_partner_event_view_status_response {
    // @@protoc_insertion_point(message:CCommunity_GetUserPartnerEventViewStatus_Response.PartnerEvent)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PartnerEvent {
        // message fields
        // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventViewStatus_Response.PartnerEvent.event_gid)
        pub event_gid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventViewStatus_Response.PartnerEvent.last_shown_time)
        pub last_shown_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventViewStatus_Response.PartnerEvent.last_read_time)
        pub last_read_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventViewStatus_Response.PartnerEvent.clan_account_id)
        pub clan_account_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCommunity_GetUserPartnerEventViewStatus_Response.PartnerEvent.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PartnerEvent {
        fn default() -> &'a PartnerEvent {
            <PartnerEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PartnerEvent {
        pub fn new() -> PartnerEvent {
            ::std::default::Default::default()
        }

        // optional fixed64 event_gid = 1;

        pub fn event_gid(&self) -> u64 {
            self.event_gid.unwrap_or(0)
        }

        pub fn clear_event_gid(&mut self) {
            self.event_gid = ::std::option::Option::None;
        }

        pub fn has_event_gid(&self) -> bool {
            self.event_gid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_gid(&mut self, v: u64) {
            self.event_gid = ::std::option::Option::Some(v);
        }

        // optional uint32 last_shown_time = 2;

        pub fn last_shown_time(&self) -> u32 {
            self.last_shown_time.unwrap_or(0)
        }

        pub fn clear_last_shown_time(&mut self) {
            self.last_shown_time = ::std::option::Option::None;
        }

        pub fn has_last_shown_time(&self) -> bool {
            self.last_shown_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_shown_time(&mut self, v: u32) {
            self.last_shown_time = ::std::option::Option::Some(v);
        }

        // optional uint32 last_read_time = 3;

        pub fn last_read_time(&self) -> u32 {
            self.last_read_time.unwrap_or(0)
        }

        pub fn clear_last_read_time(&mut self) {
            self.last_read_time = ::std::option::Option::None;
        }

        pub fn has_last_read_time(&self) -> bool {
            self.last_read_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_read_time(&mut self, v: u32) {
            self.last_read_time = ::std::option::Option::Some(v);
        }

        // optional uint32 clan_account_id = 4;

        pub fn clan_account_id(&self) -> u32 {
            self.clan_account_id.unwrap_or(0)
        }

        pub fn clear_clan_account_id(&mut self) {
            self.clan_account_id = ::std::option::Option::None;
        }

        pub fn has_clan_account_id(&self) -> bool {
            self.clan_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clan_account_id(&mut self, v: u32) {
            self.clan_account_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PartnerEvent {
        const NAME: &'static str = "PartnerEvent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.event_gid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.last_shown_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.last_read_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.clan_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.event_gid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.last_shown_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.last_read_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.clan_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.event_gid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.last_shown_time {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.last_read_time {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.clan_account_id {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PartnerEvent {
            PartnerEvent::new()
        }

        fn clear(&mut self) {
            self.event_gid = ::std::option::Option::None;
            self.last_shown_time = ::std::option::Option::None;
            self.last_read_time = ::std::option::Option::None;
            self.clan_account_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PartnerEvent {
            static instance: PartnerEvent = PartnerEvent {
                event_gid: ::std::option::Option::None,
                last_shown_time: ::std::option::Option::None,
                last_read_time: ::std::option::Option::None,
                clan_account_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CCommunity_PartnerEventsShowMoreForApp_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_PartnerEventsShowMoreForApp_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_PartnerEventsShowMoreForApp_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_PartnerEventsShowMoreForApp_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_PartnerEventsShowMoreForApp_Request {
    fn default() -> &'a CCommunity_PartnerEventsShowMoreForApp_Request {
        <CCommunity_PartnerEventsShowMoreForApp_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_PartnerEventsShowMoreForApp_Request {
    pub fn new() -> CCommunity_PartnerEventsShowMoreForApp_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_PartnerEventsShowMoreForApp_Request {
    const NAME: &'static str = "CCommunity_PartnerEventsShowMoreForApp_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_PartnerEventsShowMoreForApp_Request {
        CCommunity_PartnerEventsShowMoreForApp_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_PartnerEventsShowMoreForApp_Request {
        static instance: CCommunity_PartnerEventsShowMoreForApp_Request = CCommunity_PartnerEventsShowMoreForApp_Request {
            appid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_PartnerEventsShowMoreForApp_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_PartnerEventsShowMoreForApp_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_PartnerEventsShowMoreForApp_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_PartnerEventsShowMoreForApp_Response {
    fn default() -> &'a CCommunity_PartnerEventsShowMoreForApp_Response {
        <CCommunity_PartnerEventsShowMoreForApp_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_PartnerEventsShowMoreForApp_Response {
    pub fn new() -> CCommunity_PartnerEventsShowMoreForApp_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_PartnerEventsShowMoreForApp_Response {
    const NAME: &'static str = "CCommunity_PartnerEventsShowMoreForApp_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_PartnerEventsShowMoreForApp_Response {
        CCommunity_PartnerEventsShowMoreForApp_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_PartnerEventsShowMoreForApp_Response {
        static instance: CCommunity_PartnerEventsShowMoreForApp_Response = CCommunity_PartnerEventsShowMoreForApp_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_PartnerEventsShowLessForApp_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_PartnerEventsShowLessForApp_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_PartnerEventsShowLessForApp_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_PartnerEventsShowLessForApp_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_PartnerEventsShowLessForApp_Request {
    fn default() -> &'a CCommunity_PartnerEventsShowLessForApp_Request {
        <CCommunity_PartnerEventsShowLessForApp_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_PartnerEventsShowLessForApp_Request {
    pub fn new() -> CCommunity_PartnerEventsShowLessForApp_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_PartnerEventsShowLessForApp_Request {
    const NAME: &'static str = "CCommunity_PartnerEventsShowLessForApp_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_PartnerEventsShowLessForApp_Request {
        CCommunity_PartnerEventsShowLessForApp_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_PartnerEventsShowLessForApp_Request {
        static instance: CCommunity_PartnerEventsShowLessForApp_Request = CCommunity_PartnerEventsShowLessForApp_Request {
            appid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_PartnerEventsShowLessForApp_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_PartnerEventsShowLessForApp_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_PartnerEventsShowLessForApp_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_PartnerEventsShowLessForApp_Response {
    fn default() -> &'a CCommunity_PartnerEventsShowLessForApp_Response {
        <CCommunity_PartnerEventsShowLessForApp_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_PartnerEventsShowLessForApp_Response {
    pub fn new() -> CCommunity_PartnerEventsShowLessForApp_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_PartnerEventsShowLessForApp_Response {
    const NAME: &'static str = "CCommunity_PartnerEventsShowLessForApp_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_PartnerEventsShowLessForApp_Response {
        CCommunity_PartnerEventsShowLessForApp_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_PartnerEventsShowLessForApp_Response {
        static instance: CCommunity_PartnerEventsShowLessForApp_Response = CCommunity_PartnerEventsShowLessForApp_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_ClearUserPartnerEventsAppPriorities_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_ClearUserPartnerEventsAppPriorities_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_ClearUserPartnerEventsAppPriorities_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_ClearUserPartnerEventsAppPriorities_Request {
    fn default() -> &'a CCommunity_ClearUserPartnerEventsAppPriorities_Request {
        <CCommunity_ClearUserPartnerEventsAppPriorities_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_ClearUserPartnerEventsAppPriorities_Request {
    pub fn new() -> CCommunity_ClearUserPartnerEventsAppPriorities_Request {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_ClearUserPartnerEventsAppPriorities_Request {
    const NAME: &'static str = "CCommunity_ClearUserPartnerEventsAppPriorities_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_ClearUserPartnerEventsAppPriorities_Request {
        CCommunity_ClearUserPartnerEventsAppPriorities_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_ClearUserPartnerEventsAppPriorities_Request {
        static instance: CCommunity_ClearUserPartnerEventsAppPriorities_Request = CCommunity_ClearUserPartnerEventsAppPriorities_Request {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_ClearUserPartnerEventsAppPriorities_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_ClearUserPartnerEventsAppPriorities_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_ClearUserPartnerEventsAppPriorities_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_ClearUserPartnerEventsAppPriorities_Response {
    fn default() -> &'a CCommunity_ClearUserPartnerEventsAppPriorities_Response {
        <CCommunity_ClearUserPartnerEventsAppPriorities_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_ClearUserPartnerEventsAppPriorities_Response {
    pub fn new() -> CCommunity_ClearUserPartnerEventsAppPriorities_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_ClearUserPartnerEventsAppPriorities_Response {
    const NAME: &'static str = "CCommunity_ClearUserPartnerEventsAppPriorities_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_ClearUserPartnerEventsAppPriorities_Response {
        CCommunity_ClearUserPartnerEventsAppPriorities_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_ClearUserPartnerEventsAppPriorities_Response {
        static instance: CCommunity_ClearUserPartnerEventsAppPriorities_Response = CCommunity_ClearUserPartnerEventsAppPriorities_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetUserPartnerEventsAppPriorities_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetUserPartnerEventsAppPriorities_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetUserPartnerEventsAppPriorities_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetUserPartnerEventsAppPriorities_Request {
    fn default() -> &'a CCommunity_GetUserPartnerEventsAppPriorities_Request {
        <CCommunity_GetUserPartnerEventsAppPriorities_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetUserPartnerEventsAppPriorities_Request {
    pub fn new() -> CCommunity_GetUserPartnerEventsAppPriorities_Request {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetUserPartnerEventsAppPriorities_Request {
    const NAME: &'static str = "CCommunity_GetUserPartnerEventsAppPriorities_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetUserPartnerEventsAppPriorities_Request {
        CCommunity_GetUserPartnerEventsAppPriorities_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetUserPartnerEventsAppPriorities_Request {
        static instance: CCommunity_GetUserPartnerEventsAppPriorities_Request = CCommunity_GetUserPartnerEventsAppPriorities_Request {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_PartnerEventsAppPriority)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_PartnerEventsAppPriority {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_PartnerEventsAppPriority.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_PartnerEventsAppPriority.user_app_priority)
    pub user_app_priority: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_PartnerEventsAppPriority.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_PartnerEventsAppPriority {
    fn default() -> &'a CCommunity_PartnerEventsAppPriority {
        <CCommunity_PartnerEventsAppPriority as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_PartnerEventsAppPriority {
    pub fn new() -> CCommunity_PartnerEventsAppPriority {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 user_app_priority = 2;

    pub fn user_app_priority(&self) -> i32 {
        self.user_app_priority.unwrap_or(0)
    }

    pub fn clear_user_app_priority(&mut self) {
        self.user_app_priority = ::std::option::Option::None;
    }

    pub fn has_user_app_priority(&self) -> bool {
        self.user_app_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_app_priority(&mut self, v: i32) {
        self.user_app_priority = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_PartnerEventsAppPriority {
    const NAME: &'static str = "CCommunity_PartnerEventsAppPriority";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.user_app_priority = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.user_app_priority {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.user_app_priority {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_PartnerEventsAppPriority {
        CCommunity_PartnerEventsAppPriority::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.user_app_priority = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_PartnerEventsAppPriority {
        static instance: CCommunity_PartnerEventsAppPriority = CCommunity_PartnerEventsAppPriority {
            appid: ::std::option::Option::None,
            user_app_priority: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_GetUserPartnerEventsAppPriorities_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_GetUserPartnerEventsAppPriorities_Response {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_GetUserPartnerEventsAppPriorities_Response.priorities)
    pub priorities: ::std::vec::Vec<CCommunity_PartnerEventsAppPriority>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_GetUserPartnerEventsAppPriorities_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_GetUserPartnerEventsAppPriorities_Response {
    fn default() -> &'a CCommunity_GetUserPartnerEventsAppPriorities_Response {
        <CCommunity_GetUserPartnerEventsAppPriorities_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_GetUserPartnerEventsAppPriorities_Response {
    pub fn new() -> CCommunity_GetUserPartnerEventsAppPriorities_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_GetUserPartnerEventsAppPriorities_Response {
    const NAME: &'static str = "CCommunity_GetUserPartnerEventsAppPriorities_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.priorities.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.priorities {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.priorities {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_GetUserPartnerEventsAppPriorities_Response {
        CCommunity_GetUserPartnerEventsAppPriorities_Response::new()
    }

    fn clear(&mut self) {
        self.priorities.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_GetUserPartnerEventsAppPriorities_Response {
        static instance: CCommunity_GetUserPartnerEventsAppPriorities_Response = CCommunity_GetUserPartnerEventsAppPriorities_Response {
            priorities: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_ClearSinglePartnerEventsAppPriority_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_ClearSinglePartnerEventsAppPriority_Request {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_ClearSinglePartnerEventsAppPriority_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_ClearSinglePartnerEventsAppPriority_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_ClearSinglePartnerEventsAppPriority_Request {
    fn default() -> &'a CCommunity_ClearSinglePartnerEventsAppPriority_Request {
        <CCommunity_ClearSinglePartnerEventsAppPriority_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_ClearSinglePartnerEventsAppPriority_Request {
    pub fn new() -> CCommunity_ClearSinglePartnerEventsAppPriority_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_ClearSinglePartnerEventsAppPriority_Request {
    const NAME: &'static str = "CCommunity_ClearSinglePartnerEventsAppPriority_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_ClearSinglePartnerEventsAppPriority_Request {
        CCommunity_ClearSinglePartnerEventsAppPriority_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_ClearSinglePartnerEventsAppPriority_Request {
        static instance: CCommunity_ClearSinglePartnerEventsAppPriority_Request = CCommunity_ClearSinglePartnerEventsAppPriority_Request {
            appid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCommunity_ClearSinglePartnerEventsAppPriority_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_ClearSinglePartnerEventsAppPriority_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_ClearSinglePartnerEventsAppPriority_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_ClearSinglePartnerEventsAppPriority_Response {
    fn default() -> &'a CCommunity_ClearSinglePartnerEventsAppPriority_Response {
        <CCommunity_ClearSinglePartnerEventsAppPriority_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCommunity_ClearSinglePartnerEventsAppPriority_Response {
    pub fn new() -> CCommunity_ClearSinglePartnerEventsAppPriority_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCommunity_ClearSinglePartnerEventsAppPriority_Response {
    const NAME: &'static str = "CCommunity_ClearSinglePartnerEventsAppPriority_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_ClearSinglePartnerEventsAppPriority_Response {
        CCommunity_ClearSinglePartnerEventsAppPriority_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_ClearSinglePartnerEventsAppPriority_Response {
        static instance: CCommunity_ClearSinglePartnerEventsAppPriority_Response = CCommunity_ClearSinglePartnerEventsAppPriority_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPartnerEventDisplayLocation)
pub enum EPartnerEventDisplayLocation {
    // @@protoc_insertion_point(enum_value:EPartnerEventDisplayLocation.k_EPartnerEventDisplayLocation_Invalid)
    k_EPartnerEventDisplayLocation_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EPartnerEventDisplayLocation.k_EPartnerEventDisplayLocation_AppDetailsSpotlight)
    k_EPartnerEventDisplayLocation_AppDetailsSpotlight = 1,
    // @@protoc_insertion_point(enum_value:EPartnerEventDisplayLocation.k_EPartnerEventDisplayLocation_LibraryOverview)
    k_EPartnerEventDisplayLocation_LibraryOverview = 2,
    // @@protoc_insertion_point(enum_value:EPartnerEventDisplayLocation.k_EPartnerEventDisplayLocation_StoreAppPage)
    k_EPartnerEventDisplayLocation_StoreAppPage = 3,
    // @@protoc_insertion_point(enum_value:EPartnerEventDisplayLocation.k_EPartnerEventDisplayLocation_EventScroller)
    k_EPartnerEventDisplayLocation_EventScroller = 4,
    // @@protoc_insertion_point(enum_value:EPartnerEventDisplayLocation.k_EPartnerEventDisplayLocation_AppDetailsActivity)
    k_EPartnerEventDisplayLocation_AppDetailsActivity = 5,
    // @@protoc_insertion_point(enum_value:EPartnerEventDisplayLocation.k_EPartnerEventDisplayLocation_CommunityHub)
    k_EPartnerEventDisplayLocation_CommunityHub = 6,
    // @@protoc_insertion_point(enum_value:EPartnerEventDisplayLocation.k_EPartnerEventDisplayLocation_StoreFrontPage)
    k_EPartnerEventDisplayLocation_StoreFrontPage = 7,
    // @@protoc_insertion_point(enum_value:EPartnerEventDisplayLocation.k_EPartnerEventDisplayLocation_NewsHub)
    k_EPartnerEventDisplayLocation_NewsHub = 8,
    // @@protoc_insertion_point(enum_value:EPartnerEventDisplayLocation.k_EPartnerEventDisplayLocation_GamepadHome)
    k_EPartnerEventDisplayLocation_GamepadHome = 9,
}

impl ::steam_vent_proto_common::protobuf::Enum for EPartnerEventDisplayLocation {
    const NAME: &'static str = "EPartnerEventDisplayLocation";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPartnerEventDisplayLocation> {
        match value {
            0 => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_Invalid),
            1 => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_AppDetailsSpotlight),
            2 => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_LibraryOverview),
            3 => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_StoreAppPage),
            4 => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_EventScroller),
            5 => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_AppDetailsActivity),
            6 => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_CommunityHub),
            7 => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_StoreFrontPage),
            8 => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_NewsHub),
            9 => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_GamepadHome),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPartnerEventDisplayLocation> {
        match str {
            "k_EPartnerEventDisplayLocation_Invalid" => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_Invalid),
            "k_EPartnerEventDisplayLocation_AppDetailsSpotlight" => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_AppDetailsSpotlight),
            "k_EPartnerEventDisplayLocation_LibraryOverview" => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_LibraryOverview),
            "k_EPartnerEventDisplayLocation_StoreAppPage" => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_StoreAppPage),
            "k_EPartnerEventDisplayLocation_EventScroller" => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_EventScroller),
            "k_EPartnerEventDisplayLocation_AppDetailsActivity" => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_AppDetailsActivity),
            "k_EPartnerEventDisplayLocation_CommunityHub" => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_CommunityHub),
            "k_EPartnerEventDisplayLocation_StoreFrontPage" => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_StoreFrontPage),
            "k_EPartnerEventDisplayLocation_NewsHub" => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_NewsHub),
            "k_EPartnerEventDisplayLocation_GamepadHome" => ::std::option::Option::Some(EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_GamepadHome),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPartnerEventDisplayLocation] = &[
        EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_Invalid,
        EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_AppDetailsSpotlight,
        EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_LibraryOverview,
        EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_StoreAppPage,
        EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_EventScroller,
        EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_AppDetailsActivity,
        EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_CommunityHub,
        EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_StoreFrontPage,
        EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_NewsHub,
        EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_GamepadHome,
    ];
}

impl ::std::default::Default for EPartnerEventDisplayLocation {
    fn default() -> Self {
        EPartnerEventDisplayLocation::k_EPartnerEventDisplayLocation_Invalid
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages_base::*;
#[allow(unused_imports)]
use crate::steammessages_unified_base_steamclient::*;
#[allow(unused_imports)]
use crate::enums::*;
impl ::steam_vent_proto_common::RpcMessage for CCommunity_GetApps_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_GetApps_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_GetAppRichPresenceLocalization_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_GetAppRichPresenceLocalization_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_GetCommentThread_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_Comment {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_GetCommentThread_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_PostCommentToThread_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_PostCommentToThread_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_DeleteCommentFromThread_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_DeleteCommentFromThread_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_RateCommentThread_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_RateCommentThread_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_GetCommentThreadRatings_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_GetCommentThreadRatings_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_RateClanAnnouncement_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_RateClanAnnouncement_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_GetClanAnnouncementVoteForUser_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_GetClanAnnouncementVoteForUser_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_GetAvatarHistory_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_GetAvatarHistory_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CAppPriority {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_GetUserPartnerEventNews_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_GetUserPartnerEventNews_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_GetBestEventsForUser_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_PartnerEventResult {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_GetBestEventsForUser_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_MarkPartnerEventsForUser_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_MarkPartnerEventsForUser_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_GetUserPartnerEventViewStatus_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_GetUserPartnerEventViewStatus_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_PartnerEventsShowMoreForApp_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_PartnerEventsShowMoreForApp_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_PartnerEventsShowLessForApp_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_PartnerEventsShowLessForApp_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_ClearUserPartnerEventsAppPriorities_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_ClearUserPartnerEventsAppPriorities_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_GetUserPartnerEventsAppPriorities_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCommunity_PartnerEventsAppPriority {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_GetUserPartnerEventsAppPriorities_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_ClearSinglePartnerEventsAppPriority_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CCommunity_ClearSinglePartnerEventsAppPriority_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
///
struct Community {}
impl ::steam_vent_proto_common::RpcService for Community {
    const SERVICE_NAME: &'static str = "Community";
}
impl ::steam_vent_proto_common::RpcMethod
for CCommunity_ClearSinglePartnerEventsAppPriority_Request {
    const METHOD_NAME: &'static str = "Community.ClearSinglePartnerEventsAppPriority#1";
    type Response = CCommunity_ClearSinglePartnerEventsAppPriority_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CCommunity_ClearUserPartnerEventsAppPriorities_Request {
    const METHOD_NAME: &'static str = "Community.ClearUserPartnerEventsAppPriorities#1";
    type Response = CCommunity_ClearUserPartnerEventsAppPriorities_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CCommunity_DeleteCommentFromThread_Request {
    const METHOD_NAME: &'static str = "Community.DeleteCommentFromThread#1";
    type Response = CCommunity_DeleteCommentFromThread_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CCommunity_GetAppRichPresenceLocalization_Request {
    const METHOD_NAME: &'static str = "Community.GetAppRichPresenceLocalization#1";
    type Response = CCommunity_GetAppRichPresenceLocalization_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CCommunity_GetApps_Request {
    const METHOD_NAME: &'static str = "Community.GetApps#1";
    type Response = CCommunity_GetApps_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CCommunity_GetAvatarHistory_Request {
    const METHOD_NAME: &'static str = "Community.GetAvatarHistory#1";
    type Response = CCommunity_GetAvatarHistory_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CCommunity_GetBestEventsForUser_Request {
    const METHOD_NAME: &'static str = "Community.GetBestEventsForUser#1";
    type Response = CCommunity_GetBestEventsForUser_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CCommunity_GetClanAnnouncementVoteForUser_Request {
    const METHOD_NAME: &'static str = "Community.GetClanAnnouncementVoteForUser#1";
    type Response = CCommunity_GetClanAnnouncementVoteForUser_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CCommunity_GetCommentThreadRatings_Request {
    const METHOD_NAME: &'static str = "Community.GetCommentThreadRatings#1";
    type Response = CCommunity_GetCommentThreadRatings_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CCommunity_GetCommentThread_Request {
    const METHOD_NAME: &'static str = "Community.GetCommentThread#1";
    type Response = CCommunity_GetCommentThread_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CCommunity_GetUserPartnerEventNews_Request {
    const METHOD_NAME: &'static str = "Community.GetUserPartnerEventNews#1";
    type Response = CCommunity_GetUserPartnerEventNews_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CCommunity_GetUserPartnerEventViewStatus_Request {
    const METHOD_NAME: &'static str = "Community.GetUserPartnerEventViewStatus#1";
    type Response = CCommunity_GetUserPartnerEventViewStatus_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CCommunity_GetUserPartnerEventsAppPriorities_Request {
    const METHOD_NAME: &'static str = "Community.GetUserPartnerEventsAppPriorities#1";
    type Response = CCommunity_GetUserPartnerEventsAppPriorities_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CCommunity_MarkPartnerEventsForUser_Request {
    const METHOD_NAME: &'static str = "Community.MarkPartnerEventsForUser#1";
    type Response = CCommunity_MarkPartnerEventsForUser_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CCommunity_PartnerEventsShowLessForApp_Request {
    const METHOD_NAME: &'static str = "Community.PartnerEventsShowLessForApp#1";
    type Response = CCommunity_PartnerEventsShowLessForApp_Response;
}
impl ::steam_vent_proto_common::RpcMethod
for CCommunity_PartnerEventsShowMoreForApp_Request {
    const METHOD_NAME: &'static str = "Community.PartnerEventsShowMoreForApp#1";
    type Response = CCommunity_PartnerEventsShowMoreForApp_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CCommunity_PostCommentToThread_Request {
    const METHOD_NAME: &'static str = "Community.PostCommentToThread#1";
    type Response = CCommunity_PostCommentToThread_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CCommunity_RateClanAnnouncement_Request {
    const METHOD_NAME: &'static str = "Community.RateClanAnnouncement#1";
    type Response = CCommunity_RateClanAnnouncement_Response;
}
impl ::steam_vent_proto_common::RpcMethod for CCommunity_RateCommentThread_Request {
    const METHOD_NAME: &'static str = "Community.RateCommentThread#1";
    type Response = CCommunity_RateCommentThread_Response;
}
