// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `enums.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPublishedFileQueryType)
pub enum EPublishedFileQueryType {
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByVote)
    k_PublishedFileQueryType_RankedByVote = 0,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByPublicationDate)
    k_PublishedFileQueryType_RankedByPublicationDate = 1,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate)
    k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate = 2,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByTrend)
    k_PublishedFileQueryType_RankedByTrend = 3,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate)
    k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate = 4,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate)
    k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate = 5,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByNumTimesReported)
    k_PublishedFileQueryType_RankedByNumTimesReported = 6,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate)
    k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate = 7,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_NotYetRated)
    k_PublishedFileQueryType_NotYetRated = 8,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions)
    k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions = 9,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByTotalVotesAsc)
    k_PublishedFileQueryType_RankedByTotalVotesAsc = 10,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByVotesUp)
    k_PublishedFileQueryType_RankedByVotesUp = 11,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByTextSearch)
    k_PublishedFileQueryType_RankedByTextSearch = 12,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByPlaytimeTrend)
    k_PublishedFileQueryType_RankedByPlaytimeTrend = 13,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByTotalPlaytime)
    k_PublishedFileQueryType_RankedByTotalPlaytime = 14,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByAveragePlaytimeTrend)
    k_PublishedFileQueryType_RankedByAveragePlaytimeTrend = 15,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime)
    k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime = 16,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend)
    k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend = 17,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions)
    k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions = 18,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByInappropriateContentRating)
    k_PublishedFileQueryType_RankedByInappropriateContentRating = 19,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByBanContentCheck)
    k_PublishedFileQueryType_RankedByBanContentCheck = 20,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByLastUpdatedDate)
    k_PublishedFileQueryType_RankedByLastUpdatedDate = 21,
}

impl ::steam_vent_proto_common::protobuf::Enum for EPublishedFileQueryType {
    const NAME: &'static str = "EPublishedFileQueryType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileQueryType> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVote),
            1 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPublicationDate),
            2 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate),
            3 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTrend),
            4 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate),
            5 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate),
            6 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByNumTimesReported),
            7 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate),
            8 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_NotYetRated),
            9 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions),
            10 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalVotesAsc),
            11 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVotesUp),
            12 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTextSearch),
            13 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeTrend),
            14 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalPlaytime),
            15 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByAveragePlaytimeTrend),
            16 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime),
            17 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend),
            18 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions),
            19 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByInappropriateContentRating),
            20 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByBanContentCheck),
            21 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLastUpdatedDate),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPublishedFileQueryType> {
        match str {
            "k_PublishedFileQueryType_RankedByVote" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVote),
            "k_PublishedFileQueryType_RankedByPublicationDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPublicationDate),
            "k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate),
            "k_PublishedFileQueryType_RankedByTrend" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTrend),
            "k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate),
            "k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate),
            "k_PublishedFileQueryType_RankedByNumTimesReported" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByNumTimesReported),
            "k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate),
            "k_PublishedFileQueryType_NotYetRated" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_NotYetRated),
            "k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions),
            "k_PublishedFileQueryType_RankedByTotalVotesAsc" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalVotesAsc),
            "k_PublishedFileQueryType_RankedByVotesUp" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVotesUp),
            "k_PublishedFileQueryType_RankedByTextSearch" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTextSearch),
            "k_PublishedFileQueryType_RankedByPlaytimeTrend" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeTrend),
            "k_PublishedFileQueryType_RankedByTotalPlaytime" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalPlaytime),
            "k_PublishedFileQueryType_RankedByAveragePlaytimeTrend" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByAveragePlaytimeTrend),
            "k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime),
            "k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend),
            "k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions),
            "k_PublishedFileQueryType_RankedByInappropriateContentRating" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByInappropriateContentRating),
            "k_PublishedFileQueryType_RankedByBanContentCheck" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByBanContentCheck),
            "k_PublishedFileQueryType_RankedByLastUpdatedDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLastUpdatedDate),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPublishedFileQueryType] = &[
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVote,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPublicationDate,
        EPublishedFileQueryType::k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTrend,
        EPublishedFileQueryType::k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate,
        EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByNumTimesReported,
        EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate,
        EPublishedFileQueryType::k_PublishedFileQueryType_NotYetRated,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalVotesAsc,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVotesUp,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTextSearch,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeTrend,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalPlaytime,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByAveragePlaytimeTrend,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByInappropriateContentRating,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByBanContentCheck,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLastUpdatedDate,
    ];
}

impl ::std::default::Default for EPublishedFileQueryType {
    fn default() -> Self {
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVote
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPublishedFileInappropriateProvider)
pub enum EPublishedFileInappropriateProvider {
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateProvider.k_EPublishedFileInappropriateProvider_Invalid)
    k_EPublishedFileInappropriateProvider_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateProvider.k_EPublishedFileInappropriateProvider_Google)
    k_EPublishedFileInappropriateProvider_Google = 1,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateProvider.k_EPublishedFileInappropriateProvider_Amazon)
    k_EPublishedFileInappropriateProvider_Amazon = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EPublishedFileInappropriateProvider {
    const NAME: &'static str = "EPublishedFileInappropriateProvider";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileInappropriateProvider> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Invalid),
            1 => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Google),
            2 => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Amazon),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPublishedFileInappropriateProvider> {
        match str {
            "k_EPublishedFileInappropriateProvider_Invalid" => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Invalid),
            "k_EPublishedFileInappropriateProvider_Google" => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Google),
            "k_EPublishedFileInappropriateProvider_Amazon" => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Amazon),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPublishedFileInappropriateProvider] = &[
        EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Invalid,
        EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Google,
        EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Amazon,
    ];
}

impl ::std::default::Default for EPublishedFileInappropriateProvider {
    fn default() -> Self {
        EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPublishedFileInappropriateResult)
pub enum EPublishedFileInappropriateResult {
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_NotScanned)
    k_EPublishedFileInappropriateResult_NotScanned = 0,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_VeryUnlikely)
    k_EPublishedFileInappropriateResult_VeryUnlikely = 1,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_Unlikely)
    k_EPublishedFileInappropriateResult_Unlikely = 30,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_Possible)
    k_EPublishedFileInappropriateResult_Possible = 50,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_Likely)
    k_EPublishedFileInappropriateResult_Likely = 75,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_VeryLikely)
    k_EPublishedFileInappropriateResult_VeryLikely = 100,
}

impl ::steam_vent_proto_common::protobuf::Enum for EPublishedFileInappropriateResult {
    const NAME: &'static str = "EPublishedFileInappropriateResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileInappropriateResult> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned),
            1 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryUnlikely),
            30 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Unlikely),
            50 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Possible),
            75 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Likely),
            100 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryLikely),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPublishedFileInappropriateResult> {
        match str {
            "k_EPublishedFileInappropriateResult_NotScanned" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned),
            "k_EPublishedFileInappropriateResult_VeryUnlikely" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryUnlikely),
            "k_EPublishedFileInappropriateResult_Unlikely" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Unlikely),
            "k_EPublishedFileInappropriateResult_Possible" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Possible),
            "k_EPublishedFileInappropriateResult_Likely" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Likely),
            "k_EPublishedFileInappropriateResult_VeryLikely" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryLikely),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPublishedFileInappropriateResult] = &[
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned,
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryUnlikely,
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Unlikely,
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Possible,
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Likely,
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryLikely,
    ];
}

impl ::std::default::Default for EPublishedFileInappropriateResult {
    fn default() -> Self {
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPersonaStateFlag)
pub enum EPersonaStateFlag {
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_HasRichPresence)
    k_EPersonaStateFlag_HasRichPresence = 1,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_InJoinableGame)
    k_EPersonaStateFlag_InJoinableGame = 2,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_Golden)
    k_EPersonaStateFlag_Golden = 4,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_RemotePlayTogether)
    k_EPersonaStateFlag_RemotePlayTogether = 8,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_ClientTypeWeb)
    k_EPersonaStateFlag_ClientTypeWeb = 256,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_ClientTypeMobile)
    k_EPersonaStateFlag_ClientTypeMobile = 512,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_ClientTypeTenfoot)
    k_EPersonaStateFlag_ClientTypeTenfoot = 1024,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_ClientTypeVR)
    k_EPersonaStateFlag_ClientTypeVR = 2048,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_LaunchTypeGamepad)
    k_EPersonaStateFlag_LaunchTypeGamepad = 4096,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_LaunchTypeCompatTool)
    k_EPersonaStateFlag_LaunchTypeCompatTool = 8192,
}

impl ::steam_vent_proto_common::protobuf::Enum for EPersonaStateFlag {
    const NAME: &'static str = "EPersonaStateFlag";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPersonaStateFlag> {
        match value {
            1 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence),
            2 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_InJoinableGame),
            4 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_Golden),
            8 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_RemotePlayTogether),
            256 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeWeb),
            512 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeMobile),
            1024 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeTenfoot),
            2048 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeVR),
            4096 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeGamepad),
            8192 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeCompatTool),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPersonaStateFlag> {
        match str {
            "k_EPersonaStateFlag_HasRichPresence" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence),
            "k_EPersonaStateFlag_InJoinableGame" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_InJoinableGame),
            "k_EPersonaStateFlag_Golden" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_Golden),
            "k_EPersonaStateFlag_RemotePlayTogether" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_RemotePlayTogether),
            "k_EPersonaStateFlag_ClientTypeWeb" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeWeb),
            "k_EPersonaStateFlag_ClientTypeMobile" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeMobile),
            "k_EPersonaStateFlag_ClientTypeTenfoot" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeTenfoot),
            "k_EPersonaStateFlag_ClientTypeVR" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeVR),
            "k_EPersonaStateFlag_LaunchTypeGamepad" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeGamepad),
            "k_EPersonaStateFlag_LaunchTypeCompatTool" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeCompatTool),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPersonaStateFlag] = &[
        EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence,
        EPersonaStateFlag::k_EPersonaStateFlag_InJoinableGame,
        EPersonaStateFlag::k_EPersonaStateFlag_Golden,
        EPersonaStateFlag::k_EPersonaStateFlag_RemotePlayTogether,
        EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeWeb,
        EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeMobile,
        EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeTenfoot,
        EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeVR,
        EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeGamepad,
        EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeCompatTool,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EPersonaStateFlag {
    fn default() -> Self {
        EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EContentCheckProvider)
pub enum EContentCheckProvider {
    // @@protoc_insertion_point(enum_value:EContentCheckProvider.k_EContentCheckProvider_Invalid)
    k_EContentCheckProvider_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EContentCheckProvider.k_EContentCheckProvider_Google_DEPRECATED)
    k_EContentCheckProvider_Google_DEPRECATED = 1,
    // @@protoc_insertion_point(enum_value:EContentCheckProvider.k_EContentCheckProvider_Amazon)
    k_EContentCheckProvider_Amazon = 2,
    // @@protoc_insertion_point(enum_value:EContentCheckProvider.k_EContentCheckProvider_Local)
    k_EContentCheckProvider_Local = 3,
    // @@protoc_insertion_point(enum_value:EContentCheckProvider.k_EContentCheckProvider_GoogleVertexAI)
    k_EContentCheckProvider_GoogleVertexAI = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for EContentCheckProvider {
    const NAME: &'static str = "EContentCheckProvider";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EContentCheckProvider> {
        match value {
            0 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Invalid),
            1 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Google_DEPRECATED),
            2 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Amazon),
            3 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Local),
            4 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_GoogleVertexAI),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EContentCheckProvider> {
        match str {
            "k_EContentCheckProvider_Invalid" => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Invalid),
            "k_EContentCheckProvider_Google_DEPRECATED" => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Google_DEPRECATED),
            "k_EContentCheckProvider_Amazon" => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Amazon),
            "k_EContentCheckProvider_Local" => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Local),
            "k_EContentCheckProvider_GoogleVertexAI" => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_GoogleVertexAI),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EContentCheckProvider] = &[
        EContentCheckProvider::k_EContentCheckProvider_Invalid,
        EContentCheckProvider::k_EContentCheckProvider_Google_DEPRECATED,
        EContentCheckProvider::k_EContentCheckProvider_Amazon,
        EContentCheckProvider::k_EContentCheckProvider_Local,
        EContentCheckProvider::k_EContentCheckProvider_GoogleVertexAI,
    ];
}

impl ::std::default::Default for EContentCheckProvider {
    fn default() -> Self {
        EContentCheckProvider::k_EContentCheckProvider_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EProfileCustomizationType)
pub enum EProfileCustomizationType {
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeInvalid)
    k_EProfileCustomizationTypeInvalid = 0,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeRareAchievementShowcase)
    k_EProfileCustomizationTypeRareAchievementShowcase = 1,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeGameCollector)
    k_EProfileCustomizationTypeGameCollector = 2,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeItemShowcase)
    k_EProfileCustomizationTypeItemShowcase = 3,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeTradeShowcase)
    k_EProfileCustomizationTypeTradeShowcase = 4,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeBadges)
    k_EProfileCustomizationTypeBadges = 5,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeFavoriteGame)
    k_EProfileCustomizationTypeFavoriteGame = 6,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeScreenshotShowcase)
    k_EProfileCustomizationTypeScreenshotShowcase = 7,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeCustomText)
    k_EProfileCustomizationTypeCustomText = 8,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeFavoriteGroup)
    k_EProfileCustomizationTypeFavoriteGroup = 9,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeRecommendation)
    k_EProfileCustomizationTypeRecommendation = 10,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeWorkshopItem)
    k_EProfileCustomizationTypeWorkshopItem = 11,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeMyWorkshop)
    k_EProfileCustomizationTypeMyWorkshop = 12,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeArtworkShowcase)
    k_EProfileCustomizationTypeArtworkShowcase = 13,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeVideoShowcase)
    k_EProfileCustomizationTypeVideoShowcase = 14,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeGuides)
    k_EProfileCustomizationTypeGuides = 15,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeMyGuides)
    k_EProfileCustomizationTypeMyGuides = 16,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeAchievements)
    k_EProfileCustomizationTypeAchievements = 17,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeGreenlight)
    k_EProfileCustomizationTypeGreenlight = 18,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeMyGreenlight)
    k_EProfileCustomizationTypeMyGreenlight = 19,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeSalien)
    k_EProfileCustomizationTypeSalien = 20,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeLoyaltyRewardReactions)
    k_EProfileCustomizationTypeLoyaltyRewardReactions = 21,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeSingleArtworkShowcase)
    k_EProfileCustomizationTypeSingleArtworkShowcase = 22,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeAchievementsCompletionist)
    k_EProfileCustomizationTypeAchievementsCompletionist = 23,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeReplay)
    k_EProfileCustomizationTypeReplay = 24,
}

impl ::steam_vent_proto_common::protobuf::Enum for EProfileCustomizationType {
    const NAME: &'static str = "EProfileCustomizationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProfileCustomizationType> {
        match value {
            0 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeInvalid),
            1 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeRareAchievementShowcase),
            2 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGameCollector),
            3 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeItemShowcase),
            4 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeTradeShowcase),
            5 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeBadges),
            6 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGame),
            7 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeScreenshotShowcase),
            8 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeCustomText),
            9 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGroup),
            10 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeRecommendation),
            11 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeWorkshopItem),
            12 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyWorkshop),
            13 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeArtworkShowcase),
            14 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeVideoShowcase),
            15 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGuides),
            16 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyGuides),
            17 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeAchievements),
            18 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGreenlight),
            19 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyGreenlight),
            20 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeSalien),
            21 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeLoyaltyRewardReactions),
            22 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeSingleArtworkShowcase),
            23 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeAchievementsCompletionist),
            24 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeReplay),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EProfileCustomizationType> {
        match str {
            "k_EProfileCustomizationTypeInvalid" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeInvalid),
            "k_EProfileCustomizationTypeRareAchievementShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeRareAchievementShowcase),
            "k_EProfileCustomizationTypeGameCollector" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGameCollector),
            "k_EProfileCustomizationTypeItemShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeItemShowcase),
            "k_EProfileCustomizationTypeTradeShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeTradeShowcase),
            "k_EProfileCustomizationTypeBadges" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeBadges),
            "k_EProfileCustomizationTypeFavoriteGame" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGame),
            "k_EProfileCustomizationTypeScreenshotShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeScreenshotShowcase),
            "k_EProfileCustomizationTypeCustomText" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeCustomText),
            "k_EProfileCustomizationTypeFavoriteGroup" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGroup),
            "k_EProfileCustomizationTypeRecommendation" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeRecommendation),
            "k_EProfileCustomizationTypeWorkshopItem" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeWorkshopItem),
            "k_EProfileCustomizationTypeMyWorkshop" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyWorkshop),
            "k_EProfileCustomizationTypeArtworkShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeArtworkShowcase),
            "k_EProfileCustomizationTypeVideoShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeVideoShowcase),
            "k_EProfileCustomizationTypeGuides" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGuides),
            "k_EProfileCustomizationTypeMyGuides" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyGuides),
            "k_EProfileCustomizationTypeAchievements" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeAchievements),
            "k_EProfileCustomizationTypeGreenlight" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGreenlight),
            "k_EProfileCustomizationTypeMyGreenlight" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyGreenlight),
            "k_EProfileCustomizationTypeSalien" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeSalien),
            "k_EProfileCustomizationTypeLoyaltyRewardReactions" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeLoyaltyRewardReactions),
            "k_EProfileCustomizationTypeSingleArtworkShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeSingleArtworkShowcase),
            "k_EProfileCustomizationTypeAchievementsCompletionist" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeAchievementsCompletionist),
            "k_EProfileCustomizationTypeReplay" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeReplay),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EProfileCustomizationType] = &[
        EProfileCustomizationType::k_EProfileCustomizationTypeInvalid,
        EProfileCustomizationType::k_EProfileCustomizationTypeRareAchievementShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeGameCollector,
        EProfileCustomizationType::k_EProfileCustomizationTypeItemShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeTradeShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeBadges,
        EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGame,
        EProfileCustomizationType::k_EProfileCustomizationTypeScreenshotShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeCustomText,
        EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGroup,
        EProfileCustomizationType::k_EProfileCustomizationTypeRecommendation,
        EProfileCustomizationType::k_EProfileCustomizationTypeWorkshopItem,
        EProfileCustomizationType::k_EProfileCustomizationTypeMyWorkshop,
        EProfileCustomizationType::k_EProfileCustomizationTypeArtworkShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeVideoShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeGuides,
        EProfileCustomizationType::k_EProfileCustomizationTypeMyGuides,
        EProfileCustomizationType::k_EProfileCustomizationTypeAchievements,
        EProfileCustomizationType::k_EProfileCustomizationTypeGreenlight,
        EProfileCustomizationType::k_EProfileCustomizationTypeMyGreenlight,
        EProfileCustomizationType::k_EProfileCustomizationTypeSalien,
        EProfileCustomizationType::k_EProfileCustomizationTypeLoyaltyRewardReactions,
        EProfileCustomizationType::k_EProfileCustomizationTypeSingleArtworkShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeAchievementsCompletionist,
        EProfileCustomizationType::k_EProfileCustomizationTypeReplay,
    ];
}

impl ::std::default::Default for EProfileCustomizationType {
    fn default() -> Self {
        EProfileCustomizationType::k_EProfileCustomizationTypeInvalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPublishedFileStorageSystem)
pub enum EPublishedFileStorageSystem {
    // @@protoc_insertion_point(enum_value:EPublishedFileStorageSystem.k_EPublishedFileStorageSystemInvalid)
    k_EPublishedFileStorageSystemInvalid = 0,
    // @@protoc_insertion_point(enum_value:EPublishedFileStorageSystem.k_EPublishedFileStorageSystemLegacyCloud)
    k_EPublishedFileStorageSystemLegacyCloud = 1,
    // @@protoc_insertion_point(enum_value:EPublishedFileStorageSystem.k_EPublishedFileStorageSystemDepot)
    k_EPublishedFileStorageSystemDepot = 2,
    // @@protoc_insertion_point(enum_value:EPublishedFileStorageSystem.k_EPublishedFileStorageSystemUGCCloud)
    k_EPublishedFileStorageSystemUGCCloud = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for EPublishedFileStorageSystem {
    const NAME: &'static str = "EPublishedFileStorageSystem";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileStorageSystem> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemInvalid),
            1 => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemLegacyCloud),
            2 => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemDepot),
            3 => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemUGCCloud),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPublishedFileStorageSystem> {
        match str {
            "k_EPublishedFileStorageSystemInvalid" => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemInvalid),
            "k_EPublishedFileStorageSystemLegacyCloud" => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemLegacyCloud),
            "k_EPublishedFileStorageSystemDepot" => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemDepot),
            "k_EPublishedFileStorageSystemUGCCloud" => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemUGCCloud),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPublishedFileStorageSystem] = &[
        EPublishedFileStorageSystem::k_EPublishedFileStorageSystemInvalid,
        EPublishedFileStorageSystem::k_EPublishedFileStorageSystemLegacyCloud,
        EPublishedFileStorageSystem::k_EPublishedFileStorageSystemDepot,
        EPublishedFileStorageSystem::k_EPublishedFileStorageSystemUGCCloud,
    ];
}

impl ::std::default::Default for EPublishedFileStorageSystem {
    fn default() -> Self {
        EPublishedFileStorageSystem::k_EPublishedFileStorageSystemInvalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECloudStoragePersistState)
pub enum ECloudStoragePersistState {
    // @@protoc_insertion_point(enum_value:ECloudStoragePersistState.k_ECloudStoragePersistStatePersisted)
    k_ECloudStoragePersistStatePersisted = 0,
    // @@protoc_insertion_point(enum_value:ECloudStoragePersistState.k_ECloudStoragePersistStateForgotten)
    k_ECloudStoragePersistStateForgotten = 1,
    // @@protoc_insertion_point(enum_value:ECloudStoragePersistState.k_ECloudStoragePersistStateDeleted)
    k_ECloudStoragePersistStateDeleted = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for ECloudStoragePersistState {
    const NAME: &'static str = "ECloudStoragePersistState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECloudStoragePersistState> {
        match value {
            0 => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStatePersisted),
            1 => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStateForgotten),
            2 => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStateDeleted),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECloudStoragePersistState> {
        match str {
            "k_ECloudStoragePersistStatePersisted" => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStatePersisted),
            "k_ECloudStoragePersistStateForgotten" => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStateForgotten),
            "k_ECloudStoragePersistStateDeleted" => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStateDeleted),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECloudStoragePersistState] = &[
        ECloudStoragePersistState::k_ECloudStoragePersistStatePersisted,
        ECloudStoragePersistState::k_ECloudStoragePersistStateForgotten,
        ECloudStoragePersistState::k_ECloudStoragePersistStateDeleted,
    ];
}

impl ::std::default::Default for ECloudStoragePersistState {
    fn default() -> Self {
        ECloudStoragePersistState::k_ECloudStoragePersistStatePersisted
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESDCardFormatStage)
pub enum ESDCardFormatStage {
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Invalid)
    k_ESDCardFormatStage_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Starting)
    k_ESDCardFormatStage_Starting = 1,
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Testing)
    k_ESDCardFormatStage_Testing = 2,
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Rescuing)
    k_ESDCardFormatStage_Rescuing = 3,
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Formatting)
    k_ESDCardFormatStage_Formatting = 4,
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Finalizing)
    k_ESDCardFormatStage_Finalizing = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESDCardFormatStage {
    const NAME: &'static str = "ESDCardFormatStage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESDCardFormatStage> {
        match value {
            0 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Invalid),
            1 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Starting),
            2 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Testing),
            3 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Rescuing),
            4 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Formatting),
            5 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Finalizing),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESDCardFormatStage> {
        match str {
            "k_ESDCardFormatStage_Invalid" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Invalid),
            "k_ESDCardFormatStage_Starting" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Starting),
            "k_ESDCardFormatStage_Testing" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Testing),
            "k_ESDCardFormatStage_Rescuing" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Rescuing),
            "k_ESDCardFormatStage_Formatting" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Formatting),
            "k_ESDCardFormatStage_Finalizing" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Finalizing),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESDCardFormatStage] = &[
        ESDCardFormatStage::k_ESDCardFormatStage_Invalid,
        ESDCardFormatStage::k_ESDCardFormatStage_Starting,
        ESDCardFormatStage::k_ESDCardFormatStage_Testing,
        ESDCardFormatStage::k_ESDCardFormatStage_Rescuing,
        ESDCardFormatStage::k_ESDCardFormatStage_Formatting,
        ESDCardFormatStage::k_ESDCardFormatStage_Finalizing,
    ];
}

impl ::std::default::Default for ESDCardFormatStage {
    fn default() -> Self {
        ESDCardFormatStage::k_ESDCardFormatStage_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStorageFormatStage)
pub enum EStorageFormatStage {
    // @@protoc_insertion_point(enum_value:EStorageFormatStage.k_EStorageFormatStage_Invalid)
    k_EStorageFormatStage_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EStorageFormatStage.k_EStorageFormatStage_NotRunning)
    k_EStorageFormatStage_NotRunning = 1,
    // @@protoc_insertion_point(enum_value:EStorageFormatStage.k_EStorageFormatStage_Starting)
    k_EStorageFormatStage_Starting = 2,
    // @@protoc_insertion_point(enum_value:EStorageFormatStage.k_EStorageFormatStage_Testing)
    k_EStorageFormatStage_Testing = 3,
    // @@protoc_insertion_point(enum_value:EStorageFormatStage.k_EStorageFormatStage_Rescuing)
    k_EStorageFormatStage_Rescuing = 4,
    // @@protoc_insertion_point(enum_value:EStorageFormatStage.k_EStorageFormatStage_Formatting)
    k_EStorageFormatStage_Formatting = 5,
    // @@protoc_insertion_point(enum_value:EStorageFormatStage.k_EStorageFormatStage_Finalizing)
    k_EStorageFormatStage_Finalizing = 6,
}

impl ::steam_vent_proto_common::protobuf::Enum for EStorageFormatStage {
    const NAME: &'static str = "EStorageFormatStage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStorageFormatStage> {
        match value {
            0 => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Invalid),
            1 => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_NotRunning),
            2 => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Starting),
            3 => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Testing),
            4 => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Rescuing),
            5 => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Formatting),
            6 => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Finalizing),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStorageFormatStage> {
        match str {
            "k_EStorageFormatStage_Invalid" => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Invalid),
            "k_EStorageFormatStage_NotRunning" => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_NotRunning),
            "k_EStorageFormatStage_Starting" => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Starting),
            "k_EStorageFormatStage_Testing" => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Testing),
            "k_EStorageFormatStage_Rescuing" => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Rescuing),
            "k_EStorageFormatStage_Formatting" => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Formatting),
            "k_EStorageFormatStage_Finalizing" => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Finalizing),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStorageFormatStage] = &[
        EStorageFormatStage::k_EStorageFormatStage_Invalid,
        EStorageFormatStage::k_EStorageFormatStage_NotRunning,
        EStorageFormatStage::k_EStorageFormatStage_Starting,
        EStorageFormatStage::k_EStorageFormatStage_Testing,
        EStorageFormatStage::k_EStorageFormatStage_Rescuing,
        EStorageFormatStage::k_EStorageFormatStage_Formatting,
        EStorageFormatStage::k_EStorageFormatStage_Finalizing,
    ];
}

impl ::std::default::Default for EStorageFormatStage {
    fn default() -> Self {
        EStorageFormatStage::k_EStorageFormatStage_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemFanControlMode)
pub enum ESystemFanControlMode {
    // @@protoc_insertion_point(enum_value:ESystemFanControlMode.k_SystemFanControlMode_Invalid)
    k_SystemFanControlMode_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemFanControlMode.k_SystemFanControlMode_Disabled)
    k_SystemFanControlMode_Disabled = 1,
    // @@protoc_insertion_point(enum_value:ESystemFanControlMode.k_SystemFanControlMode_Default)
    k_SystemFanControlMode_Default = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESystemFanControlMode {
    const NAME: &'static str = "ESystemFanControlMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemFanControlMode> {
        match value {
            0 => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Invalid),
            1 => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Disabled),
            2 => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Default),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemFanControlMode> {
        match str {
            "k_SystemFanControlMode_Invalid" => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Invalid),
            "k_SystemFanControlMode_Disabled" => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Disabled),
            "k_SystemFanControlMode_Default" => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Default),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemFanControlMode] = &[
        ESystemFanControlMode::k_SystemFanControlMode_Invalid,
        ESystemFanControlMode::k_SystemFanControlMode_Disabled,
        ESystemFanControlMode::k_SystemFanControlMode_Default,
    ];
}

impl ::std::default::Default for ESystemFanControlMode {
    fn default() -> Self {
        ESystemFanControlMode::k_SystemFanControlMode_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStartupMovieVariant)
pub enum EStartupMovieVariant {
    // @@protoc_insertion_point(enum_value:EStartupMovieVariant.k_EStartupMovieVariant_Invalid)
    k_EStartupMovieVariant_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EStartupMovieVariant.k_EStartupMovieVariant_Default)
    k_EStartupMovieVariant_Default = 1,
    // @@protoc_insertion_point(enum_value:EStartupMovieVariant.k_EStartupMovieVariant_Orange)
    k_EStartupMovieVariant_Orange = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EStartupMovieVariant {
    const NAME: &'static str = "EStartupMovieVariant";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStartupMovieVariant> {
        match value {
            0 => ::std::option::Option::Some(EStartupMovieVariant::k_EStartupMovieVariant_Invalid),
            1 => ::std::option::Option::Some(EStartupMovieVariant::k_EStartupMovieVariant_Default),
            2 => ::std::option::Option::Some(EStartupMovieVariant::k_EStartupMovieVariant_Orange),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStartupMovieVariant> {
        match str {
            "k_EStartupMovieVariant_Invalid" => ::std::option::Option::Some(EStartupMovieVariant::k_EStartupMovieVariant_Invalid),
            "k_EStartupMovieVariant_Default" => ::std::option::Option::Some(EStartupMovieVariant::k_EStartupMovieVariant_Default),
            "k_EStartupMovieVariant_Orange" => ::std::option::Option::Some(EStartupMovieVariant::k_EStartupMovieVariant_Orange),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStartupMovieVariant] = &[
        EStartupMovieVariant::k_EStartupMovieVariant_Invalid,
        EStartupMovieVariant::k_EStartupMovieVariant_Default,
        EStartupMovieVariant::k_EStartupMovieVariant_Orange,
    ];
}

impl ::std::default::Default for EStartupMovieVariant {
    fn default() -> Self {
        EStartupMovieVariant::k_EStartupMovieVariant_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EColorGamutLabelSet)
pub enum EColorGamutLabelSet {
    // @@protoc_insertion_point(enum_value:EColorGamutLabelSet.k_ColorGamutLabelSet_Default)
    k_ColorGamutLabelSet_Default = 0,
    // @@protoc_insertion_point(enum_value:EColorGamutLabelSet.k_ColorGamutLabelSet_sRGB_Native)
    k_ColorGamutLabelSet_sRGB_Native = 1,
    // @@protoc_insertion_point(enum_value:EColorGamutLabelSet.k_ColorGamutLabelSet_Native_sRGB_Boosted)
    k_ColorGamutLabelSet_Native_sRGB_Boosted = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EColorGamutLabelSet {
    const NAME: &'static str = "EColorGamutLabelSet";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EColorGamutLabelSet> {
        match value {
            0 => ::std::option::Option::Some(EColorGamutLabelSet::k_ColorGamutLabelSet_Default),
            1 => ::std::option::Option::Some(EColorGamutLabelSet::k_ColorGamutLabelSet_sRGB_Native),
            2 => ::std::option::Option::Some(EColorGamutLabelSet::k_ColorGamutLabelSet_Native_sRGB_Boosted),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EColorGamutLabelSet> {
        match str {
            "k_ColorGamutLabelSet_Default" => ::std::option::Option::Some(EColorGamutLabelSet::k_ColorGamutLabelSet_Default),
            "k_ColorGamutLabelSet_sRGB_Native" => ::std::option::Option::Some(EColorGamutLabelSet::k_ColorGamutLabelSet_sRGB_Native),
            "k_ColorGamutLabelSet_Native_sRGB_Boosted" => ::std::option::Option::Some(EColorGamutLabelSet::k_ColorGamutLabelSet_Native_sRGB_Boosted),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EColorGamutLabelSet] = &[
        EColorGamutLabelSet::k_ColorGamutLabelSet_Default,
        EColorGamutLabelSet::k_ColorGamutLabelSet_sRGB_Native,
        EColorGamutLabelSet::k_ColorGamutLabelSet_Native_sRGB_Boosted,
    ];
}

impl ::std::default::Default for EColorGamutLabelSet {
    fn default() -> Self {
        EColorGamutLabelSet::k_ColorGamutLabelSet_Default
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EWindowStackingOrder)
pub enum EWindowStackingOrder {
    // @@protoc_insertion_point(enum_value:EWindowStackingOrder.k_EWindowStackingOrder_Invalid)
    k_EWindowStackingOrder_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EWindowStackingOrder.k_EWindowStackingOrder_Top)
    k_EWindowStackingOrder_Top = 1,
    // @@protoc_insertion_point(enum_value:EWindowStackingOrder.k_EWindowStackingOrder_Bottom)
    k_EWindowStackingOrder_Bottom = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EWindowStackingOrder {
    const NAME: &'static str = "EWindowStackingOrder";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EWindowStackingOrder> {
        match value {
            0 => ::std::option::Option::Some(EWindowStackingOrder::k_EWindowStackingOrder_Invalid),
            1 => ::std::option::Option::Some(EWindowStackingOrder::k_EWindowStackingOrder_Top),
            2 => ::std::option::Option::Some(EWindowStackingOrder::k_EWindowStackingOrder_Bottom),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EWindowStackingOrder> {
        match str {
            "k_EWindowStackingOrder_Invalid" => ::std::option::Option::Some(EWindowStackingOrder::k_EWindowStackingOrder_Invalid),
            "k_EWindowStackingOrder_Top" => ::std::option::Option::Some(EWindowStackingOrder::k_EWindowStackingOrder_Top),
            "k_EWindowStackingOrder_Bottom" => ::std::option::Option::Some(EWindowStackingOrder::k_EWindowStackingOrder_Bottom),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EWindowStackingOrder] = &[
        EWindowStackingOrder::k_EWindowStackingOrder_Invalid,
        EWindowStackingOrder::k_EWindowStackingOrder_Top,
        EWindowStackingOrder::k_EWindowStackingOrder_Bottom,
    ];
}

impl ::std::default::Default for EWindowStackingOrder {
    fn default() -> Self {
        EWindowStackingOrder::k_EWindowStackingOrder_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBluetoothDeviceType)
pub enum EBluetoothDeviceType {
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Invalid)
    k_BluetoothDeviceType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Unknown)
    k_BluetoothDeviceType_Unknown = 1,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Phone)
    k_BluetoothDeviceType_Phone = 2,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Computer)
    k_BluetoothDeviceType_Computer = 3,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Headset)
    k_BluetoothDeviceType_Headset = 4,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Headphones)
    k_BluetoothDeviceType_Headphones = 5,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Speakers)
    k_BluetoothDeviceType_Speakers = 6,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_OtherAudio)
    k_BluetoothDeviceType_OtherAudio = 7,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Mouse)
    k_BluetoothDeviceType_Mouse = 8,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Joystick)
    k_BluetoothDeviceType_Joystick = 9,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Gamepad)
    k_BluetoothDeviceType_Gamepad = 10,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Keyboard)
    k_BluetoothDeviceType_Keyboard = 11,
}

impl ::steam_vent_proto_common::protobuf::Enum for EBluetoothDeviceType {
    const NAME: &'static str = "EBluetoothDeviceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBluetoothDeviceType> {
        match value {
            0 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Invalid),
            1 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Unknown),
            2 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Phone),
            3 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Computer),
            4 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Headset),
            5 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Headphones),
            6 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Speakers),
            7 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_OtherAudio),
            8 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Mouse),
            9 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Joystick),
            10 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Gamepad),
            11 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Keyboard),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBluetoothDeviceType> {
        match str {
            "k_BluetoothDeviceType_Invalid" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Invalid),
            "k_BluetoothDeviceType_Unknown" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Unknown),
            "k_BluetoothDeviceType_Phone" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Phone),
            "k_BluetoothDeviceType_Computer" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Computer),
            "k_BluetoothDeviceType_Headset" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Headset),
            "k_BluetoothDeviceType_Headphones" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Headphones),
            "k_BluetoothDeviceType_Speakers" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Speakers),
            "k_BluetoothDeviceType_OtherAudio" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_OtherAudio),
            "k_BluetoothDeviceType_Mouse" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Mouse),
            "k_BluetoothDeviceType_Joystick" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Joystick),
            "k_BluetoothDeviceType_Gamepad" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Gamepad),
            "k_BluetoothDeviceType_Keyboard" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Keyboard),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBluetoothDeviceType] = &[
        EBluetoothDeviceType::k_BluetoothDeviceType_Invalid,
        EBluetoothDeviceType::k_BluetoothDeviceType_Unknown,
        EBluetoothDeviceType::k_BluetoothDeviceType_Phone,
        EBluetoothDeviceType::k_BluetoothDeviceType_Computer,
        EBluetoothDeviceType::k_BluetoothDeviceType_Headset,
        EBluetoothDeviceType::k_BluetoothDeviceType_Headphones,
        EBluetoothDeviceType::k_BluetoothDeviceType_Speakers,
        EBluetoothDeviceType::k_BluetoothDeviceType_OtherAudio,
        EBluetoothDeviceType::k_BluetoothDeviceType_Mouse,
        EBluetoothDeviceType::k_BluetoothDeviceType_Joystick,
        EBluetoothDeviceType::k_BluetoothDeviceType_Gamepad,
        EBluetoothDeviceType::k_BluetoothDeviceType_Keyboard,
    ];
}

impl ::std::default::Default for EBluetoothDeviceType {
    fn default() -> Self {
        EBluetoothDeviceType::k_BluetoothDeviceType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemAudioDirection)
pub enum ESystemAudioDirection {
    // @@protoc_insertion_point(enum_value:ESystemAudioDirection.k_SystemAudioDirection_Invalid)
    k_SystemAudioDirection_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemAudioDirection.k_SystemAudioDirection_Input)
    k_SystemAudioDirection_Input = 1,
    // @@protoc_insertion_point(enum_value:ESystemAudioDirection.k_SystemAudioDirection_Output)
    k_SystemAudioDirection_Output = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESystemAudioDirection {
    const NAME: &'static str = "ESystemAudioDirection";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemAudioDirection> {
        match value {
            0 => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Invalid),
            1 => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Input),
            2 => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Output),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemAudioDirection> {
        match str {
            "k_SystemAudioDirection_Invalid" => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Invalid),
            "k_SystemAudioDirection_Input" => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Input),
            "k_SystemAudioDirection_Output" => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Output),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemAudioDirection] = &[
        ESystemAudioDirection::k_SystemAudioDirection_Invalid,
        ESystemAudioDirection::k_SystemAudioDirection_Input,
        ESystemAudioDirection::k_SystemAudioDirection_Output,
    ];
}

impl ::std::default::Default for ESystemAudioDirection {
    fn default() -> Self {
        ESystemAudioDirection::k_SystemAudioDirection_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemAudioChannel)
pub enum ESystemAudioChannel {
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_Invalid)
    k_SystemAudioChannel_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_Aggregated)
    k_SystemAudioChannel_Aggregated = 1,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_FrontLeft)
    k_SystemAudioChannel_FrontLeft = 2,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_FrontRight)
    k_SystemAudioChannel_FrontRight = 3,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_LFE)
    k_SystemAudioChannel_LFE = 4,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_BackLeft)
    k_SystemAudioChannel_BackLeft = 5,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_BackRight)
    k_SystemAudioChannel_BackRight = 6,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_FrontCenter)
    k_SystemAudioChannel_FrontCenter = 7,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_Unknown)
    k_SystemAudioChannel_Unknown = 8,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_Mono)
    k_SystemAudioChannel_Mono = 9,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESystemAudioChannel {
    const NAME: &'static str = "ESystemAudioChannel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemAudioChannel> {
        match value {
            0 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Invalid),
            1 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Aggregated),
            2 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontLeft),
            3 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontRight),
            4 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_LFE),
            5 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_BackLeft),
            6 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_BackRight),
            7 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontCenter),
            8 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Unknown),
            9 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Mono),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemAudioChannel> {
        match str {
            "k_SystemAudioChannel_Invalid" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Invalid),
            "k_SystemAudioChannel_Aggregated" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Aggregated),
            "k_SystemAudioChannel_FrontLeft" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontLeft),
            "k_SystemAudioChannel_FrontRight" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontRight),
            "k_SystemAudioChannel_LFE" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_LFE),
            "k_SystemAudioChannel_BackLeft" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_BackLeft),
            "k_SystemAudioChannel_BackRight" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_BackRight),
            "k_SystemAudioChannel_FrontCenter" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontCenter),
            "k_SystemAudioChannel_Unknown" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Unknown),
            "k_SystemAudioChannel_Mono" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Mono),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemAudioChannel] = &[
        ESystemAudioChannel::k_SystemAudioChannel_Invalid,
        ESystemAudioChannel::k_SystemAudioChannel_Aggregated,
        ESystemAudioChannel::k_SystemAudioChannel_FrontLeft,
        ESystemAudioChannel::k_SystemAudioChannel_FrontRight,
        ESystemAudioChannel::k_SystemAudioChannel_LFE,
        ESystemAudioChannel::k_SystemAudioChannel_BackLeft,
        ESystemAudioChannel::k_SystemAudioChannel_BackRight,
        ESystemAudioChannel::k_SystemAudioChannel_FrontCenter,
        ESystemAudioChannel::k_SystemAudioChannel_Unknown,
        ESystemAudioChannel::k_SystemAudioChannel_Mono,
    ];
}

impl ::std::default::Default for ESystemAudioChannel {
    fn default() -> Self {
        ESystemAudioChannel::k_SystemAudioChannel_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemAudioPortType)
pub enum ESystemAudioPortType {
    // @@protoc_insertion_point(enum_value:ESystemAudioPortType.k_SystemAudioPortType_Invalid)
    k_SystemAudioPortType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortType.k_SystemAudioPortType_Unknown)
    k_SystemAudioPortType_Unknown = 1,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortType.k_SystemAudioPortType_Audio32f)
    k_SystemAudioPortType_Audio32f = 2,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortType.k_SystemAudioPortType_Midi8b)
    k_SystemAudioPortType_Midi8b = 3,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortType.k_SystemAudioPortType_Video32RGBA)
    k_SystemAudioPortType_Video32RGBA = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESystemAudioPortType {
    const NAME: &'static str = "ESystemAudioPortType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemAudioPortType> {
        match value {
            0 => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Invalid),
            1 => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Unknown),
            2 => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Audio32f),
            3 => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Midi8b),
            4 => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Video32RGBA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemAudioPortType> {
        match str {
            "k_SystemAudioPortType_Invalid" => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Invalid),
            "k_SystemAudioPortType_Unknown" => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Unknown),
            "k_SystemAudioPortType_Audio32f" => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Audio32f),
            "k_SystemAudioPortType_Midi8b" => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Midi8b),
            "k_SystemAudioPortType_Video32RGBA" => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Video32RGBA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemAudioPortType] = &[
        ESystemAudioPortType::k_SystemAudioPortType_Invalid,
        ESystemAudioPortType::k_SystemAudioPortType_Unknown,
        ESystemAudioPortType::k_SystemAudioPortType_Audio32f,
        ESystemAudioPortType::k_SystemAudioPortType_Midi8b,
        ESystemAudioPortType::k_SystemAudioPortType_Video32RGBA,
    ];
}

impl ::std::default::Default for ESystemAudioPortType {
    fn default() -> Self {
        ESystemAudioPortType::k_SystemAudioPortType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemAudioPortDirection)
pub enum ESystemAudioPortDirection {
    // @@protoc_insertion_point(enum_value:ESystemAudioPortDirection.k_SystemAudioPortDirection_Invalid)
    k_SystemAudioPortDirection_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortDirection.k_SystemAudioPortDirection_Input)
    k_SystemAudioPortDirection_Input = 1,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortDirection.k_SystemAudioPortDirection_Output)
    k_SystemAudioPortDirection_Output = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESystemAudioPortDirection {
    const NAME: &'static str = "ESystemAudioPortDirection";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemAudioPortDirection> {
        match value {
            0 => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Invalid),
            1 => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Input),
            2 => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Output),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemAudioPortDirection> {
        match str {
            "k_SystemAudioPortDirection_Invalid" => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Invalid),
            "k_SystemAudioPortDirection_Input" => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Input),
            "k_SystemAudioPortDirection_Output" => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Output),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemAudioPortDirection] = &[
        ESystemAudioPortDirection::k_SystemAudioPortDirection_Invalid,
        ESystemAudioPortDirection::k_SystemAudioPortDirection_Input,
        ESystemAudioPortDirection::k_SystemAudioPortDirection_Output,
    ];
}

impl ::std::default::Default for ESystemAudioPortDirection {
    fn default() -> Self {
        ESystemAudioPortDirection::k_SystemAudioPortDirection_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemServiceState)
pub enum ESystemServiceState {
    // @@protoc_insertion_point(enum_value:ESystemServiceState.k_ESystemServiceState_Unavailable)
    k_ESystemServiceState_Unavailable = 0,
    // @@protoc_insertion_point(enum_value:ESystemServiceState.k_ESystemServiceState_Disabled)
    k_ESystemServiceState_Disabled = 1,
    // @@protoc_insertion_point(enum_value:ESystemServiceState.k_ESystemServiceState_Enabled)
    k_ESystemServiceState_Enabled = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESystemServiceState {
    const NAME: &'static str = "ESystemServiceState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemServiceState> {
        match value {
            0 => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Unavailable),
            1 => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Disabled),
            2 => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Enabled),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemServiceState> {
        match str {
            "k_ESystemServiceState_Unavailable" => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Unavailable),
            "k_ESystemServiceState_Disabled" => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Disabled),
            "k_ESystemServiceState_Enabled" => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Enabled),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemServiceState] = &[
        ESystemServiceState::k_ESystemServiceState_Unavailable,
        ESystemServiceState::k_ESystemServiceState_Disabled,
        ESystemServiceState::k_ESystemServiceState_Enabled,
    ];
}

impl ::std::default::Default for ESystemServiceState {
    fn default() -> Self {
        ESystemServiceState::k_ESystemServiceState_Unavailable
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGraphicsPerfOverlayLevel)
pub enum EGraphicsPerfOverlayLevel {
    // @@protoc_insertion_point(enum_value:EGraphicsPerfOverlayLevel.k_EGraphicsPerfOverlayLevel_Hidden)
    k_EGraphicsPerfOverlayLevel_Hidden = 0,
    // @@protoc_insertion_point(enum_value:EGraphicsPerfOverlayLevel.k_EGraphicsPerfOverlayLevel_Basic)
    k_EGraphicsPerfOverlayLevel_Basic = 1,
    // @@protoc_insertion_point(enum_value:EGraphicsPerfOverlayLevel.k_EGraphicsPerfOverlayLevel_Medium)
    k_EGraphicsPerfOverlayLevel_Medium = 2,
    // @@protoc_insertion_point(enum_value:EGraphicsPerfOverlayLevel.k_EGraphicsPerfOverlayLevel_Full)
    k_EGraphicsPerfOverlayLevel_Full = 3,
    // @@protoc_insertion_point(enum_value:EGraphicsPerfOverlayLevel.k_EGraphicsPerfOverlayLevel_Minimal)
    k_EGraphicsPerfOverlayLevel_Minimal = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for EGraphicsPerfOverlayLevel {
    const NAME: &'static str = "EGraphicsPerfOverlayLevel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGraphicsPerfOverlayLevel> {
        match value {
            0 => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden),
            1 => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Basic),
            2 => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Medium),
            3 => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Full),
            4 => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Minimal),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGraphicsPerfOverlayLevel> {
        match str {
            "k_EGraphicsPerfOverlayLevel_Hidden" => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden),
            "k_EGraphicsPerfOverlayLevel_Basic" => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Basic),
            "k_EGraphicsPerfOverlayLevel_Medium" => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Medium),
            "k_EGraphicsPerfOverlayLevel_Full" => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Full),
            "k_EGraphicsPerfOverlayLevel_Minimal" => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Minimal),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGraphicsPerfOverlayLevel] = &[
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden,
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Basic,
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Medium,
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Full,
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Minimal,
    ];
}

impl ::std::default::Default for EGraphicsPerfOverlayLevel {
    fn default() -> Self {
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGPUPerformanceLevel)
pub enum EGPUPerformanceLevel {
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_Invalid)
    k_EGPUPerformanceLevel_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_Auto)
    k_EGPUPerformanceLevel_Auto = 1,
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_Manual)
    k_EGPUPerformanceLevel_Manual = 2,
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_Low)
    k_EGPUPerformanceLevel_Low = 3,
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_High)
    k_EGPUPerformanceLevel_High = 4,
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_Profiling)
    k_EGPUPerformanceLevel_Profiling = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for EGPUPerformanceLevel {
    const NAME: &'static str = "EGPUPerformanceLevel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGPUPerformanceLevel> {
        match value {
            0 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid),
            1 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Auto),
            2 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Manual),
            3 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Low),
            4 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_High),
            5 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Profiling),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGPUPerformanceLevel> {
        match str {
            "k_EGPUPerformanceLevel_Invalid" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid),
            "k_EGPUPerformanceLevel_Auto" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Auto),
            "k_EGPUPerformanceLevel_Manual" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Manual),
            "k_EGPUPerformanceLevel_Low" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Low),
            "k_EGPUPerformanceLevel_High" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_High),
            "k_EGPUPerformanceLevel_Profiling" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Profiling),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGPUPerformanceLevel] = &[
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid,
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Auto,
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Manual,
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Low,
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_High,
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Profiling,
    ];
}

impl ::std::default::Default for EGPUPerformanceLevel {
    fn default() -> Self {
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EScalingFilter)
pub enum EScalingFilter {
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_Invalid)
    k_EScalingFilter_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_FSR)
    k_EScalingFilter_FSR = 1,
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_Nearest)
    k_EScalingFilter_Nearest = 2,
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_Integer)
    k_EScalingFilter_Integer = 3,
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_Linear)
    k_EScalingFilter_Linear = 4,
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_NIS)
    k_EScalingFilter_NIS = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for EScalingFilter {
    const NAME: &'static str = "EScalingFilter";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EScalingFilter> {
        match value {
            0 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Invalid),
            1 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_FSR),
            2 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Nearest),
            3 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Integer),
            4 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Linear),
            5 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_NIS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EScalingFilter> {
        match str {
            "k_EScalingFilter_Invalid" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Invalid),
            "k_EScalingFilter_FSR" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_FSR),
            "k_EScalingFilter_Nearest" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Nearest),
            "k_EScalingFilter_Integer" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Integer),
            "k_EScalingFilter_Linear" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Linear),
            "k_EScalingFilter_NIS" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_NIS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EScalingFilter] = &[
        EScalingFilter::k_EScalingFilter_Invalid,
        EScalingFilter::k_EScalingFilter_FSR,
        EScalingFilter::k_EScalingFilter_Nearest,
        EScalingFilter::k_EScalingFilter_Integer,
        EScalingFilter::k_EScalingFilter_Linear,
        EScalingFilter::k_EScalingFilter_NIS,
    ];
}

impl ::std::default::Default for EScalingFilter {
    fn default() -> Self {
        EScalingFilter::k_EScalingFilter_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESplitScalingFilter)
pub enum ESplitScalingFilter {
    // @@protoc_insertion_point(enum_value:ESplitScalingFilter.k_ESplitScalingFilter_Invalid)
    k_ESplitScalingFilter_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESplitScalingFilter.k_ESplitScalingFilter_Linear)
    k_ESplitScalingFilter_Linear = 1,
    // @@protoc_insertion_point(enum_value:ESplitScalingFilter.k_ESplitScalingFilter_Nearest)
    k_ESplitScalingFilter_Nearest = 2,
    // @@protoc_insertion_point(enum_value:ESplitScalingFilter.k_ESplitScalingFilter_FSR)
    k_ESplitScalingFilter_FSR = 3,
    // @@protoc_insertion_point(enum_value:ESplitScalingFilter.k_ESplitScalingFilter_NIS)
    k_ESplitScalingFilter_NIS = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESplitScalingFilter {
    const NAME: &'static str = "ESplitScalingFilter";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESplitScalingFilter> {
        match value {
            0 => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_Invalid),
            1 => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_Linear),
            2 => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_Nearest),
            3 => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_FSR),
            4 => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_NIS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESplitScalingFilter> {
        match str {
            "k_ESplitScalingFilter_Invalid" => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_Invalid),
            "k_ESplitScalingFilter_Linear" => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_Linear),
            "k_ESplitScalingFilter_Nearest" => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_Nearest),
            "k_ESplitScalingFilter_FSR" => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_FSR),
            "k_ESplitScalingFilter_NIS" => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_NIS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESplitScalingFilter] = &[
        ESplitScalingFilter::k_ESplitScalingFilter_Invalid,
        ESplitScalingFilter::k_ESplitScalingFilter_Linear,
        ESplitScalingFilter::k_ESplitScalingFilter_Nearest,
        ESplitScalingFilter::k_ESplitScalingFilter_FSR,
        ESplitScalingFilter::k_ESplitScalingFilter_NIS,
    ];
}

impl ::std::default::Default for ESplitScalingFilter {
    fn default() -> Self {
        ESplitScalingFilter::k_ESplitScalingFilter_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESplitScalingScaler)
pub enum ESplitScalingScaler {
    // @@protoc_insertion_point(enum_value:ESplitScalingScaler.k_ESplitScalingScaler_Invalid)
    k_ESplitScalingScaler_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESplitScalingScaler.k_ESplitScalingScaler_Auto)
    k_ESplitScalingScaler_Auto = 1,
    // @@protoc_insertion_point(enum_value:ESplitScalingScaler.k_ESplitScalingScaler_Integer)
    k_ESplitScalingScaler_Integer = 2,
    // @@protoc_insertion_point(enum_value:ESplitScalingScaler.k_ESplitScalingScaler_Fit)
    k_ESplitScalingScaler_Fit = 3,
    // @@protoc_insertion_point(enum_value:ESplitScalingScaler.k_ESplitScalingScaler_Fill)
    k_ESplitScalingScaler_Fill = 4,
    // @@protoc_insertion_point(enum_value:ESplitScalingScaler.k_ESplitScalingScaler_Stretch)
    k_ESplitScalingScaler_Stretch = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESplitScalingScaler {
    const NAME: &'static str = "ESplitScalingScaler";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESplitScalingScaler> {
        match value {
            0 => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Invalid),
            1 => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Auto),
            2 => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Integer),
            3 => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Fit),
            4 => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Fill),
            5 => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Stretch),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESplitScalingScaler> {
        match str {
            "k_ESplitScalingScaler_Invalid" => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Invalid),
            "k_ESplitScalingScaler_Auto" => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Auto),
            "k_ESplitScalingScaler_Integer" => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Integer),
            "k_ESplitScalingScaler_Fit" => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Fit),
            "k_ESplitScalingScaler_Fill" => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Fill),
            "k_ESplitScalingScaler_Stretch" => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Stretch),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESplitScalingScaler] = &[
        ESplitScalingScaler::k_ESplitScalingScaler_Invalid,
        ESplitScalingScaler::k_ESplitScalingScaler_Auto,
        ESplitScalingScaler::k_ESplitScalingScaler_Integer,
        ESplitScalingScaler::k_ESplitScalingScaler_Fit,
        ESplitScalingScaler::k_ESplitScalingScaler_Fill,
        ESplitScalingScaler::k_ESplitScalingScaler_Stretch,
    ];
}

impl ::std::default::Default for ESplitScalingScaler {
    fn default() -> Self {
        ESplitScalingScaler::k_ESplitScalingScaler_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGamescopeBlurMode)
pub enum EGamescopeBlurMode {
    // @@protoc_insertion_point(enum_value:EGamescopeBlurMode.k_EGamescopeBlurMode_Disabled)
    k_EGamescopeBlurMode_Disabled = 0,
    // @@protoc_insertion_point(enum_value:EGamescopeBlurMode.k_EGamescopeBlurMode_IfOccluded)
    k_EGamescopeBlurMode_IfOccluded = 1,
    // @@protoc_insertion_point(enum_value:EGamescopeBlurMode.k_EGamescopeBlurMode_Always)
    k_EGamescopeBlurMode_Always = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EGamescopeBlurMode {
    const NAME: &'static str = "EGamescopeBlurMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGamescopeBlurMode> {
        match value {
            0 => ::std::option::Option::Some(EGamescopeBlurMode::k_EGamescopeBlurMode_Disabled),
            1 => ::std::option::Option::Some(EGamescopeBlurMode::k_EGamescopeBlurMode_IfOccluded),
            2 => ::std::option::Option::Some(EGamescopeBlurMode::k_EGamescopeBlurMode_Always),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGamescopeBlurMode> {
        match str {
            "k_EGamescopeBlurMode_Disabled" => ::std::option::Option::Some(EGamescopeBlurMode::k_EGamescopeBlurMode_Disabled),
            "k_EGamescopeBlurMode_IfOccluded" => ::std::option::Option::Some(EGamescopeBlurMode::k_EGamescopeBlurMode_IfOccluded),
            "k_EGamescopeBlurMode_Always" => ::std::option::Option::Some(EGamescopeBlurMode::k_EGamescopeBlurMode_Always),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGamescopeBlurMode] = &[
        EGamescopeBlurMode::k_EGamescopeBlurMode_Disabled,
        EGamescopeBlurMode::k_EGamescopeBlurMode_IfOccluded,
        EGamescopeBlurMode::k_EGamescopeBlurMode_Always,
    ];
}

impl ::std::default::Default for EGamescopeBlurMode {
    fn default() -> Self {
        EGamescopeBlurMode::k_EGamescopeBlurMode_Disabled
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESLSHelper)
pub enum ESLSHelper {
    // @@protoc_insertion_point(enum_value:ESLSHelper.k_ESLSHelper_Invalid)
    k_ESLSHelper_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESLSHelper.k_ESLSHelper_Minidump)
    k_ESLSHelper_Minidump = 1,
    // @@protoc_insertion_point(enum_value:ESLSHelper.k_ESLSHelper_Kdump)
    k_ESLSHelper_Kdump = 2,
    // @@protoc_insertion_point(enum_value:ESLSHelper.k_ESLSHelper_Journal)
    k_ESLSHelper_Journal = 3,
    // @@protoc_insertion_point(enum_value:ESLSHelper.k_ESLSHelper_Gpu)
    k_ESLSHelper_Gpu = 4,
    // @@protoc_insertion_point(enum_value:ESLSHelper.k_ESLSHelper_SystemInfo)
    k_ESLSHelper_SystemInfo = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESLSHelper {
    const NAME: &'static str = "ESLSHelper";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESLSHelper> {
        match value {
            0 => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Invalid),
            1 => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Minidump),
            2 => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Kdump),
            3 => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Journal),
            4 => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Gpu),
            5 => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_SystemInfo),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESLSHelper> {
        match str {
            "k_ESLSHelper_Invalid" => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Invalid),
            "k_ESLSHelper_Minidump" => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Minidump),
            "k_ESLSHelper_Kdump" => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Kdump),
            "k_ESLSHelper_Journal" => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Journal),
            "k_ESLSHelper_Gpu" => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Gpu),
            "k_ESLSHelper_SystemInfo" => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_SystemInfo),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESLSHelper] = &[
        ESLSHelper::k_ESLSHelper_Invalid,
        ESLSHelper::k_ESLSHelper_Minidump,
        ESLSHelper::k_ESLSHelper_Kdump,
        ESLSHelper::k_ESLSHelper_Journal,
        ESLSHelper::k_ESLSHelper_Gpu,
        ESLSHelper::k_ESLSHelper_SystemInfo,
    ];
}

impl ::std::default::Default for ESLSHelper {
    fn default() -> Self {
        ESLSHelper::k_ESLSHelper_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EHDRVisualization)
pub enum EHDRVisualization {
    // @@protoc_insertion_point(enum_value:EHDRVisualization.k_EHDRVisualization_None)
    k_EHDRVisualization_None = 0,
    // @@protoc_insertion_point(enum_value:EHDRVisualization.k_EHDRVisualization_Heatmap)
    k_EHDRVisualization_Heatmap = 1,
    // @@protoc_insertion_point(enum_value:EHDRVisualization.k_EHDRVisualization_Analysis)
    k_EHDRVisualization_Analysis = 2,
    // @@protoc_insertion_point(enum_value:EHDRVisualization.k_EHDRVisualization_HeatmapExtended)
    k_EHDRVisualization_HeatmapExtended = 3,
    // @@protoc_insertion_point(enum_value:EHDRVisualization.k_EHDRVisualization_HeatmapClassic)
    k_EHDRVisualization_HeatmapClassic = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for EHDRVisualization {
    const NAME: &'static str = "EHDRVisualization";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHDRVisualization> {
        match value {
            0 => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_None),
            1 => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_Heatmap),
            2 => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_Analysis),
            3 => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_HeatmapExtended),
            4 => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_HeatmapClassic),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EHDRVisualization> {
        match str {
            "k_EHDRVisualization_None" => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_None),
            "k_EHDRVisualization_Heatmap" => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_Heatmap),
            "k_EHDRVisualization_Analysis" => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_Analysis),
            "k_EHDRVisualization_HeatmapExtended" => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_HeatmapExtended),
            "k_EHDRVisualization_HeatmapClassic" => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_HeatmapClassic),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EHDRVisualization] = &[
        EHDRVisualization::k_EHDRVisualization_None,
        EHDRVisualization::k_EHDRVisualization_Heatmap,
        EHDRVisualization::k_EHDRVisualization_Analysis,
        EHDRVisualization::k_EHDRVisualization_HeatmapExtended,
        EHDRVisualization::k_EHDRVisualization_HeatmapClassic,
    ];
}

impl ::std::default::Default for EHDRVisualization {
    fn default() -> Self {
        EHDRVisualization::k_EHDRVisualization_None
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EHDRToneMapOperator)
pub enum EHDRToneMapOperator {
    // @@protoc_insertion_point(enum_value:EHDRToneMapOperator.k_EHDRToneMapOperator_Invalid)
    k_EHDRToneMapOperator_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EHDRToneMapOperator.k_EHDRToneMapOperator_Uncharted)
    k_EHDRToneMapOperator_Uncharted = 1,
    // @@protoc_insertion_point(enum_value:EHDRToneMapOperator.k_EHDRToneMapOperator_Reinhard)
    k_EHDRToneMapOperator_Reinhard = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EHDRToneMapOperator {
    const NAME: &'static str = "EHDRToneMapOperator";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHDRToneMapOperator> {
        match value {
            0 => ::std::option::Option::Some(EHDRToneMapOperator::k_EHDRToneMapOperator_Invalid),
            1 => ::std::option::Option::Some(EHDRToneMapOperator::k_EHDRToneMapOperator_Uncharted),
            2 => ::std::option::Option::Some(EHDRToneMapOperator::k_EHDRToneMapOperator_Reinhard),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EHDRToneMapOperator> {
        match str {
            "k_EHDRToneMapOperator_Invalid" => ::std::option::Option::Some(EHDRToneMapOperator::k_EHDRToneMapOperator_Invalid),
            "k_EHDRToneMapOperator_Uncharted" => ::std::option::Option::Some(EHDRToneMapOperator::k_EHDRToneMapOperator_Uncharted),
            "k_EHDRToneMapOperator_Reinhard" => ::std::option::Option::Some(EHDRToneMapOperator::k_EHDRToneMapOperator_Reinhard),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EHDRToneMapOperator] = &[
        EHDRToneMapOperator::k_EHDRToneMapOperator_Invalid,
        EHDRToneMapOperator::k_EHDRToneMapOperator_Uncharted,
        EHDRToneMapOperator::k_EHDRToneMapOperator_Reinhard,
    ];
}

impl ::std::default::Default for EHDRToneMapOperator {
    fn default() -> Self {
        EHDRToneMapOperator::k_EHDRToneMapOperator_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECPUGovernor)
pub enum ECPUGovernor {
    // @@protoc_insertion_point(enum_value:ECPUGovernor.k_ECPUGovernor_Invalid)
    k_ECPUGovernor_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ECPUGovernor.k_ECPUGovernor_Perf)
    k_ECPUGovernor_Perf = 1,
    // @@protoc_insertion_point(enum_value:ECPUGovernor.k_ECPUGovernor_Powersave)
    k_ECPUGovernor_Powersave = 2,
    // @@protoc_insertion_point(enum_value:ECPUGovernor.k_ECPUGovernor_Manual)
    k_ECPUGovernor_Manual = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for ECPUGovernor {
    const NAME: &'static str = "ECPUGovernor";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECPUGovernor> {
        match value {
            0 => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Invalid),
            1 => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Perf),
            2 => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Powersave),
            3 => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Manual),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECPUGovernor> {
        match str {
            "k_ECPUGovernor_Invalid" => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Invalid),
            "k_ECPUGovernor_Perf" => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Perf),
            "k_ECPUGovernor_Powersave" => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Powersave),
            "k_ECPUGovernor_Manual" => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Manual),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECPUGovernor] = &[
        ECPUGovernor::k_ECPUGovernor_Invalid,
        ECPUGovernor::k_ECPUGovernor_Perf,
        ECPUGovernor::k_ECPUGovernor_Powersave,
        ECPUGovernor::k_ECPUGovernor_Manual,
    ];
}

impl ::std::default::Default for ECPUGovernor {
    fn default() -> Self {
        ECPUGovernor::k_ECPUGovernor_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EUpdaterType)
pub enum EUpdaterType {
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Invalid)
    k_EUpdaterType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Client)
    k_EUpdaterType_Client = 1,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_OS)
    k_EUpdaterType_OS = 2,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_BIOS)
    k_EUpdaterType_BIOS = 3,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Aggregated)
    k_EUpdaterType_Aggregated = 4,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Test1)
    k_EUpdaterType_Test1 = 5,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Test2)
    k_EUpdaterType_Test2 = 6,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Dummy)
    k_EUpdaterType_Dummy = 7,
}

impl ::steam_vent_proto_common::protobuf::Enum for EUpdaterType {
    const NAME: &'static str = "EUpdaterType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EUpdaterType> {
        match value {
            0 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Invalid),
            1 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Client),
            2 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_OS),
            3 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_BIOS),
            4 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Aggregated),
            5 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Test1),
            6 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Test2),
            7 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Dummy),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EUpdaterType> {
        match str {
            "k_EUpdaterType_Invalid" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Invalid),
            "k_EUpdaterType_Client" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Client),
            "k_EUpdaterType_OS" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_OS),
            "k_EUpdaterType_BIOS" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_BIOS),
            "k_EUpdaterType_Aggregated" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Aggregated),
            "k_EUpdaterType_Test1" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Test1),
            "k_EUpdaterType_Test2" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Test2),
            "k_EUpdaterType_Dummy" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Dummy),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EUpdaterType] = &[
        EUpdaterType::k_EUpdaterType_Invalid,
        EUpdaterType::k_EUpdaterType_Client,
        EUpdaterType::k_EUpdaterType_OS,
        EUpdaterType::k_EUpdaterType_BIOS,
        EUpdaterType::k_EUpdaterType_Aggregated,
        EUpdaterType::k_EUpdaterType_Test1,
        EUpdaterType::k_EUpdaterType_Test2,
        EUpdaterType::k_EUpdaterType_Dummy,
    ];
}

impl ::std::default::Default for EUpdaterType {
    fn default() -> Self {
        EUpdaterType::k_EUpdaterType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EUpdaterState)
pub enum EUpdaterState {
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_Invalid)
    k_EUpdaterState_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_UpToDate)
    k_EUpdaterState_UpToDate = 2,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_Checking)
    k_EUpdaterState_Checking = 3,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_Available)
    k_EUpdaterState_Available = 4,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_Applying)
    k_EUpdaterState_Applying = 5,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_ClientRestartPending)
    k_EUpdaterState_ClientRestartPending = 6,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_SystemRestartPending)
    k_EUpdaterState_SystemRestartPending = 7,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_RollBack)
    k_EUpdaterState_RollBack = 8,
}

impl ::steam_vent_proto_common::protobuf::Enum for EUpdaterState {
    const NAME: &'static str = "EUpdaterState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EUpdaterState> {
        match value {
            0 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Invalid),
            2 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_UpToDate),
            3 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Checking),
            4 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Available),
            5 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Applying),
            6 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_ClientRestartPending),
            7 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_SystemRestartPending),
            8 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_RollBack),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EUpdaterState> {
        match str {
            "k_EUpdaterState_Invalid" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Invalid),
            "k_EUpdaterState_UpToDate" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_UpToDate),
            "k_EUpdaterState_Checking" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Checking),
            "k_EUpdaterState_Available" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Available),
            "k_EUpdaterState_Applying" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Applying),
            "k_EUpdaterState_ClientRestartPending" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_ClientRestartPending),
            "k_EUpdaterState_SystemRestartPending" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_SystemRestartPending),
            "k_EUpdaterState_RollBack" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_RollBack),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EUpdaterState] = &[
        EUpdaterState::k_EUpdaterState_Invalid,
        EUpdaterState::k_EUpdaterState_UpToDate,
        EUpdaterState::k_EUpdaterState_Checking,
        EUpdaterState::k_EUpdaterState_Available,
        EUpdaterState::k_EUpdaterState_Applying,
        EUpdaterState::k_EUpdaterState_ClientRestartPending,
        EUpdaterState::k_EUpdaterState_SystemRestartPending,
        EUpdaterState::k_EUpdaterState_RollBack,
    ];
}

impl ::std::default::Default for EUpdaterState {
    fn default() -> Self {
        EUpdaterState::k_EUpdaterState_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStorageBlockContentType)
pub enum EStorageBlockContentType {
    // @@protoc_insertion_point(enum_value:EStorageBlockContentType.k_EStorageBlockContentType_Invalid)
    k_EStorageBlockContentType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EStorageBlockContentType.k_EStorageBlockContentType_Unknown)
    k_EStorageBlockContentType_Unknown = 1,
    // @@protoc_insertion_point(enum_value:EStorageBlockContentType.k_EStorageBlockContentType_FileSystem)
    k_EStorageBlockContentType_FileSystem = 2,
    // @@protoc_insertion_point(enum_value:EStorageBlockContentType.k_EStorageBlockContentType_Crypto)
    k_EStorageBlockContentType_Crypto = 3,
    // @@protoc_insertion_point(enum_value:EStorageBlockContentType.k_EStorageBlockContentType_Raid)
    k_EStorageBlockContentType_Raid = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for EStorageBlockContentType {
    const NAME: &'static str = "EStorageBlockContentType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStorageBlockContentType> {
        match value {
            0 => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Invalid),
            1 => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Unknown),
            2 => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_FileSystem),
            3 => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Crypto),
            4 => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Raid),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStorageBlockContentType> {
        match str {
            "k_EStorageBlockContentType_Invalid" => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Invalid),
            "k_EStorageBlockContentType_Unknown" => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Unknown),
            "k_EStorageBlockContentType_FileSystem" => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_FileSystem),
            "k_EStorageBlockContentType_Crypto" => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Crypto),
            "k_EStorageBlockContentType_Raid" => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Raid),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStorageBlockContentType] = &[
        EStorageBlockContentType::k_EStorageBlockContentType_Invalid,
        EStorageBlockContentType::k_EStorageBlockContentType_Unknown,
        EStorageBlockContentType::k_EStorageBlockContentType_FileSystem,
        EStorageBlockContentType::k_EStorageBlockContentType_Crypto,
        EStorageBlockContentType::k_EStorageBlockContentType_Raid,
    ];
}

impl ::std::default::Default for EStorageBlockContentType {
    fn default() -> Self {
        EStorageBlockContentType::k_EStorageBlockContentType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStorageBlockFileSystemType)
pub enum EStorageBlockFileSystemType {
    // @@protoc_insertion_point(enum_value:EStorageBlockFileSystemType.k_EStorageBlockFileSystemType_Invalid)
    k_EStorageBlockFileSystemType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EStorageBlockFileSystemType.k_EStorageBlockFileSystemType_Unknown)
    k_EStorageBlockFileSystemType_Unknown = 1,
    // @@protoc_insertion_point(enum_value:EStorageBlockFileSystemType.k_EStorageBlockFileSystemType_VFat)
    k_EStorageBlockFileSystemType_VFat = 2,
    // @@protoc_insertion_point(enum_value:EStorageBlockFileSystemType.k_EStorageBlockFileSystemType_Ext4)
    k_EStorageBlockFileSystemType_Ext4 = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for EStorageBlockFileSystemType {
    const NAME: &'static str = "EStorageBlockFileSystemType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStorageBlockFileSystemType> {
        match value {
            0 => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid),
            1 => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Unknown),
            2 => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_VFat),
            3 => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Ext4),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStorageBlockFileSystemType> {
        match str {
            "k_EStorageBlockFileSystemType_Invalid" => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid),
            "k_EStorageBlockFileSystemType_Unknown" => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Unknown),
            "k_EStorageBlockFileSystemType_VFat" => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_VFat),
            "k_EStorageBlockFileSystemType_Ext4" => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Ext4),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStorageBlockFileSystemType] = &[
        EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid,
        EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Unknown,
        EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_VFat,
        EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Ext4,
    ];
}

impl ::std::default::Default for EStorageBlockFileSystemType {
    fn default() -> Self {
        EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStorageDriveMediaType)
pub enum EStorageDriveMediaType {
    // @@protoc_insertion_point(enum_value:EStorageDriveMediaType.k_EStorageDriveMediaType_Invalid)
    k_EStorageDriveMediaType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EStorageDriveMediaType.k_EStorageDriveMediaType_Unknown)
    k_EStorageDriveMediaType_Unknown = 1,
    // @@protoc_insertion_point(enum_value:EStorageDriveMediaType.k_EStorageDriveMediaType_HDD)
    k_EStorageDriveMediaType_HDD = 2,
    // @@protoc_insertion_point(enum_value:EStorageDriveMediaType.k_EStorageDriveMediaType_SSD)
    k_EStorageDriveMediaType_SSD = 3,
    // @@protoc_insertion_point(enum_value:EStorageDriveMediaType.k_EStorageDriveMediaType_Removable)
    k_EStorageDriveMediaType_Removable = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for EStorageDriveMediaType {
    const NAME: &'static str = "EStorageDriveMediaType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStorageDriveMediaType> {
        match value {
            0 => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_Invalid),
            1 => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_Unknown),
            2 => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_HDD),
            3 => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_SSD),
            4 => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_Removable),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStorageDriveMediaType> {
        match str {
            "k_EStorageDriveMediaType_Invalid" => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_Invalid),
            "k_EStorageDriveMediaType_Unknown" => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_Unknown),
            "k_EStorageDriveMediaType_HDD" => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_HDD),
            "k_EStorageDriveMediaType_SSD" => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_SSD),
            "k_EStorageDriveMediaType_Removable" => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_Removable),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStorageDriveMediaType] = &[
        EStorageDriveMediaType::k_EStorageDriveMediaType_Invalid,
        EStorageDriveMediaType::k_EStorageDriveMediaType_Unknown,
        EStorageDriveMediaType::k_EStorageDriveMediaType_HDD,
        EStorageDriveMediaType::k_EStorageDriveMediaType_SSD,
        EStorageDriveMediaType::k_EStorageDriveMediaType_Removable,
    ];
}

impl ::std::default::Default for EStorageDriveMediaType {
    fn default() -> Self {
        EStorageDriveMediaType::k_EStorageDriveMediaType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemDisplayCompatibilityMode)
pub enum ESystemDisplayCompatibilityMode {
    // @@protoc_insertion_point(enum_value:ESystemDisplayCompatibilityMode.k_ESystemDisplayCompatibilityMode_Invalid)
    k_ESystemDisplayCompatibilityMode_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemDisplayCompatibilityMode.k_ESystemDisplayCompatibilityMode_None)
    k_ESystemDisplayCompatibilityMode_None = 1,
    // @@protoc_insertion_point(enum_value:ESystemDisplayCompatibilityMode.k_ESystemDisplayCompatibilityMode_MinimalBandwith)
    k_ESystemDisplayCompatibilityMode_MinimalBandwith = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESystemDisplayCompatibilityMode {
    const NAME: &'static str = "ESystemDisplayCompatibilityMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemDisplayCompatibilityMode> {
        match value {
            0 => ::std::option::Option::Some(ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_Invalid),
            1 => ::std::option::Option::Some(ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_None),
            2 => ::std::option::Option::Some(ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_MinimalBandwith),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemDisplayCompatibilityMode> {
        match str {
            "k_ESystemDisplayCompatibilityMode_Invalid" => ::std::option::Option::Some(ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_Invalid),
            "k_ESystemDisplayCompatibilityMode_None" => ::std::option::Option::Some(ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_None),
            "k_ESystemDisplayCompatibilityMode_MinimalBandwith" => ::std::option::Option::Some(ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_MinimalBandwith),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemDisplayCompatibilityMode] = &[
        ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_Invalid,
        ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_None,
        ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_MinimalBandwith,
    ];
}

impl ::std::default::Default for ESystemDisplayCompatibilityMode {
    fn default() -> Self {
        ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamDeckCompatibilityCategory)
pub enum ESteamDeckCompatibilityCategory {
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityCategory.k_ESteamDeckCompatibilityCategory_Unknown)
    k_ESteamDeckCompatibilityCategory_Unknown = 0,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityCategory.k_ESteamDeckCompatibilityCategory_Unsupported)
    k_ESteamDeckCompatibilityCategory_Unsupported = 1,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityCategory.k_ESteamDeckCompatibilityCategory_Playable)
    k_ESteamDeckCompatibilityCategory_Playable = 2,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityCategory.k_ESteamDeckCompatibilityCategory_Verified)
    k_ESteamDeckCompatibilityCategory_Verified = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESteamDeckCompatibilityCategory {
    const NAME: &'static str = "ESteamDeckCompatibilityCategory";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDeckCompatibilityCategory> {
        match value {
            0 => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unknown),
            1 => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unsupported),
            2 => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Playable),
            3 => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Verified),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamDeckCompatibilityCategory> {
        match str {
            "k_ESteamDeckCompatibilityCategory_Unknown" => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unknown),
            "k_ESteamDeckCompatibilityCategory_Unsupported" => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unsupported),
            "k_ESteamDeckCompatibilityCategory_Playable" => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Playable),
            "k_ESteamDeckCompatibilityCategory_Verified" => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Verified),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamDeckCompatibilityCategory] = &[
        ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unknown,
        ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unsupported,
        ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Playable,
        ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Verified,
    ];
}

impl ::std::default::Default for ESteamDeckCompatibilityCategory {
    fn default() -> Self {
        ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unknown
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamDeckCompatibilityResultDisplayType)
pub enum ESteamDeckCompatibilityResultDisplayType {
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityResultDisplayType.k_ESteamDeckCompatibilityResultDisplayType_Invisible)
    k_ESteamDeckCompatibilityResultDisplayType_Invisible = 0,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityResultDisplayType.k_ESteamDeckCompatibilityResultDisplayType_Informational)
    k_ESteamDeckCompatibilityResultDisplayType_Informational = 1,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityResultDisplayType.k_ESteamDeckCompatibilityResultDisplayType_Unsupported)
    k_ESteamDeckCompatibilityResultDisplayType_Unsupported = 2,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityResultDisplayType.k_ESteamDeckCompatibilityResultDisplayType_Playable)
    k_ESteamDeckCompatibilityResultDisplayType_Playable = 3,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityResultDisplayType.k_ESteamDeckCompatibilityResultDisplayType_Verified)
    k_ESteamDeckCompatibilityResultDisplayType_Verified = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESteamDeckCompatibilityResultDisplayType {
    const NAME: &'static str = "ESteamDeckCompatibilityResultDisplayType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDeckCompatibilityResultDisplayType> {
        match value {
            0 => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Invisible),
            1 => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Informational),
            2 => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Unsupported),
            3 => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Playable),
            4 => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Verified),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamDeckCompatibilityResultDisplayType> {
        match str {
            "k_ESteamDeckCompatibilityResultDisplayType_Invisible" => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Invisible),
            "k_ESteamDeckCompatibilityResultDisplayType_Informational" => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Informational),
            "k_ESteamDeckCompatibilityResultDisplayType_Unsupported" => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Unsupported),
            "k_ESteamDeckCompatibilityResultDisplayType_Playable" => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Playable),
            "k_ESteamDeckCompatibilityResultDisplayType_Verified" => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Verified),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamDeckCompatibilityResultDisplayType] = &[
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Invisible,
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Informational,
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Unsupported,
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Playable,
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Verified,
    ];
}

impl ::std::default::Default for ESteamDeckCompatibilityResultDisplayType {
    fn default() -> Self {
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Invisible
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamDeckCompatibilityTestResult)
pub enum ESteamDeckCompatibilityTestResult {
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityTestResult.k_ESteamDeckCompatibilityTestResult_Invalid)
    k_ESteamDeckCompatibilityTestResult_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityTestResult.k_ESteamDeckCompatibilityTestResult_NotApplicable)
    k_ESteamDeckCompatibilityTestResult_NotApplicable = 1,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityTestResult.k_ESteamDeckCompatibilityTestResult_Pass)
    k_ESteamDeckCompatibilityTestResult_Pass = 2,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityTestResult.k_ESteamDeckCompatibilityTestResult_Fail)
    k_ESteamDeckCompatibilityTestResult_Fail = 3,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityTestResult.k_ESteamDeckCompatibilityTestResult_FailMinor)
    k_ESteamDeckCompatibilityTestResult_FailMinor = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESteamDeckCompatibilityTestResult {
    const NAME: &'static str = "ESteamDeckCompatibilityTestResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDeckCompatibilityTestResult> {
        match value {
            0 => ::std::option::Option::Some(ESteamDeckCompatibilityTestResult::k_ESteamDeckCompatibilityTestResult_Invalid),
            1 => ::std::option::Option::Some(ESteamDeckCompatibilityTestResult::k_ESteamDeckCompatibilityTestResult_NotApplicable),
            2 => ::std::option::Option::Some(ESteamDeckCompatibilityTestResult::k_ESteamDeckCompatibilityTestResult_Pass),
            3 => ::std::option::Option::Some(ESteamDeckCompatibilityTestResult::k_ESteamDeckCompatibilityTestResult_Fail),
            4 => ::std::option::Option::Some(ESteamDeckCompatibilityTestResult::k_ESteamDeckCompatibilityTestResult_FailMinor),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamDeckCompatibilityTestResult> {
        match str {
            "k_ESteamDeckCompatibilityTestResult_Invalid" => ::std::option::Option::Some(ESteamDeckCompatibilityTestResult::k_ESteamDeckCompatibilityTestResult_Invalid),
            "k_ESteamDeckCompatibilityTestResult_NotApplicable" => ::std::option::Option::Some(ESteamDeckCompatibilityTestResult::k_ESteamDeckCompatibilityTestResult_NotApplicable),
            "k_ESteamDeckCompatibilityTestResult_Pass" => ::std::option::Option::Some(ESteamDeckCompatibilityTestResult::k_ESteamDeckCompatibilityTestResult_Pass),
            "k_ESteamDeckCompatibilityTestResult_Fail" => ::std::option::Option::Some(ESteamDeckCompatibilityTestResult::k_ESteamDeckCompatibilityTestResult_Fail),
            "k_ESteamDeckCompatibilityTestResult_FailMinor" => ::std::option::Option::Some(ESteamDeckCompatibilityTestResult::k_ESteamDeckCompatibilityTestResult_FailMinor),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamDeckCompatibilityTestResult] = &[
        ESteamDeckCompatibilityTestResult::k_ESteamDeckCompatibilityTestResult_Invalid,
        ESteamDeckCompatibilityTestResult::k_ESteamDeckCompatibilityTestResult_NotApplicable,
        ESteamDeckCompatibilityTestResult::k_ESteamDeckCompatibilityTestResult_Pass,
        ESteamDeckCompatibilityTestResult::k_ESteamDeckCompatibilityTestResult_Fail,
        ESteamDeckCompatibilityTestResult::k_ESteamDeckCompatibilityTestResult_FailMinor,
    ];
}

impl ::std::default::Default for ESteamDeckCompatibilityTestResult {
    fn default() -> Self {
        ESteamDeckCompatibilityTestResult::k_ESteamDeckCompatibilityTestResult_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EACState)
pub enum EACState {
    // @@protoc_insertion_point(enum_value:EACState.k_EACState_Unknown)
    k_EACState_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EACState.k_EACState_Disconnected)
    k_EACState_Disconnected = 1,
    // @@protoc_insertion_point(enum_value:EACState.k_EACState_Connected)
    k_EACState_Connected = 2,
    // @@protoc_insertion_point(enum_value:EACState.k_EACState_ConnectedSlow)
    k_EACState_ConnectedSlow = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for EACState {
    const NAME: &'static str = "EACState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EACState> {
        match value {
            0 => ::std::option::Option::Some(EACState::k_EACState_Unknown),
            1 => ::std::option::Option::Some(EACState::k_EACState_Disconnected),
            2 => ::std::option::Option::Some(EACState::k_EACState_Connected),
            3 => ::std::option::Option::Some(EACState::k_EACState_ConnectedSlow),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EACState> {
        match str {
            "k_EACState_Unknown" => ::std::option::Option::Some(EACState::k_EACState_Unknown),
            "k_EACState_Disconnected" => ::std::option::Option::Some(EACState::k_EACState_Disconnected),
            "k_EACState_Connected" => ::std::option::Option::Some(EACState::k_EACState_Connected),
            "k_EACState_ConnectedSlow" => ::std::option::Option::Some(EACState::k_EACState_ConnectedSlow),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EACState] = &[
        EACState::k_EACState_Unknown,
        EACState::k_EACState_Disconnected,
        EACState::k_EACState_Connected,
        EACState::k_EACState_ConnectedSlow,
    ];
}

impl ::std::default::Default for EACState {
    fn default() -> Self {
        EACState::k_EACState_Unknown
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBatteryState)
pub enum EBatteryState {
    // @@protoc_insertion_point(enum_value:EBatteryState.k_EBatteryState_Unknown)
    k_EBatteryState_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EBatteryState.k_EBatteryState_Discharging)
    k_EBatteryState_Discharging = 1,
    // @@protoc_insertion_point(enum_value:EBatteryState.k_EBatteryState_Charging)
    k_EBatteryState_Charging = 2,
    // @@protoc_insertion_point(enum_value:EBatteryState.k_EBatteryState_Full)
    k_EBatteryState_Full = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for EBatteryState {
    const NAME: &'static str = "EBatteryState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBatteryState> {
        match value {
            0 => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Unknown),
            1 => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Discharging),
            2 => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Charging),
            3 => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Full),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBatteryState> {
        match str {
            "k_EBatteryState_Unknown" => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Unknown),
            "k_EBatteryState_Discharging" => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Discharging),
            "k_EBatteryState_Charging" => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Charging),
            "k_EBatteryState_Full" => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Full),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBatteryState] = &[
        EBatteryState::k_EBatteryState_Unknown,
        EBatteryState::k_EBatteryState_Discharging,
        EBatteryState::k_EBatteryState_Charging,
        EBatteryState::k_EBatteryState_Full,
    ];
}

impl ::std::default::Default for EBatteryState {
    fn default() -> Self {
        EBatteryState::k_EBatteryState_Unknown
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EOSBranch)
pub enum EOSBranch {
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_Unknown)
    k_EOSBranch_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_Release)
    k_EOSBranch_Release = 1,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_ReleaseCandidate)
    k_EOSBranch_ReleaseCandidate = 2,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_Beta)
    k_EOSBranch_Beta = 3,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_BetaCandidate)
    k_EOSBranch_BetaCandidate = 4,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_Preview)
    k_EOSBranch_Preview = 5,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_PreviewCandidate)
    k_EOSBranch_PreviewCandidate = 6,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_Main)
    k_EOSBranch_Main = 7,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_Staging)
    k_EOSBranch_Staging = 8,
}

impl ::steam_vent_proto_common::protobuf::Enum for EOSBranch {
    const NAME: &'static str = "EOSBranch";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EOSBranch> {
        match value {
            0 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Unknown),
            1 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Release),
            2 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_ReleaseCandidate),
            3 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Beta),
            4 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_BetaCandidate),
            5 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Preview),
            6 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_PreviewCandidate),
            7 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Main),
            8 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Staging),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EOSBranch> {
        match str {
            "k_EOSBranch_Unknown" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Unknown),
            "k_EOSBranch_Release" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Release),
            "k_EOSBranch_ReleaseCandidate" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_ReleaseCandidate),
            "k_EOSBranch_Beta" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Beta),
            "k_EOSBranch_BetaCandidate" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_BetaCandidate),
            "k_EOSBranch_Preview" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Preview),
            "k_EOSBranch_PreviewCandidate" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_PreviewCandidate),
            "k_EOSBranch_Main" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Main),
            "k_EOSBranch_Staging" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Staging),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EOSBranch] = &[
        EOSBranch::k_EOSBranch_Unknown,
        EOSBranch::k_EOSBranch_Release,
        EOSBranch::k_EOSBranch_ReleaseCandidate,
        EOSBranch::k_EOSBranch_Beta,
        EOSBranch::k_EOSBranch_BetaCandidate,
        EOSBranch::k_EOSBranch_Preview,
        EOSBranch::k_EOSBranch_PreviewCandidate,
        EOSBranch::k_EOSBranch_Main,
        EOSBranch::k_EOSBranch_Staging,
    ];
}

impl ::std::default::Default for EOSBranch {
    fn default() -> Self {
        EOSBranch::k_EOSBranch_Unknown
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECommunityItemClass)
pub enum ECommunityItemClass {
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Invalid)
    k_ECommunityItemClass_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Badge)
    k_ECommunityItemClass_Badge = 1,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_GameCard)
    k_ECommunityItemClass_GameCard = 2,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_ProfileBackground)
    k_ECommunityItemClass_ProfileBackground = 3,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Emoticon)
    k_ECommunityItemClass_Emoticon = 4,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_BoosterPack)
    k_ECommunityItemClass_BoosterPack = 5,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Consumable)
    k_ECommunityItemClass_Consumable = 6,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_GameGoo)
    k_ECommunityItemClass_GameGoo = 7,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_ProfileModifier)
    k_ECommunityItemClass_ProfileModifier = 8,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Scene)
    k_ECommunityItemClass_Scene = 9,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_SalienItem)
    k_ECommunityItemClass_SalienItem = 10,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Sticker)
    k_ECommunityItemClass_Sticker = 11,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_ChatEffect)
    k_ECommunityItemClass_ChatEffect = 12,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_MiniProfileBackground)
    k_ECommunityItemClass_MiniProfileBackground = 13,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_AvatarFrame)
    k_ECommunityItemClass_AvatarFrame = 14,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_AnimatedAvatar)
    k_ECommunityItemClass_AnimatedAvatar = 15,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_SteamDeckKeyboardSkin)
    k_ECommunityItemClass_SteamDeckKeyboardSkin = 16,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_SteamDeckStartupMovie)
    k_ECommunityItemClass_SteamDeckStartupMovie = 17,
}

impl ::steam_vent_proto_common::protobuf::Enum for ECommunityItemClass {
    const NAME: &'static str = "ECommunityItemClass";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECommunityItemClass> {
        match value {
            0 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Invalid),
            1 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Badge),
            2 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_GameCard),
            3 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ProfileBackground),
            4 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Emoticon),
            5 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_BoosterPack),
            6 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Consumable),
            7 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_GameGoo),
            8 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ProfileModifier),
            9 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Scene),
            10 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_SalienItem),
            11 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Sticker),
            12 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ChatEffect),
            13 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_MiniProfileBackground),
            14 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_AvatarFrame),
            15 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_AnimatedAvatar),
            16 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_SteamDeckKeyboardSkin),
            17 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_SteamDeckStartupMovie),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECommunityItemClass> {
        match str {
            "k_ECommunityItemClass_Invalid" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Invalid),
            "k_ECommunityItemClass_Badge" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Badge),
            "k_ECommunityItemClass_GameCard" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_GameCard),
            "k_ECommunityItemClass_ProfileBackground" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ProfileBackground),
            "k_ECommunityItemClass_Emoticon" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Emoticon),
            "k_ECommunityItemClass_BoosterPack" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_BoosterPack),
            "k_ECommunityItemClass_Consumable" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Consumable),
            "k_ECommunityItemClass_GameGoo" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_GameGoo),
            "k_ECommunityItemClass_ProfileModifier" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ProfileModifier),
            "k_ECommunityItemClass_Scene" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Scene),
            "k_ECommunityItemClass_SalienItem" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_SalienItem),
            "k_ECommunityItemClass_Sticker" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Sticker),
            "k_ECommunityItemClass_ChatEffect" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ChatEffect),
            "k_ECommunityItemClass_MiniProfileBackground" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_MiniProfileBackground),
            "k_ECommunityItemClass_AvatarFrame" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_AvatarFrame),
            "k_ECommunityItemClass_AnimatedAvatar" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_AnimatedAvatar),
            "k_ECommunityItemClass_SteamDeckKeyboardSkin" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_SteamDeckKeyboardSkin),
            "k_ECommunityItemClass_SteamDeckStartupMovie" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_SteamDeckStartupMovie),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECommunityItemClass] = &[
        ECommunityItemClass::k_ECommunityItemClass_Invalid,
        ECommunityItemClass::k_ECommunityItemClass_Badge,
        ECommunityItemClass::k_ECommunityItemClass_GameCard,
        ECommunityItemClass::k_ECommunityItemClass_ProfileBackground,
        ECommunityItemClass::k_ECommunityItemClass_Emoticon,
        ECommunityItemClass::k_ECommunityItemClass_BoosterPack,
        ECommunityItemClass::k_ECommunityItemClass_Consumable,
        ECommunityItemClass::k_ECommunityItemClass_GameGoo,
        ECommunityItemClass::k_ECommunityItemClass_ProfileModifier,
        ECommunityItemClass::k_ECommunityItemClass_Scene,
        ECommunityItemClass::k_ECommunityItemClass_SalienItem,
        ECommunityItemClass::k_ECommunityItemClass_Sticker,
        ECommunityItemClass::k_ECommunityItemClass_ChatEffect,
        ECommunityItemClass::k_ECommunityItemClass_MiniProfileBackground,
        ECommunityItemClass::k_ECommunityItemClass_AvatarFrame,
        ECommunityItemClass::k_ECommunityItemClass_AnimatedAvatar,
        ECommunityItemClass::k_ECommunityItemClass_SteamDeckKeyboardSkin,
        ECommunityItemClass::k_ECommunityItemClass_SteamDeckStartupMovie,
    ];
}

impl ::std::default::Default for ECommunityItemClass {
    fn default() -> Self {
        ECommunityItemClass::k_ECommunityItemClass_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamDeckCompatibilityFeedback)
pub enum ESteamDeckCompatibilityFeedback {
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityFeedback.k_ESteamDeckCompatibilityFeedback_Unset)
    k_ESteamDeckCompatibilityFeedback_Unset = 0,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityFeedback.k_ESteamDeckCompatibilityFeedback_Agree)
    k_ESteamDeckCompatibilityFeedback_Agree = 1,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityFeedback.k_ESteamDeckCompatibilityFeedback_Disagree)
    k_ESteamDeckCompatibilityFeedback_Disagree = 2,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityFeedback.k_ESteamDeckCompatibilityFeedback_Ignore)
    k_ESteamDeckCompatibilityFeedback_Ignore = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESteamDeckCompatibilityFeedback {
    const NAME: &'static str = "ESteamDeckCompatibilityFeedback";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDeckCompatibilityFeedback> {
        match value {
            0 => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset),
            1 => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Agree),
            2 => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Disagree),
            3 => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Ignore),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamDeckCompatibilityFeedback> {
        match str {
            "k_ESteamDeckCompatibilityFeedback_Unset" => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset),
            "k_ESteamDeckCompatibilityFeedback_Agree" => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Agree),
            "k_ESteamDeckCompatibilityFeedback_Disagree" => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Disagree),
            "k_ESteamDeckCompatibilityFeedback_Ignore" => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Ignore),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamDeckCompatibilityFeedback] = &[
        ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset,
        ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Agree,
        ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Disagree,
        ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Ignore,
    ];
}

impl ::std::default::Default for ESteamDeckCompatibilityFeedback {
    fn default() -> Self {
        ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EProvideDeckFeedbackPreference)
pub enum EProvideDeckFeedbackPreference {
    // @@protoc_insertion_point(enum_value:EProvideDeckFeedbackPreference.k_EProvideDeckFeedbackPreference_Unset)
    k_EProvideDeckFeedbackPreference_Unset = 0,
    // @@protoc_insertion_point(enum_value:EProvideDeckFeedbackPreference.k_EProvideDeckFeedbackPreference_Yes)
    k_EProvideDeckFeedbackPreference_Yes = 1,
    // @@protoc_insertion_point(enum_value:EProvideDeckFeedbackPreference.k_EProvideDeckFeedbackPreference_No)
    k_EProvideDeckFeedbackPreference_No = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EProvideDeckFeedbackPreference {
    const NAME: &'static str = "EProvideDeckFeedbackPreference";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProvideDeckFeedbackPreference> {
        match value {
            0 => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Unset),
            1 => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Yes),
            2 => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_No),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EProvideDeckFeedbackPreference> {
        match str {
            "k_EProvideDeckFeedbackPreference_Unset" => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Unset),
            "k_EProvideDeckFeedbackPreference_Yes" => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Yes),
            "k_EProvideDeckFeedbackPreference_No" => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_No),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EProvideDeckFeedbackPreference] = &[
        EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Unset,
        EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Yes,
        EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_No,
    ];
}

impl ::std::default::Default for EProvideDeckFeedbackPreference {
    fn default() -> Self {
        EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Unset
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETouchGesture)
pub enum ETouchGesture {
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureNone)
    k_ETouchGestureNone = 0,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureTouch)
    k_ETouchGestureTouch = 1,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureTap)
    k_ETouchGestureTap = 2,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureDoubleTap)
    k_ETouchGestureDoubleTap = 3,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureShortPress)
    k_ETouchGestureShortPress = 4,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureLongPress)
    k_ETouchGestureLongPress = 5,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureLongTap)
    k_ETouchGestureLongTap = 6,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureTwoFingerTap)
    k_ETouchGestureTwoFingerTap = 7,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureTapCancelled)
    k_ETouchGestureTapCancelled = 8,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGesturePinchBegin)
    k_ETouchGesturePinchBegin = 9,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGesturePinchUpdate)
    k_ETouchGesturePinchUpdate = 10,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGesturePinchEnd)
    k_ETouchGesturePinchEnd = 11,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureFlingStart)
    k_ETouchGestureFlingStart = 12,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureFlingCancelled)
    k_ETouchGestureFlingCancelled = 13,
}

impl ::steam_vent_proto_common::protobuf::Enum for ETouchGesture {
    const NAME: &'static str = "ETouchGesture";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETouchGesture> {
        match value {
            0 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureNone),
            1 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTouch),
            2 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTap),
            3 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureDoubleTap),
            4 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureShortPress),
            5 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureLongPress),
            6 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureLongTap),
            7 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTwoFingerTap),
            8 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTapCancelled),
            9 => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchBegin),
            10 => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchUpdate),
            11 => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchEnd),
            12 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureFlingStart),
            13 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureFlingCancelled),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETouchGesture> {
        match str {
            "k_ETouchGestureNone" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureNone),
            "k_ETouchGestureTouch" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTouch),
            "k_ETouchGestureTap" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTap),
            "k_ETouchGestureDoubleTap" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureDoubleTap),
            "k_ETouchGestureShortPress" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureShortPress),
            "k_ETouchGestureLongPress" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureLongPress),
            "k_ETouchGestureLongTap" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureLongTap),
            "k_ETouchGestureTwoFingerTap" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTwoFingerTap),
            "k_ETouchGestureTapCancelled" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTapCancelled),
            "k_ETouchGesturePinchBegin" => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchBegin),
            "k_ETouchGesturePinchUpdate" => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchUpdate),
            "k_ETouchGesturePinchEnd" => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchEnd),
            "k_ETouchGestureFlingStart" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureFlingStart),
            "k_ETouchGestureFlingCancelled" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureFlingCancelled),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETouchGesture] = &[
        ETouchGesture::k_ETouchGestureNone,
        ETouchGesture::k_ETouchGestureTouch,
        ETouchGesture::k_ETouchGestureTap,
        ETouchGesture::k_ETouchGestureDoubleTap,
        ETouchGesture::k_ETouchGestureShortPress,
        ETouchGesture::k_ETouchGestureLongPress,
        ETouchGesture::k_ETouchGestureLongTap,
        ETouchGesture::k_ETouchGestureTwoFingerTap,
        ETouchGesture::k_ETouchGestureTapCancelled,
        ETouchGesture::k_ETouchGesturePinchBegin,
        ETouchGesture::k_ETouchGesturePinchUpdate,
        ETouchGesture::k_ETouchGesturePinchEnd,
        ETouchGesture::k_ETouchGestureFlingStart,
        ETouchGesture::k_ETouchGestureFlingCancelled,
    ];
}

impl ::std::default::Default for ETouchGesture {
    fn default() -> Self {
        ETouchGesture::k_ETouchGestureNone
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESessionPersistence)
pub enum ESessionPersistence {
    // @@protoc_insertion_point(enum_value:ESessionPersistence.k_ESessionPersistence_Invalid)
    k_ESessionPersistence_Invalid = -1,
    // @@protoc_insertion_point(enum_value:ESessionPersistence.k_ESessionPersistence_Ephemeral)
    k_ESessionPersistence_Ephemeral = 0,
    // @@protoc_insertion_point(enum_value:ESessionPersistence.k_ESessionPersistence_Persistent)
    k_ESessionPersistence_Persistent = 1,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESessionPersistence {
    const NAME: &'static str = "ESessionPersistence";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESessionPersistence> {
        match value {
            -1 => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Invalid),
            0 => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Ephemeral),
            1 => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Persistent),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESessionPersistence> {
        match str {
            "k_ESessionPersistence_Invalid" => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Invalid),
            "k_ESessionPersistence_Ephemeral" => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Ephemeral),
            "k_ESessionPersistence_Persistent" => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Persistent),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESessionPersistence] = &[
        ESessionPersistence::k_ESessionPersistence_Invalid,
        ESessionPersistence::k_ESessionPersistence_Ephemeral,
        ESessionPersistence::k_ESessionPersistence_Persistent,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ESessionPersistence {
    fn default() -> Self {
        ESessionPersistence::k_ESessionPersistence_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ENewSteamAnnouncementState)
pub enum ENewSteamAnnouncementState {
    // @@protoc_insertion_point(enum_value:ENewSteamAnnouncementState.k_ENewSteamAnnouncementState_Invalid)
    k_ENewSteamAnnouncementState_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ENewSteamAnnouncementState.k_ENewSteamAnnouncementState_AllRead)
    k_ENewSteamAnnouncementState_AllRead = 1,
    // @@protoc_insertion_point(enum_value:ENewSteamAnnouncementState.k_ENewSteamAnnouncementState_NewAnnouncement)
    k_ENewSteamAnnouncementState_NewAnnouncement = 2,
    // @@protoc_insertion_point(enum_value:ENewSteamAnnouncementState.k_ENewSteamAnnouncementState_FeaturedAnnouncement)
    k_ENewSteamAnnouncementState_FeaturedAnnouncement = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for ENewSteamAnnouncementState {
    const NAME: &'static str = "ENewSteamAnnouncementState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ENewSteamAnnouncementState> {
        match value {
            0 => ::std::option::Option::Some(ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_Invalid),
            1 => ::std::option::Option::Some(ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_AllRead),
            2 => ::std::option::Option::Some(ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_NewAnnouncement),
            3 => ::std::option::Option::Some(ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_FeaturedAnnouncement),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ENewSteamAnnouncementState> {
        match str {
            "k_ENewSteamAnnouncementState_Invalid" => ::std::option::Option::Some(ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_Invalid),
            "k_ENewSteamAnnouncementState_AllRead" => ::std::option::Option::Some(ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_AllRead),
            "k_ENewSteamAnnouncementState_NewAnnouncement" => ::std::option::Option::Some(ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_NewAnnouncement),
            "k_ENewSteamAnnouncementState_FeaturedAnnouncement" => ::std::option::Option::Some(ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_FeaturedAnnouncement),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ENewSteamAnnouncementState] = &[
        ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_Invalid,
        ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_AllRead,
        ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_NewAnnouncement,
        ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_FeaturedAnnouncement,
    ];
}

impl ::std::default::Default for ENewSteamAnnouncementState {
    fn default() -> Self {
        ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EForumType)
pub enum EForumType {
    // @@protoc_insertion_point(enum_value:EForumType.k_EForumType_Invalid)
    k_EForumType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EForumType.k_EForumType_General)
    k_EForumType_General = 1,
    // @@protoc_insertion_point(enum_value:EForumType.k_EForumType_ReportedPosts)
    k_EForumType_ReportedPosts = 2,
    // @@protoc_insertion_point(enum_value:EForumType.k_EForumType_Workshop)
    k_EForumType_Workshop = 3,
    // @@protoc_insertion_point(enum_value:EForumType.k_EForumType_PublishedFile)
    k_EForumType_PublishedFile = 4,
    // @@protoc_insertion_point(enum_value:EForumType.k_EForumType_Trading)
    k_EForumType_Trading = 5,
    // @@protoc_insertion_point(enum_value:EForumType.k_EForumType_PlayTest)
    k_EForumType_PlayTest = 6,
    // @@protoc_insertion_point(enum_value:EForumType.k_EForumType_Event)
    k_EForumType_Event = 7,
    // @@protoc_insertion_point(enum_value:EForumType.k_EForumType_Max)
    k_EForumType_Max = 8,
}

impl ::steam_vent_proto_common::protobuf::Enum for EForumType {
    const NAME: &'static str = "EForumType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EForumType> {
        match value {
            0 => ::std::option::Option::Some(EForumType::k_EForumType_Invalid),
            1 => ::std::option::Option::Some(EForumType::k_EForumType_General),
            2 => ::std::option::Option::Some(EForumType::k_EForumType_ReportedPosts),
            3 => ::std::option::Option::Some(EForumType::k_EForumType_Workshop),
            4 => ::std::option::Option::Some(EForumType::k_EForumType_PublishedFile),
            5 => ::std::option::Option::Some(EForumType::k_EForumType_Trading),
            6 => ::std::option::Option::Some(EForumType::k_EForumType_PlayTest),
            7 => ::std::option::Option::Some(EForumType::k_EForumType_Event),
            8 => ::std::option::Option::Some(EForumType::k_EForumType_Max),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EForumType> {
        match str {
            "k_EForumType_Invalid" => ::std::option::Option::Some(EForumType::k_EForumType_Invalid),
            "k_EForumType_General" => ::std::option::Option::Some(EForumType::k_EForumType_General),
            "k_EForumType_ReportedPosts" => ::std::option::Option::Some(EForumType::k_EForumType_ReportedPosts),
            "k_EForumType_Workshop" => ::std::option::Option::Some(EForumType::k_EForumType_Workshop),
            "k_EForumType_PublishedFile" => ::std::option::Option::Some(EForumType::k_EForumType_PublishedFile),
            "k_EForumType_Trading" => ::std::option::Option::Some(EForumType::k_EForumType_Trading),
            "k_EForumType_PlayTest" => ::std::option::Option::Some(EForumType::k_EForumType_PlayTest),
            "k_EForumType_Event" => ::std::option::Option::Some(EForumType::k_EForumType_Event),
            "k_EForumType_Max" => ::std::option::Option::Some(EForumType::k_EForumType_Max),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EForumType] = &[
        EForumType::k_EForumType_Invalid,
        EForumType::k_EForumType_General,
        EForumType::k_EForumType_ReportedPosts,
        EForumType::k_EForumType_Workshop,
        EForumType::k_EForumType_PublishedFile,
        EForumType::k_EForumType_Trading,
        EForumType::k_EForumType_PlayTest,
        EForumType::k_EForumType_Event,
        EForumType::k_EForumType_Max,
    ];
}

impl ::std::default::Default for EForumType {
    fn default() -> Self {
        EForumType::k_EForumType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECommentThreadType)
pub enum ECommentThreadType {
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeInvalid)
    k_ECommentThreadTypeInvalid = 0,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeScreenshot_Deprecated)
    k_ECommentThreadTypeScreenshot_Deprecated = 1,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeWorkshopAccount_Developer)
    k_ECommentThreadTypeWorkshopAccount_Developer = 2,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeWorkshopAccount_Public)
    k_ECommentThreadTypeWorkshopAccount_Public = 3,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypePublishedFile_Developer)
    k_ECommentThreadTypePublishedFile_Developer = 4,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypePublishedFile_Public)
    k_ECommentThreadTypePublishedFile_Public = 5,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeTest)
    k_ECommentThreadTypeTest = 6,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeForumTopic)
    k_ECommentThreadTypeForumTopic = 7,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeRecommendation)
    k_ECommentThreadTypeRecommendation = 8,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeVideo_Deprecated)
    k_ECommentThreadTypeVideo_Deprecated = 9,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeProfile)
    k_ECommentThreadTypeProfile = 10,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeNewsPost)
    k_ECommentThreadTypeNewsPost = 11,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeClan)
    k_ECommentThreadTypeClan = 12,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeClanAnnouncement)
    k_ECommentThreadTypeClanAnnouncement = 13,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeClanEvent)
    k_ECommentThreadTypeClanEvent = 14,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeUserStatusPublished)
    k_ECommentThreadTypeUserStatusPublished = 15,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeUserReceivedNewGame)
    k_ECommentThreadTypeUserReceivedNewGame = 16,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypePublishedFile_Announcement)
    k_ECommentThreadTypePublishedFile_Announcement = 17,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeModeratorMessage)
    k_ECommentThreadTypeModeratorMessage = 18,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeClanCuratedApp)
    k_ECommentThreadTypeClanCuratedApp = 19,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeQAndASession)
    k_ECommentThreadTypeQAndASession = 20,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeMax)
    k_ECommentThreadTypeMax = 21,
}

impl ::steam_vent_proto_common::protobuf::Enum for ECommentThreadType {
    const NAME: &'static str = "ECommentThreadType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECommentThreadType> {
        match value {
            0 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeInvalid),
            1 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeScreenshot_Deprecated),
            2 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeWorkshopAccount_Developer),
            3 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeWorkshopAccount_Public),
            4 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypePublishedFile_Developer),
            5 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypePublishedFile_Public),
            6 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeTest),
            7 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeForumTopic),
            8 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeRecommendation),
            9 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeVideo_Deprecated),
            10 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeProfile),
            11 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeNewsPost),
            12 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeClan),
            13 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeClanAnnouncement),
            14 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeClanEvent),
            15 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeUserStatusPublished),
            16 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeUserReceivedNewGame),
            17 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypePublishedFile_Announcement),
            18 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeModeratorMessage),
            19 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeClanCuratedApp),
            20 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeQAndASession),
            21 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeMax),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECommentThreadType> {
        match str {
            "k_ECommentThreadTypeInvalid" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeInvalid),
            "k_ECommentThreadTypeScreenshot_Deprecated" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeScreenshot_Deprecated),
            "k_ECommentThreadTypeWorkshopAccount_Developer" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeWorkshopAccount_Developer),
            "k_ECommentThreadTypeWorkshopAccount_Public" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeWorkshopAccount_Public),
            "k_ECommentThreadTypePublishedFile_Developer" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypePublishedFile_Developer),
            "k_ECommentThreadTypePublishedFile_Public" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypePublishedFile_Public),
            "k_ECommentThreadTypeTest" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeTest),
            "k_ECommentThreadTypeForumTopic" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeForumTopic),
            "k_ECommentThreadTypeRecommendation" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeRecommendation),
            "k_ECommentThreadTypeVideo_Deprecated" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeVideo_Deprecated),
            "k_ECommentThreadTypeProfile" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeProfile),
            "k_ECommentThreadTypeNewsPost" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeNewsPost),
            "k_ECommentThreadTypeClan" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeClan),
            "k_ECommentThreadTypeClanAnnouncement" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeClanAnnouncement),
            "k_ECommentThreadTypeClanEvent" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeClanEvent),
            "k_ECommentThreadTypeUserStatusPublished" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeUserStatusPublished),
            "k_ECommentThreadTypeUserReceivedNewGame" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeUserReceivedNewGame),
            "k_ECommentThreadTypePublishedFile_Announcement" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypePublishedFile_Announcement),
            "k_ECommentThreadTypeModeratorMessage" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeModeratorMessage),
            "k_ECommentThreadTypeClanCuratedApp" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeClanCuratedApp),
            "k_ECommentThreadTypeQAndASession" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeQAndASession),
            "k_ECommentThreadTypeMax" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeMax),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECommentThreadType] = &[
        ECommentThreadType::k_ECommentThreadTypeInvalid,
        ECommentThreadType::k_ECommentThreadTypeScreenshot_Deprecated,
        ECommentThreadType::k_ECommentThreadTypeWorkshopAccount_Developer,
        ECommentThreadType::k_ECommentThreadTypeWorkshopAccount_Public,
        ECommentThreadType::k_ECommentThreadTypePublishedFile_Developer,
        ECommentThreadType::k_ECommentThreadTypePublishedFile_Public,
        ECommentThreadType::k_ECommentThreadTypeTest,
        ECommentThreadType::k_ECommentThreadTypeForumTopic,
        ECommentThreadType::k_ECommentThreadTypeRecommendation,
        ECommentThreadType::k_ECommentThreadTypeVideo_Deprecated,
        ECommentThreadType::k_ECommentThreadTypeProfile,
        ECommentThreadType::k_ECommentThreadTypeNewsPost,
        ECommentThreadType::k_ECommentThreadTypeClan,
        ECommentThreadType::k_ECommentThreadTypeClanAnnouncement,
        ECommentThreadType::k_ECommentThreadTypeClanEvent,
        ECommentThreadType::k_ECommentThreadTypeUserStatusPublished,
        ECommentThreadType::k_ECommentThreadTypeUserReceivedNewGame,
        ECommentThreadType::k_ECommentThreadTypePublishedFile_Announcement,
        ECommentThreadType::k_ECommentThreadTypeModeratorMessage,
        ECommentThreadType::k_ECommentThreadTypeClanCuratedApp,
        ECommentThreadType::k_ECommentThreadTypeQAndASession,
        ECommentThreadType::k_ECommentThreadTypeMax,
    ];
}

impl ::std::default::Default for ECommentThreadType {
    fn default() -> Self {
        ECommentThreadType::k_ECommentThreadTypeInvalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBroadcastPermission)
pub enum EBroadcastPermission {
    // @@protoc_insertion_point(enum_value:EBroadcastPermission.k_EBroadcastPermissionDisabled)
    k_EBroadcastPermissionDisabled = 0,
    // @@protoc_insertion_point(enum_value:EBroadcastPermission.k_EBroadcastPermissionFriendsApprove)
    k_EBroadcastPermissionFriendsApprove = 1,
    // @@protoc_insertion_point(enum_value:EBroadcastPermission.k_EBroadcastPermissionFriendsAllowed)
    k_EBroadcastPermissionFriendsAllowed = 2,
    // @@protoc_insertion_point(enum_value:EBroadcastPermission.k_EBroadcastPermissionPublic)
    k_EBroadcastPermissionPublic = 3,
    // @@protoc_insertion_point(enum_value:EBroadcastPermission.k_EBroadcastPermissionSubscribers)
    k_EBroadcastPermissionSubscribers = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for EBroadcastPermission {
    const NAME: &'static str = "EBroadcastPermission";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBroadcastPermission> {
        match value {
            0 => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionDisabled),
            1 => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionFriendsApprove),
            2 => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionFriendsAllowed),
            3 => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionPublic),
            4 => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionSubscribers),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBroadcastPermission> {
        match str {
            "k_EBroadcastPermissionDisabled" => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionDisabled),
            "k_EBroadcastPermissionFriendsApprove" => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionFriendsApprove),
            "k_EBroadcastPermissionFriendsAllowed" => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionFriendsAllowed),
            "k_EBroadcastPermissionPublic" => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionPublic),
            "k_EBroadcastPermissionSubscribers" => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionSubscribers),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBroadcastPermission] = &[
        EBroadcastPermission::k_EBroadcastPermissionDisabled,
        EBroadcastPermission::k_EBroadcastPermissionFriendsApprove,
        EBroadcastPermission::k_EBroadcastPermissionFriendsAllowed,
        EBroadcastPermission::k_EBroadcastPermissionPublic,
        EBroadcastPermission::k_EBroadcastPermissionSubscribers,
    ];
}

impl ::std::default::Default for EBroadcastPermission {
    fn default() -> Self {
        EBroadcastPermission::k_EBroadcastPermissionDisabled
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBroadcastEncoderSetting)
pub enum EBroadcastEncoderSetting {
    // @@protoc_insertion_point(enum_value:EBroadcastEncoderSetting.k_EBroadcastEncoderBestQuality)
    k_EBroadcastEncoderBestQuality = 0,
    // @@protoc_insertion_point(enum_value:EBroadcastEncoderSetting.k_EBroadcastEncoderBestPerformance)
    k_EBroadcastEncoderBestPerformance = 1,
}

impl ::steam_vent_proto_common::protobuf::Enum for EBroadcastEncoderSetting {
    const NAME: &'static str = "EBroadcastEncoderSetting";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBroadcastEncoderSetting> {
        match value {
            0 => ::std::option::Option::Some(EBroadcastEncoderSetting::k_EBroadcastEncoderBestQuality),
            1 => ::std::option::Option::Some(EBroadcastEncoderSetting::k_EBroadcastEncoderBestPerformance),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBroadcastEncoderSetting> {
        match str {
            "k_EBroadcastEncoderBestQuality" => ::std::option::Option::Some(EBroadcastEncoderSetting::k_EBroadcastEncoderBestQuality),
            "k_EBroadcastEncoderBestPerformance" => ::std::option::Option::Some(EBroadcastEncoderSetting::k_EBroadcastEncoderBestPerformance),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBroadcastEncoderSetting] = &[
        EBroadcastEncoderSetting::k_EBroadcastEncoderBestQuality,
        EBroadcastEncoderSetting::k_EBroadcastEncoderBestPerformance,
    ];
}

impl ::std::default::Default for EBroadcastEncoderSetting {
    fn default() -> Self {
        EBroadcastEncoderSetting::k_EBroadcastEncoderBestQuality
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECloudGamingPlatform)
pub enum ECloudGamingPlatform {
    // @@protoc_insertion_point(enum_value:ECloudGamingPlatform.k_ECloudGamingPlatformNone)
    k_ECloudGamingPlatformNone = 0,
    // @@protoc_insertion_point(enum_value:ECloudGamingPlatform.k_ECloudGamingPlatformValve)
    k_ECloudGamingPlatformValve = 1,
    // @@protoc_insertion_point(enum_value:ECloudGamingPlatform.k_ECloudGamingPlatformNVIDIA)
    k_ECloudGamingPlatformNVIDIA = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for ECloudGamingPlatform {
    const NAME: &'static str = "ECloudGamingPlatform";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECloudGamingPlatform> {
        match value {
            0 => ::std::option::Option::Some(ECloudGamingPlatform::k_ECloudGamingPlatformNone),
            1 => ::std::option::Option::Some(ECloudGamingPlatform::k_ECloudGamingPlatformValve),
            2 => ::std::option::Option::Some(ECloudGamingPlatform::k_ECloudGamingPlatformNVIDIA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECloudGamingPlatform> {
        match str {
            "k_ECloudGamingPlatformNone" => ::std::option::Option::Some(ECloudGamingPlatform::k_ECloudGamingPlatformNone),
            "k_ECloudGamingPlatformValve" => ::std::option::Option::Some(ECloudGamingPlatform::k_ECloudGamingPlatformValve),
            "k_ECloudGamingPlatformNVIDIA" => ::std::option::Option::Some(ECloudGamingPlatform::k_ECloudGamingPlatformNVIDIA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECloudGamingPlatform] = &[
        ECloudGamingPlatform::k_ECloudGamingPlatformNone,
        ECloudGamingPlatform::k_ECloudGamingPlatformValve,
        ECloudGamingPlatform::k_ECloudGamingPlatformNVIDIA,
    ];
}

impl ::std::default::Default for ECloudGamingPlatform {
    fn default() -> Self {
        ECloudGamingPlatform::k_ECloudGamingPlatformNone
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECompromiseDetectionType)
pub enum ECompromiseDetectionType {
    // @@protoc_insertion_point(enum_value:ECompromiseDetectionType.k_ECompromiseDetectionType_None)
    k_ECompromiseDetectionType_None = 0,
    // @@protoc_insertion_point(enum_value:ECompromiseDetectionType.k_ECompromiseDetectionType_TradeEvent)
    k_ECompromiseDetectionType_TradeEvent = 1,
    // @@protoc_insertion_point(enum_value:ECompromiseDetectionType.k_ECompromiseDetectionType_ApiCallRate)
    k_ECompromiseDetectionType_ApiCallRate = 2,
    // @@protoc_insertion_point(enum_value:ECompromiseDetectionType.k_ECompromiseDetectionType_Manual)
    k_ECompromiseDetectionType_Manual = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for ECompromiseDetectionType {
    const NAME: &'static str = "ECompromiseDetectionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECompromiseDetectionType> {
        match value {
            0 => ::std::option::Option::Some(ECompromiseDetectionType::k_ECompromiseDetectionType_None),
            1 => ::std::option::Option::Some(ECompromiseDetectionType::k_ECompromiseDetectionType_TradeEvent),
            2 => ::std::option::Option::Some(ECompromiseDetectionType::k_ECompromiseDetectionType_ApiCallRate),
            3 => ::std::option::Option::Some(ECompromiseDetectionType::k_ECompromiseDetectionType_Manual),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECompromiseDetectionType> {
        match str {
            "k_ECompromiseDetectionType_None" => ::std::option::Option::Some(ECompromiseDetectionType::k_ECompromiseDetectionType_None),
            "k_ECompromiseDetectionType_TradeEvent" => ::std::option::Option::Some(ECompromiseDetectionType::k_ECompromiseDetectionType_TradeEvent),
            "k_ECompromiseDetectionType_ApiCallRate" => ::std::option::Option::Some(ECompromiseDetectionType::k_ECompromiseDetectionType_ApiCallRate),
            "k_ECompromiseDetectionType_Manual" => ::std::option::Option::Some(ECompromiseDetectionType::k_ECompromiseDetectionType_Manual),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECompromiseDetectionType] = &[
        ECompromiseDetectionType::k_ECompromiseDetectionType_None,
        ECompromiseDetectionType::k_ECompromiseDetectionType_TradeEvent,
        ECompromiseDetectionType::k_ECompromiseDetectionType_ApiCallRate,
        ECompromiseDetectionType::k_ECompromiseDetectionType_Manual,
    ];
}

impl ::std::default::Default for ECompromiseDetectionType {
    fn default() -> Self {
        ECompromiseDetectionType::k_ECompromiseDetectionType_None
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EAsyncGameSessionUserState)
pub enum EAsyncGameSessionUserState {
    // @@protoc_insertion_point(enum_value:EAsyncGameSessionUserState.k_EAsyncGameSessionUserStateUnknown)
    k_EAsyncGameSessionUserStateUnknown = -1,
    // @@protoc_insertion_point(enum_value:EAsyncGameSessionUserState.k_EAsyncGameSessionUserStateWaitingForOthers)
    k_EAsyncGameSessionUserStateWaitingForOthers = 0,
    // @@protoc_insertion_point(enum_value:EAsyncGameSessionUserState.k_EAsyncGameSessionUserStateReadyForAction)
    k_EAsyncGameSessionUserStateReadyForAction = 1,
    // @@protoc_insertion_point(enum_value:EAsyncGameSessionUserState.k_EAsyncGameSessionUserStateDone)
    k_EAsyncGameSessionUserStateDone = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EAsyncGameSessionUserState {
    const NAME: &'static str = "EAsyncGameSessionUserState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EAsyncGameSessionUserState> {
        match value {
            -1 => ::std::option::Option::Some(EAsyncGameSessionUserState::k_EAsyncGameSessionUserStateUnknown),
            0 => ::std::option::Option::Some(EAsyncGameSessionUserState::k_EAsyncGameSessionUserStateWaitingForOthers),
            1 => ::std::option::Option::Some(EAsyncGameSessionUserState::k_EAsyncGameSessionUserStateReadyForAction),
            2 => ::std::option::Option::Some(EAsyncGameSessionUserState::k_EAsyncGameSessionUserStateDone),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EAsyncGameSessionUserState> {
        match str {
            "k_EAsyncGameSessionUserStateUnknown" => ::std::option::Option::Some(EAsyncGameSessionUserState::k_EAsyncGameSessionUserStateUnknown),
            "k_EAsyncGameSessionUserStateWaitingForOthers" => ::std::option::Option::Some(EAsyncGameSessionUserState::k_EAsyncGameSessionUserStateWaitingForOthers),
            "k_EAsyncGameSessionUserStateReadyForAction" => ::std::option::Option::Some(EAsyncGameSessionUserState::k_EAsyncGameSessionUserStateReadyForAction),
            "k_EAsyncGameSessionUserStateDone" => ::std::option::Option::Some(EAsyncGameSessionUserState::k_EAsyncGameSessionUserStateDone),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EAsyncGameSessionUserState] = &[
        EAsyncGameSessionUserState::k_EAsyncGameSessionUserStateUnknown,
        EAsyncGameSessionUserState::k_EAsyncGameSessionUserStateWaitingForOthers,
        EAsyncGameSessionUserState::k_EAsyncGameSessionUserStateReadyForAction,
        EAsyncGameSessionUserState::k_EAsyncGameSessionUserStateDone,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EAsyncGameSessionUserState {
    fn default() -> Self {
        EAsyncGameSessionUserState::k_EAsyncGameSessionUserStateUnknown
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EAsyncGameSessionUserVisibility)
pub enum EAsyncGameSessionUserVisibility {
    // @@protoc_insertion_point(enum_value:EAsyncGameSessionUserVisibility.k_EAsyncGameSessionUserVisibilityEnvelopeAndSessionList)
    k_EAsyncGameSessionUserVisibilityEnvelopeAndSessionList = 0,
    // @@protoc_insertion_point(enum_value:EAsyncGameSessionUserVisibility.k_EAsyncGameSessionUserVisibilitySessionListOnly)
    k_EAsyncGameSessionUserVisibilitySessionListOnly = 1,
    // @@protoc_insertion_point(enum_value:EAsyncGameSessionUserVisibility.k_EAsyncGameSessionUserVisibilityDismissed)
    k_EAsyncGameSessionUserVisibilityDismissed = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EAsyncGameSessionUserVisibility {
    const NAME: &'static str = "EAsyncGameSessionUserVisibility";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EAsyncGameSessionUserVisibility> {
        match value {
            0 => ::std::option::Option::Some(EAsyncGameSessionUserVisibility::k_EAsyncGameSessionUserVisibilityEnvelopeAndSessionList),
            1 => ::std::option::Option::Some(EAsyncGameSessionUserVisibility::k_EAsyncGameSessionUserVisibilitySessionListOnly),
            2 => ::std::option::Option::Some(EAsyncGameSessionUserVisibility::k_EAsyncGameSessionUserVisibilityDismissed),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EAsyncGameSessionUserVisibility> {
        match str {
            "k_EAsyncGameSessionUserVisibilityEnvelopeAndSessionList" => ::std::option::Option::Some(EAsyncGameSessionUserVisibility::k_EAsyncGameSessionUserVisibilityEnvelopeAndSessionList),
            "k_EAsyncGameSessionUserVisibilitySessionListOnly" => ::std::option::Option::Some(EAsyncGameSessionUserVisibility::k_EAsyncGameSessionUserVisibilitySessionListOnly),
            "k_EAsyncGameSessionUserVisibilityDismissed" => ::std::option::Option::Some(EAsyncGameSessionUserVisibility::k_EAsyncGameSessionUserVisibilityDismissed),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EAsyncGameSessionUserVisibility] = &[
        EAsyncGameSessionUserVisibility::k_EAsyncGameSessionUserVisibilityEnvelopeAndSessionList,
        EAsyncGameSessionUserVisibility::k_EAsyncGameSessionUserVisibilitySessionListOnly,
        EAsyncGameSessionUserVisibility::k_EAsyncGameSessionUserVisibilityDismissed,
    ];
}

impl ::std::default::Default for EAsyncGameSessionUserVisibility {
    fn default() -> Self {
        EAsyncGameSessionUserVisibility::k_EAsyncGameSessionUserVisibilityEnvelopeAndSessionList
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGameRecordingType)
pub enum EGameRecordingType {
    // @@protoc_insertion_point(enum_value:EGameRecordingType.k_EGameRecordingType_Unknown)
    k_EGameRecordingType_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EGameRecordingType.k_EGameRecordingType_NotRecording)
    k_EGameRecordingType_NotRecording = 1,
    // @@protoc_insertion_point(enum_value:EGameRecordingType.k_EGameRecordingType_ManualRecording)
    k_EGameRecordingType_ManualRecording = 2,
    // @@protoc_insertion_point(enum_value:EGameRecordingType.k_EGameRecordingType_BackgroundRecording)
    k_EGameRecordingType_BackgroundRecording = 3,
    // @@protoc_insertion_point(enum_value:EGameRecordingType.k_EGameRecordingType_Clip)
    k_EGameRecordingType_Clip = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for EGameRecordingType {
    const NAME: &'static str = "EGameRecordingType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGameRecordingType> {
        match value {
            0 => ::std::option::Option::Some(EGameRecordingType::k_EGameRecordingType_Unknown),
            1 => ::std::option::Option::Some(EGameRecordingType::k_EGameRecordingType_NotRecording),
            2 => ::std::option::Option::Some(EGameRecordingType::k_EGameRecordingType_ManualRecording),
            3 => ::std::option::Option::Some(EGameRecordingType::k_EGameRecordingType_BackgroundRecording),
            4 => ::std::option::Option::Some(EGameRecordingType::k_EGameRecordingType_Clip),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGameRecordingType> {
        match str {
            "k_EGameRecordingType_Unknown" => ::std::option::Option::Some(EGameRecordingType::k_EGameRecordingType_Unknown),
            "k_EGameRecordingType_NotRecording" => ::std::option::Option::Some(EGameRecordingType::k_EGameRecordingType_NotRecording),
            "k_EGameRecordingType_ManualRecording" => ::std::option::Option::Some(EGameRecordingType::k_EGameRecordingType_ManualRecording),
            "k_EGameRecordingType_BackgroundRecording" => ::std::option::Option::Some(EGameRecordingType::k_EGameRecordingType_BackgroundRecording),
            "k_EGameRecordingType_Clip" => ::std::option::Option::Some(EGameRecordingType::k_EGameRecordingType_Clip),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGameRecordingType] = &[
        EGameRecordingType::k_EGameRecordingType_Unknown,
        EGameRecordingType::k_EGameRecordingType_NotRecording,
        EGameRecordingType::k_EGameRecordingType_ManualRecording,
        EGameRecordingType::k_EGameRecordingType_BackgroundRecording,
        EGameRecordingType::k_EGameRecordingType_Clip,
    ];
}

impl ::std::default::Default for EGameRecordingType {
    fn default() -> Self {
        EGameRecordingType::k_EGameRecordingType_Unknown
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EProtoAppType)
pub enum EProtoAppType {
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeInvalid)
    k_EAppTypeInvalid = 0,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeGame)
    k_EAppTypeGame = 1,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeApplication)
    k_EAppTypeApplication = 2,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeTool)
    k_EAppTypeTool = 4,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeDemo)
    k_EAppTypeDemo = 8,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeDeprected)
    k_EAppTypeDeprected = 16,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeDLC)
    k_EAppTypeDLC = 32,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeGuide)
    k_EAppTypeGuide = 64,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeDriver)
    k_EAppTypeDriver = 128,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeConfig)
    k_EAppTypeConfig = 256,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeHardware)
    k_EAppTypeHardware = 512,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeFranchise)
    k_EAppTypeFranchise = 1024,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeVideo)
    k_EAppTypeVideo = 2048,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypePlugin)
    k_EAppTypePlugin = 4096,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeMusicAlbum)
    k_EAppTypeMusicAlbum = 8192,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeSeries)
    k_EAppTypeSeries = 16384,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeComic)
    k_EAppTypeComic = 32768,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeBeta)
    k_EAppTypeBeta = 65536,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeShortcut)
    k_EAppTypeShortcut = 1073741824,
    // @@protoc_insertion_point(enum_value:EProtoAppType.k_EAppTypeDepotOnly)
    k_EAppTypeDepotOnly = -2147483648,
}

impl ::steam_vent_proto_common::protobuf::Enum for EProtoAppType {
    const NAME: &'static str = "EProtoAppType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProtoAppType> {
        match value {
            0 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeInvalid),
            1 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeGame),
            2 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeApplication),
            4 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeTool),
            8 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeDemo),
            16 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeDeprected),
            32 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeDLC),
            64 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeGuide),
            128 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeDriver),
            256 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeConfig),
            512 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeHardware),
            1024 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeFranchise),
            2048 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeVideo),
            4096 => ::std::option::Option::Some(EProtoAppType::k_EAppTypePlugin),
            8192 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeMusicAlbum),
            16384 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeSeries),
            32768 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeComic),
            65536 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeBeta),
            1073741824 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeShortcut),
            -2147483648 => ::std::option::Option::Some(EProtoAppType::k_EAppTypeDepotOnly),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EProtoAppType> {
        match str {
            "k_EAppTypeInvalid" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeInvalid),
            "k_EAppTypeGame" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeGame),
            "k_EAppTypeApplication" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeApplication),
            "k_EAppTypeTool" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeTool),
            "k_EAppTypeDemo" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeDemo),
            "k_EAppTypeDeprected" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeDeprected),
            "k_EAppTypeDLC" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeDLC),
            "k_EAppTypeGuide" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeGuide),
            "k_EAppTypeDriver" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeDriver),
            "k_EAppTypeConfig" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeConfig),
            "k_EAppTypeHardware" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeHardware),
            "k_EAppTypeFranchise" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeFranchise),
            "k_EAppTypeVideo" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeVideo),
            "k_EAppTypePlugin" => ::std::option::Option::Some(EProtoAppType::k_EAppTypePlugin),
            "k_EAppTypeMusicAlbum" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeMusicAlbum),
            "k_EAppTypeSeries" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeSeries),
            "k_EAppTypeComic" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeComic),
            "k_EAppTypeBeta" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeBeta),
            "k_EAppTypeShortcut" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeShortcut),
            "k_EAppTypeDepotOnly" => ::std::option::Option::Some(EProtoAppType::k_EAppTypeDepotOnly),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EProtoAppType] = &[
        EProtoAppType::k_EAppTypeInvalid,
        EProtoAppType::k_EAppTypeGame,
        EProtoAppType::k_EAppTypeApplication,
        EProtoAppType::k_EAppTypeTool,
        EProtoAppType::k_EAppTypeDemo,
        EProtoAppType::k_EAppTypeDeprected,
        EProtoAppType::k_EAppTypeDLC,
        EProtoAppType::k_EAppTypeGuide,
        EProtoAppType::k_EAppTypeDriver,
        EProtoAppType::k_EAppTypeConfig,
        EProtoAppType::k_EAppTypeHardware,
        EProtoAppType::k_EAppTypeFranchise,
        EProtoAppType::k_EAppTypeVideo,
        EProtoAppType::k_EAppTypePlugin,
        EProtoAppType::k_EAppTypeMusicAlbum,
        EProtoAppType::k_EAppTypeSeries,
        EProtoAppType::k_EAppTypeComic,
        EProtoAppType::k_EAppTypeBeta,
        EProtoAppType::k_EAppTypeShortcut,
        EProtoAppType::k_EAppTypeDepotOnly,
    ];
}

impl ::std::default::Default for EProtoAppType {
    fn default() -> Self {
        EProtoAppType::k_EAppTypeInvalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EWindowsUpdateInstallationImpact)
pub enum EWindowsUpdateInstallationImpact {
    // @@protoc_insertion_point(enum_value:EWindowsUpdateInstallationImpact.k_EWindowsUpdateInstallationImpact_Unknown)
    k_EWindowsUpdateInstallationImpact_Unknown = -1,
    // @@protoc_insertion_point(enum_value:EWindowsUpdateInstallationImpact.k_EWindowsUpdateInstallationImpact_Normal)
    k_EWindowsUpdateInstallationImpact_Normal = 0,
    // @@protoc_insertion_point(enum_value:EWindowsUpdateInstallationImpact.k_EWindowsUpdateInstallationImpact_Minor)
    k_EWindowsUpdateInstallationImpact_Minor = 1,
    // @@protoc_insertion_point(enum_value:EWindowsUpdateInstallationImpact.k_EWindowsUpdateInstallationImpact_ExclusiveHandling)
    k_EWindowsUpdateInstallationImpact_ExclusiveHandling = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EWindowsUpdateInstallationImpact {
    const NAME: &'static str = "EWindowsUpdateInstallationImpact";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EWindowsUpdateInstallationImpact> {
        match value {
            -1 => ::std::option::Option::Some(EWindowsUpdateInstallationImpact::k_EWindowsUpdateInstallationImpact_Unknown),
            0 => ::std::option::Option::Some(EWindowsUpdateInstallationImpact::k_EWindowsUpdateInstallationImpact_Normal),
            1 => ::std::option::Option::Some(EWindowsUpdateInstallationImpact::k_EWindowsUpdateInstallationImpact_Minor),
            2 => ::std::option::Option::Some(EWindowsUpdateInstallationImpact::k_EWindowsUpdateInstallationImpact_ExclusiveHandling),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EWindowsUpdateInstallationImpact> {
        match str {
            "k_EWindowsUpdateInstallationImpact_Unknown" => ::std::option::Option::Some(EWindowsUpdateInstallationImpact::k_EWindowsUpdateInstallationImpact_Unknown),
            "k_EWindowsUpdateInstallationImpact_Normal" => ::std::option::Option::Some(EWindowsUpdateInstallationImpact::k_EWindowsUpdateInstallationImpact_Normal),
            "k_EWindowsUpdateInstallationImpact_Minor" => ::std::option::Option::Some(EWindowsUpdateInstallationImpact::k_EWindowsUpdateInstallationImpact_Minor),
            "k_EWindowsUpdateInstallationImpact_ExclusiveHandling" => ::std::option::Option::Some(EWindowsUpdateInstallationImpact::k_EWindowsUpdateInstallationImpact_ExclusiveHandling),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EWindowsUpdateInstallationImpact] = &[
        EWindowsUpdateInstallationImpact::k_EWindowsUpdateInstallationImpact_Unknown,
        EWindowsUpdateInstallationImpact::k_EWindowsUpdateInstallationImpact_Normal,
        EWindowsUpdateInstallationImpact::k_EWindowsUpdateInstallationImpact_Minor,
        EWindowsUpdateInstallationImpact::k_EWindowsUpdateInstallationImpact_ExclusiveHandling,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EWindowsUpdateInstallationImpact {
    fn default() -> Self {
        EWindowsUpdateInstallationImpact::k_EWindowsUpdateInstallationImpact_Unknown
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EWindowsUpdateRebootBehavior)
pub enum EWindowsUpdateRebootBehavior {
    // @@protoc_insertion_point(enum_value:EWindowsUpdateRebootBehavior.k_EWindowsUpdateRebootBehavior_Unknown)
    k_EWindowsUpdateRebootBehavior_Unknown = -1,
    // @@protoc_insertion_point(enum_value:EWindowsUpdateRebootBehavior.k_EWindowsUpdateRebootBehavior_NeverNeedsReboot)
    k_EWindowsUpdateRebootBehavior_NeverNeedsReboot = 0,
    // @@protoc_insertion_point(enum_value:EWindowsUpdateRebootBehavior.k_EWindowsUpdateRebootBehavior_AlwaysNeedsReboot)
    k_EWindowsUpdateRebootBehavior_AlwaysNeedsReboot = 1,
    // @@protoc_insertion_point(enum_value:EWindowsUpdateRebootBehavior.k_EWindowsUpdateRebootBehavior_MightNeedReboot)
    k_EWindowsUpdateRebootBehavior_MightNeedReboot = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EWindowsUpdateRebootBehavior {
    const NAME: &'static str = "EWindowsUpdateRebootBehavior";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EWindowsUpdateRebootBehavior> {
        match value {
            -1 => ::std::option::Option::Some(EWindowsUpdateRebootBehavior::k_EWindowsUpdateRebootBehavior_Unknown),
            0 => ::std::option::Option::Some(EWindowsUpdateRebootBehavior::k_EWindowsUpdateRebootBehavior_NeverNeedsReboot),
            1 => ::std::option::Option::Some(EWindowsUpdateRebootBehavior::k_EWindowsUpdateRebootBehavior_AlwaysNeedsReboot),
            2 => ::std::option::Option::Some(EWindowsUpdateRebootBehavior::k_EWindowsUpdateRebootBehavior_MightNeedReboot),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EWindowsUpdateRebootBehavior> {
        match str {
            "k_EWindowsUpdateRebootBehavior_Unknown" => ::std::option::Option::Some(EWindowsUpdateRebootBehavior::k_EWindowsUpdateRebootBehavior_Unknown),
            "k_EWindowsUpdateRebootBehavior_NeverNeedsReboot" => ::std::option::Option::Some(EWindowsUpdateRebootBehavior::k_EWindowsUpdateRebootBehavior_NeverNeedsReboot),
            "k_EWindowsUpdateRebootBehavior_AlwaysNeedsReboot" => ::std::option::Option::Some(EWindowsUpdateRebootBehavior::k_EWindowsUpdateRebootBehavior_AlwaysNeedsReboot),
            "k_EWindowsUpdateRebootBehavior_MightNeedReboot" => ::std::option::Option::Some(EWindowsUpdateRebootBehavior::k_EWindowsUpdateRebootBehavior_MightNeedReboot),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EWindowsUpdateRebootBehavior] = &[
        EWindowsUpdateRebootBehavior::k_EWindowsUpdateRebootBehavior_Unknown,
        EWindowsUpdateRebootBehavior::k_EWindowsUpdateRebootBehavior_NeverNeedsReboot,
        EWindowsUpdateRebootBehavior::k_EWindowsUpdateRebootBehavior_AlwaysNeedsReboot,
        EWindowsUpdateRebootBehavior::k_EWindowsUpdateRebootBehavior_MightNeedReboot,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EWindowsUpdateRebootBehavior {
    fn default() -> Self {
        EWindowsUpdateRebootBehavior::k_EWindowsUpdateRebootBehavior_Unknown
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EExternalSaleEventType)
pub enum EExternalSaleEventType {
    // @@protoc_insertion_point(enum_value:EExternalSaleEventType.k_EExternalSaleEventType_Unknown)
    k_EExternalSaleEventType_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EExternalSaleEventType.k_EExternalSaleEventType_Publisher)
    k_EExternalSaleEventType_Publisher = 1,
    // @@protoc_insertion_point(enum_value:EExternalSaleEventType.k_EExternalSaleEventType_Showcase)
    k_EExternalSaleEventType_Showcase = 2,
    // @@protoc_insertion_point(enum_value:EExternalSaleEventType.k_EExternalSaleEventType_Region)
    k_EExternalSaleEventType_Region = 3,
    // @@protoc_insertion_point(enum_value:EExternalSaleEventType.k_EExternalSaleEventType_Theme)
    k_EExternalSaleEventType_Theme = 4,
    // @@protoc_insertion_point(enum_value:EExternalSaleEventType.k_EExternalSaleEventType_Franchise)
    k_EExternalSaleEventType_Franchise = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for EExternalSaleEventType {
    const NAME: &'static str = "EExternalSaleEventType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EExternalSaleEventType> {
        match value {
            0 => ::std::option::Option::Some(EExternalSaleEventType::k_EExternalSaleEventType_Unknown),
            1 => ::std::option::Option::Some(EExternalSaleEventType::k_EExternalSaleEventType_Publisher),
            2 => ::std::option::Option::Some(EExternalSaleEventType::k_EExternalSaleEventType_Showcase),
            3 => ::std::option::Option::Some(EExternalSaleEventType::k_EExternalSaleEventType_Region),
            4 => ::std::option::Option::Some(EExternalSaleEventType::k_EExternalSaleEventType_Theme),
            5 => ::std::option::Option::Some(EExternalSaleEventType::k_EExternalSaleEventType_Franchise),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EExternalSaleEventType> {
        match str {
            "k_EExternalSaleEventType_Unknown" => ::std::option::Option::Some(EExternalSaleEventType::k_EExternalSaleEventType_Unknown),
            "k_EExternalSaleEventType_Publisher" => ::std::option::Option::Some(EExternalSaleEventType::k_EExternalSaleEventType_Publisher),
            "k_EExternalSaleEventType_Showcase" => ::std::option::Option::Some(EExternalSaleEventType::k_EExternalSaleEventType_Showcase),
            "k_EExternalSaleEventType_Region" => ::std::option::Option::Some(EExternalSaleEventType::k_EExternalSaleEventType_Region),
            "k_EExternalSaleEventType_Theme" => ::std::option::Option::Some(EExternalSaleEventType::k_EExternalSaleEventType_Theme),
            "k_EExternalSaleEventType_Franchise" => ::std::option::Option::Some(EExternalSaleEventType::k_EExternalSaleEventType_Franchise),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EExternalSaleEventType] = &[
        EExternalSaleEventType::k_EExternalSaleEventType_Unknown,
        EExternalSaleEventType::k_EExternalSaleEventType_Publisher,
        EExternalSaleEventType::k_EExternalSaleEventType_Showcase,
        EExternalSaleEventType::k_EExternalSaleEventType_Region,
        EExternalSaleEventType::k_EExternalSaleEventType_Theme,
        EExternalSaleEventType::k_EExternalSaleEventType_Franchise,
    ];
}

impl ::std::default::Default for EExternalSaleEventType {
    fn default() -> Self {
        EExternalSaleEventType::k_EExternalSaleEventType_Unknown
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;