// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientserver_mms.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSSetRatelimitPolicyOnClient)
pub struct CMsgClientMMSSetRatelimitPolicyOnClient {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetRatelimitPolicyOnClient.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetRatelimitPolicyOnClient.enable_rate_limits)
    pub enable_rate_limits: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetRatelimitPolicyOnClient.seconds_per_message)
    pub seconds_per_message: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetRatelimitPolicyOnClient.milliseconds_per_data_update)
    pub milliseconds_per_data_update: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetRatelimitPolicyOnClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetRatelimitPolicyOnClient {
    fn default() -> &'a CMsgClientMMSSetRatelimitPolicyOnClient {
        <CMsgClientMMSSetRatelimitPolicyOnClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetRatelimitPolicyOnClient {
    pub fn new() -> CMsgClientMMSSetRatelimitPolicyOnClient {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bool enable_rate_limits = 2;

    pub fn enable_rate_limits(&self) -> bool {
        self.enable_rate_limits.unwrap_or(false)
    }

    pub fn clear_enable_rate_limits(&mut self) {
        self.enable_rate_limits = ::std::option::Option::None;
    }

    pub fn has_enable_rate_limits(&self) -> bool {
        self.enable_rate_limits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_rate_limits(&mut self, v: bool) {
        self.enable_rate_limits = ::std::option::Option::Some(v);
    }

    // optional int32 seconds_per_message = 3;

    pub fn seconds_per_message(&self) -> i32 {
        self.seconds_per_message.unwrap_or(0)
    }

    pub fn clear_seconds_per_message(&mut self) {
        self.seconds_per_message = ::std::option::Option::None;
    }

    pub fn has_seconds_per_message(&self) -> bool {
        self.seconds_per_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_per_message(&mut self, v: i32) {
        self.seconds_per_message = ::std::option::Option::Some(v);
    }

    // optional int32 milliseconds_per_data_update = 4;

    pub fn milliseconds_per_data_update(&self) -> i32 {
        self.milliseconds_per_data_update.unwrap_or(0)
    }

    pub fn clear_milliseconds_per_data_update(&mut self) {
        self.milliseconds_per_data_update = ::std::option::Option::None;
    }

    pub fn has_milliseconds_per_data_update(&self) -> bool {
        self.milliseconds_per_data_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_milliseconds_per_data_update(&mut self, v: i32) {
        self.milliseconds_per_data_update = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetRatelimitPolicyOnClient {
    const NAME: &'static str = "CMsgClientMMSSetRatelimitPolicyOnClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.enable_rate_limits = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.seconds_per_message = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.milliseconds_per_data_update = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.enable_rate_limits {
            my_size += 1 + 1;
        }
        if let Some(v) = self.seconds_per_message {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.milliseconds_per_data_update {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.enable_rate_limits {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.seconds_per_message {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.milliseconds_per_data_update {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetRatelimitPolicyOnClient {
        CMsgClientMMSSetRatelimitPolicyOnClient::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.enable_rate_limits = ::std::option::Option::None;
        self.seconds_per_message = ::std::option::Option::None;
        self.milliseconds_per_data_update = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetRatelimitPolicyOnClient {
        static instance: CMsgClientMMSSetRatelimitPolicyOnClient = CMsgClientMMSSetRatelimitPolicyOnClient {
            app_id: ::std::option::Option::None,
            enable_rate_limits: ::std::option::Option::None,
            seconds_per_message: ::std::option::Option::None,
            milliseconds_per_data_update: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSCreateLobby)
pub struct CMsgClientMMSCreateLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.max_members)
    pub max_members: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.lobby_type)
    pub lobby_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.lobby_flags)
    pub lobby_flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.deprecated_public_ip)
    pub deprecated_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.metadata)
    pub metadata: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.persona_name_owner)
    pub persona_name_owner: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobby.public_ip)
    pub public_ip: ::protobuf::MessageField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSCreateLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSCreateLobby {
    fn default() -> &'a CMsgClientMMSCreateLobby {
        <CMsgClientMMSCreateLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSCreateLobby {
    pub fn new() -> CMsgClientMMSCreateLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 2;

    pub fn max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 3;

    pub fn lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 4;

    pub fn lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 5;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_public_ip = 6;

    pub fn deprecated_public_ip(&self) -> u32 {
        self.deprecated_public_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_public_ip(&mut self) {
        self.deprecated_public_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_public_ip(&self) -> bool {
        self.deprecated_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_public_ip(&mut self, v: u32) {
        self.deprecated_public_ip = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 7;

    pub fn metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string persona_name_owner = 8;

    pub fn persona_name_owner(&self) -> &str {
        match self.persona_name_owner.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name_owner(&mut self) {
        self.persona_name_owner = ::std::option::Option::None;
    }

    pub fn has_persona_name_owner(&self) -> bool {
        self.persona_name_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name_owner(&mut self, v: ::std::string::String) {
        self.persona_name_owner = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name_owner(&mut self) -> &mut ::std::string::String {
        if self.persona_name_owner.is_none() {
            self.persona_name_owner = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona_name_owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name_owner(&mut self) -> ::std::string::String {
        self.persona_name_owner.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSCreateLobby {
    const NAME: &'static str = "CMsgClientMMSCreateLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.max_members = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.deprecated_public_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.metadata = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.persona_name_owner = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.public_ip)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.deprecated_public_ip {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.persona_name_owner.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.public_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.deprecated_public_ip {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.persona_name_owner.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.public_ip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSCreateLobby {
        CMsgClientMMSCreateLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.deprecated_public_ip = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.persona_name_owner = ::std::option::Option::None;
        self.public_ip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSCreateLobby {
        static instance: CMsgClientMMSCreateLobby = CMsgClientMMSCreateLobby {
            app_id: ::std::option::Option::None,
            max_members: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            lobby_flags: ::std::option::Option::None,
            cell_id: ::std::option::Option::None,
            deprecated_public_ip: ::std::option::Option::None,
            metadata: ::std::option::Option::None,
            persona_name_owner: ::std::option::Option::None,
            public_ip: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSCreateLobbyResponse)
pub struct CMsgClientMMSCreateLobbyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobbyResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobbyResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSCreateLobbyResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSCreateLobbyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSCreateLobbyResponse {
    fn default() -> &'a CMsgClientMMSCreateLobbyResponse {
        <CMsgClientMMSCreateLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSCreateLobbyResponse {
    pub fn new() -> CMsgClientMMSCreateLobbyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSCreateLobbyResponse {
    const NAME: &'static str = "CMsgClientMMSCreateLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSCreateLobbyResponse {
        CMsgClientMMSCreateLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSCreateLobbyResponse {
        static instance: CMsgClientMMSCreateLobbyResponse = CMsgClientMMSCreateLobbyResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSJoinLobby)
pub struct CMsgClientMMSJoinLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobby.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobby.persona_name)
    pub persona_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSJoinLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSJoinLobby {
    fn default() -> &'a CMsgClientMMSJoinLobby {
        <CMsgClientMMSJoinLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSJoinLobby {
    pub fn new() -> CMsgClientMMSJoinLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 3;

    pub fn persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name(&mut self) {
        self.persona_name = ::std::option::Option::None;
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSJoinLobby {
    const NAME: &'static str = "CMsgClientMMSJoinLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.persona_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.persona_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSJoinLobby {
        CMsgClientMMSJoinLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.persona_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSJoinLobby {
        static instance: CMsgClientMMSJoinLobby = CMsgClientMMSJoinLobby {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            persona_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSJoinLobbyResponse)
pub struct CMsgClientMMSJoinLobbyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.chat_room_enter_response)
    pub chat_room_enter_response: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.max_members)
    pub max_members: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.lobby_type)
    pub lobby_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.lobby_flags)
    pub lobby_flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.steam_id_owner)
    pub steam_id_owner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.metadata)
    pub metadata: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.members)
    pub members: ::std::vec::Vec<cmsg_client_mmsjoin_lobby_response::Member>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSJoinLobbyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSJoinLobbyResponse {
    fn default() -> &'a CMsgClientMMSJoinLobbyResponse {
        <CMsgClientMMSJoinLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSJoinLobbyResponse {
    pub fn new() -> CMsgClientMMSJoinLobbyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 chat_room_enter_response = 3;

    pub fn chat_room_enter_response(&self) -> i32 {
        self.chat_room_enter_response.unwrap_or(0)
    }

    pub fn clear_chat_room_enter_response(&mut self) {
        self.chat_room_enter_response = ::std::option::Option::None;
    }

    pub fn has_chat_room_enter_response(&self) -> bool {
        self.chat_room_enter_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_enter_response(&mut self, v: i32) {
        self.chat_room_enter_response = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 4;

    pub fn max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 5;

    pub fn lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 6;

    pub fn lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_owner = 7;

    pub fn steam_id_owner(&self) -> u64 {
        self.steam_id_owner.unwrap_or(0)
    }

    pub fn clear_steam_id_owner(&mut self) {
        self.steam_id_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_owner(&self) -> bool {
        self.steam_id_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_owner(&mut self, v: u64) {
        self.steam_id_owner = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 8;

    pub fn metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSJoinLobbyResponse {
    const NAME: &'static str = "CMsgClientMMSJoinLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.chat_room_enter_response = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.max_members = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                57 => {
                    self.steam_id_owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                66 => {
                    self.metadata = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    self.members.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_room_enter_response {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.steam_id_owner {
            my_size += 1 + 8;
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.chat_room_enter_response {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.steam_id_owner {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(8, v)?;
        }
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSJoinLobbyResponse {
        CMsgClientMMSJoinLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.chat_room_enter_response = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.steam_id_owner = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSJoinLobbyResponse {
        static instance: CMsgClientMMSJoinLobbyResponse = CMsgClientMMSJoinLobbyResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            chat_room_enter_response: ::std::option::Option::None,
            max_members: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            lobby_flags: ::std::option::Option::None,
            steam_id_owner: ::std::option::Option::None,
            metadata: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientMMSJoinLobbyResponse`
pub mod cmsg_client_mmsjoin_lobby_response {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientMMSJoinLobbyResponse.Member)
    pub struct Member {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.Member.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.Member.persona_name)
        pub persona_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientMMSJoinLobbyResponse.Member.metadata)
        pub metadata: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientMMSJoinLobbyResponse.Member.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Member {
        fn default() -> &'a Member {
            <Member as ::protobuf::Message>::default_instance()
        }
    }

    impl Member {
        pub fn new() -> Member {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional string persona_name = 2;

        pub fn persona_name(&self) -> &str {
            match self.persona_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_persona_name(&mut self) {
            self.persona_name = ::std::option::Option::None;
        }

        pub fn has_persona_name(&self) -> bool {
            self.persona_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_name(&mut self, v: ::std::string::String) {
            self.persona_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
            if self.persona_name.is_none() {
                self.persona_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.persona_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_persona_name(&mut self) -> ::std::string::String {
            self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes metadata = 3;

        pub fn metadata(&self) -> &[u8] {
            match self.metadata.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_metadata(&mut self) {
            self.metadata = ::std::option::Option::None;
        }

        pub fn has_metadata(&self) -> bool {
            self.metadata.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
            self.metadata = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.metadata.is_none() {
                self.metadata = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.metadata.as_mut().unwrap()
        }

        // Take field
        pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
            self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for Member {
        const NAME: &'static str = "Member";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    18 => {
                        self.persona_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.metadata = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.persona_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.metadata.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.persona_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.metadata.as_ref() {
                os.write_bytes(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Member {
            Member::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.persona_name = ::std::option::Option::None;
            self.metadata = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Member {
            static instance: Member = Member {
                steam_id: ::std::option::Option::None,
                persona_name: ::std::option::Option::None,
                metadata: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSLeaveLobby)
pub struct CMsgClientMMSLeaveLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSLeaveLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLeaveLobby.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSLeaveLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLeaveLobby {
    fn default() -> &'a CMsgClientMMSLeaveLobby {
        <CMsgClientMMSLeaveLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLeaveLobby {
    pub fn new() -> CMsgClientMMSLeaveLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSLeaveLobby {
    const NAME: &'static str = "CMsgClientMMSLeaveLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSLeaveLobby {
        CMsgClientMMSLeaveLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSLeaveLobby {
        static instance: CMsgClientMMSLeaveLobby = CMsgClientMMSLeaveLobby {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSLeaveLobbyResponse)
pub struct CMsgClientMMSLeaveLobbyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSLeaveLobbyResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLeaveLobbyResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLeaveLobbyResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSLeaveLobbyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLeaveLobbyResponse {
    fn default() -> &'a CMsgClientMMSLeaveLobbyResponse {
        <CMsgClientMMSLeaveLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLeaveLobbyResponse {
    pub fn new() -> CMsgClientMMSLeaveLobbyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSLeaveLobbyResponse {
    const NAME: &'static str = "CMsgClientMMSLeaveLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSLeaveLobbyResponse {
        CMsgClientMMSLeaveLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSLeaveLobbyResponse {
        static instance: CMsgClientMMSLeaveLobbyResponse = CMsgClientMMSLeaveLobbyResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSGetLobbyList)
pub struct CMsgClientMMSGetLobbyList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.num_lobbies_requested)
    pub num_lobbies_requested: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.cell_id)
    pub cell_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.deprecated_public_ip)
    pub deprecated_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.filters)
    pub filters: ::std::vec::Vec<cmsg_client_mmsget_lobby_list::Filter>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.public_ip)
    pub public_ip: ::protobuf::MessageField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyList {
    fn default() -> &'a CMsgClientMMSGetLobbyList {
        <CMsgClientMMSGetLobbyList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyList {
    pub fn new() -> CMsgClientMMSGetLobbyList {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 num_lobbies_requested = 3;

    pub fn num_lobbies_requested(&self) -> i32 {
        self.num_lobbies_requested.unwrap_or(0)
    }

    pub fn clear_num_lobbies_requested(&mut self) {
        self.num_lobbies_requested = ::std::option::Option::None;
    }

    pub fn has_num_lobbies_requested(&self) -> bool {
        self.num_lobbies_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_lobbies_requested(&mut self, v: i32) {
        self.num_lobbies_requested = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 4;

    pub fn cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_public_ip = 5;

    pub fn deprecated_public_ip(&self) -> u32 {
        self.deprecated_public_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_public_ip(&mut self) {
        self.deprecated_public_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_public_ip(&self) -> bool {
        self.deprecated_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_public_ip(&mut self, v: u32) {
        self.deprecated_public_ip = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyList {
    const NAME: &'static str = "CMsgClientMMSGetLobbyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.num_lobbies_requested = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.deprecated_public_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.filters.push(is.read_message()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.public_ip)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.num_lobbies_requested {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.deprecated_public_ip {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.public_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_lobbies_requested {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.deprecated_public_ip {
            os.write_uint32(5, v)?;
        }
        for v in &self.filters {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.public_ip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSGetLobbyList {
        CMsgClientMMSGetLobbyList::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.num_lobbies_requested = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.deprecated_public_ip = ::std::option::Option::None;
        self.filters.clear();
        self.public_ip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyList {
        static instance: CMsgClientMMSGetLobbyList = CMsgClientMMSGetLobbyList {
            app_id: ::std::option::Option::None,
            num_lobbies_requested: ::std::option::Option::None,
            cell_id: ::std::option::Option::None,
            deprecated_public_ip: ::std::option::Option::None,
            filters: ::std::vec::Vec::new(),
            public_ip: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientMMSGetLobbyList`
pub mod cmsg_client_mmsget_lobby_list {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientMMSGetLobbyList.Filter)
    pub struct Filter {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.Filter.key)
        pub key: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.Filter.value)
        pub value: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.Filter.comparision)
        pub comparision: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyList.Filter.filter_type)
        pub filter_type: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyList.Filter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Filter {
        fn default() -> &'a Filter {
            <Filter as ::protobuf::Message>::default_instance()
        }
    }

    impl Filter {
        pub fn new() -> Filter {
            ::std::default::Default::default()
        }

        // optional string key = 1;

        pub fn key(&self) -> &str {
            match self.key.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_key(&mut self) {
            self.key = ::std::option::Option::None;
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            if self.key.is_none() {
                self.key = ::std::option::Option::Some(::std::string::String::new());
            }
            self.key.as_mut().unwrap()
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            self.key.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 comparision = 3;

        pub fn comparision(&self) -> i32 {
            self.comparision.unwrap_or(0)
        }

        pub fn clear_comparision(&mut self) {
            self.comparision = ::std::option::Option::None;
        }

        pub fn has_comparision(&self) -> bool {
            self.comparision.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comparision(&mut self, v: i32) {
            self.comparision = ::std::option::Option::Some(v);
        }

        // optional int32 filter_type = 4;

        pub fn filter_type(&self) -> i32 {
            self.filter_type.unwrap_or(0)
        }

        pub fn clear_filter_type(&mut self) {
            self.filter_type = ::std::option::Option::None;
        }

        pub fn has_filter_type(&self) -> bool {
            self.filter_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_filter_type(&mut self, v: i32) {
            self.filter_type = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Filter {
        const NAME: &'static str = "Filter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.comparision = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.filter_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.key.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.comparision {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.filter_type {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.key.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.comparision {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.filter_type {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Filter {
            Filter::new()
        }

        fn clear(&mut self) {
            self.key = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.comparision = ::std::option::Option::None;
            self.filter_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Filter {
            static instance: Filter = Filter {
                key: ::std::option::Option::None,
                value: ::std::option::Option::None,
                comparision: ::std::option::Option::None,
                filter_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSGetLobbyListResponse)
pub struct CMsgClientMMSGetLobbyListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.lobbies)
    pub lobbies: ::std::vec::Vec<cmsg_client_mmsget_lobby_list_response::Lobby>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyListResponse {
    fn default() -> &'a CMsgClientMMSGetLobbyListResponse {
        <CMsgClientMMSGetLobbyListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyListResponse {
    pub fn new() -> CMsgClientMMSGetLobbyListResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyListResponse {
    const NAME: &'static str = "CMsgClientMMSGetLobbyListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.lobbies.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.lobbies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        for v in &self.lobbies {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSGetLobbyListResponse {
        CMsgClientMMSGetLobbyListResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.lobbies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyListResponse {
        static instance: CMsgClientMMSGetLobbyListResponse = CMsgClientMMSGetLobbyListResponse {
            app_id: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            lobbies: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientMMSGetLobbyListResponse`
pub mod cmsg_client_mmsget_lobby_list_response {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientMMSGetLobbyListResponse.Lobby)
    pub struct Lobby {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.max_members)
        pub max_members: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.lobby_type)
        pub lobby_type: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.lobby_flags)
        pub lobby_flags: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.metadata)
        pub metadata: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.num_members)
        pub num_members: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.distance)
        pub distance: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyListResponse.Lobby.weight)
        pub weight: ::std::option::Option<i64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyListResponse.Lobby.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Lobby {
        fn default() -> &'a Lobby {
            <Lobby as ::protobuf::Message>::default_instance()
        }
    }

    impl Lobby {
        pub fn new() -> Lobby {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional int32 max_members = 2;

        pub fn max_members(&self) -> i32 {
            self.max_members.unwrap_or(0)
        }

        pub fn clear_max_members(&mut self) {
            self.max_members = ::std::option::Option::None;
        }

        pub fn has_max_members(&self) -> bool {
            self.max_members.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_members(&mut self, v: i32) {
            self.max_members = ::std::option::Option::Some(v);
        }

        // optional int32 lobby_type = 3;

        pub fn lobby_type(&self) -> i32 {
            self.lobby_type.unwrap_or(0)
        }

        pub fn clear_lobby_type(&mut self) {
            self.lobby_type = ::std::option::Option::None;
        }

        pub fn has_lobby_type(&self) -> bool {
            self.lobby_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_type(&mut self, v: i32) {
            self.lobby_type = ::std::option::Option::Some(v);
        }

        // optional int32 lobby_flags = 4;

        pub fn lobby_flags(&self) -> i32 {
            self.lobby_flags.unwrap_or(0)
        }

        pub fn clear_lobby_flags(&mut self) {
            self.lobby_flags = ::std::option::Option::None;
        }

        pub fn has_lobby_flags(&self) -> bool {
            self.lobby_flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_flags(&mut self, v: i32) {
            self.lobby_flags = ::std::option::Option::Some(v);
        }

        // optional bytes metadata = 5;

        pub fn metadata(&self) -> &[u8] {
            match self.metadata.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_metadata(&mut self) {
            self.metadata = ::std::option::Option::None;
        }

        pub fn has_metadata(&self) -> bool {
            self.metadata.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
            self.metadata = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.metadata.is_none() {
                self.metadata = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.metadata.as_mut().unwrap()
        }

        // Take field
        pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
            self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional int32 num_members = 6;

        pub fn num_members(&self) -> i32 {
            self.num_members.unwrap_or(0)
        }

        pub fn clear_num_members(&mut self) {
            self.num_members = ::std::option::Option::None;
        }

        pub fn has_num_members(&self) -> bool {
            self.num_members.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_members(&mut self, v: i32) {
            self.num_members = ::std::option::Option::Some(v);
        }

        // optional float distance = 7;

        pub fn distance(&self) -> f32 {
            self.distance.unwrap_or(0.)
        }

        pub fn clear_distance(&mut self) {
            self.distance = ::std::option::Option::None;
        }

        pub fn has_distance(&self) -> bool {
            self.distance.is_some()
        }

        // Param is passed by value, moved
        pub fn set_distance(&mut self, v: f32) {
            self.distance = ::std::option::Option::Some(v);
        }

        // optional int64 weight = 8;

        pub fn weight(&self) -> i64 {
            self.weight.unwrap_or(0)
        }

        pub fn clear_weight(&mut self) {
            self.weight = ::std::option::Option::None;
        }

        pub fn has_weight(&self) -> bool {
            self.weight.is_some()
        }

        // Param is passed by value, moved
        pub fn set_weight(&mut self, v: i64) {
            self.weight = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Lobby {
        const NAME: &'static str = "Lobby";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.max_members = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        self.metadata = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    48 => {
                        self.num_members = ::std::option::Option::Some(is.read_int32()?);
                    },
                    61 => {
                        self.distance = ::std::option::Option::Some(is.read_float()?);
                    },
                    64 => {
                        self.weight = ::std::option::Option::Some(is.read_int64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.max_members {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.lobby_type {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.lobby_flags {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.metadata.as_ref() {
                my_size += ::protobuf::rt::bytes_size(5, &v);
            }
            if let Some(v) = self.num_members {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.distance {
                my_size += 1 + 4;
            }
            if let Some(v) = self.weight {
                my_size += ::protobuf::rt::int64_size(8, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.max_members {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.lobby_type {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.lobby_flags {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.metadata.as_ref() {
                os.write_bytes(5, v)?;
            }
            if let Some(v) = self.num_members {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.distance {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.weight {
                os.write_int64(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Lobby {
            Lobby::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.max_members = ::std::option::Option::None;
            self.lobby_type = ::std::option::Option::None;
            self.lobby_flags = ::std::option::Option::None;
            self.metadata = ::std::option::Option::None;
            self.num_members = ::std::option::Option::None;
            self.distance = ::std::option::Option::None;
            self.weight = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Lobby {
            static instance: Lobby = Lobby {
                steam_id: ::std::option::Option::None,
                max_members: ::std::option::Option::None,
                lobby_type: ::std::option::Option::None,
                lobby_flags: ::std::option::Option::None,
                metadata: ::std::option::Option::None,
                num_members: ::std::option::Option::None,
                distance: ::std::option::Option::None,
                weight: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyData)
pub struct CMsgClientMMSSetLobbyData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.steam_id_member)
    pub steam_id_member: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.max_members)
    pub max_members: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.lobby_type)
    pub lobby_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.lobby_flags)
    pub lobby_flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyData.metadata)
    pub metadata: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyData {
    fn default() -> &'a CMsgClientMMSSetLobbyData {
        <CMsgClientMMSSetLobbyData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyData {
    pub fn new() -> CMsgClientMMSSetLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_member = 3;

    pub fn steam_id_member(&self) -> u64 {
        self.steam_id_member.unwrap_or(0)
    }

    pub fn clear_steam_id_member(&mut self) {
        self.steam_id_member = ::std::option::Option::None;
    }

    pub fn has_steam_id_member(&self) -> bool {
        self.steam_id_member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_member(&mut self, v: u64) {
        self.steam_id_member = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 4;

    pub fn max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 5;

    pub fn lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 6;

    pub fn lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 7;

    pub fn metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyData {
    const NAME: &'static str = "CMsgClientMMSSetLobbyData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_member = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.max_members = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.metadata = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_member {
            my_size += 1 + 8;
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_member {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyData {
        CMsgClientMMSSetLobbyData::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_member = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyData {
        static instance: CMsgClientMMSSetLobbyData = CMsgClientMMSSetLobbyData {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_member: ::std::option::Option::None,
            max_members: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            lobby_flags: ::std::option::Option::None,
            metadata: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyDataResponse)
pub struct CMsgClientMMSSetLobbyDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyDataResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyDataResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyDataResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyDataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyDataResponse {
    fn default() -> &'a CMsgClientMMSSetLobbyDataResponse {
        <CMsgClientMMSSetLobbyDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyDataResponse {
    pub fn new() -> CMsgClientMMSSetLobbyDataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyDataResponse {
    const NAME: &'static str = "CMsgClientMMSSetLobbyDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyDataResponse {
        CMsgClientMMSSetLobbyDataResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyDataResponse {
        static instance: CMsgClientMMSSetLobbyDataResponse = CMsgClientMMSSetLobbyDataResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSGetLobbyData)
pub struct CMsgClientMMSGetLobbyData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyData.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyData.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyData {
    fn default() -> &'a CMsgClientMMSGetLobbyData {
        <CMsgClientMMSGetLobbyData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyData {
    pub fn new() -> CMsgClientMMSGetLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyData {
    const NAME: &'static str = "CMsgClientMMSGetLobbyData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSGetLobbyData {
        CMsgClientMMSGetLobbyData::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyData {
        static instance: CMsgClientMMSGetLobbyData = CMsgClientMMSGetLobbyData {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSLobbyData)
pub struct CMsgClientMMSLobbyData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.num_members)
    pub num_members: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.max_members)
    pub max_members: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.lobby_type)
    pub lobby_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.lobby_flags)
    pub lobby_flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.steam_id_owner)
    pub steam_id_owner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.metadata)
    pub metadata: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.members)
    pub members: ::std::vec::Vec<cmsg_client_mmslobby_data::Member>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.lobby_cellid)
    pub lobby_cellid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.owner_should_accept_changes)
    pub owner_should_accept_changes: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSLobbyData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLobbyData {
    fn default() -> &'a CMsgClientMMSLobbyData {
        <CMsgClientMMSLobbyData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLobbyData {
    pub fn new() -> CMsgClientMMSLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 num_members = 3;

    pub fn num_members(&self) -> i32 {
        self.num_members.unwrap_or(0)
    }

    pub fn clear_num_members(&mut self) {
        self.num_members = ::std::option::Option::None;
    }

    pub fn has_num_members(&self) -> bool {
        self.num_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_members(&mut self, v: i32) {
        self.num_members = ::std::option::Option::Some(v);
    }

    // optional int32 max_members = 4;

    pub fn max_members(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_type = 5;

    pub fn lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional int32 lobby_flags = 6;

    pub fn lobby_flags(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_owner = 7;

    pub fn steam_id_owner(&self) -> u64 {
        self.steam_id_owner.unwrap_or(0)
    }

    pub fn clear_steam_id_owner(&mut self) {
        self.steam_id_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_owner(&self) -> bool {
        self.steam_id_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_owner(&mut self, v: u64) {
        self.steam_id_owner = ::std::option::Option::Some(v);
    }

    // optional bytes metadata = 8;

    pub fn metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 lobby_cellid = 10;

    pub fn lobby_cellid(&self) -> u32 {
        self.lobby_cellid.unwrap_or(0)
    }

    pub fn clear_lobby_cellid(&mut self) {
        self.lobby_cellid = ::std::option::Option::None;
    }

    pub fn has_lobby_cellid(&self) -> bool {
        self.lobby_cellid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_cellid(&mut self, v: u32) {
        self.lobby_cellid = ::std::option::Option::Some(v);
    }

    // optional bool owner_should_accept_changes = 11;

    pub fn owner_should_accept_changes(&self) -> bool {
        self.owner_should_accept_changes.unwrap_or(false)
    }

    pub fn clear_owner_should_accept_changes(&mut self) {
        self.owner_should_accept_changes = ::std::option::Option::None;
    }

    pub fn has_owner_should_accept_changes(&self) -> bool {
        self.owner_should_accept_changes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_should_accept_changes(&mut self, v: bool) {
        self.owner_should_accept_changes = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyData {
    const NAME: &'static str = "CMsgClientMMSLobbyData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.num_members = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.max_members = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.lobby_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                57 => {
                    self.steam_id_owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                66 => {
                    self.metadata = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    self.members.push(is.read_message()?);
                },
                80 => {
                    self.lobby_cellid = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.owner_should_accept_changes = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.num_members {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.max_members {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.lobby_flags {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.steam_id_owner {
            my_size += 1 + 8;
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.lobby_cellid {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.owner_should_accept_changes {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.num_members {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.max_members {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.lobby_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.steam_id_owner {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(8, v)?;
        }
        for v in &self.members {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.lobby_cellid {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.owner_should_accept_changes {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSLobbyData {
        CMsgClientMMSLobbyData::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.num_members = ::std::option::Option::None;
        self.max_members = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.lobby_flags = ::std::option::Option::None;
        self.steam_id_owner = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.members.clear();
        self.lobby_cellid = ::std::option::Option::None;
        self.owner_should_accept_changes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSLobbyData {
        static instance: CMsgClientMMSLobbyData = CMsgClientMMSLobbyData {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            num_members: ::std::option::Option::None,
            max_members: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            lobby_flags: ::std::option::Option::None,
            steam_id_owner: ::std::option::Option::None,
            metadata: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            lobby_cellid: ::std::option::Option::None,
            owner_should_accept_changes: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientMMSLobbyData`
pub mod cmsg_client_mmslobby_data {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientMMSLobbyData.Member)
    pub struct Member {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.Member.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.Member.persona_name)
        pub persona_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientMMSLobbyData.Member.metadata)
        pub metadata: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientMMSLobbyData.Member.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Member {
        fn default() -> &'a Member {
            <Member as ::protobuf::Message>::default_instance()
        }
    }

    impl Member {
        pub fn new() -> Member {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional string persona_name = 2;

        pub fn persona_name(&self) -> &str {
            match self.persona_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_persona_name(&mut self) {
            self.persona_name = ::std::option::Option::None;
        }

        pub fn has_persona_name(&self) -> bool {
            self.persona_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona_name(&mut self, v: ::std::string::String) {
            self.persona_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
            if self.persona_name.is_none() {
                self.persona_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.persona_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_persona_name(&mut self) -> ::std::string::String {
            self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes metadata = 3;

        pub fn metadata(&self) -> &[u8] {
            match self.metadata.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_metadata(&mut self) {
            self.metadata = ::std::option::Option::None;
        }

        pub fn has_metadata(&self) -> bool {
            self.metadata.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
            self.metadata = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.metadata.is_none() {
                self.metadata = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.metadata.as_mut().unwrap()
        }

        // Take field
        pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
            self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for Member {
        const NAME: &'static str = "Member";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    18 => {
                        self.persona_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.metadata = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.persona_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.metadata.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.persona_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.metadata.as_ref() {
                os.write_bytes(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Member {
            Member::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.persona_name = ::std::option::Option::None;
            self.metadata = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Member {
            static instance: Member = Member {
                steam_id: ::std::option::Option::None,
                persona_name: ::std::option::Option::None,
                metadata: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSSendLobbyChatMsg)
pub struct CMsgClientMMSSendLobbyChatMsg {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSendLobbyChatMsg.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSendLobbyChatMsg.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSendLobbyChatMsg.steam_id_target)
    pub steam_id_target: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSendLobbyChatMsg.lobby_message)
    pub lobby_message: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSendLobbyChatMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSendLobbyChatMsg {
    fn default() -> &'a CMsgClientMMSSendLobbyChatMsg {
        <CMsgClientMMSSendLobbyChatMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSendLobbyChatMsg {
    pub fn new() -> CMsgClientMMSSendLobbyChatMsg {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_target = 3;

    pub fn steam_id_target(&self) -> u64 {
        self.steam_id_target.unwrap_or(0)
    }

    pub fn clear_steam_id_target(&mut self) {
        self.steam_id_target = ::std::option::Option::None;
    }

    pub fn has_steam_id_target(&self) -> bool {
        self.steam_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_target(&mut self, v: u64) {
        self.steam_id_target = ::std::option::Option::Some(v);
    }

    // optional bytes lobby_message = 4;

    pub fn lobby_message(&self) -> &[u8] {
        match self.lobby_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_lobby_message(&mut self) {
        self.lobby_message = ::std::option::Option::None;
    }

    pub fn has_lobby_message(&self) -> bool {
        self.lobby_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.lobby_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lobby_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.lobby_message.is_none() {
            self.lobby_message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.lobby_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_lobby_message(&mut self) -> ::std::vec::Vec<u8> {
        self.lobby_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSSendLobbyChatMsg {
    const NAME: &'static str = "CMsgClientMMSSendLobbyChatMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_target = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.lobby_message = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_target {
            my_size += 1 + 8;
        }
        if let Some(v) = self.lobby_message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_target {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.lobby_message.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSendLobbyChatMsg {
        CMsgClientMMSSendLobbyChatMsg::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_target = ::std::option::Option::None;
        self.lobby_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSendLobbyChatMsg {
        static instance: CMsgClientMMSSendLobbyChatMsg = CMsgClientMMSSendLobbyChatMsg {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_target: ::std::option::Option::None,
            lobby_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSLobbyChatMsg)
pub struct CMsgClientMMSLobbyChatMsg {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyChatMsg.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyChatMsg.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyChatMsg.steam_id_sender)
    pub steam_id_sender: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyChatMsg.lobby_message)
    pub lobby_message: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSLobbyChatMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLobbyChatMsg {
    fn default() -> &'a CMsgClientMMSLobbyChatMsg {
        <CMsgClientMMSLobbyChatMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLobbyChatMsg {
    pub fn new() -> CMsgClientMMSLobbyChatMsg {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_sender = 3;

    pub fn steam_id_sender(&self) -> u64 {
        self.steam_id_sender.unwrap_or(0)
    }

    pub fn clear_steam_id_sender(&mut self) {
        self.steam_id_sender = ::std::option::Option::None;
    }

    pub fn has_steam_id_sender(&self) -> bool {
        self.steam_id_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_sender(&mut self, v: u64) {
        self.steam_id_sender = ::std::option::Option::Some(v);
    }

    // optional bytes lobby_message = 4;

    pub fn lobby_message(&self) -> &[u8] {
        match self.lobby_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_lobby_message(&mut self) {
        self.lobby_message = ::std::option::Option::None;
    }

    pub fn has_lobby_message(&self) -> bool {
        self.lobby_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.lobby_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lobby_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.lobby_message.is_none() {
            self.lobby_message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.lobby_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_lobby_message(&mut self) -> ::std::vec::Vec<u8> {
        self.lobby_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyChatMsg {
    const NAME: &'static str = "CMsgClientMMSLobbyChatMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_sender = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.lobby_message = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_sender {
            my_size += 1 + 8;
        }
        if let Some(v) = self.lobby_message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_sender {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.lobby_message.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSLobbyChatMsg {
        CMsgClientMMSLobbyChatMsg::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_sender = ::std::option::Option::None;
        self.lobby_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSLobbyChatMsg {
        static instance: CMsgClientMMSLobbyChatMsg = CMsgClientMMSLobbyChatMsg {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_sender: ::std::option::Option::None,
            lobby_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyOwner)
pub struct CMsgClientMMSSetLobbyOwner {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwner.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwner.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwner.steam_id_new_owner)
    pub steam_id_new_owner: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyOwner.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyOwner {
    fn default() -> &'a CMsgClientMMSSetLobbyOwner {
        <CMsgClientMMSSetLobbyOwner as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyOwner {
    pub fn new() -> CMsgClientMMSSetLobbyOwner {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_new_owner = 3;

    pub fn steam_id_new_owner(&self) -> u64 {
        self.steam_id_new_owner.unwrap_or(0)
    }

    pub fn clear_steam_id_new_owner(&mut self) {
        self.steam_id_new_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_new_owner(&self) -> bool {
        self.steam_id_new_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_new_owner(&mut self, v: u64) {
        self.steam_id_new_owner = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyOwner {
    const NAME: &'static str = "CMsgClientMMSSetLobbyOwner";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_new_owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_new_owner {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_new_owner {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyOwner {
        CMsgClientMMSSetLobbyOwner::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_new_owner = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyOwner {
        static instance: CMsgClientMMSSetLobbyOwner = CMsgClientMMSSetLobbyOwner {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_new_owner: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyOwnerResponse)
pub struct CMsgClientMMSSetLobbyOwnerResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwnerResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwnerResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyOwnerResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyOwnerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyOwnerResponse {
    fn default() -> &'a CMsgClientMMSSetLobbyOwnerResponse {
        <CMsgClientMMSSetLobbyOwnerResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyOwnerResponse {
    pub fn new() -> CMsgClientMMSSetLobbyOwnerResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyOwnerResponse {
    const NAME: &'static str = "CMsgClientMMSSetLobbyOwnerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyOwnerResponse {
        CMsgClientMMSSetLobbyOwnerResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyOwnerResponse {
        static instance: CMsgClientMMSSetLobbyOwnerResponse = CMsgClientMMSSetLobbyOwnerResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyLinked)
pub struct CMsgClientMMSSetLobbyLinked {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyLinked.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyLinked.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyLinked.steam_id_lobby2)
    pub steam_id_lobby2: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyLinked.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyLinked {
    fn default() -> &'a CMsgClientMMSSetLobbyLinked {
        <CMsgClientMMSSetLobbyLinked as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyLinked {
    pub fn new() -> CMsgClientMMSSetLobbyLinked {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby2 = 3;

    pub fn steam_id_lobby2(&self) -> u64 {
        self.steam_id_lobby2.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby2(&mut self) {
        self.steam_id_lobby2 = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby2(&self) -> bool {
        self.steam_id_lobby2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby2(&mut self, v: u64) {
        self.steam_id_lobby2 = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyLinked {
    const NAME: &'static str = "CMsgClientMMSSetLobbyLinked";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_lobby2 = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_lobby2 {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_lobby2 {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyLinked {
        CMsgClientMMSSetLobbyLinked::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_lobby2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyLinked {
        static instance: CMsgClientMMSSetLobbyLinked = CMsgClientMMSSetLobbyLinked {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_lobby2: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSSetLobbyGameServer)
pub struct CMsgClientMMSSetLobbyGameServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.deprecated_game_server_ip)
    pub deprecated_game_server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.game_server_port)
    pub game_server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.game_server_steam_id)
    pub game_server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSSetLobbyGameServer.game_server_ip)
    pub game_server_ip: ::protobuf::MessageField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSSetLobbyGameServer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSSetLobbyGameServer {
    fn default() -> &'a CMsgClientMMSSetLobbyGameServer {
        <CMsgClientMMSSetLobbyGameServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSSetLobbyGameServer {
    pub fn new() -> CMsgClientMMSSetLobbyGameServer {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_game_server_ip = 3;

    pub fn deprecated_game_server_ip(&self) -> u32 {
        self.deprecated_game_server_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_game_server_ip(&mut self) {
        self.deprecated_game_server_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_game_server_ip(&self) -> bool {
        self.deprecated_game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_game_server_ip(&mut self, v: u32) {
        self.deprecated_game_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_port = 4;

    pub fn game_server_port(&self) -> u32 {
        self.game_server_port.unwrap_or(0)
    }

    pub fn clear_game_server_port(&mut self) {
        self.game_server_port = ::std::option::Option::None;
    }

    pub fn has_game_server_port(&self) -> bool {
        self.game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_port(&mut self, v: u32) {
        self.game_server_port = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_server_steam_id = 5;

    pub fn game_server_steam_id(&self) -> u64 {
        self.game_server_steam_id.unwrap_or(0)
    }

    pub fn clear_game_server_steam_id(&mut self) {
        self.game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_game_server_steam_id(&self) -> bool {
        self.game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_steam_id(&mut self, v: u64) {
        self.game_server_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyGameServer {
    const NAME: &'static str = "CMsgClientMMSSetLobbyGameServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.deprecated_game_server_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.game_server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_server_ip)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_server_port {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.game_server_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_server_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_server_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_server_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.game_server_ip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSSetLobbyGameServer {
        CMsgClientMMSSetLobbyGameServer::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.deprecated_game_server_ip = ::std::option::Option::None;
        self.game_server_port = ::std::option::Option::None;
        self.game_server_steam_id = ::std::option::Option::None;
        self.game_server_ip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSSetLobbyGameServer {
        static instance: CMsgClientMMSSetLobbyGameServer = CMsgClientMMSSetLobbyGameServer {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            deprecated_game_server_ip: ::std::option::Option::None,
            game_server_port: ::std::option::Option::None,
            game_server_steam_id: ::std::option::Option::None,
            game_server_ip: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSLobbyGameServerSet)
pub struct CMsgClientMMSLobbyGameServerSet {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.deprecated_game_server_ip)
    pub deprecated_game_server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.game_server_port)
    pub game_server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.game_server_steam_id)
    pub game_server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSLobbyGameServerSet.game_server_ip)
    pub game_server_ip: ::protobuf::MessageField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSLobbyGameServerSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSLobbyGameServerSet {
    fn default() -> &'a CMsgClientMMSLobbyGameServerSet {
        <CMsgClientMMSLobbyGameServerSet as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSLobbyGameServerSet {
    pub fn new() -> CMsgClientMMSLobbyGameServerSet {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_game_server_ip = 3;

    pub fn deprecated_game_server_ip(&self) -> u32 {
        self.deprecated_game_server_ip.unwrap_or(0)
    }

    pub fn clear_deprecated_game_server_ip(&mut self) {
        self.deprecated_game_server_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_game_server_ip(&self) -> bool {
        self.deprecated_game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_game_server_ip(&mut self, v: u32) {
        self.deprecated_game_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_port = 4;

    pub fn game_server_port(&self) -> u32 {
        self.game_server_port.unwrap_or(0)
    }

    pub fn clear_game_server_port(&mut self) {
        self.game_server_port = ::std::option::Option::None;
    }

    pub fn has_game_server_port(&self) -> bool {
        self.game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_port(&mut self, v: u32) {
        self.game_server_port = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_server_steam_id = 5;

    pub fn game_server_steam_id(&self) -> u64 {
        self.game_server_steam_id.unwrap_or(0)
    }

    pub fn clear_game_server_steam_id(&mut self) {
        self.game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_game_server_steam_id(&self) -> bool {
        self.game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_steam_id(&mut self, v: u64) {
        self.game_server_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyGameServerSet {
    const NAME: &'static str = "CMsgClientMMSLobbyGameServerSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.deprecated_game_server_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.game_server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_server_ip)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_server_port {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.game_server_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_server_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.deprecated_game_server_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_server_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_server_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.game_server_ip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSLobbyGameServerSet {
        CMsgClientMMSLobbyGameServerSet::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.deprecated_game_server_ip = ::std::option::Option::None;
        self.game_server_port = ::std::option::Option::None;
        self.game_server_steam_id = ::std::option::Option::None;
        self.game_server_ip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSLobbyGameServerSet {
        static instance: CMsgClientMMSLobbyGameServerSet = CMsgClientMMSLobbyGameServerSet {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            deprecated_game_server_ip: ::std::option::Option::None,
            game_server_port: ::std::option::Option::None,
            game_server_steam_id: ::std::option::Option::None,
            game_server_ip: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSUserJoinedLobby)
pub struct CMsgClientMMSUserJoinedLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSUserJoinedLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserJoinedLobby.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserJoinedLobby.steam_id_user)
    pub steam_id_user: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserJoinedLobby.persona_name)
    pub persona_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSUserJoinedLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSUserJoinedLobby {
    fn default() -> &'a CMsgClientMMSUserJoinedLobby {
        <CMsgClientMMSUserJoinedLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSUserJoinedLobby {
    pub fn new() -> CMsgClientMMSUserJoinedLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_user = 3;

    pub fn steam_id_user(&self) -> u64 {
        self.steam_id_user.unwrap_or(0)
    }

    pub fn clear_steam_id_user(&mut self) {
        self.steam_id_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_user(&self) -> bool {
        self.steam_id_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user(&mut self, v: u64) {
        self.steam_id_user = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 4;

    pub fn persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name(&mut self) {
        self.persona_name = ::std::option::Option::None;
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSUserJoinedLobby {
    const NAME: &'static str = "CMsgClientMMSUserJoinedLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_user = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.persona_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_user {
            my_size += 1 + 8;
        }
        if let Some(v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_user {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.persona_name.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSUserJoinedLobby {
        CMsgClientMMSUserJoinedLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_user = ::std::option::Option::None;
        self.persona_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSUserJoinedLobby {
        static instance: CMsgClientMMSUserJoinedLobby = CMsgClientMMSUserJoinedLobby {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_user: ::std::option::Option::None,
            persona_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSUserLeftLobby)
pub struct CMsgClientMMSUserLeftLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSUserLeftLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserLeftLobby.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserLeftLobby.steam_id_user)
    pub steam_id_user: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSUserLeftLobby.persona_name)
    pub persona_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSUserLeftLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSUserLeftLobby {
    fn default() -> &'a CMsgClientMMSUserLeftLobby {
        <CMsgClientMMSUserLeftLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSUserLeftLobby {
    pub fn new() -> CMsgClientMMSUserLeftLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_user = 3;

    pub fn steam_id_user(&self) -> u64 {
        self.steam_id_user.unwrap_or(0)
    }

    pub fn clear_steam_id_user(&mut self) {
        self.steam_id_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_user(&self) -> bool {
        self.steam_id_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user(&mut self, v: u64) {
        self.steam_id_user = ::std::option::Option::Some(v);
    }

    // optional string persona_name = 4;

    pub fn persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_persona_name(&mut self) {
        self.persona_name = ::std::option::Option::None;
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientMMSUserLeftLobby {
    const NAME: &'static str = "CMsgClientMMSUserLeftLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_user = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.persona_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_user {
            my_size += 1 + 8;
        }
        if let Some(v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_user {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.persona_name.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSUserLeftLobby {
        CMsgClientMMSUserLeftLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_user = ::std::option::Option::None;
        self.persona_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSUserLeftLobby {
        static instance: CMsgClientMMSUserLeftLobby = CMsgClientMMSUserLeftLobby {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_user: ::std::option::Option::None,
            persona_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSInviteToLobby)
pub struct CMsgClientMMSInviteToLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSInviteToLobby.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSInviteToLobby.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSInviteToLobby.steam_id_user_invited)
    pub steam_id_user_invited: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSInviteToLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSInviteToLobby {
    fn default() -> &'a CMsgClientMMSInviteToLobby {
        <CMsgClientMMSInviteToLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSInviteToLobby {
    pub fn new() -> CMsgClientMMSInviteToLobby {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_user_invited = 3;

    pub fn steam_id_user_invited(&self) -> u64 {
        self.steam_id_user_invited.unwrap_or(0)
    }

    pub fn clear_steam_id_user_invited(&mut self) {
        self.steam_id_user_invited = ::std::option::Option::None;
    }

    pub fn has_steam_id_user_invited(&self) -> bool {
        self.steam_id_user_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user_invited(&mut self, v: u64) {
        self.steam_id_user_invited = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSInviteToLobby {
    const NAME: &'static str = "CMsgClientMMSInviteToLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_user_invited = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_user_invited {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_user_invited {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSInviteToLobby {
        CMsgClientMMSInviteToLobby::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.steam_id_user_invited = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSInviteToLobby {
        static instance: CMsgClientMMSInviteToLobby = CMsgClientMMSInviteToLobby {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            steam_id_user_invited: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSGetLobbyStatus)
pub struct CMsgClientMMSGetLobbyStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatus.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatus.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatus.claim_membership)
    pub claim_membership: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatus.claim_ownership)
    pub claim_ownership: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyStatus {
    fn default() -> &'a CMsgClientMMSGetLobbyStatus {
        <CMsgClientMMSGetLobbyStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyStatus {
    pub fn new() -> CMsgClientMMSGetLobbyStatus {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional bool claim_membership = 3;

    pub fn claim_membership(&self) -> bool {
        self.claim_membership.unwrap_or(false)
    }

    pub fn clear_claim_membership(&mut self) {
        self.claim_membership = ::std::option::Option::None;
    }

    pub fn has_claim_membership(&self) -> bool {
        self.claim_membership.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claim_membership(&mut self, v: bool) {
        self.claim_membership = ::std::option::Option::Some(v);
    }

    // optional bool claim_ownership = 4;

    pub fn claim_ownership(&self) -> bool {
        self.claim_ownership.unwrap_or(false)
    }

    pub fn clear_claim_ownership(&mut self) {
        self.claim_ownership = ::std::option::Option::None;
    }

    pub fn has_claim_ownership(&self) -> bool {
        self.claim_ownership.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claim_ownership(&mut self, v: bool) {
        self.claim_ownership = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyStatus {
    const NAME: &'static str = "CMsgClientMMSGetLobbyStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.claim_membership = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.claim_ownership = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.claim_membership {
            my_size += 1 + 1;
        }
        if let Some(v) = self.claim_ownership {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.claim_membership {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.claim_ownership {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSGetLobbyStatus {
        CMsgClientMMSGetLobbyStatus::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.claim_membership = ::std::option::Option::None;
        self.claim_ownership = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyStatus {
        static instance: CMsgClientMMSGetLobbyStatus = CMsgClientMMSGetLobbyStatus {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            claim_membership: ::std::option::Option::None,
            claim_ownership: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientMMSGetLobbyStatusResponse)
pub struct CMsgClientMMSGetLobbyStatusResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatusResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatusResponse.steam_id_lobby)
    pub steam_id_lobby: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientMMSGetLobbyStatusResponse.lobby_status)
    pub lobby_status: ::std::option::Option<::protobuf::EnumOrUnknown<EMMSLobbyStatus>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientMMSGetLobbyStatusResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientMMSGetLobbyStatusResponse {
    fn default() -> &'a CMsgClientMMSGetLobbyStatusResponse {
        <CMsgClientMMSGetLobbyStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientMMSGetLobbyStatusResponse {
    pub fn new() -> CMsgClientMMSGetLobbyStatusResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn steam_id_lobby(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    // optional .EMMSLobbyStatus lobby_status = 3;

    pub fn lobby_status(&self) -> EMMSLobbyStatus {
        match self.lobby_status {
            Some(e) => e.enum_value_or(EMMSLobbyStatus::k_EMMSLobbyStatusInvalid),
            None => EMMSLobbyStatus::k_EMMSLobbyStatusInvalid,
        }
    }

    pub fn clear_lobby_status(&mut self) {
        self.lobby_status = ::std::option::Option::None;
    }

    pub fn has_lobby_status(&self) -> bool {
        self.lobby_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_status(&mut self, v: EMMSLobbyStatus) {
        self.lobby_status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyStatusResponse {
    const NAME: &'static str = "CMsgClientMMSGetLobbyStatusResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steam_id_lobby = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.lobby_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steam_id_lobby {
            my_size += 1 + 8;
        }
        if let Some(v) = self.lobby_status {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steam_id_lobby {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.lobby_status {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientMMSGetLobbyStatusResponse {
        CMsgClientMMSGetLobbyStatusResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steam_id_lobby = ::std::option::Option::None;
        self.lobby_status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientMMSGetLobbyStatusResponse {
        static instance: CMsgClientMMSGetLobbyStatusResponse = CMsgClientMMSGetLobbyStatusResponse {
            app_id: ::std::option::Option::None,
            steam_id_lobby: ::std::option::Option::None,
            lobby_status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EMMSLobbyStatus)
pub enum EMMSLobbyStatus {
    // @@protoc_insertion_point(enum_value:EMMSLobbyStatus.k_EMMSLobbyStatusInvalid)
    k_EMMSLobbyStatusInvalid = 0,
    // @@protoc_insertion_point(enum_value:EMMSLobbyStatus.k_EMMSLobbyStatusExists)
    k_EMMSLobbyStatusExists = 1,
    // @@protoc_insertion_point(enum_value:EMMSLobbyStatus.k_EMMSLobbyStatusDoesNotExist)
    k_EMMSLobbyStatusDoesNotExist = 2,
    // @@protoc_insertion_point(enum_value:EMMSLobbyStatus.k_EMMSLobbyStatusNotAMember)
    k_EMMSLobbyStatusNotAMember = 3,
}

impl ::protobuf::Enum for EMMSLobbyStatus {
    const NAME: &'static str = "EMMSLobbyStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMMSLobbyStatus> {
        match value {
            0 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusInvalid),
            1 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusExists),
            2 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusDoesNotExist),
            3 => ::std::option::Option::Some(EMMSLobbyStatus::k_EMMSLobbyStatusNotAMember),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMMSLobbyStatus] = &[
        EMMSLobbyStatus::k_EMMSLobbyStatusInvalid,
        EMMSLobbyStatus::k_EMMSLobbyStatusExists,
        EMMSLobbyStatus::k_EMMSLobbyStatusDoesNotExist,
        EMMSLobbyStatus::k_EMMSLobbyStatusNotAMember,
    ];
}

impl ::std::default::Default for EMMSLobbyStatus {
    fn default() -> Self {
        EMMSLobbyStatus::k_EMMSLobbyStatusInvalid
    }
}

#[allow(unused_imports)]
use crate::steammessages_base::*;
impl crate::RpcMessage for CMsgClientMMSSetRatelimitPolicyOnClient {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSSetRatelimitPolicyOnClient {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSSetRatelimitPolicyOnClient;
}
impl crate::RpcMessage for CMsgClientMMSCreateLobby {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSCreateLobby {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSCreateLobby;
}
impl crate::RpcMessage for CMsgClientMMSCreateLobbyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSCreateLobbyResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSCreateLobbyResponse;
}
impl crate::RpcMessage for CMsgClientMMSJoinLobby {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSJoinLobby {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSJoinLobby;
}
impl crate::RpcMessage for CMsgClientMMSJoinLobbyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSJoinLobbyResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSJoinLobbyResponse;
}
impl crate::RpcMessage for CMsgClientMMSLeaveLobby {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSLeaveLobby {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSLeaveLobby;
}
impl crate::RpcMessage for CMsgClientMMSLeaveLobbyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSLeaveLobbyResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSLeaveLobbyResponse;
}
impl crate::RpcMessage for CMsgClientMMSGetLobbyList {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSGetLobbyList {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSGetLobbyList;
}
impl crate::RpcMessage for CMsgClientMMSGetLobbyListResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSGetLobbyListResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSGetLobbyListResponse;
}
impl crate::RpcMessage for CMsgClientMMSSetLobbyData {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSSetLobbyData {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSSetLobbyData;
}
impl crate::RpcMessage for CMsgClientMMSSetLobbyDataResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSSetLobbyDataResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSSetLobbyDataResponse;
}
impl crate::RpcMessage for CMsgClientMMSGetLobbyData {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSGetLobbyData {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSGetLobbyData;
}
impl crate::RpcMessage for CMsgClientMMSLobbyData {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSLobbyData {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSLobbyData;
}
impl crate::RpcMessage for CMsgClientMMSSendLobbyChatMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSSendLobbyChatMsg {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSSendLobbyChatMsg;
}
impl crate::RpcMessage for CMsgClientMMSLobbyChatMsg {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSLobbyChatMsg {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSLobbyChatMsg;
}
impl crate::RpcMessage for CMsgClientMMSSetLobbyOwner {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSSetLobbyOwner {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSSetLobbyOwner;
}
impl crate::RpcMessage for CMsgClientMMSSetLobbyOwnerResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSSetLobbyOwnerResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSSetLobbyOwnerResponse;
}
impl crate::RpcMessage for CMsgClientMMSSetLobbyLinked {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSSetLobbyLinked {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSSetLobbyLinked;
}
impl crate::RpcMessage for CMsgClientMMSSetLobbyGameServer {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSSetLobbyGameServer {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSSetLobbyGameServer;
}
impl crate::RpcMessage for CMsgClientMMSLobbyGameServerSet {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSLobbyGameServerSet {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSLobbyGameServerSet;
}
impl crate::RpcMessage for CMsgClientMMSUserJoinedLobby {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSUserJoinedLobby {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSUserJoinedLobby;
}
impl crate::RpcMessage for CMsgClientMMSUserLeftLobby {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSUserLeftLobby {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSUserLeftLobby;
}
impl crate::RpcMessage for CMsgClientMMSInviteToLobby {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSInviteToLobby {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSInviteToLobby;
}
impl crate::RpcMessage for CMsgClientMMSGetLobbyStatus {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSGetLobbyStatus {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSGetLobbyStatus;
}
impl crate::RpcMessage for CMsgClientMMSGetLobbyStatusResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientMMSGetLobbyStatusResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientMMSGetLobbyStatusResponse;
}
