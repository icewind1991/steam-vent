// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/protobuf/descriptor.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.FileDescriptorSet)
pub struct FileDescriptorSet {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorSet.file)
    pub file: ::std::vec::Vec<FileDescriptorProto>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FileDescriptorSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileDescriptorSet {
    fn default() -> &'a FileDescriptorSet {
        <FileDescriptorSet as ::protobuf::Message>::default_instance()
    }
}

impl FileDescriptorSet {
    pub fn new() -> FileDescriptorSet {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FileDescriptorSet {
    const NAME: &'static str = "FileDescriptorSet";

    fn is_initialized(&self) -> bool {
        for v in &self.file {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.file {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.file {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileDescriptorSet {
        FileDescriptorSet::new()
    }

    fn clear(&mut self) {
        self.file.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileDescriptorSet {
        static instance: FileDescriptorSet = FileDescriptorSet {
            file: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.FileDescriptorProto)
pub struct FileDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.package)
    pub package: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.dependency)
    pub dependency: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.public_dependency)
    pub public_dependency: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.weak_dependency)
    pub weak_dependency: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.message_type)
    pub message_type: ::std::vec::Vec<DescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.enum_type)
    pub enum_type: ::std::vec::Vec<EnumDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.service)
    pub service: ::std::vec::Vec<ServiceDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.extension)
    pub extension: ::std::vec::Vec<FieldDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.options)
    pub options: ::protobuf::MessageField<FileOptions>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.source_code_info)
    pub source_code_info: ::protobuf::MessageField<SourceCodeInfo>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.syntax)
    pub syntax: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FileDescriptorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileDescriptorProto {
    fn default() -> &'a FileDescriptorProto {
        <FileDescriptorProto as ::protobuf::Message>::default_instance()
    }
}

impl FileDescriptorProto {
    pub fn new() -> FileDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string package = 2;

    pub fn package(&self) -> &str {
        match self.package.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_package(&mut self) {
        self.package = ::std::option::Option::None;
    }

    pub fn has_package(&self) -> bool {
        self.package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package(&mut self, v: ::std::string::String) {
        self.package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_package(&mut self) -> &mut ::std::string::String {
        if self.package.is_none() {
            self.package = ::std::option::Option::Some(::std::string::String::new());
        }
        self.package.as_mut().unwrap()
    }

    // Take field
    pub fn take_package(&mut self) -> ::std::string::String {
        self.package.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string syntax = 12;

    pub fn syntax(&self) -> &str {
        match self.syntax.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_syntax(&mut self) {
        self.syntax = ::std::option::Option::None;
    }

    pub fn has_syntax(&self) -> bool {
        self.syntax.is_some()
    }

    // Param is passed by value, moved
    pub fn set_syntax(&mut self, v: ::std::string::String) {
        self.syntax = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_syntax(&mut self) -> &mut ::std::string::String {
        if self.syntax.is_none() {
            self.syntax = ::std::option::Option::Some(::std::string::String::new());
        }
        self.syntax.as_mut().unwrap()
    }

    // Take field
    pub fn take_syntax(&mut self) -> ::std::string::String {
        self.syntax.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for FileDescriptorProto {
    const NAME: &'static str = "FileDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.message_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.enum_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source_code_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.package = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.dependency.push(is.read_string()?);
                },
                82 => {
                    is.read_repeated_packed_int32_into(&mut self.public_dependency)?;
                },
                80 => {
                    self.public_dependency.push(is.read_int32()?);
                },
                90 => {
                    is.read_repeated_packed_int32_into(&mut self.weak_dependency)?;
                },
                88 => {
                    self.weak_dependency.push(is.read_int32()?);
                },
                34 => {
                    self.message_type.push(is.read_message()?);
                },
                42 => {
                    self.enum_type.push(is.read_message()?);
                },
                50 => {
                    self.service.push(is.read_message()?);
                },
                58 => {
                    self.extension.push(is.read_message()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.source_code_info)?;
                },
                98 => {
                    self.syntax = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.package.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.dependency {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.public_dependency {
            my_size += ::protobuf::rt::int32_size(10, *value);
        };
        for value in &self.weak_dependency {
            my_size += ::protobuf::rt::int32_size(11, *value);
        };
        for value in &self.message_type {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.enum_type {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.service {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.source_code_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.syntax.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.package.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.dependency {
            os.write_string(3, &v)?;
        };
        for v in &self.public_dependency {
            os.write_int32(10, *v)?;
        };
        for v in &self.weak_dependency {
            os.write_int32(11, *v)?;
        };
        for v in &self.message_type {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.enum_type {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.service {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.extension {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.source_code_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.syntax.as_ref() {
            os.write_string(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileDescriptorProto {
        FileDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.package = ::std::option::Option::None;
        self.dependency.clear();
        self.public_dependency.clear();
        self.weak_dependency.clear();
        self.message_type.clear();
        self.enum_type.clear();
        self.service.clear();
        self.extension.clear();
        self.options.clear();
        self.source_code_info.clear();
        self.syntax = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileDescriptorProto {
        static instance: FileDescriptorProto = FileDescriptorProto {
            name: ::std::option::Option::None,
            package: ::std::option::Option::None,
            dependency: ::std::vec::Vec::new(),
            public_dependency: ::std::vec::Vec::new(),
            weak_dependency: ::std::vec::Vec::new(),
            message_type: ::std::vec::Vec::new(),
            enum_type: ::std::vec::Vec::new(),
            service: ::std::vec::Vec::new(),
            extension: ::std::vec::Vec::new(),
            options: ::protobuf::MessageField::none(),
            source_code_info: ::protobuf::MessageField::none(),
            syntax: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.DescriptorProto)
pub struct DescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.field)
    pub field: ::std::vec::Vec<FieldDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.extension)
    pub extension: ::std::vec::Vec<FieldDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.nested_type)
    pub nested_type: ::std::vec::Vec<DescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.enum_type)
    pub enum_type: ::std::vec::Vec<EnumDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.extension_range)
    pub extension_range: ::std::vec::Vec<descriptor_proto::ExtensionRange>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.oneof_decl)
    pub oneof_decl: ::std::vec::Vec<OneofDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.options)
    pub options: ::protobuf::MessageField<MessageOptions>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.reserved_range)
    pub reserved_range: ::std::vec::Vec<descriptor_proto::ReservedRange>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.reserved_name)
    pub reserved_name: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.DescriptorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DescriptorProto {
    fn default() -> &'a DescriptorProto {
        <DescriptorProto as ::protobuf::Message>::default_instance()
    }
}

impl DescriptorProto {
    pub fn new() -> DescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DescriptorProto {
    const NAME: &'static str = "DescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.field {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nested_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.enum_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension_range {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.oneof_decl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reserved_range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.field.push(is.read_message()?);
                },
                50 => {
                    self.extension.push(is.read_message()?);
                },
                26 => {
                    self.nested_type.push(is.read_message()?);
                },
                34 => {
                    self.enum_type.push(is.read_message()?);
                },
                42 => {
                    self.extension_range.push(is.read_message()?);
                },
                66 => {
                    self.oneof_decl.push(is.read_message()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                74 => {
                    self.reserved_range.push(is.read_message()?);
                },
                82 => {
                    self.reserved_name.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.field {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.nested_type {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.enum_type {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.extension_range {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.oneof_decl {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.reserved_range {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.reserved_name {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.field {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.extension {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.nested_type {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.enum_type {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.extension_range {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.oneof_decl {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.reserved_range {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.reserved_name {
            os.write_string(10, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DescriptorProto {
        DescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.field.clear();
        self.extension.clear();
        self.nested_type.clear();
        self.enum_type.clear();
        self.extension_range.clear();
        self.oneof_decl.clear();
        self.options.clear();
        self.reserved_range.clear();
        self.reserved_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DescriptorProto {
        static instance: DescriptorProto = DescriptorProto {
            name: ::std::option::Option::None,
            field: ::std::vec::Vec::new(),
            extension: ::std::vec::Vec::new(),
            nested_type: ::std::vec::Vec::new(),
            enum_type: ::std::vec::Vec::new(),
            extension_range: ::std::vec::Vec::new(),
            oneof_decl: ::std::vec::Vec::new(),
            options: ::protobuf::MessageField::none(),
            reserved_range: ::std::vec::Vec::new(),
            reserved_name: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `DescriptorProto`
pub mod descriptor_proto {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.protobuf.DescriptorProto.ExtensionRange)
    pub struct ExtensionRange {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ExtensionRange.start)
        pub start: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ExtensionRange.end)
        pub end: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ExtensionRange.options)
        pub options: ::protobuf::MessageField<super::ExtensionRangeOptions>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.DescriptorProto.ExtensionRange.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ExtensionRange {
        fn default() -> &'a ExtensionRange {
            <ExtensionRange as ::protobuf::Message>::default_instance()
        }
    }

    impl ExtensionRange {
        pub fn new() -> ExtensionRange {
            ::std::default::Default::default()
        }

        // optional int32 start = 1;

        pub fn start(&self) -> i32 {
            self.start.unwrap_or(0)
        }

        pub fn clear_start(&mut self) {
            self.start = ::std::option::Option::None;
        }

        pub fn has_start(&self) -> bool {
            self.start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start(&mut self, v: i32) {
            self.start = ::std::option::Option::Some(v);
        }

        // optional int32 end = 2;

        pub fn end(&self) -> i32 {
            self.end.unwrap_or(0)
        }

        pub fn clear_end(&mut self) {
            self.end = ::std::option::Option::None;
        }

        pub fn has_end(&self) -> bool {
            self.end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end(&mut self, v: i32) {
            self.end = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ExtensionRange {
        const NAME: &'static str = "ExtensionRange";

        fn is_initialized(&self) -> bool {
            for v in &self.options {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.start = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.end = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.end {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.options.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.start {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.end {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.options.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ExtensionRange {
            ExtensionRange::new()
        }

        fn clear(&mut self) {
            self.start = ::std::option::Option::None;
            self.end = ::std::option::Option::None;
            self.options.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ExtensionRange {
            static instance: ExtensionRange = ExtensionRange {
                start: ::std::option::Option::None,
                end: ::std::option::Option::None,
                options: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.protobuf.DescriptorProto.ReservedRange)
    pub struct ReservedRange {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ReservedRange.start)
        pub start: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ReservedRange.end)
        pub end: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.DescriptorProto.ReservedRange.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReservedRange {
        fn default() -> &'a ReservedRange {
            <ReservedRange as ::protobuf::Message>::default_instance()
        }
    }

    impl ReservedRange {
        pub fn new() -> ReservedRange {
            ::std::default::Default::default()
        }

        // optional int32 start = 1;

        pub fn start(&self) -> i32 {
            self.start.unwrap_or(0)
        }

        pub fn clear_start(&mut self) {
            self.start = ::std::option::Option::None;
        }

        pub fn has_start(&self) -> bool {
            self.start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start(&mut self, v: i32) {
            self.start = ::std::option::Option::Some(v);
        }

        // optional int32 end = 2;

        pub fn end(&self) -> i32 {
            self.end.unwrap_or(0)
        }

        pub fn clear_end(&mut self) {
            self.end = ::std::option::Option::None;
        }

        pub fn has_end(&self) -> bool {
            self.end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end(&mut self, v: i32) {
            self.end = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ReservedRange {
        const NAME: &'static str = "ReservedRange";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.start = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.end = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.end {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.start {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.end {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReservedRange {
            ReservedRange::new()
        }

        fn clear(&mut self) {
            self.start = ::std::option::Option::None;
            self.end = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReservedRange {
            static instance: ReservedRange = ReservedRange {
                start: ::std::option::Option::None,
                end: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.ExtensionRangeOptions)
pub struct ExtensionRangeOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.ExtensionRangeOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.ExtensionRangeOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExtensionRangeOptions {
    fn default() -> &'a ExtensionRangeOptions {
        <ExtensionRangeOptions as ::protobuf::Message>::default_instance()
    }
}

impl ExtensionRangeOptions {
    pub fn new() -> ExtensionRangeOptions {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ExtensionRangeOptions {
    const NAME: &'static str = "ExtensionRangeOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.uninterpreted_option {
            ::protobuf::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExtensionRangeOptions {
        ExtensionRangeOptions::new()
    }

    fn clear(&mut self) {
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExtensionRangeOptions {
        static instance: ExtensionRangeOptions = ExtensionRangeOptions {
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.FieldDescriptorProto)
pub struct FieldDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.number)
    pub number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.label)
    pub label: ::std::option::Option<::protobuf::EnumOrUnknown<field_descriptor_proto::Label>>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<field_descriptor_proto::Type>>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.type_name)
    pub type_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.extendee)
    pub extendee: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.default_value)
    pub default_value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.oneof_index)
    pub oneof_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.json_name)
    pub json_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.options)
    pub options: ::protobuf::MessageField<FieldOptions>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.proto3_optional)
    pub proto3_optional: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FieldDescriptorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FieldDescriptorProto {
    fn default() -> &'a FieldDescriptorProto {
        <FieldDescriptorProto as ::protobuf::Message>::default_instance()
    }
}

impl FieldDescriptorProto {
    pub fn new() -> FieldDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 number = 3;

    pub fn number(&self) -> i32 {
        self.number.unwrap_or(0)
    }

    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i32) {
        self.number = ::std::option::Option::Some(v);
    }

    // optional .google.protobuf.FieldDescriptorProto.Label label = 4;

    pub fn label(&self) -> field_descriptor_proto::Label {
        match self.label {
            Some(e) => e.enum_value_or(field_descriptor_proto::Label::LABEL_OPTIONAL),
            None => field_descriptor_proto::Label::LABEL_OPTIONAL,
        }
    }

    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None;
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: field_descriptor_proto::Label) {
        self.label = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .google.protobuf.FieldDescriptorProto.Type type = 5;

    pub fn type_(&self) -> field_descriptor_proto::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(field_descriptor_proto::Type::TYPE_DOUBLE),
            None => field_descriptor_proto::Type::TYPE_DOUBLE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: field_descriptor_proto::Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string type_name = 6;

    pub fn type_name(&self) -> &str {
        match self.type_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_name(&mut self) {
        self.type_name = ::std::option::Option::None;
    }

    pub fn has_type_name(&self) -> bool {
        self.type_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_name(&mut self, v: ::std::string::String) {
        self.type_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_name(&mut self) -> &mut ::std::string::String {
        if self.type_name.is_none() {
            self.type_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_name(&mut self) -> ::std::string::String {
        self.type_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string extendee = 2;

    pub fn extendee(&self) -> &str {
        match self.extendee.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_extendee(&mut self) {
        self.extendee = ::std::option::Option::None;
    }

    pub fn has_extendee(&self) -> bool {
        self.extendee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extendee(&mut self, v: ::std::string::String) {
        self.extendee = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extendee(&mut self) -> &mut ::std::string::String {
        if self.extendee.is_none() {
            self.extendee = ::std::option::Option::Some(::std::string::String::new());
        }
        self.extendee.as_mut().unwrap()
    }

    // Take field
    pub fn take_extendee(&mut self) -> ::std::string::String {
        self.extendee.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string default_value = 7;

    pub fn default_value(&self) -> &str {
        match self.default_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_default_value(&mut self) {
        self.default_value = ::std::option::Option::None;
    }

    pub fn has_default_value(&self) -> bool {
        self.default_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_value(&mut self, v: ::std::string::String) {
        self.default_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_value(&mut self) -> &mut ::std::string::String {
        if self.default_value.is_none() {
            self.default_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.default_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_value(&mut self) -> ::std::string::String {
        self.default_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 oneof_index = 9;

    pub fn oneof_index(&self) -> i32 {
        self.oneof_index.unwrap_or(0)
    }

    pub fn clear_oneof_index(&mut self) {
        self.oneof_index = ::std::option::Option::None;
    }

    pub fn has_oneof_index(&self) -> bool {
        self.oneof_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oneof_index(&mut self, v: i32) {
        self.oneof_index = ::std::option::Option::Some(v);
    }

    // optional string json_name = 10;

    pub fn json_name(&self) -> &str {
        match self.json_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_json_name(&mut self) {
        self.json_name = ::std::option::Option::None;
    }

    pub fn has_json_name(&self) -> bool {
        self.json_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_json_name(&mut self, v: ::std::string::String) {
        self.json_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_json_name(&mut self) -> &mut ::std::string::String {
        if self.json_name.is_none() {
            self.json_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.json_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_json_name(&mut self) -> ::std::string::String {
        self.json_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool proto3_optional = 17;

    pub fn proto3_optional(&self) -> bool {
        self.proto3_optional.unwrap_or(false)
    }

    pub fn clear_proto3_optional(&mut self) {
        self.proto3_optional = ::std::option::Option::None;
    }

    pub fn has_proto3_optional(&self) -> bool {
        self.proto3_optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proto3_optional(&mut self, v: bool) {
        self.proto3_optional = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for FieldDescriptorProto {
    const NAME: &'static str = "FieldDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.number = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.label = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.type_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.extendee = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.default_value = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.oneof_index = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.json_name = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                136 => {
                    self.proto3_optional = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.number {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.label {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.type_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.extendee.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.default_value.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.oneof_index {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.json_name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.proto3_optional {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.number {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.label {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.type_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.extendee.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.default_value.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.oneof_index {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.json_name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.proto3_optional {
            os.write_bool(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FieldDescriptorProto {
        FieldDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.number = ::std::option::Option::None;
        self.label = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_name = ::std::option::Option::None;
        self.extendee = ::std::option::Option::None;
        self.default_value = ::std::option::Option::None;
        self.oneof_index = ::std::option::Option::None;
        self.json_name = ::std::option::Option::None;
        self.options.clear();
        self.proto3_optional = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FieldDescriptorProto {
        static instance: FieldDescriptorProto = FieldDescriptorProto {
            name: ::std::option::Option::None,
            number: ::std::option::Option::None,
            label: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            type_name: ::std::option::Option::None,
            extendee: ::std::option::Option::None,
            default_value: ::std::option::Option::None,
            oneof_index: ::std::option::Option::None,
            json_name: ::std::option::Option::None,
            options: ::protobuf::MessageField::none(),
            proto3_optional: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `FieldDescriptorProto`
pub mod field_descriptor_proto {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FieldDescriptorProto.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_DOUBLE)
        TYPE_DOUBLE = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_FLOAT)
        TYPE_FLOAT = 2,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_INT64)
        TYPE_INT64 = 3,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_UINT64)
        TYPE_UINT64 = 4,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_INT32)
        TYPE_INT32 = 5,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_FIXED64)
        TYPE_FIXED64 = 6,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_FIXED32)
        TYPE_FIXED32 = 7,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_BOOL)
        TYPE_BOOL = 8,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_STRING)
        TYPE_STRING = 9,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_GROUP)
        TYPE_GROUP = 10,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_MESSAGE)
        TYPE_MESSAGE = 11,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_BYTES)
        TYPE_BYTES = 12,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_UINT32)
        TYPE_UINT32 = 13,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_ENUM)
        TYPE_ENUM = 14,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_SFIXED32)
        TYPE_SFIXED32 = 15,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_SFIXED64)
        TYPE_SFIXED64 = 16,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_SINT32)
        TYPE_SINT32 = 17,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_SINT64)
        TYPE_SINT64 = 18,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                1 => ::std::option::Option::Some(Type::TYPE_DOUBLE),
                2 => ::std::option::Option::Some(Type::TYPE_FLOAT),
                3 => ::std::option::Option::Some(Type::TYPE_INT64),
                4 => ::std::option::Option::Some(Type::TYPE_UINT64),
                5 => ::std::option::Option::Some(Type::TYPE_INT32),
                6 => ::std::option::Option::Some(Type::TYPE_FIXED64),
                7 => ::std::option::Option::Some(Type::TYPE_FIXED32),
                8 => ::std::option::Option::Some(Type::TYPE_BOOL),
                9 => ::std::option::Option::Some(Type::TYPE_STRING),
                10 => ::std::option::Option::Some(Type::TYPE_GROUP),
                11 => ::std::option::Option::Some(Type::TYPE_MESSAGE),
                12 => ::std::option::Option::Some(Type::TYPE_BYTES),
                13 => ::std::option::Option::Some(Type::TYPE_UINT32),
                14 => ::std::option::Option::Some(Type::TYPE_ENUM),
                15 => ::std::option::Option::Some(Type::TYPE_SFIXED32),
                16 => ::std::option::Option::Some(Type::TYPE_SFIXED64),
                17 => ::std::option::Option::Some(Type::TYPE_SINT32),
                18 => ::std::option::Option::Some(Type::TYPE_SINT64),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::TYPE_DOUBLE,
            Type::TYPE_FLOAT,
            Type::TYPE_INT64,
            Type::TYPE_UINT64,
            Type::TYPE_INT32,
            Type::TYPE_FIXED64,
            Type::TYPE_FIXED32,
            Type::TYPE_BOOL,
            Type::TYPE_STRING,
            Type::TYPE_GROUP,
            Type::TYPE_MESSAGE,
            Type::TYPE_BYTES,
            Type::TYPE_UINT32,
            Type::TYPE_ENUM,
            Type::TYPE_SFIXED32,
            Type::TYPE_SFIXED64,
            Type::TYPE_SINT32,
            Type::TYPE_SINT64,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::TYPE_DOUBLE
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FieldDescriptorProto.Label)
    pub enum Label {
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Label.LABEL_OPTIONAL)
        LABEL_OPTIONAL = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Label.LABEL_REQUIRED)
        LABEL_REQUIRED = 2,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Label.LABEL_REPEATED)
        LABEL_REPEATED = 3,
    }

    impl ::protobuf::Enum for Label {
        const NAME: &'static str = "Label";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Label> {
            match value {
                1 => ::std::option::Option::Some(Label::LABEL_OPTIONAL),
                2 => ::std::option::Option::Some(Label::LABEL_REQUIRED),
                3 => ::std::option::Option::Some(Label::LABEL_REPEATED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Label] = &[
            Label::LABEL_OPTIONAL,
            Label::LABEL_REQUIRED,
            Label::LABEL_REPEATED,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Label {
        fn default() -> Self {
            Label::LABEL_OPTIONAL
        }
    }

}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.OneofDescriptorProto)
pub struct OneofDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.OneofDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.OneofDescriptorProto.options)
    pub options: ::protobuf::MessageField<OneofOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.OneofDescriptorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OneofDescriptorProto {
    fn default() -> &'a OneofDescriptorProto {
        <OneofDescriptorProto as ::protobuf::Message>::default_instance()
    }
}

impl OneofDescriptorProto {
    pub fn new() -> OneofDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for OneofDescriptorProto {
    const NAME: &'static str = "OneofDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OneofDescriptorProto {
        OneofDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OneofDescriptorProto {
        static instance: OneofDescriptorProto = OneofDescriptorProto {
            name: ::std::option::Option::None,
            options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.EnumDescriptorProto)
pub struct EnumDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.value)
    pub value: ::std::vec::Vec<EnumValueDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.options)
    pub options: ::protobuf::MessageField<EnumOptions>,
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.reserved_range)
    pub reserved_range: ::std::vec::Vec<enum_descriptor_proto::EnumReservedRange>,
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.reserved_name)
    pub reserved_name: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumDescriptorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumDescriptorProto {
    fn default() -> &'a EnumDescriptorProto {
        <EnumDescriptorProto as ::protobuf::Message>::default_instance()
    }
}

impl EnumDescriptorProto {
    pub fn new() -> EnumDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for EnumDescriptorProto {
    const NAME: &'static str = "EnumDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reserved_range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                34 => {
                    self.reserved_range.push(is.read_message()?);
                },
                42 => {
                    self.reserved_name.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.reserved_range {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.reserved_name {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.value {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.reserved_range {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.reserved_name {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumDescriptorProto {
        EnumDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value.clear();
        self.options.clear();
        self.reserved_range.clear();
        self.reserved_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumDescriptorProto {
        static instance: EnumDescriptorProto = EnumDescriptorProto {
            name: ::std::option::Option::None,
            value: ::std::vec::Vec::new(),
            options: ::protobuf::MessageField::none(),
            reserved_range: ::std::vec::Vec::new(),
            reserved_name: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `EnumDescriptorProto`
pub mod enum_descriptor_proto {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.protobuf.EnumDescriptorProto.EnumReservedRange)
    pub struct EnumReservedRange {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.EnumReservedRange.start)
        pub start: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.EnumReservedRange.end)
        pub end: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.EnumDescriptorProto.EnumReservedRange.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EnumReservedRange {
        fn default() -> &'a EnumReservedRange {
            <EnumReservedRange as ::protobuf::Message>::default_instance()
        }
    }

    impl EnumReservedRange {
        pub fn new() -> EnumReservedRange {
            ::std::default::Default::default()
        }

        // optional int32 start = 1;

        pub fn start(&self) -> i32 {
            self.start.unwrap_or(0)
        }

        pub fn clear_start(&mut self) {
            self.start = ::std::option::Option::None;
        }

        pub fn has_start(&self) -> bool {
            self.start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start(&mut self, v: i32) {
            self.start = ::std::option::Option::Some(v);
        }

        // optional int32 end = 2;

        pub fn end(&self) -> i32 {
            self.end.unwrap_or(0)
        }

        pub fn clear_end(&mut self) {
            self.end = ::std::option::Option::None;
        }

        pub fn has_end(&self) -> bool {
            self.end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end(&mut self, v: i32) {
            self.end = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for EnumReservedRange {
        const NAME: &'static str = "EnumReservedRange";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.start = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.end = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.end {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.start {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.end {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EnumReservedRange {
            EnumReservedRange::new()
        }

        fn clear(&mut self) {
            self.start = ::std::option::Option::None;
            self.end = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EnumReservedRange {
            static instance: EnumReservedRange = EnumReservedRange {
                start: ::std::option::Option::None,
                end: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.EnumValueDescriptorProto)
pub struct EnumValueDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.EnumValueDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.EnumValueDescriptorProto.number)
    pub number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:google.protobuf.EnumValueDescriptorProto.options)
    pub options: ::protobuf::MessageField<EnumValueOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumValueDescriptorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumValueDescriptorProto {
    fn default() -> &'a EnumValueDescriptorProto {
        <EnumValueDescriptorProto as ::protobuf::Message>::default_instance()
    }
}

impl EnumValueDescriptorProto {
    pub fn new() -> EnumValueDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 number = 2;

    pub fn number(&self) -> i32 {
        self.number.unwrap_or(0)
    }

    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i32) {
        self.number = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EnumValueDescriptorProto {
    const NAME: &'static str = "EnumValueDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.number = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.number {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.number {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumValueDescriptorProto {
        EnumValueDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.number = ::std::option::Option::None;
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumValueDescriptorProto {
        static instance: EnumValueDescriptorProto = EnumValueDescriptorProto {
            name: ::std::option::Option::None,
            number: ::std::option::Option::None,
            options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.ServiceDescriptorProto)
pub struct ServiceDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.ServiceDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.ServiceDescriptorProto.method)
    pub method: ::std::vec::Vec<MethodDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.ServiceDescriptorProto.options)
    pub options: ::protobuf::MessageField<ServiceOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.ServiceDescriptorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceDescriptorProto {
    fn default() -> &'a ServiceDescriptorProto {
        <ServiceDescriptorProto as ::protobuf::Message>::default_instance()
    }
}

impl ServiceDescriptorProto {
    pub fn new() -> ServiceDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ServiceDescriptorProto {
    const NAME: &'static str = "ServiceDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.method {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.method.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.method {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.method {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceDescriptorProto {
        ServiceDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.method.clear();
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceDescriptorProto {
        static instance: ServiceDescriptorProto = ServiceDescriptorProto {
            name: ::std::option::Option::None,
            method: ::std::vec::Vec::new(),
            options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.MethodDescriptorProto)
pub struct MethodDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.input_type)
    pub input_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.output_type)
    pub output_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.options)
    pub options: ::protobuf::MessageField<MethodOptions>,
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.client_streaming)
    pub client_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.server_streaming)
    pub server_streaming: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.MethodDescriptorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MethodDescriptorProto {
    fn default() -> &'a MethodDescriptorProto {
        <MethodDescriptorProto as ::protobuf::Message>::default_instance()
    }
}

impl MethodDescriptorProto {
    pub fn new() -> MethodDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string input_type = 2;

    pub fn input_type(&self) -> &str {
        match self.input_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_input_type(&mut self) {
        self.input_type = ::std::option::Option::None;
    }

    pub fn has_input_type(&self) -> bool {
        self.input_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_type(&mut self, v: ::std::string::String) {
        self.input_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_type(&mut self) -> &mut ::std::string::String {
        if self.input_type.is_none() {
            self.input_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.input_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_type(&mut self) -> ::std::string::String {
        self.input_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string output_type = 3;

    pub fn output_type(&self) -> &str {
        match self.output_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_output_type(&mut self) {
        self.output_type = ::std::option::Option::None;
    }

    pub fn has_output_type(&self) -> bool {
        self.output_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_type(&mut self, v: ::std::string::String) {
        self.output_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_type(&mut self) -> &mut ::std::string::String {
        if self.output_type.is_none() {
            self.output_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.output_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_type(&mut self) -> ::std::string::String {
        self.output_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool client_streaming = 5;

    pub fn client_streaming(&self) -> bool {
        self.client_streaming.unwrap_or(false)
    }

    pub fn clear_client_streaming(&mut self) {
        self.client_streaming = ::std::option::Option::None;
    }

    pub fn has_client_streaming(&self) -> bool {
        self.client_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_streaming(&mut self, v: bool) {
        self.client_streaming = ::std::option::Option::Some(v);
    }

    // optional bool server_streaming = 6;

    pub fn server_streaming(&self) -> bool {
        self.server_streaming.unwrap_or(false)
    }

    pub fn clear_server_streaming(&mut self) {
        self.server_streaming = ::std::option::Option::None;
    }

    pub fn has_server_streaming(&self) -> bool {
        self.server_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_streaming(&mut self, v: bool) {
        self.server_streaming = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MethodDescriptorProto {
    const NAME: &'static str = "MethodDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.input_type = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.output_type = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                40 => {
                    self.client_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.server_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.input_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.output_type.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.client_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.server_streaming {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.input_type.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.output_type.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.client_streaming {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.server_streaming {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MethodDescriptorProto {
        MethodDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.input_type = ::std::option::Option::None;
        self.output_type = ::std::option::Option::None;
        self.options.clear();
        self.client_streaming = ::std::option::Option::None;
        self.server_streaming = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MethodDescriptorProto {
        static instance: MethodDescriptorProto = MethodDescriptorProto {
            name: ::std::option::Option::None,
            input_type: ::std::option::Option::None,
            output_type: ::std::option::Option::None,
            options: ::protobuf::MessageField::none(),
            client_streaming: ::std::option::Option::None,
            server_streaming: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.FileOptions)
pub struct FileOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_package)
    pub java_package: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_outer_classname)
    pub java_outer_classname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_multiple_files)
    pub java_multiple_files: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_generate_equals_and_hash)
    pub java_generate_equals_and_hash: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_string_check_utf8)
    pub java_string_check_utf8: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.optimize_for)
    pub optimize_for: ::std::option::Option<::protobuf::EnumOrUnknown<file_options::OptimizeMode>>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.go_package)
    pub go_package: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.cc_generic_services)
    pub cc_generic_services: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_generic_services)
    pub java_generic_services: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.py_generic_services)
    pub py_generic_services: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.php_generic_services)
    pub php_generic_services: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.cc_enable_arenas)
    pub cc_enable_arenas: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.objc_class_prefix)
    pub objc_class_prefix: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.csharp_namespace)
    pub csharp_namespace: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.swift_prefix)
    pub swift_prefix: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.php_class_prefix)
    pub php_class_prefix: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.php_namespace)
    pub php_namespace: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.php_metadata_namespace)
    pub php_metadata_namespace: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.ruby_package)
    pub ruby_package: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FileOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileOptions {
    fn default() -> &'a FileOptions {
        <FileOptions as ::protobuf::Message>::default_instance()
    }
}

impl FileOptions {
    pub fn new() -> FileOptions {
        ::std::default::Default::default()
    }

    // optional string java_package = 1;

    pub fn java_package(&self) -> &str {
        match self.java_package.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_java_package(&mut self) {
        self.java_package = ::std::option::Option::None;
    }

    pub fn has_java_package(&self) -> bool {
        self.java_package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_package(&mut self, v: ::std::string::String) {
        self.java_package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_java_package(&mut self) -> &mut ::std::string::String {
        if self.java_package.is_none() {
            self.java_package = ::std::option::Option::Some(::std::string::String::new());
        }
        self.java_package.as_mut().unwrap()
    }

    // Take field
    pub fn take_java_package(&mut self) -> ::std::string::String {
        self.java_package.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string java_outer_classname = 8;

    pub fn java_outer_classname(&self) -> &str {
        match self.java_outer_classname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_java_outer_classname(&mut self) {
        self.java_outer_classname = ::std::option::Option::None;
    }

    pub fn has_java_outer_classname(&self) -> bool {
        self.java_outer_classname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_outer_classname(&mut self, v: ::std::string::String) {
        self.java_outer_classname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_java_outer_classname(&mut self) -> &mut ::std::string::String {
        if self.java_outer_classname.is_none() {
            self.java_outer_classname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.java_outer_classname.as_mut().unwrap()
    }

    // Take field
    pub fn take_java_outer_classname(&mut self) -> ::std::string::String {
        self.java_outer_classname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool java_multiple_files = 10;

    pub fn java_multiple_files(&self) -> bool {
        self.java_multiple_files.unwrap_or(false)
    }

    pub fn clear_java_multiple_files(&mut self) {
        self.java_multiple_files = ::std::option::Option::None;
    }

    pub fn has_java_multiple_files(&self) -> bool {
        self.java_multiple_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_multiple_files(&mut self, v: bool) {
        self.java_multiple_files = ::std::option::Option::Some(v);
    }

    // optional bool java_generate_equals_and_hash = 20;

    pub fn java_generate_equals_and_hash(&self) -> bool {
        self.java_generate_equals_and_hash.unwrap_or(false)
    }

    pub fn clear_java_generate_equals_and_hash(&mut self) {
        self.java_generate_equals_and_hash = ::std::option::Option::None;
    }

    pub fn has_java_generate_equals_and_hash(&self) -> bool {
        self.java_generate_equals_and_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_generate_equals_and_hash(&mut self, v: bool) {
        self.java_generate_equals_and_hash = ::std::option::Option::Some(v);
    }

    // optional bool java_string_check_utf8 = 27;

    pub fn java_string_check_utf8(&self) -> bool {
        self.java_string_check_utf8.unwrap_or(false)
    }

    pub fn clear_java_string_check_utf8(&mut self) {
        self.java_string_check_utf8 = ::std::option::Option::None;
    }

    pub fn has_java_string_check_utf8(&self) -> bool {
        self.java_string_check_utf8.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_string_check_utf8(&mut self, v: bool) {
        self.java_string_check_utf8 = ::std::option::Option::Some(v);
    }

    // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9;

    pub fn optimize_for(&self) -> file_options::OptimizeMode {
        match self.optimize_for {
            Some(e) => e.enum_value_or(file_options::OptimizeMode::SPEED),
            None => file_options::OptimizeMode::SPEED,
        }
    }

    pub fn clear_optimize_for(&mut self) {
        self.optimize_for = ::std::option::Option::None;
    }

    pub fn has_optimize_for(&self) -> bool {
        self.optimize_for.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optimize_for(&mut self, v: file_options::OptimizeMode) {
        self.optimize_for = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string go_package = 11;

    pub fn go_package(&self) -> &str {
        match self.go_package.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_go_package(&mut self) {
        self.go_package = ::std::option::Option::None;
    }

    pub fn has_go_package(&self) -> bool {
        self.go_package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_go_package(&mut self, v: ::std::string::String) {
        self.go_package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_go_package(&mut self) -> &mut ::std::string::String {
        if self.go_package.is_none() {
            self.go_package = ::std::option::Option::Some(::std::string::String::new());
        }
        self.go_package.as_mut().unwrap()
    }

    // Take field
    pub fn take_go_package(&mut self) -> ::std::string::String {
        self.go_package.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool cc_generic_services = 16;

    pub fn cc_generic_services(&self) -> bool {
        self.cc_generic_services.unwrap_or(false)
    }

    pub fn clear_cc_generic_services(&mut self) {
        self.cc_generic_services = ::std::option::Option::None;
    }

    pub fn has_cc_generic_services(&self) -> bool {
        self.cc_generic_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cc_generic_services(&mut self, v: bool) {
        self.cc_generic_services = ::std::option::Option::Some(v);
    }

    // optional bool java_generic_services = 17;

    pub fn java_generic_services(&self) -> bool {
        self.java_generic_services.unwrap_or(false)
    }

    pub fn clear_java_generic_services(&mut self) {
        self.java_generic_services = ::std::option::Option::None;
    }

    pub fn has_java_generic_services(&self) -> bool {
        self.java_generic_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_generic_services(&mut self, v: bool) {
        self.java_generic_services = ::std::option::Option::Some(v);
    }

    // optional bool py_generic_services = 18;

    pub fn py_generic_services(&self) -> bool {
        self.py_generic_services.unwrap_or(false)
    }

    pub fn clear_py_generic_services(&mut self) {
        self.py_generic_services = ::std::option::Option::None;
    }

    pub fn has_py_generic_services(&self) -> bool {
        self.py_generic_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_py_generic_services(&mut self, v: bool) {
        self.py_generic_services = ::std::option::Option::Some(v);
    }

    // optional bool php_generic_services = 42;

    pub fn php_generic_services(&self) -> bool {
        self.php_generic_services.unwrap_or(false)
    }

    pub fn clear_php_generic_services(&mut self) {
        self.php_generic_services = ::std::option::Option::None;
    }

    pub fn has_php_generic_services(&self) -> bool {
        self.php_generic_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_php_generic_services(&mut self, v: bool) {
        self.php_generic_services = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 23;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    // optional bool cc_enable_arenas = 31;

    pub fn cc_enable_arenas(&self) -> bool {
        self.cc_enable_arenas.unwrap_or(true)
    }

    pub fn clear_cc_enable_arenas(&mut self) {
        self.cc_enable_arenas = ::std::option::Option::None;
    }

    pub fn has_cc_enable_arenas(&self) -> bool {
        self.cc_enable_arenas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cc_enable_arenas(&mut self, v: bool) {
        self.cc_enable_arenas = ::std::option::Option::Some(v);
    }

    // optional string objc_class_prefix = 36;

    pub fn objc_class_prefix(&self) -> &str {
        match self.objc_class_prefix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_objc_class_prefix(&mut self) {
        self.objc_class_prefix = ::std::option::Option::None;
    }

    pub fn has_objc_class_prefix(&self) -> bool {
        self.objc_class_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_objc_class_prefix(&mut self, v: ::std::string::String) {
        self.objc_class_prefix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objc_class_prefix(&mut self) -> &mut ::std::string::String {
        if self.objc_class_prefix.is_none() {
            self.objc_class_prefix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.objc_class_prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_objc_class_prefix(&mut self) -> ::std::string::String {
        self.objc_class_prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string csharp_namespace = 37;

    pub fn csharp_namespace(&self) -> &str {
        match self.csharp_namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_csharp_namespace(&mut self) {
        self.csharp_namespace = ::std::option::Option::None;
    }

    pub fn has_csharp_namespace(&self) -> bool {
        self.csharp_namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_csharp_namespace(&mut self, v: ::std::string::String) {
        self.csharp_namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_csharp_namespace(&mut self) -> &mut ::std::string::String {
        if self.csharp_namespace.is_none() {
            self.csharp_namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.csharp_namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_csharp_namespace(&mut self) -> ::std::string::String {
        self.csharp_namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string swift_prefix = 39;

    pub fn swift_prefix(&self) -> &str {
        match self.swift_prefix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_swift_prefix(&mut self) {
        self.swift_prefix = ::std::option::Option::None;
    }

    pub fn has_swift_prefix(&self) -> bool {
        self.swift_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swift_prefix(&mut self, v: ::std::string::String) {
        self.swift_prefix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_swift_prefix(&mut self) -> &mut ::std::string::String {
        if self.swift_prefix.is_none() {
            self.swift_prefix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.swift_prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_swift_prefix(&mut self) -> ::std::string::String {
        self.swift_prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string php_class_prefix = 40;

    pub fn php_class_prefix(&self) -> &str {
        match self.php_class_prefix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_php_class_prefix(&mut self) {
        self.php_class_prefix = ::std::option::Option::None;
    }

    pub fn has_php_class_prefix(&self) -> bool {
        self.php_class_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_php_class_prefix(&mut self, v: ::std::string::String) {
        self.php_class_prefix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_php_class_prefix(&mut self) -> &mut ::std::string::String {
        if self.php_class_prefix.is_none() {
            self.php_class_prefix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.php_class_prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_php_class_prefix(&mut self) -> ::std::string::String {
        self.php_class_prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string php_namespace = 41;

    pub fn php_namespace(&self) -> &str {
        match self.php_namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_php_namespace(&mut self) {
        self.php_namespace = ::std::option::Option::None;
    }

    pub fn has_php_namespace(&self) -> bool {
        self.php_namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_php_namespace(&mut self, v: ::std::string::String) {
        self.php_namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_php_namespace(&mut self) -> &mut ::std::string::String {
        if self.php_namespace.is_none() {
            self.php_namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.php_namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_php_namespace(&mut self) -> ::std::string::String {
        self.php_namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string php_metadata_namespace = 44;

    pub fn php_metadata_namespace(&self) -> &str {
        match self.php_metadata_namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_php_metadata_namespace(&mut self) {
        self.php_metadata_namespace = ::std::option::Option::None;
    }

    pub fn has_php_metadata_namespace(&self) -> bool {
        self.php_metadata_namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_php_metadata_namespace(&mut self, v: ::std::string::String) {
        self.php_metadata_namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_php_metadata_namespace(&mut self) -> &mut ::std::string::String {
        if self.php_metadata_namespace.is_none() {
            self.php_metadata_namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.php_metadata_namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_php_metadata_namespace(&mut self) -> ::std::string::String {
        self.php_metadata_namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ruby_package = 45;

    pub fn ruby_package(&self) -> &str {
        match self.ruby_package.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ruby_package(&mut self) {
        self.ruby_package = ::std::option::Option::None;
    }

    pub fn has_ruby_package(&self) -> bool {
        self.ruby_package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ruby_package(&mut self, v: ::std::string::String) {
        self.ruby_package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ruby_package(&mut self) -> &mut ::std::string::String {
        if self.ruby_package.is_none() {
            self.ruby_package = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ruby_package.as_mut().unwrap()
    }

    // Take field
    pub fn take_ruby_package(&mut self) -> ::std::string::String {
        self.ruby_package.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for FileOptions {
    const NAME: &'static str = "FileOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.java_package = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.java_outer_classname = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.java_multiple_files = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.java_generate_equals_and_hash = ::std::option::Option::Some(is.read_bool()?);
                },
                216 => {
                    self.java_string_check_utf8 = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.optimize_for = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                90 => {
                    self.go_package = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.cc_generic_services = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.java_generic_services = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.py_generic_services = ::std::option::Option::Some(is.read_bool()?);
                },
                336 => {
                    self.php_generic_services = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                248 => {
                    self.cc_enable_arenas = ::std::option::Option::Some(is.read_bool()?);
                },
                290 => {
                    self.objc_class_prefix = ::std::option::Option::Some(is.read_string()?);
                },
                298 => {
                    self.csharp_namespace = ::std::option::Option::Some(is.read_string()?);
                },
                314 => {
                    self.swift_prefix = ::std::option::Option::Some(is.read_string()?);
                },
                322 => {
                    self.php_class_prefix = ::std::option::Option::Some(is.read_string()?);
                },
                330 => {
                    self.php_namespace = ::std::option::Option::Some(is.read_string()?);
                },
                354 => {
                    self.php_metadata_namespace = ::std::option::Option::Some(is.read_string()?);
                },
                362 => {
                    self.ruby_package = ::std::option::Option::Some(is.read_string()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.java_package.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.java_outer_classname.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.java_multiple_files {
            my_size += 1 + 1;
        }
        if let Some(v) = self.java_generate_equals_and_hash {
            my_size += 2 + 1;
        }
        if let Some(v) = self.java_string_check_utf8 {
            my_size += 2 + 1;
        }
        if let Some(v) = self.optimize_for {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.go_package.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.cc_generic_services {
            my_size += 2 + 1;
        }
        if let Some(v) = self.java_generic_services {
            my_size += 2 + 1;
        }
        if let Some(v) = self.py_generic_services {
            my_size += 2 + 1;
        }
        if let Some(v) = self.php_generic_services {
            my_size += 2 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 2 + 1;
        }
        if let Some(v) = self.cc_enable_arenas {
            my_size += 2 + 1;
        }
        if let Some(v) = self.objc_class_prefix.as_ref() {
            my_size += ::protobuf::rt::string_size(36, &v);
        }
        if let Some(v) = self.csharp_namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(37, &v);
        }
        if let Some(v) = self.swift_prefix.as_ref() {
            my_size += ::protobuf::rt::string_size(39, &v);
        }
        if let Some(v) = self.php_class_prefix.as_ref() {
            my_size += ::protobuf::rt::string_size(40, &v);
        }
        if let Some(v) = self.php_namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(41, &v);
        }
        if let Some(v) = self.php_metadata_namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(44, &v);
        }
        if let Some(v) = self.ruby_package.as_ref() {
            my_size += ::protobuf::rt::string_size(45, &v);
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.java_package.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.java_outer_classname.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.java_multiple_files {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.java_generate_equals_and_hash {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.java_string_check_utf8 {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.optimize_for {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.go_package.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.cc_generic_services {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.java_generic_services {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.py_generic_services {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.php_generic_services {
            os.write_bool(42, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.cc_enable_arenas {
            os.write_bool(31, v)?;
        }
        if let Some(v) = self.objc_class_prefix.as_ref() {
            os.write_string(36, v)?;
        }
        if let Some(v) = self.csharp_namespace.as_ref() {
            os.write_string(37, v)?;
        }
        if let Some(v) = self.swift_prefix.as_ref() {
            os.write_string(39, v)?;
        }
        if let Some(v) = self.php_class_prefix.as_ref() {
            os.write_string(40, v)?;
        }
        if let Some(v) = self.php_namespace.as_ref() {
            os.write_string(41, v)?;
        }
        if let Some(v) = self.php_metadata_namespace.as_ref() {
            os.write_string(44, v)?;
        }
        if let Some(v) = self.ruby_package.as_ref() {
            os.write_string(45, v)?;
        }
        for v in &self.uninterpreted_option {
            ::protobuf::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileOptions {
        FileOptions::new()
    }

    fn clear(&mut self) {
        self.java_package = ::std::option::Option::None;
        self.java_outer_classname = ::std::option::Option::None;
        self.java_multiple_files = ::std::option::Option::None;
        self.java_generate_equals_and_hash = ::std::option::Option::None;
        self.java_string_check_utf8 = ::std::option::Option::None;
        self.optimize_for = ::std::option::Option::None;
        self.go_package = ::std::option::Option::None;
        self.cc_generic_services = ::std::option::Option::None;
        self.java_generic_services = ::std::option::Option::None;
        self.py_generic_services = ::std::option::Option::None;
        self.php_generic_services = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.cc_enable_arenas = ::std::option::Option::None;
        self.objc_class_prefix = ::std::option::Option::None;
        self.csharp_namespace = ::std::option::Option::None;
        self.swift_prefix = ::std::option::Option::None;
        self.php_class_prefix = ::std::option::Option::None;
        self.php_namespace = ::std::option::Option::None;
        self.php_metadata_namespace = ::std::option::Option::None;
        self.ruby_package = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileOptions {
        static instance: FileOptions = FileOptions {
            java_package: ::std::option::Option::None,
            java_outer_classname: ::std::option::Option::None,
            java_multiple_files: ::std::option::Option::None,
            java_generate_equals_and_hash: ::std::option::Option::None,
            java_string_check_utf8: ::std::option::Option::None,
            optimize_for: ::std::option::Option::None,
            go_package: ::std::option::Option::None,
            cc_generic_services: ::std::option::Option::None,
            java_generic_services: ::std::option::Option::None,
            py_generic_services: ::std::option::Option::None,
            php_generic_services: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            cc_enable_arenas: ::std::option::Option::None,
            objc_class_prefix: ::std::option::Option::None,
            csharp_namespace: ::std::option::Option::None,
            swift_prefix: ::std::option::Option::None,
            php_class_prefix: ::std::option::Option::None,
            php_namespace: ::std::option::Option::None,
            php_metadata_namespace: ::std::option::Option::None,
            ruby_package: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `FileOptions`
pub mod file_options {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FileOptions.OptimizeMode)
    pub enum OptimizeMode {
        // @@protoc_insertion_point(enum_value:google.protobuf.FileOptions.OptimizeMode.SPEED)
        SPEED = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FileOptions.OptimizeMode.CODE_SIZE)
        CODE_SIZE = 2,
        // @@protoc_insertion_point(enum_value:google.protobuf.FileOptions.OptimizeMode.LITE_RUNTIME)
        LITE_RUNTIME = 3,
    }

    impl ::protobuf::Enum for OptimizeMode {
        const NAME: &'static str = "OptimizeMode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<OptimizeMode> {
            match value {
                1 => ::std::option::Option::Some(OptimizeMode::SPEED),
                2 => ::std::option::Option::Some(OptimizeMode::CODE_SIZE),
                3 => ::std::option::Option::Some(OptimizeMode::LITE_RUNTIME),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [OptimizeMode] = &[
            OptimizeMode::SPEED,
            OptimizeMode::CODE_SIZE,
            OptimizeMode::LITE_RUNTIME,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for OptimizeMode {
        fn default() -> Self {
            OptimizeMode::SPEED
        }
    }

}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.MessageOptions)
pub struct MessageOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.message_set_wire_format)
    pub message_set_wire_format: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.no_standard_descriptor_accessor)
    pub no_standard_descriptor_accessor: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.map_entry)
    pub map_entry: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.MessageOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageOptions {
    fn default() -> &'a MessageOptions {
        <MessageOptions as ::protobuf::Message>::default_instance()
    }
}

impl MessageOptions {
    pub fn new() -> MessageOptions {
        ::std::default::Default::default()
    }

    // optional bool message_set_wire_format = 1;

    pub fn message_set_wire_format(&self) -> bool {
        self.message_set_wire_format.unwrap_or(false)
    }

    pub fn clear_message_set_wire_format(&mut self) {
        self.message_set_wire_format = ::std::option::Option::None;
    }

    pub fn has_message_set_wire_format(&self) -> bool {
        self.message_set_wire_format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_set_wire_format(&mut self, v: bool) {
        self.message_set_wire_format = ::std::option::Option::Some(v);
    }

    // optional bool no_standard_descriptor_accessor = 2;

    pub fn no_standard_descriptor_accessor(&self) -> bool {
        self.no_standard_descriptor_accessor.unwrap_or(false)
    }

    pub fn clear_no_standard_descriptor_accessor(&mut self) {
        self.no_standard_descriptor_accessor = ::std::option::Option::None;
    }

    pub fn has_no_standard_descriptor_accessor(&self) -> bool {
        self.no_standard_descriptor_accessor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_standard_descriptor_accessor(&mut self, v: bool) {
        self.no_standard_descriptor_accessor = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 3;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    // optional bool map_entry = 7;

    pub fn map_entry(&self) -> bool {
        self.map_entry.unwrap_or(false)
    }

    pub fn clear_map_entry(&mut self) {
        self.map_entry = ::std::option::Option::None;
    }

    pub fn has_map_entry(&self) -> bool {
        self.map_entry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_entry(&mut self, v: bool) {
        self.map_entry = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MessageOptions {
    const NAME: &'static str = "MessageOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.message_set_wire_format = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.no_standard_descriptor_accessor = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.map_entry = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_set_wire_format {
            my_size += 1 + 1;
        }
        if let Some(v) = self.no_standard_descriptor_accessor {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.map_entry {
            my_size += 1 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message_set_wire_format {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.no_standard_descriptor_accessor {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.map_entry {
            os.write_bool(7, v)?;
        }
        for v in &self.uninterpreted_option {
            ::protobuf::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageOptions {
        MessageOptions::new()
    }

    fn clear(&mut self) {
        self.message_set_wire_format = ::std::option::Option::None;
        self.no_standard_descriptor_accessor = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.map_entry = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageOptions {
        static instance: MessageOptions = MessageOptions {
            message_set_wire_format: ::std::option::Option::None,
            no_standard_descriptor_accessor: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            map_entry: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.FieldOptions)
pub struct FieldOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.ctype)
    pub ctype: ::std::option::Option<::protobuf::EnumOrUnknown<field_options::CType>>,
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.packed)
    pub packed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.jstype)
    pub jstype: ::std::option::Option<::protobuf::EnumOrUnknown<field_options::JSType>>,
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.lazy)
    pub lazy: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.weak)
    pub weak: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FieldOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FieldOptions {
    fn default() -> &'a FieldOptions {
        <FieldOptions as ::protobuf::Message>::default_instance()
    }
}

impl FieldOptions {
    pub fn new() -> FieldOptions {
        ::std::default::Default::default()
    }

    // optional .google.protobuf.FieldOptions.CType ctype = 1;

    pub fn ctype(&self) -> field_options::CType {
        match self.ctype {
            Some(e) => e.enum_value_or(field_options::CType::STRING),
            None => field_options::CType::STRING,
        }
    }

    pub fn clear_ctype(&mut self) {
        self.ctype = ::std::option::Option::None;
    }

    pub fn has_ctype(&self) -> bool {
        self.ctype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctype(&mut self, v: field_options::CType) {
        self.ctype = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool packed = 2;

    pub fn packed(&self) -> bool {
        self.packed.unwrap_or(false)
    }

    pub fn clear_packed(&mut self) {
        self.packed = ::std::option::Option::None;
    }

    pub fn has_packed(&self) -> bool {
        self.packed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packed(&mut self, v: bool) {
        self.packed = ::std::option::Option::Some(v);
    }

    // optional .google.protobuf.FieldOptions.JSType jstype = 6;

    pub fn jstype(&self) -> field_options::JSType {
        match self.jstype {
            Some(e) => e.enum_value_or(field_options::JSType::JS_NORMAL),
            None => field_options::JSType::JS_NORMAL,
        }
    }

    pub fn clear_jstype(&mut self) {
        self.jstype = ::std::option::Option::None;
    }

    pub fn has_jstype(&self) -> bool {
        self.jstype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jstype(&mut self, v: field_options::JSType) {
        self.jstype = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool lazy = 5;

    pub fn lazy(&self) -> bool {
        self.lazy.unwrap_or(false)
    }

    pub fn clear_lazy(&mut self) {
        self.lazy = ::std::option::Option::None;
    }

    pub fn has_lazy(&self) -> bool {
        self.lazy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lazy(&mut self, v: bool) {
        self.lazy = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 3;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    // optional bool weak = 10;

    pub fn weak(&self) -> bool {
        self.weak.unwrap_or(false)
    }

    pub fn clear_weak(&mut self) {
        self.weak = ::std::option::Option::None;
    }

    pub fn has_weak(&self) -> bool {
        self.weak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weak(&mut self, v: bool) {
        self.weak = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for FieldOptions {
    const NAME: &'static str = "FieldOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ctype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.packed = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.jstype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.lazy = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.weak = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ctype {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.packed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.jstype {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.lazy {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.weak {
            my_size += 1 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ctype {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.packed {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.jstype {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.lazy {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.weak {
            os.write_bool(10, v)?;
        }
        for v in &self.uninterpreted_option {
            ::protobuf::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FieldOptions {
        FieldOptions::new()
    }

    fn clear(&mut self) {
        self.ctype = ::std::option::Option::None;
        self.packed = ::std::option::Option::None;
        self.jstype = ::std::option::Option::None;
        self.lazy = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.weak = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FieldOptions {
        static instance: FieldOptions = FieldOptions {
            ctype: ::std::option::Option::None,
            packed: ::std::option::Option::None,
            jstype: ::std::option::Option::None,
            lazy: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            weak: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `FieldOptions`
pub mod field_options {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FieldOptions.CType)
    pub enum CType {
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.CType.STRING)
        STRING = 0,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.CType.CORD)
        CORD = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.CType.STRING_PIECE)
        STRING_PIECE = 2,
    }

    impl ::protobuf::Enum for CType {
        const NAME: &'static str = "CType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<CType> {
            match value {
                0 => ::std::option::Option::Some(CType::STRING),
                1 => ::std::option::Option::Some(CType::CORD),
                2 => ::std::option::Option::Some(CType::STRING_PIECE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [CType] = &[
            CType::STRING,
            CType::CORD,
            CType::STRING_PIECE,
        ];
    }

    impl ::std::default::Default for CType {
        fn default() -> Self {
            CType::STRING
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FieldOptions.JSType)
    pub enum JSType {
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.JSType.JS_NORMAL)
        JS_NORMAL = 0,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.JSType.JS_STRING)
        JS_STRING = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.JSType.JS_NUMBER)
        JS_NUMBER = 2,
    }

    impl ::protobuf::Enum for JSType {
        const NAME: &'static str = "JSType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<JSType> {
            match value {
                0 => ::std::option::Option::Some(JSType::JS_NORMAL),
                1 => ::std::option::Option::Some(JSType::JS_STRING),
                2 => ::std::option::Option::Some(JSType::JS_NUMBER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [JSType] = &[
            JSType::JS_NORMAL,
            JSType::JS_STRING,
            JSType::JS_NUMBER,
        ];
    }

    impl ::std::default::Default for JSType {
        fn default() -> Self {
            JSType::JS_NORMAL
        }
    }

}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.OneofOptions)
pub struct OneofOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.OneofOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.OneofOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OneofOptions {
    fn default() -> &'a OneofOptions {
        <OneofOptions as ::protobuf::Message>::default_instance()
    }
}

impl OneofOptions {
    pub fn new() -> OneofOptions {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for OneofOptions {
    const NAME: &'static str = "OneofOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.uninterpreted_option {
            ::protobuf::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OneofOptions {
        OneofOptions::new()
    }

    fn clear(&mut self) {
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OneofOptions {
        static instance: OneofOptions = OneofOptions {
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.EnumOptions)
pub struct EnumOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.EnumOptions.allow_alias)
    pub allow_alias: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.EnumOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.EnumOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumOptions {
    fn default() -> &'a EnumOptions {
        <EnumOptions as ::protobuf::Message>::default_instance()
    }
}

impl EnumOptions {
    pub fn new() -> EnumOptions {
        ::std::default::Default::default()
    }

    // optional bool allow_alias = 2;

    pub fn allow_alias(&self) -> bool {
        self.allow_alias.unwrap_or(false)
    }

    pub fn clear_allow_alias(&mut self) {
        self.allow_alias = ::std::option::Option::None;
    }

    pub fn has_allow_alias(&self) -> bool {
        self.allow_alias.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_alias(&mut self, v: bool) {
        self.allow_alias = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 3;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EnumOptions {
    const NAME: &'static str = "EnumOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.allow_alias = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.allow_alias {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.allow_alias {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(3, v)?;
        }
        for v in &self.uninterpreted_option {
            ::protobuf::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumOptions {
        EnumOptions::new()
    }

    fn clear(&mut self) {
        self.allow_alias = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumOptions {
        static instance: EnumOptions = EnumOptions {
            allow_alias: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.EnumValueOptions)
pub struct EnumValueOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.EnumValueOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.EnumValueOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumValueOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumValueOptions {
    fn default() -> &'a EnumValueOptions {
        <EnumValueOptions as ::protobuf::Message>::default_instance()
    }
}

impl EnumValueOptions {
    pub fn new() -> EnumValueOptions {
        ::std::default::Default::default()
    }

    // optional bool deprecated = 1;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EnumValueOptions {
    const NAME: &'static str = "EnumValueOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deprecated {
            os.write_bool(1, v)?;
        }
        for v in &self.uninterpreted_option {
            ::protobuf::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumValueOptions {
        EnumValueOptions::new()
    }

    fn clear(&mut self) {
        self.deprecated = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumValueOptions {
        static instance: EnumValueOptions = EnumValueOptions {
            deprecated: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.ServiceOptions)
pub struct ServiceOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.ServiceOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.ServiceOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.ServiceOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceOptions {
    fn default() -> &'a ServiceOptions {
        <ServiceOptions as ::protobuf::Message>::default_instance()
    }
}

impl ServiceOptions {
    pub fn new() -> ServiceOptions {
        ::std::default::Default::default()
    }

    // optional bool deprecated = 33;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ServiceOptions {
    const NAME: &'static str = "ServiceOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                264 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deprecated {
            my_size += 2 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deprecated {
            os.write_bool(33, v)?;
        }
        for v in &self.uninterpreted_option {
            ::protobuf::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceOptions {
        ServiceOptions::new()
    }

    fn clear(&mut self) {
        self.deprecated = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceOptions {
        static instance: ServiceOptions = ServiceOptions {
            deprecated: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.MethodOptions)
pub struct MethodOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.MethodOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.MethodOptions.idempotency_level)
    pub idempotency_level: ::std::option::Option<::protobuf::EnumOrUnknown<method_options::IdempotencyLevel>>,
    // @@protoc_insertion_point(field:google.protobuf.MethodOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.MethodOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MethodOptions {
    fn default() -> &'a MethodOptions {
        <MethodOptions as ::protobuf::Message>::default_instance()
    }
}

impl MethodOptions {
    pub fn new() -> MethodOptions {
        ::std::default::Default::default()
    }

    // optional bool deprecated = 33;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    // optional .google.protobuf.MethodOptions.IdempotencyLevel idempotency_level = 34;

    pub fn idempotency_level(&self) -> method_options::IdempotencyLevel {
        match self.idempotency_level {
            Some(e) => e.enum_value_or(method_options::IdempotencyLevel::IDEMPOTENCY_UNKNOWN),
            None => method_options::IdempotencyLevel::IDEMPOTENCY_UNKNOWN,
        }
    }

    pub fn clear_idempotency_level(&mut self) {
        self.idempotency_level = ::std::option::Option::None;
    }

    pub fn has_idempotency_level(&self) -> bool {
        self.idempotency_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idempotency_level(&mut self, v: method_options::IdempotencyLevel) {
        self.idempotency_level = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for MethodOptions {
    const NAME: &'static str = "MethodOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                264 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                272 => {
                    self.idempotency_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deprecated {
            my_size += 2 + 1;
        }
        if let Some(v) = self.idempotency_level {
            my_size += ::protobuf::rt::int32_size(34, v.value());
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deprecated {
            os.write_bool(33, v)?;
        }
        if let Some(v) = self.idempotency_level {
            os.write_enum(34, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.uninterpreted_option {
            ::protobuf::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MethodOptions {
        MethodOptions::new()
    }

    fn clear(&mut self) {
        self.deprecated = ::std::option::Option::None;
        self.idempotency_level = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MethodOptions {
        static instance: MethodOptions = MethodOptions {
            deprecated: ::std::option::Option::None,
            idempotency_level: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `MethodOptions`
pub mod method_options {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.MethodOptions.IdempotencyLevel)
    pub enum IdempotencyLevel {
        // @@protoc_insertion_point(enum_value:google.protobuf.MethodOptions.IdempotencyLevel.IDEMPOTENCY_UNKNOWN)
        IDEMPOTENCY_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:google.protobuf.MethodOptions.IdempotencyLevel.NO_SIDE_EFFECTS)
        NO_SIDE_EFFECTS = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.MethodOptions.IdempotencyLevel.IDEMPOTENT)
        IDEMPOTENT = 2,
    }

    impl ::protobuf::Enum for IdempotencyLevel {
        const NAME: &'static str = "IdempotencyLevel";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<IdempotencyLevel> {
            match value {
                0 => ::std::option::Option::Some(IdempotencyLevel::IDEMPOTENCY_UNKNOWN),
                1 => ::std::option::Option::Some(IdempotencyLevel::NO_SIDE_EFFECTS),
                2 => ::std::option::Option::Some(IdempotencyLevel::IDEMPOTENT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [IdempotencyLevel] = &[
            IdempotencyLevel::IDEMPOTENCY_UNKNOWN,
            IdempotencyLevel::NO_SIDE_EFFECTS,
            IdempotencyLevel::IDEMPOTENT,
        ];
    }

    impl ::std::default::Default for IdempotencyLevel {
        fn default() -> Self {
            IdempotencyLevel::IDEMPOTENCY_UNKNOWN
        }
    }

}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.UninterpretedOption)
pub struct UninterpretedOption {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.name)
    pub name: ::std::vec::Vec<uninterpreted_option::NamePart>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.identifier_value)
    pub identifier_value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.positive_int_value)
    pub positive_int_value: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.negative_int_value)
    pub negative_int_value: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.double_value)
    pub double_value: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.string_value)
    pub string_value: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.aggregate_value)
    pub aggregate_value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.UninterpretedOption.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UninterpretedOption {
    fn default() -> &'a UninterpretedOption {
        <UninterpretedOption as ::protobuf::Message>::default_instance()
    }
}

impl UninterpretedOption {
    pub fn new() -> UninterpretedOption {
        ::std::default::Default::default()
    }

    // optional string identifier_value = 3;

    pub fn identifier_value(&self) -> &str {
        match self.identifier_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_identifier_value(&mut self) {
        self.identifier_value = ::std::option::Option::None;
    }

    pub fn has_identifier_value(&self) -> bool {
        self.identifier_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier_value(&mut self, v: ::std::string::String) {
        self.identifier_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier_value(&mut self) -> &mut ::std::string::String {
        if self.identifier_value.is_none() {
            self.identifier_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.identifier_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier_value(&mut self) -> ::std::string::String {
        self.identifier_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 positive_int_value = 4;

    pub fn positive_int_value(&self) -> u64 {
        self.positive_int_value.unwrap_or(0)
    }

    pub fn clear_positive_int_value(&mut self) {
        self.positive_int_value = ::std::option::Option::None;
    }

    pub fn has_positive_int_value(&self) -> bool {
        self.positive_int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positive_int_value(&mut self, v: u64) {
        self.positive_int_value = ::std::option::Option::Some(v);
    }

    // optional int64 negative_int_value = 5;

    pub fn negative_int_value(&self) -> i64 {
        self.negative_int_value.unwrap_or(0)
    }

    pub fn clear_negative_int_value(&mut self) {
        self.negative_int_value = ::std::option::Option::None;
    }

    pub fn has_negative_int_value(&self) -> bool {
        self.negative_int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative_int_value(&mut self, v: i64) {
        self.negative_int_value = ::std::option::Option::Some(v);
    }

    // optional double double_value = 6;

    pub fn double_value(&self) -> f64 {
        self.double_value.unwrap_or(0.)
    }

    pub fn clear_double_value(&mut self) {
        self.double_value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        self.double_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.double_value = ::std::option::Option::Some(v);
    }

    // optional bytes string_value = 7;

    pub fn string_value(&self) -> &[u8] {
        match self.string_value.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_string_value(&mut self) {
        self.string_value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.string_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.string_value.is_none() {
            self.string_value = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.string_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::vec::Vec<u8> {
        self.string_value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string aggregate_value = 8;

    pub fn aggregate_value(&self) -> &str {
        match self.aggregate_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_aggregate_value(&mut self) {
        self.aggregate_value = ::std::option::Option::None;
    }

    pub fn has_aggregate_value(&self) -> bool {
        self.aggregate_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregate_value(&mut self, v: ::std::string::String) {
        self.aggregate_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aggregate_value(&mut self) -> &mut ::std::string::String {
        if self.aggregate_value.is_none() {
            self.aggregate_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.aggregate_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_aggregate_value(&mut self) -> ::std::string::String {
        self.aggregate_value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for UninterpretedOption {
    const NAME: &'static str = "UninterpretedOption";

    fn is_initialized(&self) -> bool {
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.name.push(is.read_message()?);
                },
                26 => {
                    self.identifier_value = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.positive_int_value = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.negative_int_value = ::std::option::Option::Some(is.read_int64()?);
                },
                49 => {
                    self.double_value = ::std::option::Option::Some(is.read_double()?);
                },
                58 => {
                    self.string_value = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.aggregate_value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.name {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.identifier_value.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.positive_int_value {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.negative_int_value {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.double_value {
            my_size += 1 + 8;
        }
        if let Some(v) = self.string_value.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.aggregate_value.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.name {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.identifier_value.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.positive_int_value {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.negative_int_value {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.double_value {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.string_value.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.aggregate_value.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UninterpretedOption {
        UninterpretedOption::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.identifier_value = ::std::option::Option::None;
        self.positive_int_value = ::std::option::Option::None;
        self.negative_int_value = ::std::option::Option::None;
        self.double_value = ::std::option::Option::None;
        self.string_value = ::std::option::Option::None;
        self.aggregate_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UninterpretedOption {
        static instance: UninterpretedOption = UninterpretedOption {
            name: ::std::vec::Vec::new(),
            identifier_value: ::std::option::Option::None,
            positive_int_value: ::std::option::Option::None,
            negative_int_value: ::std::option::Option::None,
            double_value: ::std::option::Option::None,
            string_value: ::std::option::Option::None,
            aggregate_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `UninterpretedOption`
pub mod uninterpreted_option {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.protobuf.UninterpretedOption.NamePart)
    pub struct NamePart {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.NamePart.name_part)
        pub name_part: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.NamePart.is_extension)
        pub is_extension: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.UninterpretedOption.NamePart.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NamePart {
        fn default() -> &'a NamePart {
            <NamePart as ::protobuf::Message>::default_instance()
        }
    }

    impl NamePart {
        pub fn new() -> NamePart {
            ::std::default::Default::default()
        }

        // required string name_part = 1;

        pub fn name_part(&self) -> &str {
            match self.name_part.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name_part(&mut self) {
            self.name_part = ::std::option::Option::None;
        }

        pub fn has_name_part(&self) -> bool {
            self.name_part.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_part(&mut self, v: ::std::string::String) {
            self.name_part = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name_part(&mut self) -> &mut ::std::string::String {
            if self.name_part.is_none() {
                self.name_part = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name_part.as_mut().unwrap()
        }

        // Take field
        pub fn take_name_part(&mut self) -> ::std::string::String {
            self.name_part.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required bool is_extension = 2;

        pub fn is_extension(&self) -> bool {
            self.is_extension.unwrap_or(false)
        }

        pub fn clear_is_extension(&mut self) {
            self.is_extension = ::std::option::Option::None;
        }

        pub fn has_is_extension(&self) -> bool {
            self.is_extension.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_extension(&mut self, v: bool) {
            self.is_extension = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for NamePart {
        const NAME: &'static str = "NamePart";

        fn is_initialized(&self) -> bool {
            if self.name_part.is_none() {
                return false;
            }
            if self.is_extension.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name_part = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.is_extension = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name_part.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.is_extension {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name_part.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.is_extension {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NamePart {
            NamePart::new()
        }

        fn clear(&mut self) {
            self.name_part = ::std::option::Option::None;
            self.is_extension = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NamePart {
            static instance: NamePart = NamePart {
                name_part: ::std::option::Option::None,
                is_extension: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.SourceCodeInfo)
pub struct SourceCodeInfo {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.location)
    pub location: ::std::vec::Vec<source_code_info::Location>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.SourceCodeInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SourceCodeInfo {
    fn default() -> &'a SourceCodeInfo {
        <SourceCodeInfo as ::protobuf::Message>::default_instance()
    }
}

impl SourceCodeInfo {
    pub fn new() -> SourceCodeInfo {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SourceCodeInfo {
    const NAME: &'static str = "SourceCodeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.location.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.location {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.location {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SourceCodeInfo {
        SourceCodeInfo::new()
    }

    fn clear(&mut self) {
        self.location.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SourceCodeInfo {
        static instance: SourceCodeInfo = SourceCodeInfo {
            location: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `SourceCodeInfo`
pub mod source_code_info {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.protobuf.SourceCodeInfo.Location)
    pub struct Location {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.path)
        pub path: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.span)
        pub span: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.leading_comments)
        pub leading_comments: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.trailing_comments)
        pub trailing_comments: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
        pub leading_detached_comments: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.SourceCodeInfo.Location.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Location {
        fn default() -> &'a Location {
            <Location as ::protobuf::Message>::default_instance()
        }
    }

    impl Location {
        pub fn new() -> Location {
            ::std::default::Default::default()
        }

        // optional string leading_comments = 3;

        pub fn leading_comments(&self) -> &str {
            match self.leading_comments.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_leading_comments(&mut self) {
            self.leading_comments = ::std::option::Option::None;
        }

        pub fn has_leading_comments(&self) -> bool {
            self.leading_comments.is_some()
        }

        // Param is passed by value, moved
        pub fn set_leading_comments(&mut self, v: ::std::string::String) {
            self.leading_comments = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_leading_comments(&mut self) -> &mut ::std::string::String {
            if self.leading_comments.is_none() {
                self.leading_comments = ::std::option::Option::Some(::std::string::String::new());
            }
            self.leading_comments.as_mut().unwrap()
        }

        // Take field
        pub fn take_leading_comments(&mut self) -> ::std::string::String {
            self.leading_comments.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string trailing_comments = 4;

        pub fn trailing_comments(&self) -> &str {
            match self.trailing_comments.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_trailing_comments(&mut self) {
            self.trailing_comments = ::std::option::Option::None;
        }

        pub fn has_trailing_comments(&self) -> bool {
            self.trailing_comments.is_some()
        }

        // Param is passed by value, moved
        pub fn set_trailing_comments(&mut self, v: ::std::string::String) {
            self.trailing_comments = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_trailing_comments(&mut self) -> &mut ::std::string::String {
            if self.trailing_comments.is_none() {
                self.trailing_comments = ::std::option::Option::Some(::std::string::String::new());
            }
            self.trailing_comments.as_mut().unwrap()
        }

        // Take field
        pub fn take_trailing_comments(&mut self) -> ::std::string::String {
            self.trailing_comments.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for Location {
        const NAME: &'static str = "Location";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.path)?;
                    },
                    8 => {
                        self.path.push(is.read_int32()?);
                    },
                    18 => {
                        is.read_repeated_packed_int32_into(&mut self.span)?;
                    },
                    16 => {
                        self.span.push(is.read_int32()?);
                    },
                    26 => {
                        self.leading_comments = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.trailing_comments = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.leading_detached_comments.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::vec_packed_int32_size(1, &self.path);
            my_size += ::protobuf::rt::vec_packed_int32_size(2, &self.span);
            if let Some(v) = self.leading_comments.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.trailing_comments.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            for value in &self.leading_detached_comments {
                my_size += ::protobuf::rt::string_size(6, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_repeated_packed_int32(1, &self.path)?;
            os.write_repeated_packed_int32(2, &self.span)?;
            if let Some(v) = self.leading_comments.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.trailing_comments.as_ref() {
                os.write_string(4, v)?;
            }
            for v in &self.leading_detached_comments {
                os.write_string(6, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Location {
            Location::new()
        }

        fn clear(&mut self) {
            self.path.clear();
            self.span.clear();
            self.leading_comments = ::std::option::Option::None;
            self.trailing_comments = ::std::option::Option::None;
            self.leading_detached_comments.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Location {
            static instance: Location = Location {
                path: ::std::vec::Vec::new(),
                span: ::std::vec::Vec::new(),
                leading_comments: ::std::option::Option::None,
                trailing_comments: ::std::option::Option::None,
                leading_detached_comments: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:google.protobuf.GeneratedCodeInfo)
pub struct GeneratedCodeInfo {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.GeneratedCodeInfo.annotation)
    pub annotation: ::std::vec::Vec<generated_code_info::Annotation>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.GeneratedCodeInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GeneratedCodeInfo {
    fn default() -> &'a GeneratedCodeInfo {
        <GeneratedCodeInfo as ::protobuf::Message>::default_instance()
    }
}

impl GeneratedCodeInfo {
    pub fn new() -> GeneratedCodeInfo {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GeneratedCodeInfo {
    const NAME: &'static str = "GeneratedCodeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.annotation.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.annotation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.annotation {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GeneratedCodeInfo {
        GeneratedCodeInfo::new()
    }

    fn clear(&mut self) {
        self.annotation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GeneratedCodeInfo {
        static instance: GeneratedCodeInfo = GeneratedCodeInfo {
            annotation: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `GeneratedCodeInfo`
pub mod generated_code_info {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:google.protobuf.GeneratedCodeInfo.Annotation)
    pub struct Annotation {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.GeneratedCodeInfo.Annotation.path)
        pub path: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:google.protobuf.GeneratedCodeInfo.Annotation.source_file)
        pub source_file: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:google.protobuf.GeneratedCodeInfo.Annotation.begin)
        pub begin: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:google.protobuf.GeneratedCodeInfo.Annotation.end)
        pub end: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.GeneratedCodeInfo.Annotation.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Annotation {
        fn default() -> &'a Annotation {
            <Annotation as ::protobuf::Message>::default_instance()
        }
    }

    impl Annotation {
        pub fn new() -> Annotation {
            ::std::default::Default::default()
        }

        // optional string source_file = 2;

        pub fn source_file(&self) -> &str {
            match self.source_file.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_source_file(&mut self) {
            self.source_file = ::std::option::Option::None;
        }

        pub fn has_source_file(&self) -> bool {
            self.source_file.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_file(&mut self, v: ::std::string::String) {
            self.source_file = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_source_file(&mut self) -> &mut ::std::string::String {
            if self.source_file.is_none() {
                self.source_file = ::std::option::Option::Some(::std::string::String::new());
            }
            self.source_file.as_mut().unwrap()
        }

        // Take field
        pub fn take_source_file(&mut self) -> ::std::string::String {
            self.source_file.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 begin = 3;

        pub fn begin(&self) -> i32 {
            self.begin.unwrap_or(0)
        }

        pub fn clear_begin(&mut self) {
            self.begin = ::std::option::Option::None;
        }

        pub fn has_begin(&self) -> bool {
            self.begin.is_some()
        }

        // Param is passed by value, moved
        pub fn set_begin(&mut self, v: i32) {
            self.begin = ::std::option::Option::Some(v);
        }

        // optional int32 end = 4;

        pub fn end(&self) -> i32 {
            self.end.unwrap_or(0)
        }

        pub fn clear_end(&mut self) {
            self.end = ::std::option::Option::None;
        }

        pub fn has_end(&self) -> bool {
            self.end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end(&mut self, v: i32) {
            self.end = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Annotation {
        const NAME: &'static str = "Annotation";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.path)?;
                    },
                    8 => {
                        self.path.push(is.read_int32()?);
                    },
                    18 => {
                        self.source_file = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.begin = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.end = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::vec_packed_int32_size(1, &self.path);
            if let Some(v) = self.source_file.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.begin {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.end {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_repeated_packed_int32(1, &self.path)?;
            if let Some(v) = self.source_file.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.begin {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.end {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Annotation {
            Annotation::new()
        }

        fn clear(&mut self) {
            self.path.clear();
            self.source_file = ::std::option::Option::None;
            self.begin = ::std::option::Option::None;
            self.end = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Annotation {
            static instance: Annotation = Annotation {
                path: ::std::vec::Vec::new(),
                source_file: ::std::option::Option::None,
                begin: ::std::option::Option::None,
                end: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}
