// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientserver.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientRegisterAuthTicketWithCM)
pub struct CMsgClientRegisterAuthTicketWithCM {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRegisterAuthTicketWithCM.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRegisterAuthTicketWithCM.ticket)
    pub ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientRegisterAuthTicketWithCM.client_instance_id)
    pub client_instance_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRegisterAuthTicketWithCM.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterAuthTicketWithCM {
    fn default() -> &'a CMsgClientRegisterAuthTicketWithCM {
        <CMsgClientRegisterAuthTicketWithCM as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRegisterAuthTicketWithCM {
    pub fn new() -> CMsgClientRegisterAuthTicketWithCM {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_version = 1;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional bytes ticket = 3;

    pub fn ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 client_instance_id = 4;

    pub fn client_instance_id(&self) -> u64 {
        self.client_instance_id.unwrap_or(0)
    }

    pub fn clear_client_instance_id(&mut self) {
        self.client_instance_id = ::std::option::Option::None;
    }

    pub fn has_client_instance_id(&self) -> bool {
        self.client_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_instance_id(&mut self, v: u64) {
        self.client_instance_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRegisterAuthTicketWithCM {
    const NAME: &'static str = "CMsgClientRegisterAuthTicketWithCM";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.client_instance_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.client_instance_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.protocol_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ticket.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.client_instance_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRegisterAuthTicketWithCM {
        CMsgClientRegisterAuthTicketWithCM::new()
    }

    fn clear(&mut self) {
        self.protocol_version = ::std::option::Option::None;
        self.ticket = ::std::option::Option::None;
        self.client_instance_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRegisterAuthTicketWithCM {
        static instance: CMsgClientRegisterAuthTicketWithCM = CMsgClientRegisterAuthTicketWithCM {
            protocol_version: ::std::option::Option::None,
            ticket: ::std::option::Option::None,
            client_instance_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientTicketAuthComplete)
pub struct CMsgClientTicketAuthComplete {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.game_id)
    pub game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.estate)
    pub estate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.eauth_session_response)
    pub eauth_session_response: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.DEPRECATED_ticket)
    pub DEPRECATED_ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.ticket_crc)
    pub ticket_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.ticket_sequence)
    pub ticket_sequence: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientTicketAuthComplete.owner_steam_id)
    pub owner_steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientTicketAuthComplete.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientTicketAuthComplete {
    fn default() -> &'a CMsgClientTicketAuthComplete {
        <CMsgClientTicketAuthComplete as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientTicketAuthComplete {
    pub fn new() -> CMsgClientTicketAuthComplete {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_id = 2;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 estate = 3;

    pub fn estate(&self) -> u32 {
        self.estate.unwrap_or(0)
    }

    pub fn clear_estate(&mut self) {
        self.estate = ::std::option::Option::None;
    }

    pub fn has_estate(&self) -> bool {
        self.estate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estate(&mut self, v: u32) {
        self.estate = ::std::option::Option::Some(v);
    }

    // optional uint32 eauth_session_response = 4;

    pub fn eauth_session_response(&self) -> u32 {
        self.eauth_session_response.unwrap_or(0)
    }

    pub fn clear_eauth_session_response(&mut self) {
        self.eauth_session_response = ::std::option::Option::None;
    }

    pub fn has_eauth_session_response(&self) -> bool {
        self.eauth_session_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eauth_session_response(&mut self, v: u32) {
        self.eauth_session_response = ::std::option::Option::Some(v);
    }

    // optional bytes DEPRECATED_ticket = 5;

    pub fn DEPRECATED_ticket(&self) -> &[u8] {
        match self.DEPRECATED_ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_DEPRECATED_ticket(&mut self) {
        self.DEPRECATED_ticket = ::std::option::Option::None;
    }

    pub fn has_DEPRECATED_ticket(&self) -> bool {
        self.DEPRECATED_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DEPRECATED_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.DEPRECATED_ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DEPRECATED_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.DEPRECATED_ticket.is_none() {
            self.DEPRECATED_ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.DEPRECATED_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_DEPRECATED_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.DEPRECATED_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ticket_crc = 6;

    pub fn ticket_crc(&self) -> u32 {
        self.ticket_crc.unwrap_or(0)
    }

    pub fn clear_ticket_crc(&mut self) {
        self.ticket_crc = ::std::option::Option::None;
    }

    pub fn has_ticket_crc(&self) -> bool {
        self.ticket_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_crc(&mut self, v: u32) {
        self.ticket_crc = ::std::option::Option::Some(v);
    }

    // optional uint32 ticket_sequence = 7;

    pub fn ticket_sequence(&self) -> u32 {
        self.ticket_sequence.unwrap_or(0)
    }

    pub fn clear_ticket_sequence(&mut self) {
        self.ticket_sequence = ::std::option::Option::None;
    }

    pub fn has_ticket_sequence(&self) -> bool {
        self.ticket_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_sequence(&mut self, v: u32) {
        self.ticket_sequence = ::std::option::Option::Some(v);
    }

    // optional fixed64 owner_steam_id = 8;

    pub fn owner_steam_id(&self) -> u64 {
        self.owner_steam_id.unwrap_or(0)
    }

    pub fn clear_owner_steam_id(&mut self) {
        self.owner_steam_id = ::std::option::Option::None;
    }

    pub fn has_owner_steam_id(&self) -> bool {
        self.owner_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steam_id(&mut self, v: u64) {
        self.owner_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientTicketAuthComplete {
    const NAME: &'static str = "CMsgClientTicketAuthComplete";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.estate = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.eauth_session_response = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.DEPRECATED_ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.ticket_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.ticket_sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                65 => {
                    self.owner_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.estate {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.eauth_session_response {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.DEPRECATED_ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.ticket_crc {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.ticket_sequence {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.owner_steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.estate {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.eauth_session_response {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.DEPRECATED_ticket.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.ticket_crc {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ticket_sequence {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.owner_steam_id {
            os.write_fixed64(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientTicketAuthComplete {
        CMsgClientTicketAuthComplete::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.game_id = ::std::option::Option::None;
        self.estate = ::std::option::Option::None;
        self.eauth_session_response = ::std::option::Option::None;
        self.DEPRECATED_ticket = ::std::option::Option::None;
        self.ticket_crc = ::std::option::Option::None;
        self.ticket_sequence = ::std::option::Option::None;
        self.owner_steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientTicketAuthComplete {
        static instance: CMsgClientTicketAuthComplete = CMsgClientTicketAuthComplete {
            steam_id: ::std::option::Option::None,
            game_id: ::std::option::Option::None,
            estate: ::std::option::Option::None,
            eauth_session_response: ::std::option::Option::None,
            DEPRECATED_ticket: ::std::option::Option::None,
            ticket_crc: ::std::option::Option::None,
            ticket_sequence: ::std::option::Option::None,
            owner_steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientCMList)
pub struct CMsgClientCMList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientCMList.cm_addresses)
    pub cm_addresses: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientCMList.cm_ports)
    pub cm_ports: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientCMList.cm_websocket_addresses)
    pub cm_websocket_addresses: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientCMList.percent_default_to_websocket)
    pub percent_default_to_websocket: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientCMList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientCMList {
    fn default() -> &'a CMsgClientCMList {
        <CMsgClientCMList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCMList {
    pub fn new() -> CMsgClientCMList {
        ::std::default::Default::default()
    }

    // optional uint32 percent_default_to_websocket = 4;

    pub fn percent_default_to_websocket(&self) -> u32 {
        self.percent_default_to_websocket.unwrap_or(0)
    }

    pub fn clear_percent_default_to_websocket(&mut self) {
        self.percent_default_to_websocket = ::std::option::Option::None;
    }

    pub fn has_percent_default_to_websocket(&self) -> bool {
        self.percent_default_to_websocket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_percent_default_to_websocket(&mut self, v: u32) {
        self.percent_default_to_websocket = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCMList {
    const NAME: &'static str = "CMsgClientCMList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.cm_addresses)?;
                },
                8 => {
                    self.cm_addresses.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.cm_ports)?;
                },
                16 => {
                    self.cm_ports.push(is.read_uint32()?);
                },
                26 => {
                    self.cm_websocket_addresses.push(is.read_string()?);
                },
                32 => {
                    self.percent_default_to_websocket = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cm_addresses {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.cm_ports {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.cm_websocket_addresses {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.percent_default_to_websocket {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.cm_addresses {
            os.write_uint32(1, *v)?;
        };
        for v in &self.cm_ports {
            os.write_uint32(2, *v)?;
        };
        for v in &self.cm_websocket_addresses {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.percent_default_to_websocket {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientCMList {
        CMsgClientCMList::new()
    }

    fn clear(&mut self) {
        self.cm_addresses.clear();
        self.cm_ports.clear();
        self.cm_websocket_addresses.clear();
        self.percent_default_to_websocket = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientCMList {
        static instance: CMsgClientCMList = CMsgClientCMList {
            cm_addresses: ::std::vec::Vec::new(),
            cm_ports: ::std::vec::Vec::new(),
            cm_websocket_addresses: ::std::vec::Vec::new(),
            percent_default_to_websocket: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientP2PConnectionInfo)
pub struct CMsgClientP2PConnectionInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.steam_id_dest)
    pub steam_id_dest: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.steam_id_src)
    pub steam_id_src: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.candidate)
    pub candidate: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.legacy_connection_id_src)
    pub legacy_connection_id_src: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionInfo.rendezvous)
    pub rendezvous: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientP2PConnectionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientP2PConnectionInfo {
    fn default() -> &'a CMsgClientP2PConnectionInfo {
        <CMsgClientP2PConnectionInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientP2PConnectionInfo {
    pub fn new() -> CMsgClientP2PConnectionInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_dest = 1;

    pub fn steam_id_dest(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }

    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_src = 2;

    pub fn steam_id_src(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }

    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes candidate = 4;

    pub fn candidate(&self) -> &[u8] {
        match self.candidate.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_candidate(&mut self) {
        self.candidate = ::std::option::Option::None;
    }

    pub fn has_candidate(&self) -> bool {
        self.candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::std::vec::Vec<u8>) {
        self.candidate = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.candidate.is_none() {
            self.candidate = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.candidate.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::std::vec::Vec<u8> {
        self.candidate.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 legacy_connection_id_src = 5;

    pub fn legacy_connection_id_src(&self) -> u64 {
        self.legacy_connection_id_src.unwrap_or(0)
    }

    pub fn clear_legacy_connection_id_src(&mut self) {
        self.legacy_connection_id_src = ::std::option::Option::None;
    }

    pub fn has_legacy_connection_id_src(&self) -> bool {
        self.legacy_connection_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_connection_id_src(&mut self, v: u64) {
        self.legacy_connection_id_src = ::std::option::Option::Some(v);
    }

    // optional bytes rendezvous = 6;

    pub fn rendezvous(&self) -> &[u8] {
        match self.rendezvous.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_rendezvous(&mut self) {
        self.rendezvous = ::std::option::Option::None;
    }

    pub fn has_rendezvous(&self) -> bool {
        self.rendezvous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rendezvous(&mut self, v: ::std::vec::Vec<u8>) {
        self.rendezvous = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rendezvous(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rendezvous.is_none() {
            self.rendezvous = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.rendezvous.as_mut().unwrap()
    }

    // Take field
    pub fn take_rendezvous(&mut self) -> ::std::vec::Vec<u8> {
        self.rendezvous.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientP2PConnectionInfo {
    const NAME: &'static str = "CMsgClientP2PConnectionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_dest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.steam_id_src = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.candidate = ::std::option::Option::Some(is.read_bytes()?);
                },
                41 => {
                    self.legacy_connection_id_src = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    self.rendezvous = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_dest {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_src {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.candidate.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.legacy_connection_id_src {
            my_size += 1 + 8;
        }
        if let Some(v) = self.rendezvous.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_dest {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_src {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.candidate.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.legacy_connection_id_src {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.rendezvous.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientP2PConnectionInfo {
        CMsgClientP2PConnectionInfo::new()
    }

    fn clear(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
        self.steam_id_src = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.candidate = ::std::option::Option::None;
        self.legacy_connection_id_src = ::std::option::Option::None;
        self.rendezvous = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientP2PConnectionInfo {
        static instance: CMsgClientP2PConnectionInfo = CMsgClientP2PConnectionInfo {
            steam_id_dest: ::std::option::Option::None,
            steam_id_src: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            candidate: ::std::option::Option::None,
            legacy_connection_id_src: ::std::option::Option::None,
            rendezvous: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientP2PConnectionFailInfo)
pub struct CMsgClientP2PConnectionFailInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.steam_id_dest)
    pub steam_id_dest: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.steam_id_src)
    pub steam_id_src: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.ep2p_session_error)
    pub ep2p_session_error: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.connection_id_dest)
    pub connection_id_dest: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.close_reason)
    pub close_reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientP2PConnectionFailInfo.close_message)
    pub close_message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientP2PConnectionFailInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientP2PConnectionFailInfo {
    fn default() -> &'a CMsgClientP2PConnectionFailInfo {
        <CMsgClientP2PConnectionFailInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientP2PConnectionFailInfo {
    pub fn new() -> CMsgClientP2PConnectionFailInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_dest = 1;

    pub fn steam_id_dest(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }

    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_src = 2;

    pub fn steam_id_src(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }

    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ep2p_session_error = 4;

    pub fn ep2p_session_error(&self) -> u32 {
        self.ep2p_session_error.unwrap_or(0)
    }

    pub fn clear_ep2p_session_error(&mut self) {
        self.ep2p_session_error = ::std::option::Option::None;
    }

    pub fn has_ep2p_session_error(&self) -> bool {
        self.ep2p_session_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ep2p_session_error(&mut self, v: u32) {
        self.ep2p_session_error = ::std::option::Option::Some(v);
    }

    // optional fixed64 connection_id_dest = 5;

    pub fn connection_id_dest(&self) -> u64 {
        self.connection_id_dest.unwrap_or(0)
    }

    pub fn clear_connection_id_dest(&mut self) {
        self.connection_id_dest = ::std::option::Option::None;
    }

    pub fn has_connection_id_dest(&self) -> bool {
        self.connection_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id_dest(&mut self, v: u64) {
        self.connection_id_dest = ::std::option::Option::Some(v);
    }

    // optional uint32 close_reason = 7;

    pub fn close_reason(&self) -> u32 {
        self.close_reason.unwrap_or(0)
    }

    pub fn clear_close_reason(&mut self) {
        self.close_reason = ::std::option::Option::None;
    }

    pub fn has_close_reason(&self) -> bool {
        self.close_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_reason(&mut self, v: u32) {
        self.close_reason = ::std::option::Option::Some(v);
    }

    // optional string close_message = 8;

    pub fn close_message(&self) -> &str {
        match self.close_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_close_message(&mut self) {
        self.close_message = ::std::option::Option::None;
    }

    pub fn has_close_message(&self) -> bool {
        self.close_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_message(&mut self, v: ::std::string::String) {
        self.close_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_close_message(&mut self) -> &mut ::std::string::String {
        if self.close_message.is_none() {
            self.close_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.close_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_close_message(&mut self) -> ::std::string::String {
        self.close_message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientP2PConnectionFailInfo {
    const NAME: &'static str = "CMsgClientP2PConnectionFailInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_dest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.steam_id_src = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ep2p_session_error = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.connection_id_dest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                56 => {
                    self.close_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.close_message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_dest {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_src {
            my_size += 1 + 8;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ep2p_session_error {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.connection_id_dest {
            my_size += 1 + 8;
        }
        if let Some(v) = self.close_reason {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.close_message.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_dest {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_src {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ep2p_session_error {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.connection_id_dest {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.close_reason {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.close_message.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientP2PConnectionFailInfo {
        CMsgClientP2PConnectionFailInfo::new()
    }

    fn clear(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
        self.steam_id_src = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.ep2p_session_error = ::std::option::Option::None;
        self.connection_id_dest = ::std::option::Option::None;
        self.close_reason = ::std::option::Option::None;
        self.close_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientP2PConnectionFailInfo {
        static instance: CMsgClientP2PConnectionFailInfo = CMsgClientP2PConnectionFailInfo {
            steam_id_dest: ::std::option::Option::None,
            steam_id_src: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            ep2p_session_error: ::std::option::Option::None,
            connection_id_dest: ::std::option::Option::None,
            close_reason: ::std::option::Option::None,
            close_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientNetworkingCertRequest)
pub struct CMsgClientNetworkingCertRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientNetworkingCertRequest.key_data)
    pub key_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientNetworkingCertRequest.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientNetworkingCertRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingCertRequest {
    fn default() -> &'a CMsgClientNetworkingCertRequest {
        <CMsgClientNetworkingCertRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientNetworkingCertRequest {
    pub fn new() -> CMsgClientNetworkingCertRequest {
        ::std::default::Default::default()
    }

    // optional bytes key_data = 2;

    pub fn key_data(&self) -> &[u8] {
        match self.key_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_key_data(&mut self) {
        self.key_data = ::std::option::Option::None;
    }

    pub fn has_key_data(&self) -> bool {
        self.key_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.key_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key_data.is_none() {
            self.key_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.key_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_data(&mut self) -> ::std::vec::Vec<u8> {
        self.key_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientNetworkingCertRequest {
    const NAME: &'static str = "CMsgClientNetworkingCertRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.key_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientNetworkingCertRequest {
        CMsgClientNetworkingCertRequest::new()
    }

    fn clear(&mut self) {
        self.key_data = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientNetworkingCertRequest {
        static instance: CMsgClientNetworkingCertRequest = CMsgClientNetworkingCertRequest {
            key_data: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientNetworkingCertReply)
pub struct CMsgClientNetworkingCertReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientNetworkingCertReply.cert)
    pub cert: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientNetworkingCertReply.ca_key_id)
    pub ca_key_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientNetworkingCertReply.ca_signature)
    pub ca_signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientNetworkingCertReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingCertReply {
    fn default() -> &'a CMsgClientNetworkingCertReply {
        <CMsgClientNetworkingCertReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientNetworkingCertReply {
    pub fn new() -> CMsgClientNetworkingCertReply {
        ::std::default::Default::default()
    }

    // optional bytes cert = 4;

    pub fn cert(&self) -> &[u8] {
        match self.cert.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_cert(&mut self) {
        self.cert = ::std::option::Option::None;
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: ::std::vec::Vec<u8>) {
        self.cert = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.cert.is_none() {
            self.cert = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> ::std::vec::Vec<u8> {
        self.cert.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 ca_key_id = 5;

    pub fn ca_key_id(&self) -> u64 {
        self.ca_key_id.unwrap_or(0)
    }

    pub fn clear_ca_key_id(&mut self) {
        self.ca_key_id = ::std::option::Option::None;
    }

    pub fn has_ca_key_id(&self) -> bool {
        self.ca_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ca_key_id(&mut self, v: u64) {
        self.ca_key_id = ::std::option::Option::Some(v);
    }

    // optional bytes ca_signature = 6;

    pub fn ca_signature(&self) -> &[u8] {
        match self.ca_signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ca_signature(&mut self) {
        self.ca_signature = ::std::option::Option::None;
    }

    pub fn has_ca_signature(&self) -> bool {
        self.ca_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ca_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.ca_signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ca_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ca_signature.is_none() {
            self.ca_signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ca_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_ca_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.ca_signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientNetworkingCertReply {
    const NAME: &'static str = "CMsgClientNetworkingCertReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    self.cert = ::std::option::Option::Some(is.read_bytes()?);
                },
                41 => {
                    self.ca_key_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    self.ca_signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cert.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.ca_key_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.ca_signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cert.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.ca_key_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.ca_signature.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientNetworkingCertReply {
        CMsgClientNetworkingCertReply::new()
    }

    fn clear(&mut self) {
        self.cert = ::std::option::Option::None;
        self.ca_key_id = ::std::option::Option::None;
        self.ca_signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientNetworkingCertReply {
        static instance: CMsgClientNetworkingCertReply = CMsgClientNetworkingCertReply {
            cert: ::std::option::Option::None,
            ca_key_id: ::std::option::Option::None,
            ca_signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientNetworkingMobileCertRequest)
pub struct CMsgClientNetworkingMobileCertRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientNetworkingMobileCertRequest.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientNetworkingMobileCertRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingMobileCertRequest {
    fn default() -> &'a CMsgClientNetworkingMobileCertRequest {
        <CMsgClientNetworkingMobileCertRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientNetworkingMobileCertRequest {
    pub fn new() -> CMsgClientNetworkingMobileCertRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientNetworkingMobileCertRequest {
    const NAME: &'static str = "CMsgClientNetworkingMobileCertRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientNetworkingMobileCertRequest {
        CMsgClientNetworkingMobileCertRequest::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientNetworkingMobileCertRequest {
        static instance: CMsgClientNetworkingMobileCertRequest = CMsgClientNetworkingMobileCertRequest {
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientNetworkingMobileCertReply)
pub struct CMsgClientNetworkingMobileCertReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientNetworkingMobileCertReply.encoded_cert)
    pub encoded_cert: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientNetworkingMobileCertReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientNetworkingMobileCertReply {
    fn default() -> &'a CMsgClientNetworkingMobileCertReply {
        <CMsgClientNetworkingMobileCertReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientNetworkingMobileCertReply {
    pub fn new() -> CMsgClientNetworkingMobileCertReply {
        ::std::default::Default::default()
    }

    // optional string encoded_cert = 1;

    pub fn encoded_cert(&self) -> &str {
        match self.encoded_cert.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_encoded_cert(&mut self) {
        self.encoded_cert = ::std::option::Option::None;
    }

    pub fn has_encoded_cert(&self) -> bool {
        self.encoded_cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encoded_cert(&mut self, v: ::std::string::String) {
        self.encoded_cert = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encoded_cert(&mut self) -> &mut ::std::string::String {
        if self.encoded_cert.is_none() {
            self.encoded_cert = ::std::option::Option::Some(::std::string::String::new());
        }
        self.encoded_cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_encoded_cert(&mut self) -> ::std::string::String {
        self.encoded_cert.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientNetworkingMobileCertReply {
    const NAME: &'static str = "CMsgClientNetworkingMobileCertReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.encoded_cert = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.encoded_cert.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.encoded_cert.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientNetworkingMobileCertReply {
        CMsgClientNetworkingMobileCertReply::new()
    }

    fn clear(&mut self) {
        self.encoded_cert = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientNetworkingMobileCertReply {
        static instance: CMsgClientNetworkingMobileCertReply = CMsgClientNetworkingMobileCertReply {
            encoded_cert: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientGetAppOwnershipTicket)
pub struct CMsgClientGetAppOwnershipTicket {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetAppOwnershipTicket.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetAppOwnershipTicket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAppOwnershipTicket {
    fn default() -> &'a CMsgClientGetAppOwnershipTicket {
        <CMsgClientGetAppOwnershipTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAppOwnershipTicket {
    pub fn new() -> CMsgClientGetAppOwnershipTicket {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetAppOwnershipTicket {
    const NAME: &'static str = "CMsgClientGetAppOwnershipTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetAppOwnershipTicket {
        CMsgClientGetAppOwnershipTicket::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetAppOwnershipTicket {
        static instance: CMsgClientGetAppOwnershipTicket = CMsgClientGetAppOwnershipTicket {
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientGetAppOwnershipTicketResponse)
pub struct CMsgClientGetAppOwnershipTicketResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGetAppOwnershipTicketResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetAppOwnershipTicketResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGetAppOwnershipTicketResponse.ticket)
    pub ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGetAppOwnershipTicketResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAppOwnershipTicketResponse {
    fn default() -> &'a CMsgClientGetAppOwnershipTicketResponse {
        <CMsgClientGetAppOwnershipTicketResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAppOwnershipTicketResponse {
    pub fn new() -> CMsgClientGetAppOwnershipTicketResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes ticket = 3;

    pub fn ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientGetAppOwnershipTicketResponse {
    const NAME: &'static str = "CMsgClientGetAppOwnershipTicketResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ticket.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGetAppOwnershipTicketResponse {
        CMsgClientGetAppOwnershipTicketResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.ticket = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGetAppOwnershipTicketResponse {
        static instance: CMsgClientGetAppOwnershipTicketResponse = CMsgClientGetAppOwnershipTicketResponse {
            eresult: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            ticket: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientSessionToken)
pub struct CMsgClientSessionToken {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSessionToken.token)
    pub token: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSessionToken.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSessionToken {
    fn default() -> &'a CMsgClientSessionToken {
        <CMsgClientSessionToken as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSessionToken {
    pub fn new() -> CMsgClientSessionToken {
        ::std::default::Default::default()
    }

    // optional uint64 token = 1;

    pub fn token(&self) -> u64 {
        self.token.unwrap_or(0)
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u64) {
        self.token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSessionToken {
    const NAME: &'static str = "CMsgClientSessionToken";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.token = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSessionToken {
        CMsgClientSessionToken::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSessionToken {
        static instance: CMsgClientSessionToken = CMsgClientSessionToken {
            token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientGameConnectTokens)
pub struct CMsgClientGameConnectTokens {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGameConnectTokens.max_tokens_to_keep)
    pub max_tokens_to_keep: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGameConnectTokens.tokens)
    pub tokens: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGameConnectTokens.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGameConnectTokens {
    fn default() -> &'a CMsgClientGameConnectTokens {
        <CMsgClientGameConnectTokens as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGameConnectTokens {
    pub fn new() -> CMsgClientGameConnectTokens {
        ::std::default::Default::default()
    }

    // optional uint32 max_tokens_to_keep = 1;

    pub fn max_tokens_to_keep(&self) -> u32 {
        self.max_tokens_to_keep.unwrap_or(10u32)
    }

    pub fn clear_max_tokens_to_keep(&mut self) {
        self.max_tokens_to_keep = ::std::option::Option::None;
    }

    pub fn has_max_tokens_to_keep(&self) -> bool {
        self.max_tokens_to_keep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_tokens_to_keep(&mut self, v: u32) {
        self.max_tokens_to_keep = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGameConnectTokens {
    const NAME: &'static str = "CMsgClientGameConnectTokens";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.max_tokens_to_keep = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.tokens.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.max_tokens_to_keep {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.tokens {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.max_tokens_to_keep {
            os.write_uint32(1, v)?;
        }
        for v in &self.tokens {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGameConnectTokens {
        CMsgClientGameConnectTokens::new()
    }

    fn clear(&mut self) {
        self.max_tokens_to_keep = ::std::option::Option::None;
        self.tokens.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGameConnectTokens {
        static instance: CMsgClientGameConnectTokens = CMsgClientGameConnectTokens {
            max_tokens_to_keep: ::std::option::Option::None,
            tokens: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientGamesPlayed)
pub struct CMsgClientGamesPlayed {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGamesPlayed.games_played)
    pub games_played: ::std::vec::Vec<cmsg_client_games_played::GamePlayed>,
    // @@protoc_insertion_point(field:CMsgClientGamesPlayed.client_os_type)
    pub client_os_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGamesPlayed.cloud_gaming_platform)
    pub cloud_gaming_platform: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientGamesPlayed.recent_reauthentication)
    pub recent_reauthentication: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGamesPlayed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGamesPlayed {
    fn default() -> &'a CMsgClientGamesPlayed {
        <CMsgClientGamesPlayed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGamesPlayed {
    pub fn new() -> CMsgClientGamesPlayed {
        ::std::default::Default::default()
    }

    // optional uint32 client_os_type = 2;

    pub fn client_os_type(&self) -> u32 {
        self.client_os_type.unwrap_or(0)
    }

    pub fn clear_client_os_type(&mut self) {
        self.client_os_type = ::std::option::Option::None;
    }

    pub fn has_client_os_type(&self) -> bool {
        self.client_os_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_os_type(&mut self, v: u32) {
        self.client_os_type = ::std::option::Option::Some(v);
    }

    // optional uint32 cloud_gaming_platform = 3;

    pub fn cloud_gaming_platform(&self) -> u32 {
        self.cloud_gaming_platform.unwrap_or(0)
    }

    pub fn clear_cloud_gaming_platform(&mut self) {
        self.cloud_gaming_platform = ::std::option::Option::None;
    }

    pub fn has_cloud_gaming_platform(&self) -> bool {
        self.cloud_gaming_platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloud_gaming_platform(&mut self, v: u32) {
        self.cloud_gaming_platform = ::std::option::Option::Some(v);
    }

    // optional bool recent_reauthentication = 4;

    pub fn recent_reauthentication(&self) -> bool {
        self.recent_reauthentication.unwrap_or(false)
    }

    pub fn clear_recent_reauthentication(&mut self) {
        self.recent_reauthentication = ::std::option::Option::None;
    }

    pub fn has_recent_reauthentication(&self) -> bool {
        self.recent_reauthentication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_reauthentication(&mut self, v: bool) {
        self.recent_reauthentication = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGamesPlayed {
    const NAME: &'static str = "CMsgClientGamesPlayed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.games_played.push(is.read_message()?);
                },
                16 => {
                    self.client_os_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cloud_gaming_platform = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.recent_reauthentication = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.games_played {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.client_os_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cloud_gaming_platform {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.recent_reauthentication {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.games_played {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.client_os_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cloud_gaming_platform {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.recent_reauthentication {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGamesPlayed {
        CMsgClientGamesPlayed::new()
    }

    fn clear(&mut self) {
        self.games_played.clear();
        self.client_os_type = ::std::option::Option::None;
        self.cloud_gaming_platform = ::std::option::Option::None;
        self.recent_reauthentication = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGamesPlayed {
        static instance: CMsgClientGamesPlayed = CMsgClientGamesPlayed {
            games_played: ::std::vec::Vec::new(),
            client_os_type: ::std::option::Option::None,
            cloud_gaming_platform: ::std::option::Option::None,
            recent_reauthentication: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientGamesPlayed`
pub mod cmsg_client_games_played {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientGamesPlayed.ProcessInfo)
    pub struct ProcessInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.ProcessInfo.process_id)
        pub process_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.ProcessInfo.process_id_parent)
        pub process_id_parent: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.ProcessInfo.parent_is_steam)
        pub parent_is_steam: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientGamesPlayed.ProcessInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ProcessInfo {
        fn default() -> &'a ProcessInfo {
            <ProcessInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl ProcessInfo {
        pub fn new() -> ProcessInfo {
            ::std::default::Default::default()
        }

        // optional uint32 process_id = 1;

        pub fn process_id(&self) -> u32 {
            self.process_id.unwrap_or(0)
        }

        pub fn clear_process_id(&mut self) {
            self.process_id = ::std::option::Option::None;
        }

        pub fn has_process_id(&self) -> bool {
            self.process_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_process_id(&mut self, v: u32) {
            self.process_id = ::std::option::Option::Some(v);
        }

        // optional uint32 process_id_parent = 2;

        pub fn process_id_parent(&self) -> u32 {
            self.process_id_parent.unwrap_or(0)
        }

        pub fn clear_process_id_parent(&mut self) {
            self.process_id_parent = ::std::option::Option::None;
        }

        pub fn has_process_id_parent(&self) -> bool {
            self.process_id_parent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_process_id_parent(&mut self, v: u32) {
            self.process_id_parent = ::std::option::Option::Some(v);
        }

        // optional bool parent_is_steam = 3;

        pub fn parent_is_steam(&self) -> bool {
            self.parent_is_steam.unwrap_or(false)
        }

        pub fn clear_parent_is_steam(&mut self) {
            self.parent_is_steam = ::std::option::Option::None;
        }

        pub fn has_parent_is_steam(&self) -> bool {
            self.parent_is_steam.is_some()
        }

        // Param is passed by value, moved
        pub fn set_parent_is_steam(&mut self, v: bool) {
            self.parent_is_steam = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ProcessInfo {
        const NAME: &'static str = "ProcessInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.process_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.process_id_parent = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.parent_is_steam = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.process_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.process_id_parent {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.parent_is_steam {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.process_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.process_id_parent {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.parent_is_steam {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ProcessInfo {
            ProcessInfo::new()
        }

        fn clear(&mut self) {
            self.process_id = ::std::option::Option::None;
            self.process_id_parent = ::std::option::Option::None;
            self.parent_is_steam = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ProcessInfo {
            static instance: ProcessInfo = ProcessInfo {
                process_id: ::std::option::Option::None,
                process_id_parent: ::std::option::Option::None,
                parent_is_steam: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientGamesPlayed.GamePlayed)
    pub struct GamePlayed {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.steam_id_gs)
        pub steam_id_gs: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_id)
        pub game_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.deprecated_game_ip_address)
        pub deprecated_game_ip_address: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_port)
        pub game_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.is_secure)
        pub is_secure: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.token)
        pub token: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_extra_info)
        pub game_extra_info: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_data_blob)
        pub game_data_blob: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.process_id)
        pub process_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.streaming_provider_id)
        pub streaming_provider_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_flags)
        pub game_flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.owner_id)
        pub owner_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.vr_hmd_vendor)
        pub vr_hmd_vendor: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.vr_hmd_model)
        pub vr_hmd_model: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.launch_option_type)
        pub launch_option_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.primary_controller_type)
        pub primary_controller_type: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.primary_steam_controller_serial)
        pub primary_steam_controller_serial: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.total_steam_controller_count)
        pub total_steam_controller_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.total_non_steam_controller_count)
        pub total_non_steam_controller_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.controller_workshop_file_id)
        pub controller_workshop_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.launch_source)
        pub launch_source: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.vr_hmd_runtime)
        pub vr_hmd_runtime: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_ip_address)
        pub game_ip_address: ::protobuf::MessageField<super::super::steammessages_base::CMsgIPAddress>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.controller_connection_type)
        pub controller_connection_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_os_platform)
        pub game_os_platform: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.game_build_id)
        pub game_build_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.compat_tool_id)
        pub compat_tool_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.compat_tool_cmd)
        pub compat_tool_cmd: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.compat_tool_build_id)
        pub compat_tool_build_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.beta_name)
        pub beta_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.dlc_context)
        pub dlc_context: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientGamesPlayed.GamePlayed.process_id_list)
        pub process_id_list: ::std::vec::Vec<ProcessInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientGamesPlayed.GamePlayed.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GamePlayed {
        fn default() -> &'a GamePlayed {
            <GamePlayed as ::protobuf::Message>::default_instance()
        }
    }

    impl GamePlayed {
        pub fn new() -> GamePlayed {
            ::std::default::Default::default()
        }

        // optional uint64 steam_id_gs = 1;

        pub fn steam_id_gs(&self) -> u64 {
            self.steam_id_gs.unwrap_or(0)
        }

        pub fn clear_steam_id_gs(&mut self) {
            self.steam_id_gs = ::std::option::Option::None;
        }

        pub fn has_steam_id_gs(&self) -> bool {
            self.steam_id_gs.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id_gs(&mut self, v: u64) {
            self.steam_id_gs = ::std::option::Option::Some(v);
        }

        // optional fixed64 game_id = 2;

        pub fn game_id(&self) -> u64 {
            self.game_id.unwrap_or(0)
        }

        pub fn clear_game_id(&mut self) {
            self.game_id = ::std::option::Option::None;
        }

        pub fn has_game_id(&self) -> bool {
            self.game_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_id(&mut self, v: u64) {
            self.game_id = ::std::option::Option::Some(v);
        }

        // optional uint32 deprecated_game_ip_address = 3;

        pub fn deprecated_game_ip_address(&self) -> u32 {
            self.deprecated_game_ip_address.unwrap_or(0)
        }

        pub fn clear_deprecated_game_ip_address(&mut self) {
            self.deprecated_game_ip_address = ::std::option::Option::None;
        }

        pub fn has_deprecated_game_ip_address(&self) -> bool {
            self.deprecated_game_ip_address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deprecated_game_ip_address(&mut self, v: u32) {
            self.deprecated_game_ip_address = ::std::option::Option::Some(v);
        }

        // optional uint32 game_port = 4;

        pub fn game_port(&self) -> u32 {
            self.game_port.unwrap_or(0)
        }

        pub fn clear_game_port(&mut self) {
            self.game_port = ::std::option::Option::None;
        }

        pub fn has_game_port(&self) -> bool {
            self.game_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_port(&mut self, v: u32) {
            self.game_port = ::std::option::Option::Some(v);
        }

        // optional bool is_secure = 5;

        pub fn is_secure(&self) -> bool {
            self.is_secure.unwrap_or(false)
        }

        pub fn clear_is_secure(&mut self) {
            self.is_secure = ::std::option::Option::None;
        }

        pub fn has_is_secure(&self) -> bool {
            self.is_secure.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_secure(&mut self, v: bool) {
            self.is_secure = ::std::option::Option::Some(v);
        }

        // optional bytes token = 6;

        pub fn token(&self) -> &[u8] {
            match self.token.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_token(&mut self) {
            self.token = ::std::option::Option::None;
        }

        pub fn has_token(&self) -> bool {
            self.token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
            self.token = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.token.is_none() {
                self.token = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.token.as_mut().unwrap()
        }

        // Take field
        pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
            self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional string game_extra_info = 7;

        pub fn game_extra_info(&self) -> &str {
            match self.game_extra_info.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_game_extra_info(&mut self) {
            self.game_extra_info = ::std::option::Option::None;
        }

        pub fn has_game_extra_info(&self) -> bool {
            self.game_extra_info.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_extra_info(&mut self, v: ::std::string::String) {
            self.game_extra_info = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_extra_info(&mut self) -> &mut ::std::string::String {
            if self.game_extra_info.is_none() {
                self.game_extra_info = ::std::option::Option::Some(::std::string::String::new());
            }
            self.game_extra_info.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_extra_info(&mut self) -> ::std::string::String {
            self.game_extra_info.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes game_data_blob = 8;

        pub fn game_data_blob(&self) -> &[u8] {
            match self.game_data_blob.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_game_data_blob(&mut self) {
            self.game_data_blob = ::std::option::Option::None;
        }

        pub fn has_game_data_blob(&self) -> bool {
            self.game_data_blob.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_data_blob(&mut self, v: ::std::vec::Vec<u8>) {
            self.game_data_blob = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_data_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.game_data_blob.is_none() {
                self.game_data_blob = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.game_data_blob.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_data_blob(&mut self) -> ::std::vec::Vec<u8> {
            self.game_data_blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 process_id = 9;

        pub fn process_id(&self) -> u32 {
            self.process_id.unwrap_or(0)
        }

        pub fn clear_process_id(&mut self) {
            self.process_id = ::std::option::Option::None;
        }

        pub fn has_process_id(&self) -> bool {
            self.process_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_process_id(&mut self, v: u32) {
            self.process_id = ::std::option::Option::Some(v);
        }

        // optional uint32 streaming_provider_id = 10;

        pub fn streaming_provider_id(&self) -> u32 {
            self.streaming_provider_id.unwrap_or(0)
        }

        pub fn clear_streaming_provider_id(&mut self) {
            self.streaming_provider_id = ::std::option::Option::None;
        }

        pub fn has_streaming_provider_id(&self) -> bool {
            self.streaming_provider_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_streaming_provider_id(&mut self, v: u32) {
            self.streaming_provider_id = ::std::option::Option::Some(v);
        }

        // optional uint32 game_flags = 11;

        pub fn game_flags(&self) -> u32 {
            self.game_flags.unwrap_or(0)
        }

        pub fn clear_game_flags(&mut self) {
            self.game_flags = ::std::option::Option::None;
        }

        pub fn has_game_flags(&self) -> bool {
            self.game_flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_flags(&mut self, v: u32) {
            self.game_flags = ::std::option::Option::Some(v);
        }

        // optional uint32 owner_id = 12;

        pub fn owner_id(&self) -> u32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: u32) {
            self.owner_id = ::std::option::Option::Some(v);
        }

        // optional string vr_hmd_vendor = 13;

        pub fn vr_hmd_vendor(&self) -> &str {
            match self.vr_hmd_vendor.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_vr_hmd_vendor(&mut self) {
            self.vr_hmd_vendor = ::std::option::Option::None;
        }

        pub fn has_vr_hmd_vendor(&self) -> bool {
            self.vr_hmd_vendor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vr_hmd_vendor(&mut self, v: ::std::string::String) {
            self.vr_hmd_vendor = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vr_hmd_vendor(&mut self) -> &mut ::std::string::String {
            if self.vr_hmd_vendor.is_none() {
                self.vr_hmd_vendor = ::std::option::Option::Some(::std::string::String::new());
            }
            self.vr_hmd_vendor.as_mut().unwrap()
        }

        // Take field
        pub fn take_vr_hmd_vendor(&mut self) -> ::std::string::String {
            self.vr_hmd_vendor.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string vr_hmd_model = 14;

        pub fn vr_hmd_model(&self) -> &str {
            match self.vr_hmd_model.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_vr_hmd_model(&mut self) {
            self.vr_hmd_model = ::std::option::Option::None;
        }

        pub fn has_vr_hmd_model(&self) -> bool {
            self.vr_hmd_model.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vr_hmd_model(&mut self, v: ::std::string::String) {
            self.vr_hmd_model = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vr_hmd_model(&mut self) -> &mut ::std::string::String {
            if self.vr_hmd_model.is_none() {
                self.vr_hmd_model = ::std::option::Option::Some(::std::string::String::new());
            }
            self.vr_hmd_model.as_mut().unwrap()
        }

        // Take field
        pub fn take_vr_hmd_model(&mut self) -> ::std::string::String {
            self.vr_hmd_model.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 launch_option_type = 15;

        pub fn launch_option_type(&self) -> u32 {
            self.launch_option_type.unwrap_or(0u32)
        }

        pub fn clear_launch_option_type(&mut self) {
            self.launch_option_type = ::std::option::Option::None;
        }

        pub fn has_launch_option_type(&self) -> bool {
            self.launch_option_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_launch_option_type(&mut self, v: u32) {
            self.launch_option_type = ::std::option::Option::Some(v);
        }

        // optional int32 primary_controller_type = 16;

        pub fn primary_controller_type(&self) -> i32 {
            self.primary_controller_type.unwrap_or(-1i32)
        }

        pub fn clear_primary_controller_type(&mut self) {
            self.primary_controller_type = ::std::option::Option::None;
        }

        pub fn has_primary_controller_type(&self) -> bool {
            self.primary_controller_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_primary_controller_type(&mut self, v: i32) {
            self.primary_controller_type = ::std::option::Option::Some(v);
        }

        // optional string primary_steam_controller_serial = 17;

        pub fn primary_steam_controller_serial(&self) -> &str {
            match self.primary_steam_controller_serial.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_primary_steam_controller_serial(&mut self) {
            self.primary_steam_controller_serial = ::std::option::Option::None;
        }

        pub fn has_primary_steam_controller_serial(&self) -> bool {
            self.primary_steam_controller_serial.is_some()
        }

        // Param is passed by value, moved
        pub fn set_primary_steam_controller_serial(&mut self, v: ::std::string::String) {
            self.primary_steam_controller_serial = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_primary_steam_controller_serial(&mut self) -> &mut ::std::string::String {
            if self.primary_steam_controller_serial.is_none() {
                self.primary_steam_controller_serial = ::std::option::Option::Some(::std::string::String::new());
            }
            self.primary_steam_controller_serial.as_mut().unwrap()
        }

        // Take field
        pub fn take_primary_steam_controller_serial(&mut self) -> ::std::string::String {
            self.primary_steam_controller_serial.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 total_steam_controller_count = 18;

        pub fn total_steam_controller_count(&self) -> u32 {
            self.total_steam_controller_count.unwrap_or(0u32)
        }

        pub fn clear_total_steam_controller_count(&mut self) {
            self.total_steam_controller_count = ::std::option::Option::None;
        }

        pub fn has_total_steam_controller_count(&self) -> bool {
            self.total_steam_controller_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_steam_controller_count(&mut self, v: u32) {
            self.total_steam_controller_count = ::std::option::Option::Some(v);
        }

        // optional uint32 total_non_steam_controller_count = 19;

        pub fn total_non_steam_controller_count(&self) -> u32 {
            self.total_non_steam_controller_count.unwrap_or(0u32)
        }

        pub fn clear_total_non_steam_controller_count(&mut self) {
            self.total_non_steam_controller_count = ::std::option::Option::None;
        }

        pub fn has_total_non_steam_controller_count(&self) -> bool {
            self.total_non_steam_controller_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_non_steam_controller_count(&mut self, v: u32) {
            self.total_non_steam_controller_count = ::std::option::Option::Some(v);
        }

        // optional uint64 controller_workshop_file_id = 20;

        pub fn controller_workshop_file_id(&self) -> u64 {
            self.controller_workshop_file_id.unwrap_or(0u64)
        }

        pub fn clear_controller_workshop_file_id(&mut self) {
            self.controller_workshop_file_id = ::std::option::Option::None;
        }

        pub fn has_controller_workshop_file_id(&self) -> bool {
            self.controller_workshop_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controller_workshop_file_id(&mut self, v: u64) {
            self.controller_workshop_file_id = ::std::option::Option::Some(v);
        }

        // optional uint32 launch_source = 21;

        pub fn launch_source(&self) -> u32 {
            self.launch_source.unwrap_or(0u32)
        }

        pub fn clear_launch_source(&mut self) {
            self.launch_source = ::std::option::Option::None;
        }

        pub fn has_launch_source(&self) -> bool {
            self.launch_source.is_some()
        }

        // Param is passed by value, moved
        pub fn set_launch_source(&mut self, v: u32) {
            self.launch_source = ::std::option::Option::Some(v);
        }

        // optional uint32 vr_hmd_runtime = 22;

        pub fn vr_hmd_runtime(&self) -> u32 {
            self.vr_hmd_runtime.unwrap_or(0)
        }

        pub fn clear_vr_hmd_runtime(&mut self) {
            self.vr_hmd_runtime = ::std::option::Option::None;
        }

        pub fn has_vr_hmd_runtime(&self) -> bool {
            self.vr_hmd_runtime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vr_hmd_runtime(&mut self, v: u32) {
            self.vr_hmd_runtime = ::std::option::Option::Some(v);
        }

        // optional uint32 controller_connection_type = 24;

        pub fn controller_connection_type(&self) -> u32 {
            self.controller_connection_type.unwrap_or(0u32)
        }

        pub fn clear_controller_connection_type(&mut self) {
            self.controller_connection_type = ::std::option::Option::None;
        }

        pub fn has_controller_connection_type(&self) -> bool {
            self.controller_connection_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controller_connection_type(&mut self, v: u32) {
            self.controller_connection_type = ::std::option::Option::Some(v);
        }

        // optional int32 game_os_platform = 25;

        pub fn game_os_platform(&self) -> i32 {
            self.game_os_platform.unwrap_or(0)
        }

        pub fn clear_game_os_platform(&mut self) {
            self.game_os_platform = ::std::option::Option::None;
        }

        pub fn has_game_os_platform(&self) -> bool {
            self.game_os_platform.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_os_platform(&mut self, v: i32) {
            self.game_os_platform = ::std::option::Option::Some(v);
        }

        // optional uint32 game_build_id = 26;

        pub fn game_build_id(&self) -> u32 {
            self.game_build_id.unwrap_or(0)
        }

        pub fn clear_game_build_id(&mut self) {
            self.game_build_id = ::std::option::Option::None;
        }

        pub fn has_game_build_id(&self) -> bool {
            self.game_build_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_build_id(&mut self, v: u32) {
            self.game_build_id = ::std::option::Option::Some(v);
        }

        // optional uint32 compat_tool_id = 27;

        pub fn compat_tool_id(&self) -> u32 {
            self.compat_tool_id.unwrap_or(0u32)
        }

        pub fn clear_compat_tool_id(&mut self) {
            self.compat_tool_id = ::std::option::Option::None;
        }

        pub fn has_compat_tool_id(&self) -> bool {
            self.compat_tool_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_compat_tool_id(&mut self, v: u32) {
            self.compat_tool_id = ::std::option::Option::Some(v);
        }

        // optional string compat_tool_cmd = 28;

        pub fn compat_tool_cmd(&self) -> &str {
            match self.compat_tool_cmd.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_compat_tool_cmd(&mut self) {
            self.compat_tool_cmd = ::std::option::Option::None;
        }

        pub fn has_compat_tool_cmd(&self) -> bool {
            self.compat_tool_cmd.is_some()
        }

        // Param is passed by value, moved
        pub fn set_compat_tool_cmd(&mut self, v: ::std::string::String) {
            self.compat_tool_cmd = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_compat_tool_cmd(&mut self) -> &mut ::std::string::String {
            if self.compat_tool_cmd.is_none() {
                self.compat_tool_cmd = ::std::option::Option::Some(::std::string::String::new());
            }
            self.compat_tool_cmd.as_mut().unwrap()
        }

        // Take field
        pub fn take_compat_tool_cmd(&mut self) -> ::std::string::String {
            self.compat_tool_cmd.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 compat_tool_build_id = 29;

        pub fn compat_tool_build_id(&self) -> u32 {
            self.compat_tool_build_id.unwrap_or(0)
        }

        pub fn clear_compat_tool_build_id(&mut self) {
            self.compat_tool_build_id = ::std::option::Option::None;
        }

        pub fn has_compat_tool_build_id(&self) -> bool {
            self.compat_tool_build_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_compat_tool_build_id(&mut self, v: u32) {
            self.compat_tool_build_id = ::std::option::Option::Some(v);
        }

        // optional string beta_name = 30;

        pub fn beta_name(&self) -> &str {
            match self.beta_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_beta_name(&mut self) {
            self.beta_name = ::std::option::Option::None;
        }

        pub fn has_beta_name(&self) -> bool {
            self.beta_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_beta_name(&mut self, v: ::std::string::String) {
            self.beta_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_beta_name(&mut self) -> &mut ::std::string::String {
            if self.beta_name.is_none() {
                self.beta_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.beta_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_beta_name(&mut self) -> ::std::string::String {
            self.beta_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 dlc_context = 31;

        pub fn dlc_context(&self) -> u32 {
            self.dlc_context.unwrap_or(0)
        }

        pub fn clear_dlc_context(&mut self) {
            self.dlc_context = ::std::option::Option::None;
        }

        pub fn has_dlc_context(&self) -> bool {
            self.dlc_context.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dlc_context(&mut self, v: u32) {
            self.dlc_context = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for GamePlayed {
        const NAME: &'static str = "GamePlayed";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.steam_id_gs = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    17 => {
                        self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    24 => {
                        self.deprecated_game_ip_address = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.game_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.is_secure = ::std::option::Option::Some(is.read_bool()?);
                    },
                    50 => {
                        self.token = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    58 => {
                        self.game_extra_info = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.game_data_blob = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    72 => {
                        self.process_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.streaming_provider_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.game_flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.owner_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    106 => {
                        self.vr_hmd_vendor = ::std::option::Option::Some(is.read_string()?);
                    },
                    114 => {
                        self.vr_hmd_model = ::std::option::Option::Some(is.read_string()?);
                    },
                    120 => {
                        self.launch_option_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    128 => {
                        self.primary_controller_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    138 => {
                        self.primary_steam_controller_serial = ::std::option::Option::Some(is.read_string()?);
                    },
                    144 => {
                        self.total_steam_controller_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    152 => {
                        self.total_non_steam_controller_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    160 => {
                        self.controller_workshop_file_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    168 => {
                        self.launch_source = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    176 => {
                        self.vr_hmd_runtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    186 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_ip_address)?;
                    },
                    192 => {
                        self.controller_connection_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    200 => {
                        self.game_os_platform = ::std::option::Option::Some(is.read_int32()?);
                    },
                    208 => {
                        self.game_build_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    216 => {
                        self.compat_tool_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    226 => {
                        self.compat_tool_cmd = ::std::option::Option::Some(is.read_string()?);
                    },
                    232 => {
                        self.compat_tool_build_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    242 => {
                        self.beta_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    248 => {
                        self.dlc_context = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    258 => {
                        self.process_id_list.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id_gs {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.game_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.deprecated_game_ip_address {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.game_port {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.is_secure {
                my_size += 1 + 1;
            }
            if let Some(v) = self.token.as_ref() {
                my_size += ::protobuf::rt::bytes_size(6, &v);
            }
            if let Some(v) = self.game_extra_info.as_ref() {
                my_size += ::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.game_data_blob.as_ref() {
                my_size += ::protobuf::rt::bytes_size(8, &v);
            }
            if let Some(v) = self.process_id {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.streaming_provider_id {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.game_flags {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.owner_id {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.vr_hmd_vendor.as_ref() {
                my_size += ::protobuf::rt::string_size(13, &v);
            }
            if let Some(v) = self.vr_hmd_model.as_ref() {
                my_size += ::protobuf::rt::string_size(14, &v);
            }
            if let Some(v) = self.launch_option_type {
                my_size += ::protobuf::rt::uint32_size(15, v);
            }
            if let Some(v) = self.primary_controller_type {
                my_size += ::protobuf::rt::int32_size(16, v);
            }
            if let Some(v) = self.primary_steam_controller_serial.as_ref() {
                my_size += ::protobuf::rt::string_size(17, &v);
            }
            if let Some(v) = self.total_steam_controller_count {
                my_size += ::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.total_non_steam_controller_count {
                my_size += ::protobuf::rt::uint32_size(19, v);
            }
            if let Some(v) = self.controller_workshop_file_id {
                my_size += ::protobuf::rt::uint64_size(20, v);
            }
            if let Some(v) = self.launch_source {
                my_size += ::protobuf::rt::uint32_size(21, v);
            }
            if let Some(v) = self.vr_hmd_runtime {
                my_size += ::protobuf::rt::uint32_size(22, v);
            }
            if let Some(v) = self.game_ip_address.as_ref() {
                let len = v.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.controller_connection_type {
                my_size += ::protobuf::rt::uint32_size(24, v);
            }
            if let Some(v) = self.game_os_platform {
                my_size += ::protobuf::rt::int32_size(25, v);
            }
            if let Some(v) = self.game_build_id {
                my_size += ::protobuf::rt::uint32_size(26, v);
            }
            if let Some(v) = self.compat_tool_id {
                my_size += ::protobuf::rt::uint32_size(27, v);
            }
            if let Some(v) = self.compat_tool_cmd.as_ref() {
                my_size += ::protobuf::rt::string_size(28, &v);
            }
            if let Some(v) = self.compat_tool_build_id {
                my_size += ::protobuf::rt::uint32_size(29, v);
            }
            if let Some(v) = self.beta_name.as_ref() {
                my_size += ::protobuf::rt::string_size(30, &v);
            }
            if let Some(v) = self.dlc_context {
                my_size += ::protobuf::rt::uint32_size(31, v);
            }
            for value in &self.process_id_list {
                let len = value.compute_size();
                my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steam_id_gs {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.game_id {
                os.write_fixed64(2, v)?;
            }
            if let Some(v) = self.deprecated_game_ip_address {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.game_port {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.is_secure {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.token.as_ref() {
                os.write_bytes(6, v)?;
            }
            if let Some(v) = self.game_extra_info.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.game_data_blob.as_ref() {
                os.write_bytes(8, v)?;
            }
            if let Some(v) = self.process_id {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.streaming_provider_id {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.game_flags {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.owner_id {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.vr_hmd_vendor.as_ref() {
                os.write_string(13, v)?;
            }
            if let Some(v) = self.vr_hmd_model.as_ref() {
                os.write_string(14, v)?;
            }
            if let Some(v) = self.launch_option_type {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.primary_controller_type {
                os.write_int32(16, v)?;
            }
            if let Some(v) = self.primary_steam_controller_serial.as_ref() {
                os.write_string(17, v)?;
            }
            if let Some(v) = self.total_steam_controller_count {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.total_non_steam_controller_count {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.controller_workshop_file_id {
                os.write_uint64(20, v)?;
            }
            if let Some(v) = self.launch_source {
                os.write_uint32(21, v)?;
            }
            if let Some(v) = self.vr_hmd_runtime {
                os.write_uint32(22, v)?;
            }
            if let Some(v) = self.game_ip_address.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
            }
            if let Some(v) = self.controller_connection_type {
                os.write_uint32(24, v)?;
            }
            if let Some(v) = self.game_os_platform {
                os.write_int32(25, v)?;
            }
            if let Some(v) = self.game_build_id {
                os.write_uint32(26, v)?;
            }
            if let Some(v) = self.compat_tool_id {
                os.write_uint32(27, v)?;
            }
            if let Some(v) = self.compat_tool_cmd.as_ref() {
                os.write_string(28, v)?;
            }
            if let Some(v) = self.compat_tool_build_id {
                os.write_uint32(29, v)?;
            }
            if let Some(v) = self.beta_name.as_ref() {
                os.write_string(30, v)?;
            }
            if let Some(v) = self.dlc_context {
                os.write_uint32(31, v)?;
            }
            for v in &self.process_id_list {
                ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GamePlayed {
            GamePlayed::new()
        }

        fn clear(&mut self) {
            self.steam_id_gs = ::std::option::Option::None;
            self.game_id = ::std::option::Option::None;
            self.deprecated_game_ip_address = ::std::option::Option::None;
            self.game_port = ::std::option::Option::None;
            self.is_secure = ::std::option::Option::None;
            self.token = ::std::option::Option::None;
            self.game_extra_info = ::std::option::Option::None;
            self.game_data_blob = ::std::option::Option::None;
            self.process_id = ::std::option::Option::None;
            self.streaming_provider_id = ::std::option::Option::None;
            self.game_flags = ::std::option::Option::None;
            self.owner_id = ::std::option::Option::None;
            self.vr_hmd_vendor = ::std::option::Option::None;
            self.vr_hmd_model = ::std::option::Option::None;
            self.launch_option_type = ::std::option::Option::None;
            self.primary_controller_type = ::std::option::Option::None;
            self.primary_steam_controller_serial = ::std::option::Option::None;
            self.total_steam_controller_count = ::std::option::Option::None;
            self.total_non_steam_controller_count = ::std::option::Option::None;
            self.controller_workshop_file_id = ::std::option::Option::None;
            self.launch_source = ::std::option::Option::None;
            self.vr_hmd_runtime = ::std::option::Option::None;
            self.game_ip_address.clear();
            self.controller_connection_type = ::std::option::Option::None;
            self.game_os_platform = ::std::option::Option::None;
            self.game_build_id = ::std::option::Option::None;
            self.compat_tool_id = ::std::option::Option::None;
            self.compat_tool_cmd = ::std::option::Option::None;
            self.compat_tool_build_id = ::std::option::Option::None;
            self.beta_name = ::std::option::Option::None;
            self.dlc_context = ::std::option::Option::None;
            self.process_id_list.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GamePlayed {
            static instance: GamePlayed = GamePlayed {
                steam_id_gs: ::std::option::Option::None,
                game_id: ::std::option::Option::None,
                deprecated_game_ip_address: ::std::option::Option::None,
                game_port: ::std::option::Option::None,
                is_secure: ::std::option::Option::None,
                token: ::std::option::Option::None,
                game_extra_info: ::std::option::Option::None,
                game_data_blob: ::std::option::Option::None,
                process_id: ::std::option::Option::None,
                streaming_provider_id: ::std::option::Option::None,
                game_flags: ::std::option::Option::None,
                owner_id: ::std::option::Option::None,
                vr_hmd_vendor: ::std::option::Option::None,
                vr_hmd_model: ::std::option::Option::None,
                launch_option_type: ::std::option::Option::None,
                primary_controller_type: ::std::option::Option::None,
                primary_steam_controller_serial: ::std::option::Option::None,
                total_steam_controller_count: ::std::option::Option::None,
                total_non_steam_controller_count: ::std::option::Option::None,
                controller_workshop_file_id: ::std::option::Option::None,
                launch_source: ::std::option::Option::None,
                vr_hmd_runtime: ::std::option::Option::None,
                game_ip_address: ::protobuf::MessageField::none(),
                controller_connection_type: ::std::option::Option::None,
                game_os_platform: ::std::option::Option::None,
                game_build_id: ::std::option::Option::None,
                compat_tool_id: ::std::option::Option::None,
                compat_tool_cmd: ::std::option::Option::None,
                compat_tool_build_id: ::std::option::Option::None,
                beta_name: ::std::option::Option::None,
                dlc_context: ::std::option::Option::None,
                process_id_list: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGSApprove)
pub struct CMsgGSApprove {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSApprove.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSApprove.owner_steam_id)
    pub owner_steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSApprove.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSApprove {
    fn default() -> &'a CMsgGSApprove {
        <CMsgGSApprove as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSApprove {
    pub fn new() -> CMsgGSApprove {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 owner_steam_id = 2;

    pub fn owner_steam_id(&self) -> u64 {
        self.owner_steam_id.unwrap_or(0)
    }

    pub fn clear_owner_steam_id(&mut self) {
        self.owner_steam_id = ::std::option::Option::None;
    }

    pub fn has_owner_steam_id(&self) -> bool {
        self.owner_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steam_id(&mut self, v: u64) {
        self.owner_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSApprove {
    const NAME: &'static str = "CMsgGSApprove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.owner_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.owner_steam_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSApprove {
        CMsgGSApprove::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.owner_steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSApprove {
        static instance: CMsgGSApprove = CMsgGSApprove {
            steam_id: ::std::option::Option::None,
            owner_steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGSDeny)
pub struct CMsgGSDeny {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSDeny.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSDeny.edeny_reason)
    pub edeny_reason: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGSDeny.deny_string)
    pub deny_string: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSDeny.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSDeny {
    fn default() -> &'a CMsgGSDeny {
        <CMsgGSDeny as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSDeny {
    pub fn new() -> CMsgGSDeny {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional int32 edeny_reason = 2;

    pub fn edeny_reason(&self) -> i32 {
        self.edeny_reason.unwrap_or(0)
    }

    pub fn clear_edeny_reason(&mut self) {
        self.edeny_reason = ::std::option::Option::None;
    }

    pub fn has_edeny_reason(&self) -> bool {
        self.edeny_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edeny_reason(&mut self, v: i32) {
        self.edeny_reason = ::std::option::Option::Some(v);
    }

    // optional string deny_string = 3;

    pub fn deny_string(&self) -> &str {
        match self.deny_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_deny_string(&mut self) {
        self.deny_string = ::std::option::Option::None;
    }

    pub fn has_deny_string(&self) -> bool {
        self.deny_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deny_string(&mut self, v: ::std::string::String) {
        self.deny_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deny_string(&mut self) -> &mut ::std::string::String {
        if self.deny_string.is_none() {
            self.deny_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.deny_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_deny_string(&mut self) -> ::std::string::String {
        self.deny_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGSDeny {
    const NAME: &'static str = "CMsgGSDeny";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.edeny_reason = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.deny_string = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.edeny_reason {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.deny_string.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.edeny_reason {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.deny_string.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSDeny {
        CMsgGSDeny::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.edeny_reason = ::std::option::Option::None;
        self.deny_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSDeny {
        static instance: CMsgGSDeny = CMsgGSDeny {
            steam_id: ::std::option::Option::None,
            edeny_reason: ::std::option::Option::None,
            deny_string: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGSKick)
pub struct CMsgGSKick {
    // message fields
    // @@protoc_insertion_point(field:CMsgGSKick.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGSKick.edeny_reason)
    pub edeny_reason: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGSKick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGSKick {
    fn default() -> &'a CMsgGSKick {
        <CMsgGSKick as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSKick {
    pub fn new() -> CMsgGSKick {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional int32 edeny_reason = 2;

    pub fn edeny_reason(&self) -> i32 {
        self.edeny_reason.unwrap_or(0)
    }

    pub fn clear_edeny_reason(&mut self) {
        self.edeny_reason = ::std::option::Option::None;
    }

    pub fn has_edeny_reason(&self) -> bool {
        self.edeny_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edeny_reason(&mut self, v: i32) {
        self.edeny_reason = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSKick {
    const NAME: &'static str = "CMsgGSKick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.edeny_reason = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.edeny_reason {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.edeny_reason {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGSKick {
        CMsgGSKick::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.edeny_reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGSKick {
        static instance: CMsgGSKick = CMsgGSKick {
            steam_id: ::std::option::Option::None,
            edeny_reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientAuthList)
pub struct CMsgClientAuthList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAuthList.tokens_left)
    pub tokens_left: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.last_request_seq)
    pub last_request_seq: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.last_request_seq_from_server)
    pub last_request_seq_from_server: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.tickets)
    pub tickets: ::std::vec::Vec<super::steammessages_base::CMsgAuthTicket>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.app_ids)
    pub app_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.message_sequence)
    pub message_sequence: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthList.filtered)
    pub filtered: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAuthList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthList {
    fn default() -> &'a CMsgClientAuthList {
        <CMsgClientAuthList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthList {
    pub fn new() -> CMsgClientAuthList {
        ::std::default::Default::default()
    }

    // optional uint32 tokens_left = 1;

    pub fn tokens_left(&self) -> u32 {
        self.tokens_left.unwrap_or(0)
    }

    pub fn clear_tokens_left(&mut self) {
        self.tokens_left = ::std::option::Option::None;
    }

    pub fn has_tokens_left(&self) -> bool {
        self.tokens_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokens_left(&mut self, v: u32) {
        self.tokens_left = ::std::option::Option::Some(v);
    }

    // optional uint32 last_request_seq = 2;

    pub fn last_request_seq(&self) -> u32 {
        self.last_request_seq.unwrap_or(0)
    }

    pub fn clear_last_request_seq(&mut self) {
        self.last_request_seq = ::std::option::Option::None;
    }

    pub fn has_last_request_seq(&self) -> bool {
        self.last_request_seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_request_seq(&mut self, v: u32) {
        self.last_request_seq = ::std::option::Option::Some(v);
    }

    // optional uint32 last_request_seq_from_server = 3;

    pub fn last_request_seq_from_server(&self) -> u32 {
        self.last_request_seq_from_server.unwrap_or(0)
    }

    pub fn clear_last_request_seq_from_server(&mut self) {
        self.last_request_seq_from_server = ::std::option::Option::None;
    }

    pub fn has_last_request_seq_from_server(&self) -> bool {
        self.last_request_seq_from_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_request_seq_from_server(&mut self, v: u32) {
        self.last_request_seq_from_server = ::std::option::Option::Some(v);
    }

    // optional uint32 message_sequence = 6;

    pub fn message_sequence(&self) -> u32 {
        self.message_sequence.unwrap_or(0)
    }

    pub fn clear_message_sequence(&mut self) {
        self.message_sequence = ::std::option::Option::None;
    }

    pub fn has_message_sequence(&self) -> bool {
        self.message_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_sequence(&mut self, v: u32) {
        self.message_sequence = ::std::option::Option::Some(v);
    }

    // optional bool filtered = 7;

    pub fn filtered(&self) -> bool {
        self.filtered.unwrap_or(false)
    }

    pub fn clear_filtered(&mut self) {
        self.filtered = ::std::option::Option::None;
    }

    pub fn has_filtered(&self) -> bool {
        self.filtered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filtered(&mut self, v: bool) {
        self.filtered = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAuthList {
    const NAME: &'static str = "CMsgClientAuthList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tokens_left = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.last_request_seq = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.last_request_seq_from_server = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.tickets.push(is.read_message()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.app_ids)?;
                },
                40 => {
                    self.app_ids.push(is.read_uint32()?);
                },
                48 => {
                    self.message_sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.filtered = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tokens_left {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.last_request_seq {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.last_request_seq_from_server {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.tickets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.app_ids {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        if let Some(v) = self.message_sequence {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.filtered {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tokens_left {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_request_seq {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.last_request_seq_from_server {
            os.write_uint32(3, v)?;
        }
        for v in &self.tickets {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.app_ids {
            os.write_uint32(5, *v)?;
        };
        if let Some(v) = self.message_sequence {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.filtered {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAuthList {
        CMsgClientAuthList::new()
    }

    fn clear(&mut self) {
        self.tokens_left = ::std::option::Option::None;
        self.last_request_seq = ::std::option::Option::None;
        self.last_request_seq_from_server = ::std::option::Option::None;
        self.tickets.clear();
        self.app_ids.clear();
        self.message_sequence = ::std::option::Option::None;
        self.filtered = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAuthList {
        static instance: CMsgClientAuthList = CMsgClientAuthList {
            tokens_left: ::std::option::Option::None,
            last_request_seq: ::std::option::Option::None,
            last_request_seq_from_server: ::std::option::Option::None,
            tickets: ::std::vec::Vec::new(),
            app_ids: ::std::vec::Vec::new(),
            message_sequence: ::std::option::Option::None,
            filtered: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientAuthListAck)
pub struct CMsgClientAuthListAck {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAuthListAck.ticket_crc)
    pub ticket_crc: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthListAck.app_ids)
    pub app_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientAuthListAck.message_sequence)
    pub message_sequence: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAuthListAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthListAck {
    fn default() -> &'a CMsgClientAuthListAck {
        <CMsgClientAuthListAck as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthListAck {
    pub fn new() -> CMsgClientAuthListAck {
        ::std::default::Default::default()
    }

    // optional uint32 message_sequence = 3;

    pub fn message_sequence(&self) -> u32 {
        self.message_sequence.unwrap_or(0)
    }

    pub fn clear_message_sequence(&mut self) {
        self.message_sequence = ::std::option::Option::None;
    }

    pub fn has_message_sequence(&self) -> bool {
        self.message_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_sequence(&mut self, v: u32) {
        self.message_sequence = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAuthListAck {
    const NAME: &'static str = "CMsgClientAuthListAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.ticket_crc)?;
                },
                8 => {
                    self.ticket_crc.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.app_ids)?;
                },
                16 => {
                    self.app_ids.push(is.read_uint32()?);
                },
                24 => {
                    self.message_sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ticket_crc {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.app_ids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.message_sequence {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ticket_crc {
            os.write_uint32(1, *v)?;
        };
        for v in &self.app_ids {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.message_sequence {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAuthListAck {
        CMsgClientAuthListAck::new()
    }

    fn clear(&mut self) {
        self.ticket_crc.clear();
        self.app_ids.clear();
        self.message_sequence = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAuthListAck {
        static instance: CMsgClientAuthListAck = CMsgClientAuthListAck {
            ticket_crc: ::std::vec::Vec::new(),
            app_ids: ::std::vec::Vec::new(),
            message_sequence: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientLicenseList)
pub struct CMsgClientLicenseList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientLicenseList.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientLicenseList.licenses)
    pub licenses: ::std::vec::Vec<cmsg_client_license_list::License>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientLicenseList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientLicenseList {
    fn default() -> &'a CMsgClientLicenseList {
        <CMsgClientLicenseList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientLicenseList {
    pub fn new() -> CMsgClientLicenseList {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientLicenseList {
    const NAME: &'static str = "CMsgClientLicenseList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.licenses.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.licenses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.licenses {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientLicenseList {
        CMsgClientLicenseList::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.licenses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientLicenseList {
        static instance: CMsgClientLicenseList = CMsgClientLicenseList {
            eresult: ::std::option::Option::None,
            licenses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientLicenseList`
pub mod cmsg_client_license_list {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientLicenseList.License)
    pub struct License {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.package_id)
        pub package_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.time_created)
        pub time_created: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.time_next_process)
        pub time_next_process: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.minute_limit)
        pub minute_limit: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.minutes_used)
        pub minutes_used: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.payment_method)
        pub payment_method: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.flags)
        pub flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.purchase_country_code)
        pub purchase_country_code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.license_type)
        pub license_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.territory_code)
        pub territory_code: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.change_number)
        pub change_number: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.owner_id)
        pub owner_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.initial_period)
        pub initial_period: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.initial_time_unit)
        pub initial_time_unit: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.renewal_period)
        pub renewal_period: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.renewal_time_unit)
        pub renewal_time_unit: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.access_token)
        pub access_token: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientLicenseList.License.master_package_id)
        pub master_package_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientLicenseList.License.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a License {
        fn default() -> &'a License {
            <License as ::protobuf::Message>::default_instance()
        }
    }

    impl License {
        pub fn new() -> License {
            ::std::default::Default::default()
        }

        // optional uint32 package_id = 1;

        pub fn package_id(&self) -> u32 {
            self.package_id.unwrap_or(0)
        }

        pub fn clear_package_id(&mut self) {
            self.package_id = ::std::option::Option::None;
        }

        pub fn has_package_id(&self) -> bool {
            self.package_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_package_id(&mut self, v: u32) {
            self.package_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 time_created = 2;

        pub fn time_created(&self) -> u32 {
            self.time_created.unwrap_or(0)
        }

        pub fn clear_time_created(&mut self) {
            self.time_created = ::std::option::Option::None;
        }

        pub fn has_time_created(&self) -> bool {
            self.time_created.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_created(&mut self, v: u32) {
            self.time_created = ::std::option::Option::Some(v);
        }

        // optional fixed32 time_next_process = 3;

        pub fn time_next_process(&self) -> u32 {
            self.time_next_process.unwrap_or(0)
        }

        pub fn clear_time_next_process(&mut self) {
            self.time_next_process = ::std::option::Option::None;
        }

        pub fn has_time_next_process(&self) -> bool {
            self.time_next_process.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_next_process(&mut self, v: u32) {
            self.time_next_process = ::std::option::Option::Some(v);
        }

        // optional int32 minute_limit = 4;

        pub fn minute_limit(&self) -> i32 {
            self.minute_limit.unwrap_or(0)
        }

        pub fn clear_minute_limit(&mut self) {
            self.minute_limit = ::std::option::Option::None;
        }

        pub fn has_minute_limit(&self) -> bool {
            self.minute_limit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_minute_limit(&mut self, v: i32) {
            self.minute_limit = ::std::option::Option::Some(v);
        }

        // optional int32 minutes_used = 5;

        pub fn minutes_used(&self) -> i32 {
            self.minutes_used.unwrap_or(0)
        }

        pub fn clear_minutes_used(&mut self) {
            self.minutes_used = ::std::option::Option::None;
        }

        pub fn has_minutes_used(&self) -> bool {
            self.minutes_used.is_some()
        }

        // Param is passed by value, moved
        pub fn set_minutes_used(&mut self, v: i32) {
            self.minutes_used = ::std::option::Option::Some(v);
        }

        // optional uint32 payment_method = 6;

        pub fn payment_method(&self) -> u32 {
            self.payment_method.unwrap_or(0)
        }

        pub fn clear_payment_method(&mut self) {
            self.payment_method = ::std::option::Option::None;
        }

        pub fn has_payment_method(&self) -> bool {
            self.payment_method.is_some()
        }

        // Param is passed by value, moved
        pub fn set_payment_method(&mut self, v: u32) {
            self.payment_method = ::std::option::Option::Some(v);
        }

        // optional uint32 flags = 7;

        pub fn flags(&self) -> u32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: u32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional string purchase_country_code = 8;

        pub fn purchase_country_code(&self) -> &str {
            match self.purchase_country_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_purchase_country_code(&mut self) {
            self.purchase_country_code = ::std::option::Option::None;
        }

        pub fn has_purchase_country_code(&self) -> bool {
            self.purchase_country_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_purchase_country_code(&mut self, v: ::std::string::String) {
            self.purchase_country_code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_purchase_country_code(&mut self) -> &mut ::std::string::String {
            if self.purchase_country_code.is_none() {
                self.purchase_country_code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.purchase_country_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_purchase_country_code(&mut self) -> ::std::string::String {
            self.purchase_country_code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 license_type = 9;

        pub fn license_type(&self) -> u32 {
            self.license_type.unwrap_or(0)
        }

        pub fn clear_license_type(&mut self) {
            self.license_type = ::std::option::Option::None;
        }

        pub fn has_license_type(&self) -> bool {
            self.license_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_license_type(&mut self, v: u32) {
            self.license_type = ::std::option::Option::Some(v);
        }

        // optional int32 territory_code = 10;

        pub fn territory_code(&self) -> i32 {
            self.territory_code.unwrap_or(0)
        }

        pub fn clear_territory_code(&mut self) {
            self.territory_code = ::std::option::Option::None;
        }

        pub fn has_territory_code(&self) -> bool {
            self.territory_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_territory_code(&mut self, v: i32) {
            self.territory_code = ::std::option::Option::Some(v);
        }

        // optional int32 change_number = 11;

        pub fn change_number(&self) -> i32 {
            self.change_number.unwrap_or(0)
        }

        pub fn clear_change_number(&mut self) {
            self.change_number = ::std::option::Option::None;
        }

        pub fn has_change_number(&self) -> bool {
            self.change_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_number(&mut self, v: i32) {
            self.change_number = ::std::option::Option::Some(v);
        }

        // optional uint32 owner_id = 12;

        pub fn owner_id(&self) -> u32 {
            self.owner_id.unwrap_or(0)
        }

        pub fn clear_owner_id(&mut self) {
            self.owner_id = ::std::option::Option::None;
        }

        pub fn has_owner_id(&self) -> bool {
            self.owner_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owner_id(&mut self, v: u32) {
            self.owner_id = ::std::option::Option::Some(v);
        }

        // optional uint32 initial_period = 13;

        pub fn initial_period(&self) -> u32 {
            self.initial_period.unwrap_or(0)
        }

        pub fn clear_initial_period(&mut self) {
            self.initial_period = ::std::option::Option::None;
        }

        pub fn has_initial_period(&self) -> bool {
            self.initial_period.is_some()
        }

        // Param is passed by value, moved
        pub fn set_initial_period(&mut self, v: u32) {
            self.initial_period = ::std::option::Option::Some(v);
        }

        // optional uint32 initial_time_unit = 14;

        pub fn initial_time_unit(&self) -> u32 {
            self.initial_time_unit.unwrap_or(0)
        }

        pub fn clear_initial_time_unit(&mut self) {
            self.initial_time_unit = ::std::option::Option::None;
        }

        pub fn has_initial_time_unit(&self) -> bool {
            self.initial_time_unit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_initial_time_unit(&mut self, v: u32) {
            self.initial_time_unit = ::std::option::Option::Some(v);
        }

        // optional uint32 renewal_period = 15;

        pub fn renewal_period(&self) -> u32 {
            self.renewal_period.unwrap_or(0)
        }

        pub fn clear_renewal_period(&mut self) {
            self.renewal_period = ::std::option::Option::None;
        }

        pub fn has_renewal_period(&self) -> bool {
            self.renewal_period.is_some()
        }

        // Param is passed by value, moved
        pub fn set_renewal_period(&mut self, v: u32) {
            self.renewal_period = ::std::option::Option::Some(v);
        }

        // optional uint32 renewal_time_unit = 16;

        pub fn renewal_time_unit(&self) -> u32 {
            self.renewal_time_unit.unwrap_or(0)
        }

        pub fn clear_renewal_time_unit(&mut self) {
            self.renewal_time_unit = ::std::option::Option::None;
        }

        pub fn has_renewal_time_unit(&self) -> bool {
            self.renewal_time_unit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_renewal_time_unit(&mut self, v: u32) {
            self.renewal_time_unit = ::std::option::Option::Some(v);
        }

        // optional uint64 access_token = 17;

        pub fn access_token(&self) -> u64 {
            self.access_token.unwrap_or(0)
        }

        pub fn clear_access_token(&mut self) {
            self.access_token = ::std::option::Option::None;
        }

        pub fn has_access_token(&self) -> bool {
            self.access_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_access_token(&mut self, v: u64) {
            self.access_token = ::std::option::Option::Some(v);
        }

        // optional uint32 master_package_id = 18;

        pub fn master_package_id(&self) -> u32 {
            self.master_package_id.unwrap_or(0)
        }

        pub fn clear_master_package_id(&mut self) {
            self.master_package_id = ::std::option::Option::None;
        }

        pub fn has_master_package_id(&self) -> bool {
            self.master_package_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_master_package_id(&mut self, v: u32) {
            self.master_package_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for License {
        const NAME: &'static str = "License";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.package_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.time_created = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    29 => {
                        self.time_next_process = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    32 => {
                        self.minute_limit = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.minutes_used = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.payment_method = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    66 => {
                        self.purchase_country_code = ::std::option::Option::Some(is.read_string()?);
                    },
                    72 => {
                        self.license_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.territory_code = ::std::option::Option::Some(is.read_int32()?);
                    },
                    88 => {
                        self.change_number = ::std::option::Option::Some(is.read_int32()?);
                    },
                    96 => {
                        self.owner_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.initial_period = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.initial_time_unit = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    120 => {
                        self.renewal_period = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    128 => {
                        self.renewal_time_unit = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    136 => {
                        self.access_token = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    144 => {
                        self.master_package_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.package_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.time_created {
                my_size += 1 + 4;
            }
            if let Some(v) = self.time_next_process {
                my_size += 1 + 4;
            }
            if let Some(v) = self.minute_limit {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.minutes_used {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.payment_method {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.flags {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.purchase_country_code.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.license_type {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.territory_code {
                my_size += ::protobuf::rt::int32_size(10, v);
            }
            if let Some(v) = self.change_number {
                my_size += ::protobuf::rt::int32_size(11, v);
            }
            if let Some(v) = self.owner_id {
                my_size += ::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.initial_period {
                my_size += ::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.initial_time_unit {
                my_size += ::protobuf::rt::uint32_size(14, v);
            }
            if let Some(v) = self.renewal_period {
                my_size += ::protobuf::rt::uint32_size(15, v);
            }
            if let Some(v) = self.renewal_time_unit {
                my_size += ::protobuf::rt::uint32_size(16, v);
            }
            if let Some(v) = self.access_token {
                my_size += ::protobuf::rt::uint64_size(17, v);
            }
            if let Some(v) = self.master_package_id {
                my_size += ::protobuf::rt::uint32_size(18, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.package_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.time_created {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.time_next_process {
                os.write_fixed32(3, v)?;
            }
            if let Some(v) = self.minute_limit {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.minutes_used {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.payment_method {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.flags {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.purchase_country_code.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.license_type {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.territory_code {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.change_number {
                os.write_int32(11, v)?;
            }
            if let Some(v) = self.owner_id {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.initial_period {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.initial_time_unit {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.renewal_period {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.renewal_time_unit {
                os.write_uint32(16, v)?;
            }
            if let Some(v) = self.access_token {
                os.write_uint64(17, v)?;
            }
            if let Some(v) = self.master_package_id {
                os.write_uint32(18, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> License {
            License::new()
        }

        fn clear(&mut self) {
            self.package_id = ::std::option::Option::None;
            self.time_created = ::std::option::Option::None;
            self.time_next_process = ::std::option::Option::None;
            self.minute_limit = ::std::option::Option::None;
            self.minutes_used = ::std::option::Option::None;
            self.payment_method = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.purchase_country_code = ::std::option::Option::None;
            self.license_type = ::std::option::Option::None;
            self.territory_code = ::std::option::Option::None;
            self.change_number = ::std::option::Option::None;
            self.owner_id = ::std::option::Option::None;
            self.initial_period = ::std::option::Option::None;
            self.initial_time_unit = ::std::option::Option::None;
            self.renewal_period = ::std::option::Option::None;
            self.renewal_time_unit = ::std::option::Option::None;
            self.access_token = ::std::option::Option::None;
            self.master_package_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static License {
            static instance: License = License {
                package_id: ::std::option::Option::None,
                time_created: ::std::option::Option::None,
                time_next_process: ::std::option::Option::None,
                minute_limit: ::std::option::Option::None,
                minutes_used: ::std::option::Option::None,
                payment_method: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                purchase_country_code: ::std::option::Option::None,
                license_type: ::std::option::Option::None,
                territory_code: ::std::option::Option::None,
                change_number: ::std::option::Option::None,
                owner_id: ::std::option::Option::None,
                initial_period: ::std::option::Option::None,
                initial_time_unit: ::std::option::Option::None,
                renewal_period: ::std::option::Option::None,
                renewal_time_unit: ::std::option::Option::None,
                access_token: ::std::option::Option::None,
                master_package_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientIsLimitedAccount)
pub struct CMsgClientIsLimitedAccount {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientIsLimitedAccount.bis_limited_account)
    pub bis_limited_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientIsLimitedAccount.bis_community_banned)
    pub bis_community_banned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientIsLimitedAccount.bis_locked_account)
    pub bis_locked_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientIsLimitedAccount.bis_limited_account_allowed_to_invite_friends)
    pub bis_limited_account_allowed_to_invite_friends: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientIsLimitedAccount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientIsLimitedAccount {
    fn default() -> &'a CMsgClientIsLimitedAccount {
        <CMsgClientIsLimitedAccount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientIsLimitedAccount {
    pub fn new() -> CMsgClientIsLimitedAccount {
        ::std::default::Default::default()
    }

    // optional bool bis_limited_account = 1;

    pub fn bis_limited_account(&self) -> bool {
        self.bis_limited_account.unwrap_or(false)
    }

    pub fn clear_bis_limited_account(&mut self) {
        self.bis_limited_account = ::std::option::Option::None;
    }

    pub fn has_bis_limited_account(&self) -> bool {
        self.bis_limited_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_limited_account(&mut self, v: bool) {
        self.bis_limited_account = ::std::option::Option::Some(v);
    }

    // optional bool bis_community_banned = 2;

    pub fn bis_community_banned(&self) -> bool {
        self.bis_community_banned.unwrap_or(false)
    }

    pub fn clear_bis_community_banned(&mut self) {
        self.bis_community_banned = ::std::option::Option::None;
    }

    pub fn has_bis_community_banned(&self) -> bool {
        self.bis_community_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_community_banned(&mut self, v: bool) {
        self.bis_community_banned = ::std::option::Option::Some(v);
    }

    // optional bool bis_locked_account = 3;

    pub fn bis_locked_account(&self) -> bool {
        self.bis_locked_account.unwrap_or(false)
    }

    pub fn clear_bis_locked_account(&mut self) {
        self.bis_locked_account = ::std::option::Option::None;
    }

    pub fn has_bis_locked_account(&self) -> bool {
        self.bis_locked_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_locked_account(&mut self, v: bool) {
        self.bis_locked_account = ::std::option::Option::Some(v);
    }

    // optional bool bis_limited_account_allowed_to_invite_friends = 4;

    pub fn bis_limited_account_allowed_to_invite_friends(&self) -> bool {
        self.bis_limited_account_allowed_to_invite_friends.unwrap_or(false)
    }

    pub fn clear_bis_limited_account_allowed_to_invite_friends(&mut self) {
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::None;
    }

    pub fn has_bis_limited_account_allowed_to_invite_friends(&self) -> bool {
        self.bis_limited_account_allowed_to_invite_friends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_limited_account_allowed_to_invite_friends(&mut self, v: bool) {
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientIsLimitedAccount {
    const NAME: &'static str = "CMsgClientIsLimitedAccount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bis_limited_account = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.bis_community_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.bis_locked_account = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bis_limited_account {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bis_community_banned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bis_locked_account {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bis_limited_account_allowed_to_invite_friends {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bis_limited_account {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.bis_community_banned {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.bis_locked_account {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.bis_limited_account_allowed_to_invite_friends {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientIsLimitedAccount {
        CMsgClientIsLimitedAccount::new()
    }

    fn clear(&mut self) {
        self.bis_limited_account = ::std::option::Option::None;
        self.bis_community_banned = ::std::option::Option::None;
        self.bis_locked_account = ::std::option::Option::None;
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientIsLimitedAccount {
        static instance: CMsgClientIsLimitedAccount = CMsgClientIsLimitedAccount {
            bis_limited_account: ::std::option::Option::None,
            bis_community_banned: ::std::option::Option::None,
            bis_locked_account: ::std::option::Option::None,
            bis_limited_account_allowed_to_invite_friends: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientRequestedClientStats)
pub struct CMsgClientRequestedClientStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestedClientStats.stats_to_send)
    pub stats_to_send: ::std::vec::Vec<cmsg_client_requested_client_stats::StatsToSend>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestedClientStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestedClientStats {
    fn default() -> &'a CMsgClientRequestedClientStats {
        <CMsgClientRequestedClientStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestedClientStats {
    pub fn new() -> CMsgClientRequestedClientStats {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRequestedClientStats {
    const NAME: &'static str = "CMsgClientRequestedClientStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stats_to_send.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stats_to_send {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.stats_to_send {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestedClientStats {
        CMsgClientRequestedClientStats::new()
    }

    fn clear(&mut self) {
        self.stats_to_send.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestedClientStats {
        static instance: CMsgClientRequestedClientStats = CMsgClientRequestedClientStats {
            stats_to_send: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientRequestedClientStats`
pub mod cmsg_client_requested_client_stats {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientRequestedClientStats.StatsToSend)
    pub struct StatsToSend {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientRequestedClientStats.StatsToSend.client_stat)
        pub client_stat: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientRequestedClientStats.StatsToSend.stat_aggregate_method)
        pub stat_aggregate_method: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientRequestedClientStats.StatsToSend.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StatsToSend {
        fn default() -> &'a StatsToSend {
            <StatsToSend as ::protobuf::Message>::default_instance()
        }
    }

    impl StatsToSend {
        pub fn new() -> StatsToSend {
            ::std::default::Default::default()
        }

        // optional uint32 client_stat = 1;

        pub fn client_stat(&self) -> u32 {
            self.client_stat.unwrap_or(0)
        }

        pub fn clear_client_stat(&mut self) {
            self.client_stat = ::std::option::Option::None;
        }

        pub fn has_client_stat(&self) -> bool {
            self.client_stat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_client_stat(&mut self, v: u32) {
            self.client_stat = ::std::option::Option::Some(v);
        }

        // optional uint32 stat_aggregate_method = 2;

        pub fn stat_aggregate_method(&self) -> u32 {
            self.stat_aggregate_method.unwrap_or(0)
        }

        pub fn clear_stat_aggregate_method(&mut self) {
            self.stat_aggregate_method = ::std::option::Option::None;
        }

        pub fn has_stat_aggregate_method(&self) -> bool {
            self.stat_aggregate_method.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_aggregate_method(&mut self, v: u32) {
            self.stat_aggregate_method = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for StatsToSend {
        const NAME: &'static str = "StatsToSend";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.client_stat = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.stat_aggregate_method = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.client_stat {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.stat_aggregate_method {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.client_stat {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stat_aggregate_method {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StatsToSend {
            StatsToSend::new()
        }

        fn clear(&mut self) {
            self.client_stat = ::std::option::Option::None;
            self.stat_aggregate_method = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StatsToSend {
            static instance: StatsToSend = StatsToSend {
                client_stat: ::std::option::Option::None,
                stat_aggregate_method: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientStat2)
pub struct CMsgClientStat2 {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientStat2.stat_detail)
    pub stat_detail: ::std::vec::Vec<cmsg_client_stat2::StatDetail>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientStat2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientStat2 {
    fn default() -> &'a CMsgClientStat2 {
        <CMsgClientStat2 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientStat2 {
    pub fn new() -> CMsgClientStat2 {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientStat2 {
    const NAME: &'static str = "CMsgClientStat2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stat_detail.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stat_detail {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.stat_detail {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientStat2 {
        CMsgClientStat2::new()
    }

    fn clear(&mut self) {
        self.stat_detail.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientStat2 {
        static instance: CMsgClientStat2 = CMsgClientStat2 {
            stat_detail: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientStat2`
pub mod cmsg_client_stat2 {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientStat2.StatDetail)
    pub struct StatDetail {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.client_stat)
        pub client_stat: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.ll_value)
        pub ll_value: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.time_of_day)
        pub time_of_day: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.cell_id)
        pub cell_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.depot_id)
        pub depot_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientStat2.StatDetail.app_id)
        pub app_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientStat2.StatDetail.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StatDetail {
        fn default() -> &'a StatDetail {
            <StatDetail as ::protobuf::Message>::default_instance()
        }
    }

    impl StatDetail {
        pub fn new() -> StatDetail {
            ::std::default::Default::default()
        }

        // optional uint32 client_stat = 1;

        pub fn client_stat(&self) -> u32 {
            self.client_stat.unwrap_or(0)
        }

        pub fn clear_client_stat(&mut self) {
            self.client_stat = ::std::option::Option::None;
        }

        pub fn has_client_stat(&self) -> bool {
            self.client_stat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_client_stat(&mut self, v: u32) {
            self.client_stat = ::std::option::Option::Some(v);
        }

        // optional int64 ll_value = 2;

        pub fn ll_value(&self) -> i64 {
            self.ll_value.unwrap_or(0)
        }

        pub fn clear_ll_value(&mut self) {
            self.ll_value = ::std::option::Option::None;
        }

        pub fn has_ll_value(&self) -> bool {
            self.ll_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ll_value(&mut self, v: i64) {
            self.ll_value = ::std::option::Option::Some(v);
        }

        // optional uint32 time_of_day = 3;

        pub fn time_of_day(&self) -> u32 {
            self.time_of_day.unwrap_or(0)
        }

        pub fn clear_time_of_day(&mut self) {
            self.time_of_day = ::std::option::Option::None;
        }

        pub fn has_time_of_day(&self) -> bool {
            self.time_of_day.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_of_day(&mut self, v: u32) {
            self.time_of_day = ::std::option::Option::Some(v);
        }

        // optional uint32 cell_id = 4;

        pub fn cell_id(&self) -> u32 {
            self.cell_id.unwrap_or(0)
        }

        pub fn clear_cell_id(&mut self) {
            self.cell_id = ::std::option::Option::None;
        }

        pub fn has_cell_id(&self) -> bool {
            self.cell_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cell_id(&mut self, v: u32) {
            self.cell_id = ::std::option::Option::Some(v);
        }

        // optional uint32 depot_id = 5;

        pub fn depot_id(&self) -> u32 {
            self.depot_id.unwrap_or(0)
        }

        pub fn clear_depot_id(&mut self) {
            self.depot_id = ::std::option::Option::None;
        }

        pub fn has_depot_id(&self) -> bool {
            self.depot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_depot_id(&mut self, v: u32) {
            self.depot_id = ::std::option::Option::Some(v);
        }

        // optional uint32 app_id = 6;

        pub fn app_id(&self) -> u32 {
            self.app_id.unwrap_or(0)
        }

        pub fn clear_app_id(&mut self) {
            self.app_id = ::std::option::Option::None;
        }

        pub fn has_app_id(&self) -> bool {
            self.app_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_app_id(&mut self, v: u32) {
            self.app_id = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for StatDetail {
        const NAME: &'static str = "StatDetail";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.client_stat = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.ll_value = ::std::option::Option::Some(is.read_int64()?);
                    },
                    24 => {
                        self.time_of_day = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.depot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.client_stat {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.ll_value {
                my_size += ::protobuf::rt::int64_size(2, v);
            }
            if let Some(v) = self.time_of_day {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.cell_id {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.depot_id {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.app_id {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.client_stat {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.ll_value {
                os.write_int64(2, v)?;
            }
            if let Some(v) = self.time_of_day {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.cell_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.depot_id {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.app_id {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StatDetail {
            StatDetail::new()
        }

        fn clear(&mut self) {
            self.client_stat = ::std::option::Option::None;
            self.ll_value = ::std::option::Option::None;
            self.time_of_day = ::std::option::Option::None;
            self.cell_id = ::std::option::Option::None;
            self.depot_id = ::std::option::Option::None;
            self.app_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StatDetail {
            static instance: StatDetail = StatDetail {
                client_stat: ::std::option::Option::None,
                ll_value: ::std::option::Option::None,
                time_of_day: ::std::option::Option::None,
                cell_id: ::std::option::Option::None,
                depot_id: ::std::option::Option::None,
                app_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientInviteToGame)
pub struct CMsgClientInviteToGame {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientInviteToGame.steam_id_dest)
    pub steam_id_dest: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientInviteToGame.steam_id_src)
    pub steam_id_src: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientInviteToGame.connect_string)
    pub connect_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientInviteToGame.remote_play)
    pub remote_play: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientInviteToGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientInviteToGame {
    fn default() -> &'a CMsgClientInviteToGame {
        <CMsgClientInviteToGame as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientInviteToGame {
    pub fn new() -> CMsgClientInviteToGame {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_dest = 1;

    pub fn steam_id_dest(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }

    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_src = 2;

    pub fn steam_id_src(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }

    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    // optional string connect_string = 3;

    pub fn connect_string(&self) -> &str {
        match self.connect_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_connect_string(&mut self) {
        self.connect_string = ::std::option::Option::None;
    }

    pub fn has_connect_string(&self) -> bool {
        self.connect_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_string(&mut self, v: ::std::string::String) {
        self.connect_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect_string(&mut self) -> &mut ::std::string::String {
        if self.connect_string.is_none() {
            self.connect_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.connect_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect_string(&mut self) -> ::std::string::String {
        self.connect_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string remote_play = 4;

    pub fn remote_play(&self) -> &str {
        match self.remote_play.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_remote_play(&mut self) {
        self.remote_play = ::std::option::Option::None;
    }

    pub fn has_remote_play(&self) -> bool {
        self.remote_play.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_play(&mut self, v: ::std::string::String) {
        self.remote_play = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_play(&mut self) -> &mut ::std::string::String {
        if self.remote_play.is_none() {
            self.remote_play = ::std::option::Option::Some(::std::string::String::new());
        }
        self.remote_play.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_play(&mut self) -> ::std::string::String {
        self.remote_play.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientInviteToGame {
    const NAME: &'static str = "CMsgClientInviteToGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_dest = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.steam_id_src = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.connect_string = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.remote_play = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_dest {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_src {
            my_size += 1 + 8;
        }
        if let Some(v) = self.connect_string.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.remote_play.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_dest {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_src {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.connect_string.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.remote_play.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientInviteToGame {
        CMsgClientInviteToGame::new()
    }

    fn clear(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
        self.steam_id_src = ::std::option::Option::None;
        self.connect_string = ::std::option::Option::None;
        self.remote_play = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientInviteToGame {
        static instance: CMsgClientInviteToGame = CMsgClientInviteToGame {
            steam_id_dest: ::std::option::Option::None,
            steam_id_src: ::std::option::Option::None,
            connect_string: ::std::option::Option::None,
            remote_play: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientChatInvite)
pub struct CMsgClientChatInvite {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientChatInvite.steam_id_invited)
    pub steam_id_invited: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.steam_id_chat)
    pub steam_id_chat: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.steam_id_patron)
    pub steam_id_patron: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.chatroom_type)
    pub chatroom_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.steam_id_friend_chat)
    pub steam_id_friend_chat: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.chat_name)
    pub chat_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientChatInvite.game_id)
    pub game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientChatInvite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatInvite {
    fn default() -> &'a CMsgClientChatInvite {
        <CMsgClientChatInvite as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatInvite {
    pub fn new() -> CMsgClientChatInvite {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_invited = 1;

    pub fn steam_id_invited(&self) -> u64 {
        self.steam_id_invited.unwrap_or(0)
    }

    pub fn clear_steam_id_invited(&mut self) {
        self.steam_id_invited = ::std::option::Option::None;
    }

    pub fn has_steam_id_invited(&self) -> bool {
        self.steam_id_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_invited(&mut self, v: u64) {
        self.steam_id_invited = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_chat = 2;

    pub fn steam_id_chat(&self) -> u64 {
        self.steam_id_chat.unwrap_or(0)
    }

    pub fn clear_steam_id_chat(&mut self) {
        self.steam_id_chat = ::std::option::Option::None;
    }

    pub fn has_steam_id_chat(&self) -> bool {
        self.steam_id_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_chat(&mut self, v: u64) {
        self.steam_id_chat = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_patron = 3;

    pub fn steam_id_patron(&self) -> u64 {
        self.steam_id_patron.unwrap_or(0)
    }

    pub fn clear_steam_id_patron(&mut self) {
        self.steam_id_patron = ::std::option::Option::None;
    }

    pub fn has_steam_id_patron(&self) -> bool {
        self.steam_id_patron.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_patron(&mut self, v: u64) {
        self.steam_id_patron = ::std::option::Option::Some(v);
    }

    // optional int32 chatroom_type = 4;

    pub fn chatroom_type(&self) -> i32 {
        self.chatroom_type.unwrap_or(0)
    }

    pub fn clear_chatroom_type(&mut self) {
        self.chatroom_type = ::std::option::Option::None;
    }

    pub fn has_chatroom_type(&self) -> bool {
        self.chatroom_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chatroom_type(&mut self, v: i32) {
        self.chatroom_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_friend_chat = 5;

    pub fn steam_id_friend_chat(&self) -> u64 {
        self.steam_id_friend_chat.unwrap_or(0)
    }

    pub fn clear_steam_id_friend_chat(&mut self) {
        self.steam_id_friend_chat = ::std::option::Option::None;
    }

    pub fn has_steam_id_friend_chat(&self) -> bool {
        self.steam_id_friend_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_friend_chat(&mut self, v: u64) {
        self.steam_id_friend_chat = ::std::option::Option::Some(v);
    }

    // optional string chat_name = 6;

    pub fn chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_name(&mut self) {
        self.chat_name = ::std::option::Option::None;
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 game_id = 7;

    pub fn game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientChatInvite {
    const NAME: &'static str = "CMsgClientChatInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id_invited = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.steam_id_chat = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.steam_id_patron = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.chatroom_type = ::std::option::Option::Some(is.read_int32()?);
                },
                41 => {
                    self.steam_id_friend_chat = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    self.chat_name = ::std::option::Option::Some(is.read_string()?);
                },
                57 => {
                    self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_invited {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_chat {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steam_id_patron {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chatroom_type {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.steam_id_friend_chat {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.game_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id_invited {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steam_id_chat {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.steam_id_patron {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.chatroom_type {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.steam_id_friend_chat {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.chat_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.game_id {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientChatInvite {
        CMsgClientChatInvite::new()
    }

    fn clear(&mut self) {
        self.steam_id_invited = ::std::option::Option::None;
        self.steam_id_chat = ::std::option::Option::None;
        self.steam_id_patron = ::std::option::Option::None;
        self.chatroom_type = ::std::option::Option::None;
        self.steam_id_friend_chat = ::std::option::Option::None;
        self.chat_name = ::std::option::Option::None;
        self.game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientChatInvite {
        static instance: CMsgClientChatInvite = CMsgClientChatInvite {
            steam_id_invited: ::std::option::Option::None,
            steam_id_chat: ::std::option::Option::None,
            steam_id_patron: ::std::option::Option::None,
            chatroom_type: ::std::option::Option::None,
            steam_id_friend_chat: ::std::option::Option::None,
            chat_name: ::std::option::Option::None,
            game_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientConnectionStats)
pub struct CMsgClientConnectionStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientConnectionStats.stats_logon)
    pub stats_logon: ::protobuf::MessageField<cmsg_client_connection_stats::Stats_Logon>,
    // @@protoc_insertion_point(field:CMsgClientConnectionStats.stats_vconn)
    pub stats_vconn: ::protobuf::MessageField<cmsg_client_connection_stats::Stats_VConn>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientConnectionStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientConnectionStats {
    fn default() -> &'a CMsgClientConnectionStats {
        <CMsgClientConnectionStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientConnectionStats {
    pub fn new() -> CMsgClientConnectionStats {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientConnectionStats {
    const NAME: &'static str = "CMsgClientConnectionStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats_logon)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats_vconn)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stats_logon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stats_vconn.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stats_logon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.stats_vconn.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientConnectionStats {
        CMsgClientConnectionStats::new()
    }

    fn clear(&mut self) {
        self.stats_logon.clear();
        self.stats_vconn.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientConnectionStats {
        static instance: CMsgClientConnectionStats = CMsgClientConnectionStats {
            stats_logon: ::protobuf::MessageField::none(),
            stats_vconn: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientConnectionStats`
pub mod cmsg_client_connection_stats {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientConnectionStats.Stats_Logon)
    pub struct Stats_Logon {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.connect_attempts)
        pub connect_attempts: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.connect_successes)
        pub connect_successes: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.connect_failures)
        pub connect_failures: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.connections_dropped)
        pub connections_dropped: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.seconds_running)
        pub seconds_running: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.msec_tologonthistime)
        pub msec_tologonthistime: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.count_bad_cms)
        pub count_bad_cms: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.no_udp_connectivity)
        pub no_udp_connectivity: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.no_tcp_connectivity)
        pub no_tcp_connectivity: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.no_websocket_443_connectivity)
        pub no_websocket_443_connectivity: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_Logon.no_websocket_non_443_connectivity)
        pub no_websocket_non_443_connectivity: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientConnectionStats.Stats_Logon.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stats_Logon {
        fn default() -> &'a Stats_Logon {
            <Stats_Logon as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats_Logon {
        pub fn new() -> Stats_Logon {
            ::std::default::Default::default()
        }

        // optional int32 connect_attempts = 1;

        pub fn connect_attempts(&self) -> i32 {
            self.connect_attempts.unwrap_or(0)
        }

        pub fn clear_connect_attempts(&mut self) {
            self.connect_attempts = ::std::option::Option::None;
        }

        pub fn has_connect_attempts(&self) -> bool {
            self.connect_attempts.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connect_attempts(&mut self, v: i32) {
            self.connect_attempts = ::std::option::Option::Some(v);
        }

        // optional int32 connect_successes = 2;

        pub fn connect_successes(&self) -> i32 {
            self.connect_successes.unwrap_or(0)
        }

        pub fn clear_connect_successes(&mut self) {
            self.connect_successes = ::std::option::Option::None;
        }

        pub fn has_connect_successes(&self) -> bool {
            self.connect_successes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connect_successes(&mut self, v: i32) {
            self.connect_successes = ::std::option::Option::Some(v);
        }

        // optional int32 connect_failures = 3;

        pub fn connect_failures(&self) -> i32 {
            self.connect_failures.unwrap_or(0)
        }

        pub fn clear_connect_failures(&mut self) {
            self.connect_failures = ::std::option::Option::None;
        }

        pub fn has_connect_failures(&self) -> bool {
            self.connect_failures.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connect_failures(&mut self, v: i32) {
            self.connect_failures = ::std::option::Option::Some(v);
        }

        // optional int32 connections_dropped = 4;

        pub fn connections_dropped(&self) -> i32 {
            self.connections_dropped.unwrap_or(0)
        }

        pub fn clear_connections_dropped(&mut self) {
            self.connections_dropped = ::std::option::Option::None;
        }

        pub fn has_connections_dropped(&self) -> bool {
            self.connections_dropped.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connections_dropped(&mut self, v: i32) {
            self.connections_dropped = ::std::option::Option::Some(v);
        }

        // optional uint32 seconds_running = 5;

        pub fn seconds_running(&self) -> u32 {
            self.seconds_running.unwrap_or(0)
        }

        pub fn clear_seconds_running(&mut self) {
            self.seconds_running = ::std::option::Option::None;
        }

        pub fn has_seconds_running(&self) -> bool {
            self.seconds_running.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seconds_running(&mut self, v: u32) {
            self.seconds_running = ::std::option::Option::Some(v);
        }

        // optional uint32 msec_tologonthistime = 6;

        pub fn msec_tologonthistime(&self) -> u32 {
            self.msec_tologonthistime.unwrap_or(0)
        }

        pub fn clear_msec_tologonthistime(&mut self) {
            self.msec_tologonthistime = ::std::option::Option::None;
        }

        pub fn has_msec_tologonthistime(&self) -> bool {
            self.msec_tologonthistime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msec_tologonthistime(&mut self, v: u32) {
            self.msec_tologonthistime = ::std::option::Option::Some(v);
        }

        // optional uint32 count_bad_cms = 7;

        pub fn count_bad_cms(&self) -> u32 {
            self.count_bad_cms.unwrap_or(0)
        }

        pub fn clear_count_bad_cms(&mut self) {
            self.count_bad_cms = ::std::option::Option::None;
        }

        pub fn has_count_bad_cms(&self) -> bool {
            self.count_bad_cms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count_bad_cms(&mut self, v: u32) {
            self.count_bad_cms = ::std::option::Option::Some(v);
        }

        // optional bool no_udp_connectivity = 8;

        pub fn no_udp_connectivity(&self) -> bool {
            self.no_udp_connectivity.unwrap_or(false)
        }

        pub fn clear_no_udp_connectivity(&mut self) {
            self.no_udp_connectivity = ::std::option::Option::None;
        }

        pub fn has_no_udp_connectivity(&self) -> bool {
            self.no_udp_connectivity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_no_udp_connectivity(&mut self, v: bool) {
            self.no_udp_connectivity = ::std::option::Option::Some(v);
        }

        // optional bool no_tcp_connectivity = 9;

        pub fn no_tcp_connectivity(&self) -> bool {
            self.no_tcp_connectivity.unwrap_or(false)
        }

        pub fn clear_no_tcp_connectivity(&mut self) {
            self.no_tcp_connectivity = ::std::option::Option::None;
        }

        pub fn has_no_tcp_connectivity(&self) -> bool {
            self.no_tcp_connectivity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_no_tcp_connectivity(&mut self, v: bool) {
            self.no_tcp_connectivity = ::std::option::Option::Some(v);
        }

        // optional bool no_websocket_443_connectivity = 10;

        pub fn no_websocket_443_connectivity(&self) -> bool {
            self.no_websocket_443_connectivity.unwrap_or(false)
        }

        pub fn clear_no_websocket_443_connectivity(&mut self) {
            self.no_websocket_443_connectivity = ::std::option::Option::None;
        }

        pub fn has_no_websocket_443_connectivity(&self) -> bool {
            self.no_websocket_443_connectivity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_no_websocket_443_connectivity(&mut self, v: bool) {
            self.no_websocket_443_connectivity = ::std::option::Option::Some(v);
        }

        // optional bool no_websocket_non_443_connectivity = 11;

        pub fn no_websocket_non_443_connectivity(&self) -> bool {
            self.no_websocket_non_443_connectivity.unwrap_or(false)
        }

        pub fn clear_no_websocket_non_443_connectivity(&mut self) {
            self.no_websocket_non_443_connectivity = ::std::option::Option::None;
        }

        pub fn has_no_websocket_non_443_connectivity(&self) -> bool {
            self.no_websocket_non_443_connectivity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_no_websocket_non_443_connectivity(&mut self, v: bool) {
            self.no_websocket_non_443_connectivity = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Stats_Logon {
        const NAME: &'static str = "Stats_Logon";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.connect_attempts = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.connect_successes = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.connect_failures = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.connections_dropped = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.seconds_running = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.msec_tologonthistime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.count_bad_cms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.no_udp_connectivity = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.no_tcp_connectivity = ::std::option::Option::Some(is.read_bool()?);
                    },
                    80 => {
                        self.no_websocket_443_connectivity = ::std::option::Option::Some(is.read_bool()?);
                    },
                    88 => {
                        self.no_websocket_non_443_connectivity = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.connect_attempts {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.connect_successes {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.connect_failures {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.connections_dropped {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.seconds_running {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.msec_tologonthistime {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.count_bad_cms {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.no_udp_connectivity {
                my_size += 1 + 1;
            }
            if let Some(v) = self.no_tcp_connectivity {
                my_size += 1 + 1;
            }
            if let Some(v) = self.no_websocket_443_connectivity {
                my_size += 1 + 1;
            }
            if let Some(v) = self.no_websocket_non_443_connectivity {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.connect_attempts {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.connect_successes {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.connect_failures {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.connections_dropped {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.seconds_running {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.msec_tologonthistime {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.count_bad_cms {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.no_udp_connectivity {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.no_tcp_connectivity {
                os.write_bool(9, v)?;
            }
            if let Some(v) = self.no_websocket_443_connectivity {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.no_websocket_non_443_connectivity {
                os.write_bool(11, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stats_Logon {
            Stats_Logon::new()
        }

        fn clear(&mut self) {
            self.connect_attempts = ::std::option::Option::None;
            self.connect_successes = ::std::option::Option::None;
            self.connect_failures = ::std::option::Option::None;
            self.connections_dropped = ::std::option::Option::None;
            self.seconds_running = ::std::option::Option::None;
            self.msec_tologonthistime = ::std::option::Option::None;
            self.count_bad_cms = ::std::option::Option::None;
            self.no_udp_connectivity = ::std::option::Option::None;
            self.no_tcp_connectivity = ::std::option::Option::None;
            self.no_websocket_443_connectivity = ::std::option::Option::None;
            self.no_websocket_non_443_connectivity = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stats_Logon {
            static instance: Stats_Logon = Stats_Logon {
                connect_attempts: ::std::option::Option::None,
                connect_successes: ::std::option::Option::None,
                connect_failures: ::std::option::Option::None,
                connections_dropped: ::std::option::Option::None,
                seconds_running: ::std::option::Option::None,
                msec_tologonthistime: ::std::option::Option::None,
                count_bad_cms: ::std::option::Option::None,
                no_udp_connectivity: ::std::option::Option::None,
                no_tcp_connectivity: ::std::option::Option::None,
                no_websocket_443_connectivity: ::std::option::Option::None,
                no_websocket_non_443_connectivity: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientConnectionStats.Stats_UDP)
    pub struct Stats_UDP {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_UDP.pkts_sent)
        pub pkts_sent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_UDP.bytes_sent)
        pub bytes_sent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_UDP.pkts_recv)
        pub pkts_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_UDP.pkts_processed)
        pub pkts_processed: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_UDP.bytes_recv)
        pub bytes_recv: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientConnectionStats.Stats_UDP.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stats_UDP {
        fn default() -> &'a Stats_UDP {
            <Stats_UDP as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats_UDP {
        pub fn new() -> Stats_UDP {
            ::std::default::Default::default()
        }

        // optional uint64 pkts_sent = 1;

        pub fn pkts_sent(&self) -> u64 {
            self.pkts_sent.unwrap_or(0)
        }

        pub fn clear_pkts_sent(&mut self) {
            self.pkts_sent = ::std::option::Option::None;
        }

        pub fn has_pkts_sent(&self) -> bool {
            self.pkts_sent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_sent(&mut self, v: u64) {
            self.pkts_sent = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_sent = 2;

        pub fn bytes_sent(&self) -> u64 {
            self.bytes_sent.unwrap_or(0)
        }

        pub fn clear_bytes_sent(&mut self) {
            self.bytes_sent = ::std::option::Option::None;
        }

        pub fn has_bytes_sent(&self) -> bool {
            self.bytes_sent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_sent(&mut self, v: u64) {
            self.bytes_sent = ::std::option::Option::Some(v);
        }

        // optional uint64 pkts_recv = 3;

        pub fn pkts_recv(&self) -> u64 {
            self.pkts_recv.unwrap_or(0)
        }

        pub fn clear_pkts_recv(&mut self) {
            self.pkts_recv = ::std::option::Option::None;
        }

        pub fn has_pkts_recv(&self) -> bool {
            self.pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_recv(&mut self, v: u64) {
            self.pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 pkts_processed = 4;

        pub fn pkts_processed(&self) -> u64 {
            self.pkts_processed.unwrap_or(0)
        }

        pub fn clear_pkts_processed(&mut self) {
            self.pkts_processed = ::std::option::Option::None;
        }

        pub fn has_pkts_processed(&self) -> bool {
            self.pkts_processed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_processed(&mut self, v: u64) {
            self.pkts_processed = ::std::option::Option::Some(v);
        }

        // optional uint64 bytes_recv = 5;

        pub fn bytes_recv(&self) -> u64 {
            self.bytes_recv.unwrap_or(0)
        }

        pub fn clear_bytes_recv(&mut self) {
            self.bytes_recv = ::std::option::Option::None;
        }

        pub fn has_bytes_recv(&self) -> bool {
            self.bytes_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bytes_recv(&mut self, v: u64) {
            self.bytes_recv = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Stats_UDP {
        const NAME: &'static str = "Stats_UDP";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.pkts_sent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.bytes_sent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    32 => {
                        self.pkts_processed = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    40 => {
                        self.bytes_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.pkts_sent {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.bytes_sent {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.pkts_recv {
                my_size += ::protobuf::rt::uint64_size(3, v);
            }
            if let Some(v) = self.pkts_processed {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.bytes_recv {
                my_size += ::protobuf::rt::uint64_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.pkts_sent {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.bytes_sent {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.pkts_recv {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.pkts_processed {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.bytes_recv {
                os.write_uint64(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stats_UDP {
            Stats_UDP::new()
        }

        fn clear(&mut self) {
            self.pkts_sent = ::std::option::Option::None;
            self.bytes_sent = ::std::option::Option::None;
            self.pkts_recv = ::std::option::Option::None;
            self.pkts_processed = ::std::option::Option::None;
            self.bytes_recv = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stats_UDP {
            static instance: Stats_UDP = Stats_UDP {
                pkts_sent: ::std::option::Option::None,
                bytes_sent: ::std::option::Option::None,
                pkts_recv: ::std::option::Option::None,
                pkts_processed: ::std::option::Option::None,
                bytes_recv: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientConnectionStats.Stats_VConn)
    pub struct Stats_VConn {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.connections_udp)
        pub connections_udp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.connections_tcp)
        pub connections_tcp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.stats_udp)
        pub stats_udp: ::protobuf::MessageField<Stats_UDP>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.pkts_abandoned)
        pub pkts_abandoned: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.conn_req_received)
        pub conn_req_received: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.pkts_resent)
        pub pkts_resent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.msgs_sent)
        pub msgs_sent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.msgs_sent_failed)
        pub msgs_sent_failed: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.msgs_recv)
        pub msgs_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.datagrams_sent)
        pub datagrams_sent: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.datagrams_recv)
        pub datagrams_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.bad_pkts_recv)
        pub bad_pkts_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.unknown_conn_pkts_recv)
        pub unknown_conn_pkts_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.missed_pkts_recv)
        pub missed_pkts_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.dup_pkts_recv)
        pub dup_pkts_recv: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.failed_connect_challenges)
        pub failed_connect_challenges: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.micro_sec_avg_latency)
        pub micro_sec_avg_latency: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.micro_sec_min_latency)
        pub micro_sec_min_latency: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientConnectionStats.Stats_VConn.micro_sec_max_latency)
        pub micro_sec_max_latency: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientConnectionStats.Stats_VConn.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stats_VConn {
        fn default() -> &'a Stats_VConn {
            <Stats_VConn as ::protobuf::Message>::default_instance()
        }
    }

    impl Stats_VConn {
        pub fn new() -> Stats_VConn {
            ::std::default::Default::default()
        }

        // optional uint32 connections_udp = 1;

        pub fn connections_udp(&self) -> u32 {
            self.connections_udp.unwrap_or(0)
        }

        pub fn clear_connections_udp(&mut self) {
            self.connections_udp = ::std::option::Option::None;
        }

        pub fn has_connections_udp(&self) -> bool {
            self.connections_udp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connections_udp(&mut self, v: u32) {
            self.connections_udp = ::std::option::Option::Some(v);
        }

        // optional uint32 connections_tcp = 2;

        pub fn connections_tcp(&self) -> u32 {
            self.connections_tcp.unwrap_or(0)
        }

        pub fn clear_connections_tcp(&mut self) {
            self.connections_tcp = ::std::option::Option::None;
        }

        pub fn has_connections_tcp(&self) -> bool {
            self.connections_tcp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connections_tcp(&mut self, v: u32) {
            self.connections_tcp = ::std::option::Option::Some(v);
        }

        // optional uint64 pkts_abandoned = 4;

        pub fn pkts_abandoned(&self) -> u64 {
            self.pkts_abandoned.unwrap_or(0)
        }

        pub fn clear_pkts_abandoned(&mut self) {
            self.pkts_abandoned = ::std::option::Option::None;
        }

        pub fn has_pkts_abandoned(&self) -> bool {
            self.pkts_abandoned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_abandoned(&mut self, v: u64) {
            self.pkts_abandoned = ::std::option::Option::Some(v);
        }

        // optional uint64 conn_req_received = 5;

        pub fn conn_req_received(&self) -> u64 {
            self.conn_req_received.unwrap_or(0)
        }

        pub fn clear_conn_req_received(&mut self) {
            self.conn_req_received = ::std::option::Option::None;
        }

        pub fn has_conn_req_received(&self) -> bool {
            self.conn_req_received.is_some()
        }

        // Param is passed by value, moved
        pub fn set_conn_req_received(&mut self, v: u64) {
            self.conn_req_received = ::std::option::Option::Some(v);
        }

        // optional uint64 pkts_resent = 6;

        pub fn pkts_resent(&self) -> u64 {
            self.pkts_resent.unwrap_or(0)
        }

        pub fn clear_pkts_resent(&mut self) {
            self.pkts_resent = ::std::option::Option::None;
        }

        pub fn has_pkts_resent(&self) -> bool {
            self.pkts_resent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pkts_resent(&mut self, v: u64) {
            self.pkts_resent = ::std::option::Option::Some(v);
        }

        // optional uint64 msgs_sent = 7;

        pub fn msgs_sent(&self) -> u64 {
            self.msgs_sent.unwrap_or(0)
        }

        pub fn clear_msgs_sent(&mut self) {
            self.msgs_sent = ::std::option::Option::None;
        }

        pub fn has_msgs_sent(&self) -> bool {
            self.msgs_sent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msgs_sent(&mut self, v: u64) {
            self.msgs_sent = ::std::option::Option::Some(v);
        }

        // optional uint64 msgs_sent_failed = 8;

        pub fn msgs_sent_failed(&self) -> u64 {
            self.msgs_sent_failed.unwrap_or(0)
        }

        pub fn clear_msgs_sent_failed(&mut self) {
            self.msgs_sent_failed = ::std::option::Option::None;
        }

        pub fn has_msgs_sent_failed(&self) -> bool {
            self.msgs_sent_failed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msgs_sent_failed(&mut self, v: u64) {
            self.msgs_sent_failed = ::std::option::Option::Some(v);
        }

        // optional uint64 msgs_recv = 9;

        pub fn msgs_recv(&self) -> u64 {
            self.msgs_recv.unwrap_or(0)
        }

        pub fn clear_msgs_recv(&mut self) {
            self.msgs_recv = ::std::option::Option::None;
        }

        pub fn has_msgs_recv(&self) -> bool {
            self.msgs_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msgs_recv(&mut self, v: u64) {
            self.msgs_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 datagrams_sent = 10;

        pub fn datagrams_sent(&self) -> u64 {
            self.datagrams_sent.unwrap_or(0)
        }

        pub fn clear_datagrams_sent(&mut self) {
            self.datagrams_sent = ::std::option::Option::None;
        }

        pub fn has_datagrams_sent(&self) -> bool {
            self.datagrams_sent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_datagrams_sent(&mut self, v: u64) {
            self.datagrams_sent = ::std::option::Option::Some(v);
        }

        // optional uint64 datagrams_recv = 11;

        pub fn datagrams_recv(&self) -> u64 {
            self.datagrams_recv.unwrap_or(0)
        }

        pub fn clear_datagrams_recv(&mut self) {
            self.datagrams_recv = ::std::option::Option::None;
        }

        pub fn has_datagrams_recv(&self) -> bool {
            self.datagrams_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_datagrams_recv(&mut self, v: u64) {
            self.datagrams_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 bad_pkts_recv = 12;

        pub fn bad_pkts_recv(&self) -> u64 {
            self.bad_pkts_recv.unwrap_or(0)
        }

        pub fn clear_bad_pkts_recv(&mut self) {
            self.bad_pkts_recv = ::std::option::Option::None;
        }

        pub fn has_bad_pkts_recv(&self) -> bool {
            self.bad_pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bad_pkts_recv(&mut self, v: u64) {
            self.bad_pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 unknown_conn_pkts_recv = 13;

        pub fn unknown_conn_pkts_recv(&self) -> u64 {
            self.unknown_conn_pkts_recv.unwrap_or(0)
        }

        pub fn clear_unknown_conn_pkts_recv(&mut self) {
            self.unknown_conn_pkts_recv = ::std::option::Option::None;
        }

        pub fn has_unknown_conn_pkts_recv(&self) -> bool {
            self.unknown_conn_pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unknown_conn_pkts_recv(&mut self, v: u64) {
            self.unknown_conn_pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 missed_pkts_recv = 14;

        pub fn missed_pkts_recv(&self) -> u64 {
            self.missed_pkts_recv.unwrap_or(0)
        }

        pub fn clear_missed_pkts_recv(&mut self) {
            self.missed_pkts_recv = ::std::option::Option::None;
        }

        pub fn has_missed_pkts_recv(&self) -> bool {
            self.missed_pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_missed_pkts_recv(&mut self, v: u64) {
            self.missed_pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 dup_pkts_recv = 15;

        pub fn dup_pkts_recv(&self) -> u64 {
            self.dup_pkts_recv.unwrap_or(0)
        }

        pub fn clear_dup_pkts_recv(&mut self) {
            self.dup_pkts_recv = ::std::option::Option::None;
        }

        pub fn has_dup_pkts_recv(&self) -> bool {
            self.dup_pkts_recv.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dup_pkts_recv(&mut self, v: u64) {
            self.dup_pkts_recv = ::std::option::Option::Some(v);
        }

        // optional uint64 failed_connect_challenges = 16;

        pub fn failed_connect_challenges(&self) -> u64 {
            self.failed_connect_challenges.unwrap_or(0)
        }

        pub fn clear_failed_connect_challenges(&mut self) {
            self.failed_connect_challenges = ::std::option::Option::None;
        }

        pub fn has_failed_connect_challenges(&self) -> bool {
            self.failed_connect_challenges.is_some()
        }

        // Param is passed by value, moved
        pub fn set_failed_connect_challenges(&mut self, v: u64) {
            self.failed_connect_challenges = ::std::option::Option::Some(v);
        }

        // optional uint32 micro_sec_avg_latency = 17;

        pub fn micro_sec_avg_latency(&self) -> u32 {
            self.micro_sec_avg_latency.unwrap_or(0)
        }

        pub fn clear_micro_sec_avg_latency(&mut self) {
            self.micro_sec_avg_latency = ::std::option::Option::None;
        }

        pub fn has_micro_sec_avg_latency(&self) -> bool {
            self.micro_sec_avg_latency.is_some()
        }

        // Param is passed by value, moved
        pub fn set_micro_sec_avg_latency(&mut self, v: u32) {
            self.micro_sec_avg_latency = ::std::option::Option::Some(v);
        }

        // optional uint32 micro_sec_min_latency = 18;

        pub fn micro_sec_min_latency(&self) -> u32 {
            self.micro_sec_min_latency.unwrap_or(0)
        }

        pub fn clear_micro_sec_min_latency(&mut self) {
            self.micro_sec_min_latency = ::std::option::Option::None;
        }

        pub fn has_micro_sec_min_latency(&self) -> bool {
            self.micro_sec_min_latency.is_some()
        }

        // Param is passed by value, moved
        pub fn set_micro_sec_min_latency(&mut self, v: u32) {
            self.micro_sec_min_latency = ::std::option::Option::Some(v);
        }

        // optional uint32 micro_sec_max_latency = 19;

        pub fn micro_sec_max_latency(&self) -> u32 {
            self.micro_sec_max_latency.unwrap_or(0)
        }

        pub fn clear_micro_sec_max_latency(&mut self) {
            self.micro_sec_max_latency = ::std::option::Option::None;
        }

        pub fn has_micro_sec_max_latency(&self) -> bool {
            self.micro_sec_max_latency.is_some()
        }

        // Param is passed by value, moved
        pub fn set_micro_sec_max_latency(&mut self, v: u32) {
            self.micro_sec_max_latency = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Stats_VConn {
        const NAME: &'static str = "Stats_VConn";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.connections_udp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.connections_tcp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats_udp)?;
                    },
                    32 => {
                        self.pkts_abandoned = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    40 => {
                        self.conn_req_received = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    48 => {
                        self.pkts_resent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    56 => {
                        self.msgs_sent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    64 => {
                        self.msgs_sent_failed = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    72 => {
                        self.msgs_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    80 => {
                        self.datagrams_sent = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    88 => {
                        self.datagrams_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    96 => {
                        self.bad_pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    104 => {
                        self.unknown_conn_pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    112 => {
                        self.missed_pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    120 => {
                        self.dup_pkts_recv = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    128 => {
                        self.failed_connect_challenges = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    136 => {
                        self.micro_sec_avg_latency = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    144 => {
                        self.micro_sec_min_latency = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    152 => {
                        self.micro_sec_max_latency = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.connections_udp {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.connections_tcp {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.stats_udp.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.pkts_abandoned {
                my_size += ::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.conn_req_received {
                my_size += ::protobuf::rt::uint64_size(5, v);
            }
            if let Some(v) = self.pkts_resent {
                my_size += ::protobuf::rt::uint64_size(6, v);
            }
            if let Some(v) = self.msgs_sent {
                my_size += ::protobuf::rt::uint64_size(7, v);
            }
            if let Some(v) = self.msgs_sent_failed {
                my_size += ::protobuf::rt::uint64_size(8, v);
            }
            if let Some(v) = self.msgs_recv {
                my_size += ::protobuf::rt::uint64_size(9, v);
            }
            if let Some(v) = self.datagrams_sent {
                my_size += ::protobuf::rt::uint64_size(10, v);
            }
            if let Some(v) = self.datagrams_recv {
                my_size += ::protobuf::rt::uint64_size(11, v);
            }
            if let Some(v) = self.bad_pkts_recv {
                my_size += ::protobuf::rt::uint64_size(12, v);
            }
            if let Some(v) = self.unknown_conn_pkts_recv {
                my_size += ::protobuf::rt::uint64_size(13, v);
            }
            if let Some(v) = self.missed_pkts_recv {
                my_size += ::protobuf::rt::uint64_size(14, v);
            }
            if let Some(v) = self.dup_pkts_recv {
                my_size += ::protobuf::rt::uint64_size(15, v);
            }
            if let Some(v) = self.failed_connect_challenges {
                my_size += ::protobuf::rt::uint64_size(16, v);
            }
            if let Some(v) = self.micro_sec_avg_latency {
                my_size += ::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.micro_sec_min_latency {
                my_size += ::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.micro_sec_max_latency {
                my_size += ::protobuf::rt::uint32_size(19, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.connections_udp {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.connections_tcp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.stats_udp.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.pkts_abandoned {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.conn_req_received {
                os.write_uint64(5, v)?;
            }
            if let Some(v) = self.pkts_resent {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.msgs_sent {
                os.write_uint64(7, v)?;
            }
            if let Some(v) = self.msgs_sent_failed {
                os.write_uint64(8, v)?;
            }
            if let Some(v) = self.msgs_recv {
                os.write_uint64(9, v)?;
            }
            if let Some(v) = self.datagrams_sent {
                os.write_uint64(10, v)?;
            }
            if let Some(v) = self.datagrams_recv {
                os.write_uint64(11, v)?;
            }
            if let Some(v) = self.bad_pkts_recv {
                os.write_uint64(12, v)?;
            }
            if let Some(v) = self.unknown_conn_pkts_recv {
                os.write_uint64(13, v)?;
            }
            if let Some(v) = self.missed_pkts_recv {
                os.write_uint64(14, v)?;
            }
            if let Some(v) = self.dup_pkts_recv {
                os.write_uint64(15, v)?;
            }
            if let Some(v) = self.failed_connect_challenges {
                os.write_uint64(16, v)?;
            }
            if let Some(v) = self.micro_sec_avg_latency {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.micro_sec_min_latency {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.micro_sec_max_latency {
                os.write_uint32(19, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stats_VConn {
            Stats_VConn::new()
        }

        fn clear(&mut self) {
            self.connections_udp = ::std::option::Option::None;
            self.connections_tcp = ::std::option::Option::None;
            self.stats_udp.clear();
            self.pkts_abandoned = ::std::option::Option::None;
            self.conn_req_received = ::std::option::Option::None;
            self.pkts_resent = ::std::option::Option::None;
            self.msgs_sent = ::std::option::Option::None;
            self.msgs_sent_failed = ::std::option::Option::None;
            self.msgs_recv = ::std::option::Option::None;
            self.datagrams_sent = ::std::option::Option::None;
            self.datagrams_recv = ::std::option::Option::None;
            self.bad_pkts_recv = ::std::option::Option::None;
            self.unknown_conn_pkts_recv = ::std::option::Option::None;
            self.missed_pkts_recv = ::std::option::Option::None;
            self.dup_pkts_recv = ::std::option::Option::None;
            self.failed_connect_challenges = ::std::option::Option::None;
            self.micro_sec_avg_latency = ::std::option::Option::None;
            self.micro_sec_min_latency = ::std::option::Option::None;
            self.micro_sec_max_latency = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stats_VConn {
            static instance: Stats_VConn = Stats_VConn {
                connections_udp: ::std::option::Option::None,
                connections_tcp: ::std::option::Option::None,
                stats_udp: ::protobuf::MessageField::none(),
                pkts_abandoned: ::std::option::Option::None,
                conn_req_received: ::std::option::Option::None,
                pkts_resent: ::std::option::Option::None,
                msgs_sent: ::std::option::Option::None,
                msgs_sent_failed: ::std::option::Option::None,
                msgs_recv: ::std::option::Option::None,
                datagrams_sent: ::std::option::Option::None,
                datagrams_recv: ::std::option::Option::None,
                bad_pkts_recv: ::std::option::Option::None,
                unknown_conn_pkts_recv: ::std::option::Option::None,
                missed_pkts_recv: ::std::option::Option::None,
                dup_pkts_recv: ::std::option::Option::None,
                failed_connect_challenges: ::std::option::Option::None,
                micro_sec_avg_latency: ::std::option::Option::None,
                micro_sec_min_latency: ::std::option::Option::None,
                micro_sec_max_latency: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientServersAvailable)
pub struct CMsgClientServersAvailable {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientServersAvailable.server_types_available)
    pub server_types_available: ::std::vec::Vec<cmsg_client_servers_available::Server_Types_Available>,
    // @@protoc_insertion_point(field:CMsgClientServersAvailable.server_type_for_auth_services)
    pub server_type_for_auth_services: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientServersAvailable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientServersAvailable {
    fn default() -> &'a CMsgClientServersAvailable {
        <CMsgClientServersAvailable as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServersAvailable {
    pub fn new() -> CMsgClientServersAvailable {
        ::std::default::Default::default()
    }

    // optional uint32 server_type_for_auth_services = 2;

    pub fn server_type_for_auth_services(&self) -> u32 {
        self.server_type_for_auth_services.unwrap_or(0)
    }

    pub fn clear_server_type_for_auth_services(&mut self) {
        self.server_type_for_auth_services = ::std::option::Option::None;
    }

    pub fn has_server_type_for_auth_services(&self) -> bool {
        self.server_type_for_auth_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_type_for_auth_services(&mut self, v: u32) {
        self.server_type_for_auth_services = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientServersAvailable {
    const NAME: &'static str = "CMsgClientServersAvailable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.server_types_available.push(is.read_message()?);
                },
                16 => {
                    self.server_type_for_auth_services = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.server_types_available {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.server_type_for_auth_services {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.server_types_available {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.server_type_for_auth_services {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientServersAvailable {
        CMsgClientServersAvailable::new()
    }

    fn clear(&mut self) {
        self.server_types_available.clear();
        self.server_type_for_auth_services = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientServersAvailable {
        static instance: CMsgClientServersAvailable = CMsgClientServersAvailable {
            server_types_available: ::std::vec::Vec::new(),
            server_type_for_auth_services: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientServersAvailable`
pub mod cmsg_client_servers_available {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientServersAvailable.Server_Types_Available)
    pub struct Server_Types_Available {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientServersAvailable.Server_Types_Available.server)
        pub server: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientServersAvailable.Server_Types_Available.changed)
        pub changed: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientServersAvailable.Server_Types_Available.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Server_Types_Available {
        fn default() -> &'a Server_Types_Available {
            <Server_Types_Available as ::protobuf::Message>::default_instance()
        }
    }

    impl Server_Types_Available {
        pub fn new() -> Server_Types_Available {
            ::std::default::Default::default()
        }

        // optional uint32 server = 1;

        pub fn server(&self) -> u32 {
            self.server.unwrap_or(0)
        }

        pub fn clear_server(&mut self) {
            self.server = ::std::option::Option::None;
        }

        pub fn has_server(&self) -> bool {
            self.server.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server(&mut self, v: u32) {
            self.server = ::std::option::Option::Some(v);
        }

        // optional bool changed = 2;

        pub fn changed(&self) -> bool {
            self.changed.unwrap_or(false)
        }

        pub fn clear_changed(&mut self) {
            self.changed = ::std::option::Option::None;
        }

        pub fn has_changed(&self) -> bool {
            self.changed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_changed(&mut self, v: bool) {
            self.changed = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Server_Types_Available {
        const NAME: &'static str = "Server_Types_Available";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.server = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.changed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.changed {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.server {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.changed {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Server_Types_Available {
            Server_Types_Available::new()
        }

        fn clear(&mut self) {
            self.server = ::std::option::Option::None;
            self.changed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Server_Types_Available {
            static instance: Server_Types_Available = Server_Types_Available {
                server: ::std::option::Option::None,
                changed: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientReportOverlayDetourFailure)
pub struct CMsgClientReportOverlayDetourFailure {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientReportOverlayDetourFailure.failure_strings)
    pub failure_strings: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientReportOverlayDetourFailure.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientReportOverlayDetourFailure {
    fn default() -> &'a CMsgClientReportOverlayDetourFailure {
        <CMsgClientReportOverlayDetourFailure as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientReportOverlayDetourFailure {
    pub fn new() -> CMsgClientReportOverlayDetourFailure {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientReportOverlayDetourFailure {
    const NAME: &'static str = "CMsgClientReportOverlayDetourFailure";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.failure_strings.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.failure_strings {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.failure_strings {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientReportOverlayDetourFailure {
        CMsgClientReportOverlayDetourFailure::new()
    }

    fn clear(&mut self) {
        self.failure_strings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientReportOverlayDetourFailure {
        static instance: CMsgClientReportOverlayDetourFailure = CMsgClientReportOverlayDetourFailure {
            failure_strings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientRequestEncryptedAppTicket)
pub struct CMsgClientRequestEncryptedAppTicket {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestEncryptedAppTicket.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestEncryptedAppTicket.userdata)
    pub userdata: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestEncryptedAppTicket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestEncryptedAppTicket {
    fn default() -> &'a CMsgClientRequestEncryptedAppTicket {
        <CMsgClientRequestEncryptedAppTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestEncryptedAppTicket {
    pub fn new() -> CMsgClientRequestEncryptedAppTicket {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional bytes userdata = 2;

    pub fn userdata(&self) -> &[u8] {
        match self.userdata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_userdata(&mut self) {
        self.userdata = ::std::option::Option::None;
    }

    pub fn has_userdata(&self) -> bool {
        self.userdata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userdata(&mut self, v: ::std::vec::Vec<u8>) {
        self.userdata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userdata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.userdata.is_none() {
            self.userdata = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.userdata.as_mut().unwrap()
    }

    // Take field
    pub fn take_userdata(&mut self) -> ::std::vec::Vec<u8> {
        self.userdata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestEncryptedAppTicket {
    const NAME: &'static str = "CMsgClientRequestEncryptedAppTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.userdata = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.userdata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.userdata.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestEncryptedAppTicket {
        CMsgClientRequestEncryptedAppTicket::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.userdata = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestEncryptedAppTicket {
        static instance: CMsgClientRequestEncryptedAppTicket = CMsgClientRequestEncryptedAppTicket {
            app_id: ::std::option::Option::None,
            userdata: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientRequestEncryptedAppTicketResponse)
pub struct CMsgClientRequestEncryptedAppTicketResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientRequestEncryptedAppTicketResponse.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientRequestEncryptedAppTicketResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientRequestEncryptedAppTicketResponse.encrypted_app_ticket)
    pub encrypted_app_ticket: ::protobuf::MessageField<super::encrypted_app_ticket::EncryptedAppTicket>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientRequestEncryptedAppTicketResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestEncryptedAppTicketResponse {
    fn default() -> &'a CMsgClientRequestEncryptedAppTicketResponse {
        <CMsgClientRequestEncryptedAppTicketResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestEncryptedAppTicketResponse {
    pub fn new() -> CMsgClientRequestEncryptedAppTicketResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 2;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRequestEncryptedAppTicketResponse {
    const NAME: &'static str = "CMsgClientRequestEncryptedAppTicketResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.encrypted_app_ticket)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.encrypted_app_ticket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.encrypted_app_ticket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientRequestEncryptedAppTicketResponse {
        CMsgClientRequestEncryptedAppTicketResponse::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.encrypted_app_ticket.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientRequestEncryptedAppTicketResponse {
        static instance: CMsgClientRequestEncryptedAppTicketResponse = CMsgClientRequestEncryptedAppTicketResponse {
            app_id: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            encrypted_app_ticket: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientWalletInfoUpdate)
pub struct CMsgClientWalletInfoUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.has_wallet)
    pub has_wallet: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.balance)
    pub balance: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.currency)
    pub currency: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.balance_delayed)
    pub balance_delayed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.balance64)
    pub balance64: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.balance64_delayed)
    pub balance64_delayed: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CMsgClientWalletInfoUpdate.realm)
    pub realm: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientWalletInfoUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWalletInfoUpdate {
    fn default() -> &'a CMsgClientWalletInfoUpdate {
        <CMsgClientWalletInfoUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWalletInfoUpdate {
    pub fn new() -> CMsgClientWalletInfoUpdate {
        ::std::default::Default::default()
    }

    // optional bool has_wallet = 1;

    pub fn has_wallet(&self) -> bool {
        self.has_wallet.unwrap_or(false)
    }

    pub fn clear_has_wallet(&mut self) {
        self.has_wallet = ::std::option::Option::None;
    }

    pub fn has_has_wallet(&self) -> bool {
        self.has_wallet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_wallet(&mut self, v: bool) {
        self.has_wallet = ::std::option::Option::Some(v);
    }

    // optional int32 balance = 2;

    pub fn balance(&self) -> i32 {
        self.balance.unwrap_or(0)
    }

    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: i32) {
        self.balance = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 3;

    pub fn currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }

    // optional int32 balance_delayed = 4;

    pub fn balance_delayed(&self) -> i32 {
        self.balance_delayed.unwrap_or(0)
    }

    pub fn clear_balance_delayed(&mut self) {
        self.balance_delayed = ::std::option::Option::None;
    }

    pub fn has_balance_delayed(&self) -> bool {
        self.balance_delayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_delayed(&mut self, v: i32) {
        self.balance_delayed = ::std::option::Option::Some(v);
    }

    // optional int64 balance64 = 5;

    pub fn balance64(&self) -> i64 {
        self.balance64.unwrap_or(0)
    }

    pub fn clear_balance64(&mut self) {
        self.balance64 = ::std::option::Option::None;
    }

    pub fn has_balance64(&self) -> bool {
        self.balance64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance64(&mut self, v: i64) {
        self.balance64 = ::std::option::Option::Some(v);
    }

    // optional int64 balance64_delayed = 6;

    pub fn balance64_delayed(&self) -> i64 {
        self.balance64_delayed.unwrap_or(0)
    }

    pub fn clear_balance64_delayed(&mut self) {
        self.balance64_delayed = ::std::option::Option::None;
    }

    pub fn has_balance64_delayed(&self) -> bool {
        self.balance64_delayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance64_delayed(&mut self, v: i64) {
        self.balance64_delayed = ::std::option::Option::Some(v);
    }

    // optional int32 realm = 7;

    pub fn realm(&self) -> i32 {
        self.realm.unwrap_or(0)
    }

    pub fn clear_realm(&mut self) {
        self.realm = ::std::option::Option::None;
    }

    pub fn has_realm(&self) -> bool {
        self.realm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realm(&mut self, v: i32) {
        self.realm = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientWalletInfoUpdate {
    const NAME: &'static str = "CMsgClientWalletInfoUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.has_wallet = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.balance = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.currency = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.balance_delayed = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.balance64 = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.balance64_delayed = ::std::option::Option::Some(is.read_int64()?);
                },
                56 => {
                    self.realm = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.has_wallet {
            my_size += 1 + 1;
        }
        if let Some(v) = self.balance {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.balance_delayed {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.balance64 {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.balance64_delayed {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        if let Some(v) = self.realm {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.has_wallet {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.balance {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.balance_delayed {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.balance64 {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.balance64_delayed {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.realm {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWalletInfoUpdate {
        CMsgClientWalletInfoUpdate::new()
    }

    fn clear(&mut self) {
        self.has_wallet = ::std::option::Option::None;
        self.balance = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.balance_delayed = ::std::option::Option::None;
        self.balance64 = ::std::option::Option::None;
        self.balance64_delayed = ::std::option::Option::None;
        self.realm = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWalletInfoUpdate {
        static instance: CMsgClientWalletInfoUpdate = CMsgClientWalletInfoUpdate {
            has_wallet: ::std::option::Option::None,
            balance: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            balance_delayed: ::std::option::Option::None,
            balance64: ::std::option::Option::None,
            balance64_delayed: ::std::option::Option::None,
            realm: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientAMGetClanOfficers)
pub struct CMsgClientAMGetClanOfficers {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAMGetClanOfficers.steamid_clan)
    pub steamid_clan: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAMGetClanOfficers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetClanOfficers {
    fn default() -> &'a CMsgClientAMGetClanOfficers {
        <CMsgClientAMGetClanOfficers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetClanOfficers {
    pub fn new() -> CMsgClientAMGetClanOfficers {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_clan = 1;

    pub fn steamid_clan(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }

    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAMGetClanOfficers {
    const NAME: &'static str = "CMsgClientAMGetClanOfficers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_clan {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_clan {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAMGetClanOfficers {
        CMsgClientAMGetClanOfficers::new()
    }

    fn clear(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAMGetClanOfficers {
        static instance: CMsgClientAMGetClanOfficers = CMsgClientAMGetClanOfficers {
            steamid_clan: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientAMGetClanOfficersResponse)
pub struct CMsgClientAMGetClanOfficersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAMGetClanOfficersResponse.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientAMGetClanOfficersResponse.steamid_clan)
    pub steamid_clan: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientAMGetClanOfficersResponse.officer_count)
    pub officer_count: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAMGetClanOfficersResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetClanOfficersResponse {
    fn default() -> &'a CMsgClientAMGetClanOfficersResponse {
        <CMsgClientAMGetClanOfficersResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetClanOfficersResponse {
    pub fn new() -> CMsgClientAMGetClanOfficersResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_clan = 2;

    pub fn steamid_clan(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }

    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }

    // optional int32 officer_count = 3;

    pub fn officer_count(&self) -> i32 {
        self.officer_count.unwrap_or(0)
    }

    pub fn clear_officer_count(&mut self) {
        self.officer_count = ::std::option::Option::None;
    }

    pub fn has_officer_count(&self) -> bool {
        self.officer_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_officer_count(&mut self, v: i32) {
        self.officer_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAMGetClanOfficersResponse {
    const NAME: &'static str = "CMsgClientAMGetClanOfficersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.steamid_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.officer_count = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.steamid_clan {
            my_size += 1 + 8;
        }
        if let Some(v) = self.officer_count {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamid_clan {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.officer_count {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAMGetClanOfficersResponse {
        CMsgClientAMGetClanOfficersResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.steamid_clan = ::std::option::Option::None;
        self.officer_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAMGetClanOfficersResponse {
        static instance: CMsgClientAMGetClanOfficersResponse = CMsgClientAMGetClanOfficersResponse {
            eresult: ::std::option::Option::None,
            steamid_clan: ::std::option::Option::None,
            officer_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientAMGetPersonaNameHistory)
pub struct CMsgClientAMGetPersonaNameHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistory.id_count)
    pub id_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistory.Ids)
    pub Ids: ::std::vec::Vec<cmsg_client_amget_persona_name_history::IdInstance>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAMGetPersonaNameHistory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetPersonaNameHistory {
    fn default() -> &'a CMsgClientAMGetPersonaNameHistory {
        <CMsgClientAMGetPersonaNameHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetPersonaNameHistory {
    pub fn new() -> CMsgClientAMGetPersonaNameHistory {
        ::std::default::Default::default()
    }

    // optional int32 id_count = 1;

    pub fn id_count(&self) -> i32 {
        self.id_count.unwrap_or(0)
    }

    pub fn clear_id_count(&mut self) {
        self.id_count = ::std::option::Option::None;
    }

    pub fn has_id_count(&self) -> bool {
        self.id_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id_count(&mut self, v: i32) {
        self.id_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAMGetPersonaNameHistory {
    const NAME: &'static str = "CMsgClientAMGetPersonaNameHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id_count = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.Ids.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id_count {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.Ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id_count {
            os.write_int32(1, v)?;
        }
        for v in &self.Ids {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAMGetPersonaNameHistory {
        CMsgClientAMGetPersonaNameHistory::new()
    }

    fn clear(&mut self) {
        self.id_count = ::std::option::Option::None;
        self.Ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistory {
        static instance: CMsgClientAMGetPersonaNameHistory = CMsgClientAMGetPersonaNameHistory {
            id_count: ::std::option::Option::None,
            Ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientAMGetPersonaNameHistory`
pub mod cmsg_client_amget_persona_name_history {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientAMGetPersonaNameHistory.IdInstance)
    pub struct IdInstance {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistory.IdInstance.steamid)
        pub steamid: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientAMGetPersonaNameHistory.IdInstance.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a IdInstance {
        fn default() -> &'a IdInstance {
            <IdInstance as ::protobuf::Message>::default_instance()
        }
    }

    impl IdInstance {
        pub fn new() -> IdInstance {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for IdInstance {
        const NAME: &'static str = "IdInstance";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> IdInstance {
            IdInstance::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static IdInstance {
            static instance: IdInstance = IdInstance {
                steamid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientAMGetPersonaNameHistoryResponse)
pub struct CMsgClientAMGetPersonaNameHistoryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.responses)
    pub responses: ::std::vec::Vec<cmsg_client_amget_persona_name_history_response::NameTableInstance>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientAMGetPersonaNameHistoryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientAMGetPersonaNameHistoryResponse {
    fn default() -> &'a CMsgClientAMGetPersonaNameHistoryResponse {
        <CMsgClientAMGetPersonaNameHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAMGetPersonaNameHistoryResponse {
    pub fn new() -> CMsgClientAMGetPersonaNameHistoryResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientAMGetPersonaNameHistoryResponse {
    const NAME: &'static str = "CMsgClientAMGetPersonaNameHistoryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.responses.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.responses {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientAMGetPersonaNameHistoryResponse {
        CMsgClientAMGetPersonaNameHistoryResponse::new()
    }

    fn clear(&mut self) {
        self.responses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistoryResponse {
        static instance: CMsgClientAMGetPersonaNameHistoryResponse = CMsgClientAMGetPersonaNameHistoryResponse {
            responses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientAMGetPersonaNameHistoryResponse`
pub mod cmsg_client_amget_persona_name_history_response {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance)
    pub struct NameTableInstance {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.eresult)
        pub eresult: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.names)
        pub names: ::std::vec::Vec<name_table_instance::NameInstance>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NameTableInstance {
        fn default() -> &'a NameTableInstance {
            <NameTableInstance as ::protobuf::Message>::default_instance()
        }
    }

    impl NameTableInstance {
        pub fn new() -> NameTableInstance {
            ::std::default::Default::default()
        }

        // optional int32 eresult = 1;

        pub fn eresult(&self) -> i32 {
            self.eresult.unwrap_or(2i32)
        }

        pub fn clear_eresult(&mut self) {
            self.eresult = ::std::option::Option::None;
        }

        pub fn has_eresult(&self) -> bool {
            self.eresult.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eresult(&mut self, v: i32) {
            self.eresult = ::std::option::Option::Some(v);
        }

        // optional fixed64 steamid = 2;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for NameTableInstance {
        const NAME: &'static str = "NameTableInstance";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.eresult = ::std::option::Option::Some(is.read_int32()?);
                    },
                    17 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    26 => {
                        self.names.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.eresult {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            for value in &self.names {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.eresult {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.steamid {
                os.write_fixed64(2, v)?;
            }
            for v in &self.names {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NameTableInstance {
            NameTableInstance::new()
        }

        fn clear(&mut self) {
            self.eresult = ::std::option::Option::None;
            self.steamid = ::std::option::Option::None;
            self.names.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NameTableInstance {
            static instance: NameTableInstance = NameTableInstance {
                eresult: ::std::option::Option::None,
                steamid: ::std::option::Option::None,
                names: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `NameTableInstance`
    pub mod name_table_instance {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance)
        pub struct NameInstance {
            // message fields
            // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance.name_since)
            pub name_since: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance.name)
            pub name: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a NameInstance {
            fn default() -> &'a NameInstance {
                <NameInstance as ::protobuf::Message>::default_instance()
            }
        }

        impl NameInstance {
            pub fn new() -> NameInstance {
                ::std::default::Default::default()
            }

            // optional fixed32 name_since = 1;

            pub fn name_since(&self) -> u32 {
                self.name_since.unwrap_or(0)
            }

            pub fn clear_name_since(&mut self) {
                self.name_since = ::std::option::Option::None;
            }

            pub fn has_name_since(&self) -> bool {
                self.name_since.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name_since(&mut self, v: u32) {
                self.name_since = ::std::option::Option::Some(v);
            }

            // optional string name = 2;

            pub fn name(&self) -> &str {
                match self.name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_name(&mut self) {
                self.name = ::std::option::Option::None;
            }

            pub fn has_name(&self) -> bool {
                self.name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                if self.name.is_none() {
                    self.name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.name.as_mut().unwrap()
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                self.name.take().unwrap_or_else(|| ::std::string::String::new())
            }
        }

        impl ::protobuf::Message for NameInstance {
            const NAME: &'static str = "NameInstance";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        13 => {
                            self.name_since = ::std::option::Option::Some(is.read_fixed32()?);
                        },
                        18 => {
                            self.name = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.name_since {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.name.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.name_since {
                    os.write_fixed32(1, v)?;
                }
                if let Some(v) = self.name.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> NameInstance {
                NameInstance::new()
            }

            fn clear(&mut self) {
                self.name_since = ::std::option::Option::None;
                self.name = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static NameInstance {
                static instance: NameInstance = NameInstance {
                    name_since: ::std::option::Option::None,
                    name: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientDeregisterWithServer)
pub struct CMsgClientDeregisterWithServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientDeregisterWithServer.eservertype)
    pub eservertype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientDeregisterWithServer.app_id)
    pub app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientDeregisterWithServer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeregisterWithServer {
    fn default() -> &'a CMsgClientDeregisterWithServer {
        <CMsgClientDeregisterWithServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeregisterWithServer {
    pub fn new() -> CMsgClientDeregisterWithServer {
        ::std::default::Default::default()
    }

    // optional uint32 eservertype = 1;

    pub fn eservertype(&self) -> u32 {
        self.eservertype.unwrap_or(0)
    }

    pub fn clear_eservertype(&mut self) {
        self.eservertype = ::std::option::Option::None;
    }

    pub fn has_eservertype(&self) -> bool {
        self.eservertype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eservertype(&mut self, v: u32) {
        self.eservertype = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDeregisterWithServer {
    const NAME: &'static str = "CMsgClientDeregisterWithServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eservertype = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eservertype {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eservertype {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientDeregisterWithServer {
        CMsgClientDeregisterWithServer::new()
    }

    fn clear(&mut self) {
        self.eservertype = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientDeregisterWithServer {
        static instance: CMsgClientDeregisterWithServer = CMsgClientDeregisterWithServer {
            eservertype: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientClanState)
pub struct CMsgClientClanState {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientClanState.steamid_clan)
    pub steamid_clan: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientClanState.clan_account_flags)
    pub clan_account_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientClanState.name_info)
    pub name_info: ::protobuf::MessageField<cmsg_client_clan_state::NameInfo>,
    // @@protoc_insertion_point(field:CMsgClientClanState.user_counts)
    pub user_counts: ::protobuf::MessageField<cmsg_client_clan_state::UserCounts>,
    // @@protoc_insertion_point(field:CMsgClientClanState.events)
    pub events: ::std::vec::Vec<cmsg_client_clan_state::Event>,
    // @@protoc_insertion_point(field:CMsgClientClanState.announcements)
    pub announcements: ::std::vec::Vec<cmsg_client_clan_state::Event>,
    // @@protoc_insertion_point(field:CMsgClientClanState.chat_room_private)
    pub chat_room_private: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientClanState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientClanState {
    fn default() -> &'a CMsgClientClanState {
        <CMsgClientClanState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientClanState {
    pub fn new() -> CMsgClientClanState {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_clan = 1;

    pub fn steamid_clan(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }

    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }

    // optional uint32 clan_account_flags = 3;

    pub fn clan_account_flags(&self) -> u32 {
        self.clan_account_flags.unwrap_or(0)
    }

    pub fn clear_clan_account_flags(&mut self) {
        self.clan_account_flags = ::std::option::Option::None;
    }

    pub fn has_clan_account_flags(&self) -> bool {
        self.clan_account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_account_flags(&mut self, v: u32) {
        self.clan_account_flags = ::std::option::Option::Some(v);
    }

    // optional bool chat_room_private = 8;

    pub fn chat_room_private(&self) -> bool {
        self.chat_room_private.unwrap_or(false)
    }

    pub fn clear_chat_room_private(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
    }

    pub fn has_chat_room_private(&self) -> bool {
        self.chat_room_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_private(&mut self, v: bool) {
        self.chat_room_private = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientClanState {
    const NAME: &'static str = "CMsgClientClanState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_clan = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.clan_account_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.name_info)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user_counts)?;
                },
                50 => {
                    self.events.push(is.read_message()?);
                },
                58 => {
                    self.announcements.push(is.read_message()?);
                },
                64 => {
                    self.chat_room_private = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_clan {
            my_size += 1 + 8;
        }
        if let Some(v) = self.clan_account_flags {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.name_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user_counts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.announcements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.chat_room_private {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_clan {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.clan_account_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.name_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.user_counts.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.announcements {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.chat_room_private {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientClanState {
        CMsgClientClanState::new()
    }

    fn clear(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
        self.clan_account_flags = ::std::option::Option::None;
        self.name_info.clear();
        self.user_counts.clear();
        self.events.clear();
        self.announcements.clear();
        self.chat_room_private = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientClanState {
        static instance: CMsgClientClanState = CMsgClientClanState {
            steamid_clan: ::std::option::Option::None,
            clan_account_flags: ::std::option::Option::None,
            name_info: ::protobuf::MessageField::none(),
            user_counts: ::protobuf::MessageField::none(),
            events: ::std::vec::Vec::new(),
            announcements: ::std::vec::Vec::new(),
            chat_room_private: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientClanState`
pub mod cmsg_client_clan_state {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientClanState.NameInfo)
    pub struct NameInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientClanState.NameInfo.clan_name)
        pub clan_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientClanState.NameInfo.sha_avatar)
        pub sha_avatar: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientClanState.NameInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NameInfo {
        fn default() -> &'a NameInfo {
            <NameInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl NameInfo {
        pub fn new() -> NameInfo {
            ::std::default::Default::default()
        }

        // optional string clan_name = 1;

        pub fn clan_name(&self) -> &str {
            match self.clan_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_clan_name(&mut self) {
            self.clan_name = ::std::option::Option::None;
        }

        pub fn has_clan_name(&self) -> bool {
            self.clan_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clan_name(&mut self, v: ::std::string::String) {
            self.clan_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_clan_name(&mut self) -> &mut ::std::string::String {
            if self.clan_name.is_none() {
                self.clan_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.clan_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_clan_name(&mut self) -> ::std::string::String {
            self.clan_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes sha_avatar = 2;

        pub fn sha_avatar(&self) -> &[u8] {
            match self.sha_avatar.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_sha_avatar(&mut self) {
            self.sha_avatar = ::std::option::Option::None;
        }

        pub fn has_sha_avatar(&self) -> bool {
            self.sha_avatar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sha_avatar(&mut self, v: ::std::vec::Vec<u8>) {
            self.sha_avatar = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sha_avatar(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.sha_avatar.is_none() {
                self.sha_avatar = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.sha_avatar.as_mut().unwrap()
        }

        // Take field
        pub fn take_sha_avatar(&mut self) -> ::std::vec::Vec<u8> {
            self.sha_avatar.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::protobuf::Message for NameInfo {
        const NAME: &'static str = "NameInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.clan_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.sha_avatar = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.clan_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.sha_avatar.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.clan_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.sha_avatar.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NameInfo {
            NameInfo::new()
        }

        fn clear(&mut self) {
            self.clan_name = ::std::option::Option::None;
            self.sha_avatar = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NameInfo {
            static instance: NameInfo = NameInfo {
                clan_name: ::std::option::Option::None,
                sha_avatar: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientClanState.UserCounts)
    pub struct UserCounts {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientClanState.UserCounts.members)
        pub members: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientClanState.UserCounts.online)
        pub online: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientClanState.UserCounts.chatting)
        pub chatting: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientClanState.UserCounts.in_game)
        pub in_game: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientClanState.UserCounts.chat_room_members)
        pub chat_room_members: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientClanState.UserCounts.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UserCounts {
        fn default() -> &'a UserCounts {
            <UserCounts as ::protobuf::Message>::default_instance()
        }
    }

    impl UserCounts {
        pub fn new() -> UserCounts {
            ::std::default::Default::default()
        }

        // optional uint32 members = 1;

        pub fn members(&self) -> u32 {
            self.members.unwrap_or(0)
        }

        pub fn clear_members(&mut self) {
            self.members = ::std::option::Option::None;
        }

        pub fn has_members(&self) -> bool {
            self.members.is_some()
        }

        // Param is passed by value, moved
        pub fn set_members(&mut self, v: u32) {
            self.members = ::std::option::Option::Some(v);
        }

        // optional uint32 online = 2;

        pub fn online(&self) -> u32 {
            self.online.unwrap_or(0)
        }

        pub fn clear_online(&mut self) {
            self.online = ::std::option::Option::None;
        }

        pub fn has_online(&self) -> bool {
            self.online.is_some()
        }

        // Param is passed by value, moved
        pub fn set_online(&mut self, v: u32) {
            self.online = ::std::option::Option::Some(v);
        }

        // optional uint32 chatting = 3;

        pub fn chatting(&self) -> u32 {
            self.chatting.unwrap_or(0)
        }

        pub fn clear_chatting(&mut self) {
            self.chatting = ::std::option::Option::None;
        }

        pub fn has_chatting(&self) -> bool {
            self.chatting.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chatting(&mut self, v: u32) {
            self.chatting = ::std::option::Option::Some(v);
        }

        // optional uint32 in_game = 4;

        pub fn in_game(&self) -> u32 {
            self.in_game.unwrap_or(0)
        }

        pub fn clear_in_game(&mut self) {
            self.in_game = ::std::option::Option::None;
        }

        pub fn has_in_game(&self) -> bool {
            self.in_game.is_some()
        }

        // Param is passed by value, moved
        pub fn set_in_game(&mut self, v: u32) {
            self.in_game = ::std::option::Option::Some(v);
        }

        // optional uint32 chat_room_members = 5;

        pub fn chat_room_members(&self) -> u32 {
            self.chat_room_members.unwrap_or(0)
        }

        pub fn clear_chat_room_members(&mut self) {
            self.chat_room_members = ::std::option::Option::None;
        }

        pub fn has_chat_room_members(&self) -> bool {
            self.chat_room_members.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_room_members(&mut self, v: u32) {
            self.chat_room_members = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for UserCounts {
        const NAME: &'static str = "UserCounts";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.members = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.online = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.chatting = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.in_game = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.chat_room_members = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.members {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.online {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.chatting {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.in_game {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.chat_room_members {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.members {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.online {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.chatting {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.in_game {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.chat_room_members {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UserCounts {
            UserCounts::new()
        }

        fn clear(&mut self) {
            self.members = ::std::option::Option::None;
            self.online = ::std::option::Option::None;
            self.chatting = ::std::option::Option::None;
            self.in_game = ::std::option::Option::None;
            self.chat_room_members = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UserCounts {
            static instance: UserCounts = UserCounts {
                members: ::std::option::Option::None,
                online: ::std::option::Option::None,
                chatting: ::std::option::Option::None,
                in_game: ::std::option::Option::None,
                chat_room_members: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgClientClanState.Event)
    pub struct Event {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientClanState.Event.gid)
        pub gid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientClanState.Event.event_time)
        pub event_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientClanState.Event.headline)
        pub headline: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientClanState.Event.game_id)
        pub game_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientClanState.Event.just_posted)
        pub just_posted: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientClanState.Event.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Event {
        fn default() -> &'a Event {
            <Event as ::protobuf::Message>::default_instance()
        }
    }

    impl Event {
        pub fn new() -> Event {
            ::std::default::Default::default()
        }

        // optional fixed64 gid = 1;

        pub fn gid(&self) -> u64 {
            self.gid.unwrap_or(0)
        }

        pub fn clear_gid(&mut self) {
            self.gid = ::std::option::Option::None;
        }

        pub fn has_gid(&self) -> bool {
            self.gid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gid(&mut self, v: u64) {
            self.gid = ::std::option::Option::Some(v);
        }

        // optional uint32 event_time = 2;

        pub fn event_time(&self) -> u32 {
            self.event_time.unwrap_or(0)
        }

        pub fn clear_event_time(&mut self) {
            self.event_time = ::std::option::Option::None;
        }

        pub fn has_event_time(&self) -> bool {
            self.event_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_time(&mut self, v: u32) {
            self.event_time = ::std::option::Option::Some(v);
        }

        // optional string headline = 3;

        pub fn headline(&self) -> &str {
            match self.headline.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_headline(&mut self) {
            self.headline = ::std::option::Option::None;
        }

        pub fn has_headline(&self) -> bool {
            self.headline.is_some()
        }

        // Param is passed by value, moved
        pub fn set_headline(&mut self, v: ::std::string::String) {
            self.headline = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_headline(&mut self) -> &mut ::std::string::String {
            if self.headline.is_none() {
                self.headline = ::std::option::Option::Some(::std::string::String::new());
            }
            self.headline.as_mut().unwrap()
        }

        // Take field
        pub fn take_headline(&mut self) -> ::std::string::String {
            self.headline.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 game_id = 4;

        pub fn game_id(&self) -> u64 {
            self.game_id.unwrap_or(0)
        }

        pub fn clear_game_id(&mut self) {
            self.game_id = ::std::option::Option::None;
        }

        pub fn has_game_id(&self) -> bool {
            self.game_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_id(&mut self, v: u64) {
            self.game_id = ::std::option::Option::Some(v);
        }

        // optional bool just_posted = 5;

        pub fn just_posted(&self) -> bool {
            self.just_posted.unwrap_or(false)
        }

        pub fn clear_just_posted(&mut self) {
            self.just_posted = ::std::option::Option::None;
        }

        pub fn has_just_posted(&self) -> bool {
            self.just_posted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_just_posted(&mut self, v: bool) {
            self.just_posted = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Event {
        const NAME: &'static str = "Event";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.event_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.headline = ::std::option::Option::Some(is.read_string()?);
                    },
                    33 => {
                        self.game_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    40 => {
                        self.just_posted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.gid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.event_time {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.headline.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.game_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.just_posted {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.gid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.event_time {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.headline.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.game_id {
                os.write_fixed64(4, v)?;
            }
            if let Some(v) = self.just_posted {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Event {
            Event::new()
        }

        fn clear(&mut self) {
            self.gid = ::std::option::Option::None;
            self.event_time = ::std::option::Option::None;
            self.headline = ::std::option::Option::None;
            self.game_id = ::std::option::Option::None;
            self.just_posted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Event {
            static instance: Event = Event {
                gid: ::std::option::Option::None,
                event_time: ::std::option::Option::None,
                headline: ::std::option::Option::None,
                game_id: ::std::option::Option::None,
                just_posted: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}
#[allow(unused_imports)]
use crate::steammessages_base::*;
#[allow(unused_imports)]
use crate::encrypted_app_ticket::*;
impl crate::RpcMessage for CMsgClientRegisterAuthTicketWithCM {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRegisterAuthTicketWithCM {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRegisterAuthTicketWithCM;
}
impl crate::RpcMessage for CMsgClientTicketAuthComplete {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientTicketAuthComplete {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientTicketAuthComplete;
}
impl crate::RpcMessage for CMsgClientCMList {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientCMList {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientCMList;
}
impl crate::RpcMessage for CMsgClientP2PConnectionInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientP2PConnectionInfo {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientP2PConnectionInfo;
}
impl crate::RpcMessage for CMsgClientP2PConnectionFailInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientP2PConnectionFailInfo {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientP2PConnectionFailInfo;
}
impl crate::RpcMessage for CMsgClientNetworkingCertRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientNetworkingCertRequest {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientNetworkingCertRequest;
}
impl crate::RpcMessage for CMsgClientNetworkingCertReply {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientNetworkingMobileCertRequest {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientNetworkingMobileCertRequest {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientNetworkingMobileCertRequest;
}
impl crate::RpcMessage for CMsgClientNetworkingMobileCertReply {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgClientGetAppOwnershipTicket {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetAppOwnershipTicket {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetAppOwnershipTicket;
}
impl crate::RpcMessage for CMsgClientGetAppOwnershipTicketResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGetAppOwnershipTicketResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGetAppOwnershipTicketResponse;
}
impl crate::RpcMessage for CMsgClientSessionToken {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientSessionToken {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientSessionToken;
}
impl crate::RpcMessage for CMsgClientGameConnectTokens {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGameConnectTokens {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGameConnectTokens;
}
impl crate::RpcMessage for CMsgClientGamesPlayed {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientGamesPlayed {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientGamesPlayed;
}
impl crate::RpcMessage for CMsgGSApprove {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgGSApprove {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgGSApprove;
}
impl crate::RpcMessage for CMsgGSDeny {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgGSDeny {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgGSDeny;
}
impl crate::RpcMessage for CMsgGSKick {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgGSKick {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgGSKick;
}
impl crate::RpcMessage for CMsgClientAuthList {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientAuthList {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientAuthList;
}
impl crate::RpcMessage for CMsgClientAuthListAck {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientAuthListAck {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientAuthListAck;
}
impl crate::RpcMessage for CMsgClientLicenseList {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientLicenseList {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientLicenseList;
}
impl crate::RpcMessage for CMsgClientIsLimitedAccount {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientIsLimitedAccount {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientIsLimitedAccount;
}
impl crate::RpcMessage for CMsgClientRequestedClientStats {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRequestedClientStats {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRequestedClientStats;
}
impl crate::RpcMessage for CMsgClientStat2 {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientStat2 {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientStat2;
}
impl crate::RpcMessage for CMsgClientInviteToGame {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientInviteToGame {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientInviteToGame;
}
impl crate::RpcMessage for CMsgClientChatInvite {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientChatInvite {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientChatInvite;
}
impl crate::RpcMessage for CMsgClientConnectionStats {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientConnectionStats {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientConnectionStats;
}
impl crate::RpcMessage for CMsgClientServersAvailable {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientServersAvailable {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientServersAvailable;
}
impl crate::RpcMessage for CMsgClientReportOverlayDetourFailure {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientReportOverlayDetourFailure {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientReportOverlayDetourFailure;
}
impl crate::RpcMessage for CMsgClientRequestEncryptedAppTicket {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRequestEncryptedAppTicket {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRequestEncryptedAppTicket;
}
impl crate::RpcMessage for CMsgClientRequestEncryptedAppTicketResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientRequestEncryptedAppTicketResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientRequestEncryptedAppTicketResponse;
}
impl crate::RpcMessage for CMsgClientWalletInfoUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientWalletInfoUpdate {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientWalletInfoUpdate;
}
impl crate::RpcMessage for CMsgClientAMGetClanOfficers {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientAMGetClanOfficers {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientAMGetClanOfficers;
}
impl crate::RpcMessage for CMsgClientAMGetClanOfficersResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientAMGetClanOfficersResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientAMGetClanOfficersResponse;
}
impl crate::RpcMessage for CMsgClientAMGetPersonaNameHistory {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientAMGetPersonaNameHistory {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientAMGetPersonaNameHistory;
}
impl crate::RpcMessage for CMsgClientAMGetPersonaNameHistoryResponse {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientAMGetPersonaNameHistoryResponse {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientAMGetPersonaNameHistoryResponse;
}
impl crate::RpcMessage for CMsgClientDeregisterWithServer {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientDeregisterWithServer {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientDeregisterWithServer;
}
impl crate::RpcMessage for CMsgClientClanState {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessageWithKind for CMsgClientClanState {
    const KIND: crate::enums_clientserver::EMsg = crate::enums_clientserver::EMsg::k_EMsgClientClanState;
}
