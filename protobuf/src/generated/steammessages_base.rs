// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_base.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgIPAddress)
pub struct CMsgIPAddress {
    // message oneof groups
    pub ip: ::std::option::Option<cmsg_ipaddress::Ip>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgIPAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgIPAddress {
    fn default() -> &'a CMsgIPAddress {
        <CMsgIPAddress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgIPAddress {
    pub fn new() -> CMsgIPAddress {
        ::std::default::Default::default()
    }

    // optional fixed32 v4 = 1;

    pub fn v4(&self) -> u32 {
        match self.ip {
            ::std::option::Option::Some(cmsg_ipaddress::Ip::V4(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_v4(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_v4(&self) -> bool {
        match self.ip {
            ::std::option::Option::Some(cmsg_ipaddress::Ip::V4(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_v4(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(cmsg_ipaddress::Ip::V4(v))
    }

    // optional bytes v6 = 2;

    pub fn v6(&self) -> &[u8] {
        match self.ip {
            ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_v6(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_v6(&self) -> bool {
        match self.ip {
            ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_v6(&mut self, v: ::std::vec::Vec<u8>) {
        self.ip = ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(v))
    }

    // Mutable pointer to the field.
    pub fn mut_v6(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(_)) = self.ip {
        } else {
            self.ip = ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(::std::vec::Vec::new()));
        }
        match self.ip {
            ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_v6(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_v6() {
            match self.ip.take() {
                ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for CMsgIPAddress {
    const NAME: &'static str = "CMsgIPAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.ip = ::std::option::Option::Some(cmsg_ipaddress::Ip::V4(is.read_fixed32()?));
                },
                18 => {
                    self.ip = ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(is.read_bytes()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.ip {
            match v {
                &cmsg_ipaddress::Ip::V4(v) => {
                    my_size += 1 + 4;
                },
                &cmsg_ipaddress::Ip::V6(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.ip {
            match v {
                &cmsg_ipaddress::Ip::V4(v) => {
                    os.write_fixed32(1, v)?;
                },
                &cmsg_ipaddress::Ip::V6(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgIPAddress {
        CMsgIPAddress::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgIPAddress {
        static instance: CMsgIPAddress = CMsgIPAddress {
            ip: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgIPAddress`
pub mod cmsg_ipaddress {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgIPAddress.ip)
    pub enum Ip {
        // @@protoc_insertion_point(oneof_field:CMsgIPAddress.v4)
        V4(u32),
        // @@protoc_insertion_point(oneof_field:CMsgIPAddress.v6)
        V6(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for Ip {
    }

    impl Ip {
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgIPAddressBucket)
pub struct CMsgIPAddressBucket {
    // message fields
    // @@protoc_insertion_point(field:CMsgIPAddressBucket.original_ip_address)
    pub original_ip_address: ::protobuf::MessageField<CMsgIPAddress>,
    // @@protoc_insertion_point(field:CMsgIPAddressBucket.bucket)
    pub bucket: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgIPAddressBucket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgIPAddressBucket {
    fn default() -> &'a CMsgIPAddressBucket {
        <CMsgIPAddressBucket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgIPAddressBucket {
    pub fn new() -> CMsgIPAddressBucket {
        ::std::default::Default::default()
    }

    // optional fixed64 bucket = 2;

    pub fn bucket(&self) -> u64 {
        self.bucket.unwrap_or(0)
    }

    pub fn clear_bucket(&mut self) {
        self.bucket = ::std::option::Option::None;
    }

    pub fn has_bucket(&self) -> bool {
        self.bucket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: u64) {
        self.bucket = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgIPAddressBucket {
    const NAME: &'static str = "CMsgIPAddressBucket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.original_ip_address)?;
                },
                17 => {
                    self.bucket = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.original_ip_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bucket {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.original_ip_address.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bucket {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgIPAddressBucket {
        CMsgIPAddressBucket::new()
    }

    fn clear(&mut self) {
        self.original_ip_address.clear();
        self.bucket = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgIPAddressBucket {
        static instance: CMsgIPAddressBucket = CMsgIPAddressBucket {
            original_ip_address: ::protobuf::MessageField::none(),
            bucket: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCRoutingProtoBufHeader)
pub struct CMsgGCRoutingProtoBufHeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRoutingProtoBufHeader.dst_gcid_queue)
    pub dst_gcid_queue: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCRoutingProtoBufHeader.dst_gc_dir_index)
    pub dst_gc_dir_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRoutingProtoBufHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRoutingProtoBufHeader {
    fn default() -> &'a CMsgGCRoutingProtoBufHeader {
        <CMsgGCRoutingProtoBufHeader as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRoutingProtoBufHeader {
    pub fn new() -> CMsgGCRoutingProtoBufHeader {
        ::std::default::Default::default()
    }

    // optional uint64 dst_gcid_queue = 1;

    pub fn dst_gcid_queue(&self) -> u64 {
        self.dst_gcid_queue.unwrap_or(0)
    }

    pub fn clear_dst_gcid_queue(&mut self) {
        self.dst_gcid_queue = ::std::option::Option::None;
    }

    pub fn has_dst_gcid_queue(&self) -> bool {
        self.dst_gcid_queue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_gcid_queue(&mut self, v: u64) {
        self.dst_gcid_queue = ::std::option::Option::Some(v);
    }

    // optional uint32 dst_gc_dir_index = 2;

    pub fn dst_gc_dir_index(&self) -> u32 {
        self.dst_gc_dir_index.unwrap_or(0)
    }

    pub fn clear_dst_gc_dir_index(&mut self) {
        self.dst_gc_dir_index = ::std::option::Option::None;
    }

    pub fn has_dst_gc_dir_index(&self) -> bool {
        self.dst_gc_dir_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_gc_dir_index(&mut self, v: u32) {
        self.dst_gc_dir_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCRoutingProtoBufHeader {
    const NAME: &'static str = "CMsgGCRoutingProtoBufHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dst_gcid_queue = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.dst_gc_dir_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dst_gcid_queue {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.dst_gc_dir_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dst_gcid_queue {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.dst_gc_dir_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRoutingProtoBufHeader {
        CMsgGCRoutingProtoBufHeader::new()
    }

    fn clear(&mut self) {
        self.dst_gcid_queue = ::std::option::Option::None;
        self.dst_gc_dir_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRoutingProtoBufHeader {
        static instance: CMsgGCRoutingProtoBufHeader = CMsgGCRoutingProtoBufHeader {
            dst_gcid_queue: ::std::option::Option::None,
            dst_gc_dir_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgProtoBufHeader)
pub struct CMsgProtoBufHeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.client_sessionid)
    pub client_sessionid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.routing_appid)
    pub routing_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.jobid_source)
    pub jobid_source: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.jobid_target)
    pub jobid_target: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.target_job_name)
    pub target_job_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.seq_num)
    pub seq_num: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.error_message)
    pub error_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.auth_account_flags)
    pub auth_account_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.token_source)
    pub token_source: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.admin_spoofing_user)
    pub admin_spoofing_user: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.transport_error)
    pub transport_error: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.messageid)
    pub messageid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.publisher_group_id)
    pub publisher_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.sysid)
    pub sysid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.trace_tag)
    pub trace_tag: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.webapi_key_id)
    pub webapi_key_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.is_from_external_source)
    pub is_from_external_source: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.forward_to_sysid)
    pub forward_to_sysid: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.cm_sysid)
    pub cm_sysid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.launcher_type)
    pub launcher_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.realm)
    pub realm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.timeout_ms)
    pub timeout_ms: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.debug_source)
    pub debug_source: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.debug_source_string_index)
    pub debug_source_string_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.token_id)
    pub token_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.routing_gc)
    pub routing_gc: ::protobuf::MessageField<CMsgGCRoutingProtoBufHeader>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.session_disposition)
    pub session_disposition: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_proto_buf_header::ESessionDisposition>>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.wg_token)
    pub wg_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.webui_auth_key)
    pub webui_auth_key: ::std::option::Option<::std::string::String>,
    // message oneof groups
    pub ip_addr: ::std::option::Option<cmsg_proto_buf_header::Ip_addr>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProtoBufHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProtoBufHeader {
    fn default() -> &'a CMsgProtoBufHeader {
        <CMsgProtoBufHeader as ::protobuf::Message>::default_instance()
    }
}

impl CMsgProtoBufHeader {
    pub fn new() -> CMsgProtoBufHeader {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 client_sessionid = 2;

    pub fn client_sessionid(&self) -> i32 {
        self.client_sessionid.unwrap_or(0)
    }

    pub fn clear_client_sessionid(&mut self) {
        self.client_sessionid = ::std::option::Option::None;
    }

    pub fn has_client_sessionid(&self) -> bool {
        self.client_sessionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_sessionid(&mut self, v: i32) {
        self.client_sessionid = ::std::option::Option::Some(v);
    }

    // optional uint32 routing_appid = 3;

    pub fn routing_appid(&self) -> u32 {
        self.routing_appid.unwrap_or(0)
    }

    pub fn clear_routing_appid(&mut self) {
        self.routing_appid = ::std::option::Option::None;
    }

    pub fn has_routing_appid(&self) -> bool {
        self.routing_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routing_appid(&mut self, v: u32) {
        self.routing_appid = ::std::option::Option::Some(v);
    }

    // optional fixed64 jobid_source = 10;

    pub fn jobid_source(&self) -> u64 {
        self.jobid_source.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_jobid_source(&mut self) {
        self.jobid_source = ::std::option::Option::None;
    }

    pub fn has_jobid_source(&self) -> bool {
        self.jobid_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jobid_source(&mut self, v: u64) {
        self.jobid_source = ::std::option::Option::Some(v);
    }

    // optional fixed64 jobid_target = 11;

    pub fn jobid_target(&self) -> u64 {
        self.jobid_target.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_jobid_target(&mut self) {
        self.jobid_target = ::std::option::Option::None;
    }

    pub fn has_jobid_target(&self) -> bool {
        self.jobid_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jobid_target(&mut self, v: u64) {
        self.jobid_target = ::std::option::Option::Some(v);
    }

    // optional string target_job_name = 12;

    pub fn target_job_name(&self) -> &str {
        match self.target_job_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_target_job_name(&mut self) {
        self.target_job_name = ::std::option::Option::None;
    }

    pub fn has_target_job_name(&self) -> bool {
        self.target_job_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_job_name(&mut self, v: ::std::string::String) {
        self.target_job_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_job_name(&mut self) -> &mut ::std::string::String {
        if self.target_job_name.is_none() {
            self.target_job_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.target_job_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_target_job_name(&mut self) -> ::std::string::String {
        self.target_job_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 seq_num = 24;

    pub fn seq_num(&self) -> i32 {
        self.seq_num.unwrap_or(0)
    }

    pub fn clear_seq_num(&mut self) {
        self.seq_num = ::std::option::Option::None;
    }

    pub fn has_seq_num(&self) -> bool {
        self.seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num(&mut self, v: i32) {
        self.seq_num = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 13;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string error_message = 14;

    pub fn error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_message(&mut self) {
        self.error_message = ::std::option::Option::None;
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 auth_account_flags = 16;

    pub fn auth_account_flags(&self) -> u32 {
        self.auth_account_flags.unwrap_or(0)
    }

    pub fn clear_auth_account_flags(&mut self) {
        self.auth_account_flags = ::std::option::Option::None;
    }

    pub fn has_auth_account_flags(&self) -> bool {
        self.auth_account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_account_flags(&mut self, v: u32) {
        self.auth_account_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 token_source = 22;

    pub fn token_source(&self) -> u32 {
        self.token_source.unwrap_or(0)
    }

    pub fn clear_token_source(&mut self) {
        self.token_source = ::std::option::Option::None;
    }

    pub fn has_token_source(&self) -> bool {
        self.token_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token_source(&mut self, v: u32) {
        self.token_source = ::std::option::Option::Some(v);
    }

    // optional bool admin_spoofing_user = 23;

    pub fn admin_spoofing_user(&self) -> bool {
        self.admin_spoofing_user.unwrap_or(false)
    }

    pub fn clear_admin_spoofing_user(&mut self) {
        self.admin_spoofing_user = ::std::option::Option::None;
    }

    pub fn has_admin_spoofing_user(&self) -> bool {
        self.admin_spoofing_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_admin_spoofing_user(&mut self, v: bool) {
        self.admin_spoofing_user = ::std::option::Option::Some(v);
    }

    // optional int32 transport_error = 17;

    pub fn transport_error(&self) -> i32 {
        self.transport_error.unwrap_or(1i32)
    }

    pub fn clear_transport_error(&mut self) {
        self.transport_error = ::std::option::Option::None;
    }

    pub fn has_transport_error(&self) -> bool {
        self.transport_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport_error(&mut self, v: i32) {
        self.transport_error = ::std::option::Option::Some(v);
    }

    // optional uint64 messageid = 18;

    pub fn messageid(&self) -> u64 {
        self.messageid.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_messageid(&mut self) {
        self.messageid = ::std::option::Option::None;
    }

    pub fn has_messageid(&self) -> bool {
        self.messageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageid(&mut self, v: u64) {
        self.messageid = ::std::option::Option::Some(v);
    }

    // optional uint32 publisher_group_id = 19;

    pub fn publisher_group_id(&self) -> u32 {
        self.publisher_group_id.unwrap_or(0)
    }

    pub fn clear_publisher_group_id(&mut self) {
        self.publisher_group_id = ::std::option::Option::None;
    }

    pub fn has_publisher_group_id(&self) -> bool {
        self.publisher_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publisher_group_id(&mut self, v: u32) {
        self.publisher_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 sysid = 20;

    pub fn sysid(&self) -> u32 {
        self.sysid.unwrap_or(0)
    }

    pub fn clear_sysid(&mut self) {
        self.sysid = ::std::option::Option::None;
    }

    pub fn has_sysid(&self) -> bool {
        self.sysid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid(&mut self, v: u32) {
        self.sysid = ::std::option::Option::Some(v);
    }

    // optional uint64 trace_tag = 21;

    pub fn trace_tag(&self) -> u64 {
        self.trace_tag.unwrap_or(0)
    }

    pub fn clear_trace_tag(&mut self) {
        self.trace_tag = ::std::option::Option::None;
    }

    pub fn has_trace_tag(&self) -> bool {
        self.trace_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace_tag(&mut self, v: u64) {
        self.trace_tag = ::std::option::Option::Some(v);
    }

    // optional uint32 webapi_key_id = 25;

    pub fn webapi_key_id(&self) -> u32 {
        self.webapi_key_id.unwrap_or(0)
    }

    pub fn clear_webapi_key_id(&mut self) {
        self.webapi_key_id = ::std::option::Option::None;
    }

    pub fn has_webapi_key_id(&self) -> bool {
        self.webapi_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webapi_key_id(&mut self, v: u32) {
        self.webapi_key_id = ::std::option::Option::Some(v);
    }

    // optional bool is_from_external_source = 26;

    pub fn is_from_external_source(&self) -> bool {
        self.is_from_external_source.unwrap_or(false)
    }

    pub fn clear_is_from_external_source(&mut self) {
        self.is_from_external_source = ::std::option::Option::None;
    }

    pub fn has_is_from_external_source(&self) -> bool {
        self.is_from_external_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_from_external_source(&mut self, v: bool) {
        self.is_from_external_source = ::std::option::Option::Some(v);
    }

    // optional uint32 cm_sysid = 28;

    pub fn cm_sysid(&self) -> u32 {
        self.cm_sysid.unwrap_or(0)
    }

    pub fn clear_cm_sysid(&mut self) {
        self.cm_sysid = ::std::option::Option::None;
    }

    pub fn has_cm_sysid(&self) -> bool {
        self.cm_sysid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cm_sysid(&mut self, v: u32) {
        self.cm_sysid = ::std::option::Option::Some(v);
    }

    // optional uint32 launcher_type = 31;

    pub fn launcher_type(&self) -> u32 {
        self.launcher_type.unwrap_or(0u32)
    }

    pub fn clear_launcher_type(&mut self) {
        self.launcher_type = ::std::option::Option::None;
    }

    pub fn has_launcher_type(&self) -> bool {
        self.launcher_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launcher_type(&mut self, v: u32) {
        self.launcher_type = ::std::option::Option::Some(v);
    }

    // optional uint32 realm = 32;

    pub fn realm(&self) -> u32 {
        self.realm.unwrap_or(0u32)
    }

    pub fn clear_realm(&mut self) {
        self.realm = ::std::option::Option::None;
    }

    pub fn has_realm(&self) -> bool {
        self.realm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realm(&mut self, v: u32) {
        self.realm = ::std::option::Option::Some(v);
    }

    // optional int32 timeout_ms = 33;

    pub fn timeout_ms(&self) -> i32 {
        self.timeout_ms.unwrap_or(-1i32)
    }

    pub fn clear_timeout_ms(&mut self) {
        self.timeout_ms = ::std::option::Option::None;
    }

    pub fn has_timeout_ms(&self) -> bool {
        self.timeout_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout_ms(&mut self, v: i32) {
        self.timeout_ms = ::std::option::Option::Some(v);
    }

    // optional string debug_source = 34;

    pub fn debug_source(&self) -> &str {
        match self.debug_source.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_debug_source(&mut self) {
        self.debug_source = ::std::option::Option::None;
    }

    pub fn has_debug_source(&self) -> bool {
        self.debug_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_source(&mut self, v: ::std::string::String) {
        self.debug_source = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_source(&mut self) -> &mut ::std::string::String {
        if self.debug_source.is_none() {
            self.debug_source = ::std::option::Option::Some(::std::string::String::new());
        }
        self.debug_source.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_source(&mut self) -> ::std::string::String {
        self.debug_source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 debug_source_string_index = 35;

    pub fn debug_source_string_index(&self) -> u32 {
        self.debug_source_string_index.unwrap_or(0)
    }

    pub fn clear_debug_source_string_index(&mut self) {
        self.debug_source_string_index = ::std::option::Option::None;
    }

    pub fn has_debug_source_string_index(&self) -> bool {
        self.debug_source_string_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_source_string_index(&mut self, v: u32) {
        self.debug_source_string_index = ::std::option::Option::Some(v);
    }

    // optional uint64 token_id = 36;

    pub fn token_id(&self) -> u64 {
        self.token_id.unwrap_or(0)
    }

    pub fn clear_token_id(&mut self) {
        self.token_id = ::std::option::Option::None;
    }

    pub fn has_token_id(&self) -> bool {
        self.token_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: u64) {
        self.token_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgProtoBufHeader.ESessionDisposition session_disposition = 38;

    pub fn session_disposition(&self) -> cmsg_proto_buf_header::ESessionDisposition {
        match self.session_disposition {
            Some(e) => e.enum_value_or(cmsg_proto_buf_header::ESessionDisposition::k_ESessionDispositionNormal),
            None => cmsg_proto_buf_header::ESessionDisposition::k_ESessionDispositionNormal,
        }
    }

    pub fn clear_session_disposition(&mut self) {
        self.session_disposition = ::std::option::Option::None;
    }

    pub fn has_session_disposition(&self) -> bool {
        self.session_disposition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_disposition(&mut self, v: cmsg_proto_buf_header::ESessionDisposition) {
        self.session_disposition = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string wg_token = 39;

    pub fn wg_token(&self) -> &str {
        match self.wg_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_wg_token(&mut self) {
        self.wg_token = ::std::option::Option::None;
    }

    pub fn has_wg_token(&self) -> bool {
        self.wg_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wg_token(&mut self, v: ::std::string::String) {
        self.wg_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wg_token(&mut self) -> &mut ::std::string::String {
        if self.wg_token.is_none() {
            self.wg_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.wg_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_wg_token(&mut self) -> ::std::string::String {
        self.wg_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string webui_auth_key = 40;

    pub fn webui_auth_key(&self) -> &str {
        match self.webui_auth_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_webui_auth_key(&mut self) {
        self.webui_auth_key = ::std::option::Option::None;
    }

    pub fn has_webui_auth_key(&self) -> bool {
        self.webui_auth_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webui_auth_key(&mut self, v: ::std::string::String) {
        self.webui_auth_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webui_auth_key(&mut self) -> &mut ::std::string::String {
        if self.webui_auth_key.is_none() {
            self.webui_auth_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.webui_auth_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_webui_auth_key(&mut self) -> ::std::string::String {
        self.webui_auth_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ip = 15;

    pub fn ip(&self) -> u32 {
        match self.ip_addr {
            ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::Ip(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_ip(&mut self) {
        self.ip_addr = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        match self.ip_addr {
            ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::Ip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip_addr = ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::Ip(v))
    }

    // optional bytes ip_v6 = 29;

    pub fn ip_v6(&self) -> &[u8] {
        match self.ip_addr {
            ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_ip_v6(&mut self) {
        self.ip_addr = ::std::option::Option::None;
    }

    pub fn has_ip_v6(&self) -> bool {
        match self.ip_addr {
            ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ip_v6(&mut self, v: ::std::vec::Vec<u8>) {
        self.ip_addr = ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ip_v6(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(_)) = self.ip_addr {
        } else {
            self.ip_addr = ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(::std::vec::Vec::new()));
        }
        match self.ip_addr {
            ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ip_v6(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_ip_v6() {
            match self.ip_addr.take() {
                ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for CMsgProtoBufHeader {
    const NAME: &'static str = "CMsgProtoBufHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.client_sessionid = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.routing_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                81 => {
                    self.jobid_source = ::std::option::Option::Some(is.read_fixed64()?);
                },
                89 => {
                    self.jobid_target = ::std::option::Option::Some(is.read_fixed64()?);
                },
                98 => {
                    self.target_job_name = ::std::option::Option::Some(is.read_string()?);
                },
                192 => {
                    self.seq_num = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                114 => {
                    self.error_message = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.auth_account_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.token_source = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.admin_spoofing_user = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.transport_error = ::std::option::Option::Some(is.read_int32()?);
                },
                144 => {
                    self.messageid = ::std::option::Option::Some(is.read_uint64()?);
                },
                152 => {
                    self.publisher_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.sysid = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.trace_tag = ::std::option::Option::Some(is.read_uint64()?);
                },
                200 => {
                    self.webapi_key_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.is_from_external_source = ::std::option::Option::Some(is.read_bool()?);
                },
                218 => {
                    is.read_repeated_packed_uint32_into(&mut self.forward_to_sysid)?;
                },
                216 => {
                    self.forward_to_sysid.push(is.read_uint32()?);
                },
                224 => {
                    self.cm_sysid = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.launcher_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                256 => {
                    self.realm = ::std::option::Option::Some(is.read_uint32()?);
                },
                264 => {
                    self.timeout_ms = ::std::option::Option::Some(is.read_int32()?);
                },
                274 => {
                    self.debug_source = ::std::option::Option::Some(is.read_string()?);
                },
                280 => {
                    self.debug_source_string_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                288 => {
                    self.token_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                298 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.routing_gc)?;
                },
                304 => {
                    self.session_disposition = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                314 => {
                    self.wg_token = ::std::option::Option::Some(is.read_string()?);
                },
                322 => {
                    self.webui_auth_key = ::std::option::Option::Some(is.read_string()?);
                },
                120 => {
                    self.ip_addr = ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::Ip(is.read_uint32()?));
                },
                234 => {
                    self.ip_addr = ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(is.read_bytes()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_sessionid {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.routing_appid {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.jobid_source {
            my_size += 1 + 8;
        }
        if let Some(v) = self.jobid_target {
            my_size += 1 + 8;
        }
        if let Some(v) = self.target_job_name.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.seq_num {
            my_size += ::protobuf::rt::int32_size(24, v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.error_message.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.auth_account_flags {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.token_source {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.admin_spoofing_user {
            my_size += 2 + 1;
        }
        if let Some(v) = self.transport_error {
            my_size += ::protobuf::rt::int32_size(17, v);
        }
        if let Some(v) = self.messageid {
            my_size += ::protobuf::rt::uint64_size(18, v);
        }
        if let Some(v) = self.publisher_group_id {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.sysid {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.trace_tag {
            my_size += ::protobuf::rt::uint64_size(21, v);
        }
        if let Some(v) = self.webapi_key_id {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.is_from_external_source {
            my_size += 2 + 1;
        }
        for value in &self.forward_to_sysid {
            my_size += ::protobuf::rt::uint32_size(27, *value);
        };
        if let Some(v) = self.cm_sysid {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.launcher_type {
            my_size += ::protobuf::rt::uint32_size(31, v);
        }
        if let Some(v) = self.realm {
            my_size += ::protobuf::rt::uint32_size(32, v);
        }
        if let Some(v) = self.timeout_ms {
            my_size += ::protobuf::rt::int32_size(33, v);
        }
        if let Some(v) = self.debug_source.as_ref() {
            my_size += ::protobuf::rt::string_size(34, &v);
        }
        if let Some(v) = self.debug_source_string_index {
            my_size += ::protobuf::rt::uint32_size(35, v);
        }
        if let Some(v) = self.token_id {
            my_size += ::protobuf::rt::uint64_size(36, v);
        }
        if let Some(v) = self.routing_gc.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.session_disposition {
            my_size += ::protobuf::rt::int32_size(38, v.value());
        }
        if let Some(v) = self.wg_token.as_ref() {
            my_size += ::protobuf::rt::string_size(39, &v);
        }
        if let Some(v) = self.webui_auth_key.as_ref() {
            my_size += ::protobuf::rt::string_size(40, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.ip_addr {
            match v {
                &cmsg_proto_buf_header::Ip_addr::Ip(v) => {
                    my_size += ::protobuf::rt::uint32_size(15, v);
                },
                &cmsg_proto_buf_header::Ip_addr::IpV6(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(29, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.client_sessionid {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.routing_appid {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.jobid_source {
            os.write_fixed64(10, v)?;
        }
        if let Some(v) = self.jobid_target {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.target_job_name.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.seq_num {
            os.write_int32(24, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.error_message.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.auth_account_flags {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.token_source {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.admin_spoofing_user {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.transport_error {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.messageid {
            os.write_uint64(18, v)?;
        }
        if let Some(v) = self.publisher_group_id {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.sysid {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.trace_tag {
            os.write_uint64(21, v)?;
        }
        if let Some(v) = self.webapi_key_id {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.is_from_external_source {
            os.write_bool(26, v)?;
        }
        for v in &self.forward_to_sysid {
            os.write_uint32(27, *v)?;
        };
        if let Some(v) = self.cm_sysid {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.launcher_type {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.realm {
            os.write_uint32(32, v)?;
        }
        if let Some(v) = self.timeout_ms {
            os.write_int32(33, v)?;
        }
        if let Some(v) = self.debug_source.as_ref() {
            os.write_string(34, v)?;
        }
        if let Some(v) = self.debug_source_string_index {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.token_id {
            os.write_uint64(36, v)?;
        }
        if let Some(v) = self.routing_gc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        if let Some(v) = self.session_disposition {
            os.write_enum(38, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.wg_token.as_ref() {
            os.write_string(39, v)?;
        }
        if let Some(v) = self.webui_auth_key.as_ref() {
            os.write_string(40, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.ip_addr {
            match v {
                &cmsg_proto_buf_header::Ip_addr::Ip(v) => {
                    os.write_uint32(15, v)?;
                },
                &cmsg_proto_buf_header::Ip_addr::IpV6(ref v) => {
                    os.write_bytes(29, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProtoBufHeader {
        CMsgProtoBufHeader::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.client_sessionid = ::std::option::Option::None;
        self.routing_appid = ::std::option::Option::None;
        self.jobid_source = ::std::option::Option::None;
        self.jobid_target = ::std::option::Option::None;
        self.target_job_name = ::std::option::Option::None;
        self.seq_num = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.error_message = ::std::option::Option::None;
        self.auth_account_flags = ::std::option::Option::None;
        self.token_source = ::std::option::Option::None;
        self.admin_spoofing_user = ::std::option::Option::None;
        self.transport_error = ::std::option::Option::None;
        self.messageid = ::std::option::Option::None;
        self.publisher_group_id = ::std::option::Option::None;
        self.sysid = ::std::option::Option::None;
        self.trace_tag = ::std::option::Option::None;
        self.webapi_key_id = ::std::option::Option::None;
        self.is_from_external_source = ::std::option::Option::None;
        self.forward_to_sysid.clear();
        self.cm_sysid = ::std::option::Option::None;
        self.launcher_type = ::std::option::Option::None;
        self.realm = ::std::option::Option::None;
        self.timeout_ms = ::std::option::Option::None;
        self.debug_source = ::std::option::Option::None;
        self.debug_source_string_index = ::std::option::Option::None;
        self.token_id = ::std::option::Option::None;
        self.routing_gc.clear();
        self.session_disposition = ::std::option::Option::None;
        self.wg_token = ::std::option::Option::None;
        self.webui_auth_key = ::std::option::Option::None;
        self.ip_addr = ::std::option::Option::None;
        self.ip_addr = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProtoBufHeader {
        static instance: CMsgProtoBufHeader = CMsgProtoBufHeader {
            steamid: ::std::option::Option::None,
            client_sessionid: ::std::option::Option::None,
            routing_appid: ::std::option::Option::None,
            jobid_source: ::std::option::Option::None,
            jobid_target: ::std::option::Option::None,
            target_job_name: ::std::option::Option::None,
            seq_num: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            error_message: ::std::option::Option::None,
            auth_account_flags: ::std::option::Option::None,
            token_source: ::std::option::Option::None,
            admin_spoofing_user: ::std::option::Option::None,
            transport_error: ::std::option::Option::None,
            messageid: ::std::option::Option::None,
            publisher_group_id: ::std::option::Option::None,
            sysid: ::std::option::Option::None,
            trace_tag: ::std::option::Option::None,
            webapi_key_id: ::std::option::Option::None,
            is_from_external_source: ::std::option::Option::None,
            forward_to_sysid: ::std::vec::Vec::new(),
            cm_sysid: ::std::option::Option::None,
            launcher_type: ::std::option::Option::None,
            realm: ::std::option::Option::None,
            timeout_ms: ::std::option::Option::None,
            debug_source: ::std::option::Option::None,
            debug_source_string_index: ::std::option::Option::None,
            token_id: ::std::option::Option::None,
            routing_gc: ::protobuf::MessageField::none(),
            session_disposition: ::std::option::Option::None,
            wg_token: ::std::option::Option::None,
            webui_auth_key: ::std::option::Option::None,
            ip_addr: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgProtoBufHeader`
pub mod cmsg_proto_buf_header {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgProtoBufHeader.ip_addr)
    pub enum Ip_addr {
        // @@protoc_insertion_point(oneof_field:CMsgProtoBufHeader.ip)
        Ip(u32),
        // @@protoc_insertion_point(oneof_field:CMsgProtoBufHeader.ip_v6)
        IpV6(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for Ip_addr {
    }

    impl Ip_addr {
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgProtoBufHeader.ESessionDisposition)
    pub enum ESessionDisposition {
        // @@protoc_insertion_point(enum_value:CMsgProtoBufHeader.ESessionDisposition.k_ESessionDispositionNormal)
        k_ESessionDispositionNormal = 0,
        // @@protoc_insertion_point(enum_value:CMsgProtoBufHeader.ESessionDisposition.k_ESessionDispositionDisconnect)
        k_ESessionDispositionDisconnect = 1,
    }

    impl ::protobuf::Enum for ESessionDisposition {
        const NAME: &'static str = "ESessionDisposition";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ESessionDisposition> {
            match value {
                0 => ::std::option::Option::Some(ESessionDisposition::k_ESessionDispositionNormal),
                1 => ::std::option::Option::Some(ESessionDisposition::k_ESessionDispositionDisconnect),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ESessionDisposition] = &[
            ESessionDisposition::k_ESessionDispositionNormal,
            ESessionDisposition::k_ESessionDispositionDisconnect,
        ];
    }

    impl ::std::default::Default for ESessionDisposition {
        fn default() -> Self {
            ESessionDisposition::k_ESessionDispositionNormal
        }
    }

}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgMulti)
pub struct CMsgMulti {
    // message fields
    // @@protoc_insertion_point(field:CMsgMulti.size_unzipped)
    pub size_unzipped: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMulti.message_body)
    pub message_body: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMulti.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMulti {
    fn default() -> &'a CMsgMulti {
        <CMsgMulti as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMulti {
    pub fn new() -> CMsgMulti {
        ::std::default::Default::default()
    }

    // optional uint32 size_unzipped = 1;

    pub fn size_unzipped(&self) -> u32 {
        self.size_unzipped.unwrap_or(0)
    }

    pub fn clear_size_unzipped(&mut self) {
        self.size_unzipped = ::std::option::Option::None;
    }

    pub fn has_size_unzipped(&self) -> bool {
        self.size_unzipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_unzipped(&mut self, v: u32) {
        self.size_unzipped = ::std::option::Option::Some(v);
    }

    // optional bytes message_body = 2;

    pub fn message_body(&self) -> &[u8] {
        match self.message_body.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message_body(&mut self) {
        self.message_body = ::std::option::Option::None;
    }

    pub fn has_message_body(&self) -> bool {
        self.message_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.message_body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message_body.is_none() {
            self.message_body = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.message_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_body(&mut self) -> ::std::vec::Vec<u8> {
        self.message_body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgMulti {
    const NAME: &'static str = "CMsgMulti";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.size_unzipped = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message_body = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.size_unzipped {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message_body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.size_unzipped {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message_body.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMulti {
        CMsgMulti::new()
    }

    fn clear(&mut self) {
        self.size_unzipped = ::std::option::Option::None;
        self.message_body = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMulti {
        static instance: CMsgMulti = CMsgMulti {
            size_unzipped: ::std::option::Option::None,
            message_body: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgProtobufWrapped)
pub struct CMsgProtobufWrapped {
    // message fields
    // @@protoc_insertion_point(field:CMsgProtobufWrapped.message_body)
    pub message_body: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProtobufWrapped.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProtobufWrapped {
    fn default() -> &'a CMsgProtobufWrapped {
        <CMsgProtobufWrapped as ::protobuf::Message>::default_instance()
    }
}

impl CMsgProtobufWrapped {
    pub fn new() -> CMsgProtobufWrapped {
        ::std::default::Default::default()
    }

    // optional bytes message_body = 1;

    pub fn message_body(&self) -> &[u8] {
        match self.message_body.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message_body(&mut self) {
        self.message_body = ::std::option::Option::None;
    }

    pub fn has_message_body(&self) -> bool {
        self.message_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.message_body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message_body.is_none() {
            self.message_body = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.message_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_body(&mut self) -> ::std::vec::Vec<u8> {
        self.message_body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgProtobufWrapped {
    const NAME: &'static str = "CMsgProtobufWrapped";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message_body = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message_body.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProtobufWrapped {
        CMsgProtobufWrapped::new()
    }

    fn clear(&mut self) {
        self.message_body = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProtobufWrapped {
        static instance: CMsgProtobufWrapped = CMsgProtobufWrapped {
            message_body: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgAuthTicket)
pub struct CMsgAuthTicket {
    // message fields
    // @@protoc_insertion_point(field:CMsgAuthTicket.estate)
    pub estate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.h_steam_pipe)
    pub h_steam_pipe: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.ticket_crc)
    pub ticket_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.ticket)
    pub ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.server_secret)
    pub server_secret: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.ticket_type)
    pub ticket_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAuthTicket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAuthTicket {
    fn default() -> &'a CMsgAuthTicket {
        <CMsgAuthTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAuthTicket {
    pub fn new() -> CMsgAuthTicket {
        ::std::default::Default::default()
    }

    // optional uint32 estate = 1;

    pub fn estate(&self) -> u32 {
        self.estate.unwrap_or(0)
    }

    pub fn clear_estate(&mut self) {
        self.estate = ::std::option::Option::None;
    }

    pub fn has_estate(&self) -> bool {
        self.estate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estate(&mut self, v: u32) {
        self.estate = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 3;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 gameid = 4;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional uint32 h_steam_pipe = 5;

    pub fn h_steam_pipe(&self) -> u32 {
        self.h_steam_pipe.unwrap_or(0)
    }

    pub fn clear_h_steam_pipe(&mut self) {
        self.h_steam_pipe = ::std::option::Option::None;
    }

    pub fn has_h_steam_pipe(&self) -> bool {
        self.h_steam_pipe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_h_steam_pipe(&mut self, v: u32) {
        self.h_steam_pipe = ::std::option::Option::Some(v);
    }

    // optional uint32 ticket_crc = 6;

    pub fn ticket_crc(&self) -> u32 {
        self.ticket_crc.unwrap_or(0)
    }

    pub fn clear_ticket_crc(&mut self) {
        self.ticket_crc = ::std::option::Option::None;
    }

    pub fn has_ticket_crc(&self) -> bool {
        self.ticket_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_crc(&mut self, v: u32) {
        self.ticket_crc = ::std::option::Option::Some(v);
    }

    // optional bytes ticket = 7;

    pub fn ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes server_secret = 8;

    pub fn server_secret(&self) -> &[u8] {
        match self.server_secret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_server_secret(&mut self) {
        self.server_secret = ::std::option::Option::None;
    }

    pub fn has_server_secret(&self) -> bool {
        self.server_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_secret(&mut self, v: ::std::vec::Vec<u8>) {
        self.server_secret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_secret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.server_secret.is_none() {
            self.server_secret = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.server_secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_secret(&mut self) -> ::std::vec::Vec<u8> {
        self.server_secret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ticket_type = 9;

    pub fn ticket_type(&self) -> u32 {
        self.ticket_type.unwrap_or(0)
    }

    pub fn clear_ticket_type(&mut self) {
        self.ticket_type = ::std::option::Option::None;
    }

    pub fn has_ticket_type(&self) -> bool {
        self.ticket_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_type(&mut self, v: u32) {
        self.ticket_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAuthTicket {
    const NAME: &'static str = "CMsgAuthTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.estate = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                25 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                33 => {
                    self.gameid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.h_steam_pipe = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.ticket_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.server_secret = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.ticket_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.estate {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gameid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.h_steam_pipe {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.ticket_crc {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.server_secret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.ticket_type {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.estate {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.h_steam_pipe {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.ticket_crc {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ticket.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.server_secret.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.ticket_type {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAuthTicket {
        CMsgAuthTicket::new()
    }

    fn clear(&mut self) {
        self.estate = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.h_steam_pipe = ::std::option::Option::None;
        self.ticket_crc = ::std::option::Option::None;
        self.ticket = ::std::option::Option::None;
        self.server_secret = ::std::option::Option::None;
        self.ticket_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAuthTicket {
        static instance: CMsgAuthTicket = CMsgAuthTicket {
            estate: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            gameid: ::std::option::Option::None,
            h_steam_pipe: ::std::option::Option::None,
            ticket_crc: ::std::option::Option::None,
            ticket: ::std::option::Option::None,
            server_secret: ::std::option::Option::None,
            ticket_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CCDDBAppDetailCommon)
pub struct CCDDBAppDetailCommon {
    // message fields
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.icon)
    pub icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.tool)
    pub tool: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.demo)
    pub demo: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.media)
    pub media: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.community_visible_stats)
    pub community_visible_stats: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.friendly_name)
    pub friendly_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.propagation)
    pub propagation: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.has_adult_content)
    pub has_adult_content: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.is_visible_in_steam_china)
    pub is_visible_in_steam_china: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.app_type)
    pub app_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.has_adult_content_sex)
    pub has_adult_content_sex: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.has_adult_content_violence)
    pub has_adult_content_violence: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.content_descriptorids)
    pub content_descriptorids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCDDBAppDetailCommon.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCDDBAppDetailCommon {
    fn default() -> &'a CCDDBAppDetailCommon {
        <CCDDBAppDetailCommon as ::protobuf::Message>::default_instance()
    }
}

impl CCDDBAppDetailCommon {
    pub fn new() -> CCDDBAppDetailCommon {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon = 3;

    pub fn icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool tool = 6;

    pub fn tool(&self) -> bool {
        self.tool.unwrap_or(false)
    }

    pub fn clear_tool(&mut self) {
        self.tool = ::std::option::Option::None;
    }

    pub fn has_tool(&self) -> bool {
        self.tool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool(&mut self, v: bool) {
        self.tool = ::std::option::Option::Some(v);
    }

    // optional bool demo = 7;

    pub fn demo(&self) -> bool {
        self.demo.unwrap_or(false)
    }

    pub fn clear_demo(&mut self) {
        self.demo = ::std::option::Option::None;
    }

    pub fn has_demo(&self) -> bool {
        self.demo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_demo(&mut self, v: bool) {
        self.demo = ::std::option::Option::Some(v);
    }

    // optional bool media = 8;

    pub fn media(&self) -> bool {
        self.media.unwrap_or(false)
    }

    pub fn clear_media(&mut self) {
        self.media = ::std::option::Option::None;
    }

    pub fn has_media(&self) -> bool {
        self.media.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media(&mut self, v: bool) {
        self.media = ::std::option::Option::Some(v);
    }

    // optional bool community_visible_stats = 9;

    pub fn community_visible_stats(&self) -> bool {
        self.community_visible_stats.unwrap_or(false)
    }

    pub fn clear_community_visible_stats(&mut self) {
        self.community_visible_stats = ::std::option::Option::None;
    }

    pub fn has_community_visible_stats(&self) -> bool {
        self.community_visible_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_community_visible_stats(&mut self, v: bool) {
        self.community_visible_stats = ::std::option::Option::Some(v);
    }

    // optional string friendly_name = 10;

    pub fn friendly_name(&self) -> &str {
        match self.friendly_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_friendly_name(&mut self) {
        self.friendly_name = ::std::option::Option::None;
    }

    pub fn has_friendly_name(&self) -> bool {
        self.friendly_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendly_name(&mut self, v: ::std::string::String) {
        self.friendly_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_friendly_name(&mut self) -> &mut ::std::string::String {
        if self.friendly_name.is_none() {
            self.friendly_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.friendly_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_friendly_name(&mut self) -> ::std::string::String {
        self.friendly_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string propagation = 11;

    pub fn propagation(&self) -> &str {
        match self.propagation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_propagation(&mut self) {
        self.propagation = ::std::option::Option::None;
    }

    pub fn has_propagation(&self) -> bool {
        self.propagation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_propagation(&mut self, v: ::std::string::String) {
        self.propagation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_propagation(&mut self) -> &mut ::std::string::String {
        if self.propagation.is_none() {
            self.propagation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.propagation.as_mut().unwrap()
    }

    // Take field
    pub fn take_propagation(&mut self) -> ::std::string::String {
        self.propagation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool has_adult_content = 12;

    pub fn has_adult_content(&self) -> bool {
        self.has_adult_content.unwrap_or(false)
    }

    pub fn clear_has_adult_content(&mut self) {
        self.has_adult_content = ::std::option::Option::None;
    }

    pub fn has_has_adult_content(&self) -> bool {
        self.has_adult_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_adult_content(&mut self, v: bool) {
        self.has_adult_content = ::std::option::Option::Some(v);
    }

    // optional bool is_visible_in_steam_china = 13;

    pub fn is_visible_in_steam_china(&self) -> bool {
        self.is_visible_in_steam_china.unwrap_or(false)
    }

    pub fn clear_is_visible_in_steam_china(&mut self) {
        self.is_visible_in_steam_china = ::std::option::Option::None;
    }

    pub fn has_is_visible_in_steam_china(&self) -> bool {
        self.is_visible_in_steam_china.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_visible_in_steam_china(&mut self, v: bool) {
        self.is_visible_in_steam_china = ::std::option::Option::Some(v);
    }

    // optional uint32 app_type = 14;

    pub fn app_type(&self) -> u32 {
        self.app_type.unwrap_or(0)
    }

    pub fn clear_app_type(&mut self) {
        self.app_type = ::std::option::Option::None;
    }

    pub fn has_app_type(&self) -> bool {
        self.app_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_type(&mut self, v: u32) {
        self.app_type = ::std::option::Option::Some(v);
    }

    // optional bool has_adult_content_sex = 15;

    pub fn has_adult_content_sex(&self) -> bool {
        self.has_adult_content_sex.unwrap_or(false)
    }

    pub fn clear_has_adult_content_sex(&mut self) {
        self.has_adult_content_sex = ::std::option::Option::None;
    }

    pub fn has_has_adult_content_sex(&self) -> bool {
        self.has_adult_content_sex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_adult_content_sex(&mut self, v: bool) {
        self.has_adult_content_sex = ::std::option::Option::Some(v);
    }

    // optional bool has_adult_content_violence = 16;

    pub fn has_adult_content_violence(&self) -> bool {
        self.has_adult_content_violence.unwrap_or(false)
    }

    pub fn clear_has_adult_content_violence(&mut self) {
        self.has_adult_content_violence = ::std::option::Option::None;
    }

    pub fn has_has_adult_content_violence(&self) -> bool {
        self.has_adult_content_violence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_adult_content_violence(&mut self, v: bool) {
        self.has_adult_content_violence = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCDDBAppDetailCommon {
    const NAME: &'static str = "CCDDBAppDetailCommon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.icon = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.tool = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.demo = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.media = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.community_visible_stats = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.friendly_name = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.propagation = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.has_adult_content = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.is_visible_in_steam_china = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.app_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.has_adult_content_sex = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.has_adult_content_violence = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    is.read_repeated_packed_uint32_into(&mut self.content_descriptorids)?;
                },
                136 => {
                    self.content_descriptorids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.tool {
            my_size += 1 + 1;
        }
        if let Some(v) = self.demo {
            my_size += 1 + 1;
        }
        if let Some(v) = self.media {
            my_size += 1 + 1;
        }
        if let Some(v) = self.community_visible_stats {
            my_size += 1 + 1;
        }
        if let Some(v) = self.friendly_name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.propagation.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.has_adult_content {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_visible_in_steam_china {
            my_size += 1 + 1;
        }
        if let Some(v) = self.app_type {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.has_adult_content_sex {
            my_size += 1 + 1;
        }
        if let Some(v) = self.has_adult_content_violence {
            my_size += 2 + 1;
        }
        for value in &self.content_descriptorids {
            my_size += ::protobuf::rt::uint32_size(17, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.tool {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.demo {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.media {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.community_visible_stats {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.friendly_name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.propagation.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.has_adult_content {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.is_visible_in_steam_china {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.app_type {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.has_adult_content_sex {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.has_adult_content_violence {
            os.write_bool(16, v)?;
        }
        for v in &self.content_descriptorids {
            os.write_uint32(17, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCDDBAppDetailCommon {
        CCDDBAppDetailCommon::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.tool = ::std::option::Option::None;
        self.demo = ::std::option::Option::None;
        self.media = ::std::option::Option::None;
        self.community_visible_stats = ::std::option::Option::None;
        self.friendly_name = ::std::option::Option::None;
        self.propagation = ::std::option::Option::None;
        self.has_adult_content = ::std::option::Option::None;
        self.is_visible_in_steam_china = ::std::option::Option::None;
        self.app_type = ::std::option::Option::None;
        self.has_adult_content_sex = ::std::option::Option::None;
        self.has_adult_content_violence = ::std::option::Option::None;
        self.content_descriptorids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCDDBAppDetailCommon {
        static instance: CCDDBAppDetailCommon = CCDDBAppDetailCommon {
            appid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            tool: ::std::option::Option::None,
            demo: ::std::option::Option::None,
            media: ::std::option::Option::None,
            community_visible_stats: ::std::option::Option::None,
            friendly_name: ::std::option::Option::None,
            propagation: ::std::option::Option::None,
            has_adult_content: ::std::option::Option::None,
            is_visible_in_steam_china: ::std::option::Option::None,
            app_type: ::std::option::Option::None,
            has_adult_content_sex: ::std::option::Option::None,
            has_adult_content_violence: ::std::option::Option::None,
            content_descriptorids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgAppRights)
pub struct CMsgAppRights {
    // message fields
    // @@protoc_insertion_point(field:CMsgAppRights.edit_info)
    pub edit_info: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.publish)
    pub publish: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.view_error_data)
    pub view_error_data: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.download)
    pub download: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.upload_cdkeys)
    pub upload_cdkeys: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.generate_cdkeys)
    pub generate_cdkeys: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.view_financials)
    pub view_financials: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.manage_ceg)
    pub manage_ceg: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.manage_signing)
    pub manage_signing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.manage_cdkeys)
    pub manage_cdkeys: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.edit_marketing)
    pub edit_marketing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.economy_support)
    pub economy_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.economy_support_supervisor)
    pub economy_support_supervisor: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.manage_pricing)
    pub manage_pricing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.broadcast_live)
    pub broadcast_live: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.view_marketing_traffic)
    pub view_marketing_traffic: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.edit_store_display_content)
    pub edit_store_display_content: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAppRights.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAppRights {
    fn default() -> &'a CMsgAppRights {
        <CMsgAppRights as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAppRights {
    pub fn new() -> CMsgAppRights {
        ::std::default::Default::default()
    }

    // optional bool edit_info = 1;

    pub fn edit_info(&self) -> bool {
        self.edit_info.unwrap_or(false)
    }

    pub fn clear_edit_info(&mut self) {
        self.edit_info = ::std::option::Option::None;
    }

    pub fn has_edit_info(&self) -> bool {
        self.edit_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edit_info(&mut self, v: bool) {
        self.edit_info = ::std::option::Option::Some(v);
    }

    // optional bool publish = 2;

    pub fn publish(&self) -> bool {
        self.publish.unwrap_or(false)
    }

    pub fn clear_publish(&mut self) {
        self.publish = ::std::option::Option::None;
    }

    pub fn has_publish(&self) -> bool {
        self.publish.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publish(&mut self, v: bool) {
        self.publish = ::std::option::Option::Some(v);
    }

    // optional bool view_error_data = 3;

    pub fn view_error_data(&self) -> bool {
        self.view_error_data.unwrap_or(false)
    }

    pub fn clear_view_error_data(&mut self) {
        self.view_error_data = ::std::option::Option::None;
    }

    pub fn has_view_error_data(&self) -> bool {
        self.view_error_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_error_data(&mut self, v: bool) {
        self.view_error_data = ::std::option::Option::Some(v);
    }

    // optional bool download = 4;

    pub fn download(&self) -> bool {
        self.download.unwrap_or(false)
    }

    pub fn clear_download(&mut self) {
        self.download = ::std::option::Option::None;
    }

    pub fn has_download(&self) -> bool {
        self.download.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download(&mut self, v: bool) {
        self.download = ::std::option::Option::Some(v);
    }

    // optional bool upload_cdkeys = 5;

    pub fn upload_cdkeys(&self) -> bool {
        self.upload_cdkeys.unwrap_or(false)
    }

    pub fn clear_upload_cdkeys(&mut self) {
        self.upload_cdkeys = ::std::option::Option::None;
    }

    pub fn has_upload_cdkeys(&self) -> bool {
        self.upload_cdkeys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_cdkeys(&mut self, v: bool) {
        self.upload_cdkeys = ::std::option::Option::Some(v);
    }

    // optional bool generate_cdkeys = 6;

    pub fn generate_cdkeys(&self) -> bool {
        self.generate_cdkeys.unwrap_or(false)
    }

    pub fn clear_generate_cdkeys(&mut self) {
        self.generate_cdkeys = ::std::option::Option::None;
    }

    pub fn has_generate_cdkeys(&self) -> bool {
        self.generate_cdkeys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generate_cdkeys(&mut self, v: bool) {
        self.generate_cdkeys = ::std::option::Option::Some(v);
    }

    // optional bool view_financials = 7;

    pub fn view_financials(&self) -> bool {
        self.view_financials.unwrap_or(false)
    }

    pub fn clear_view_financials(&mut self) {
        self.view_financials = ::std::option::Option::None;
    }

    pub fn has_view_financials(&self) -> bool {
        self.view_financials.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_financials(&mut self, v: bool) {
        self.view_financials = ::std::option::Option::Some(v);
    }

    // optional bool manage_ceg = 8;

    pub fn manage_ceg(&self) -> bool {
        self.manage_ceg.unwrap_or(false)
    }

    pub fn clear_manage_ceg(&mut self) {
        self.manage_ceg = ::std::option::Option::None;
    }

    pub fn has_manage_ceg(&self) -> bool {
        self.manage_ceg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manage_ceg(&mut self, v: bool) {
        self.manage_ceg = ::std::option::Option::Some(v);
    }

    // optional bool manage_signing = 9;

    pub fn manage_signing(&self) -> bool {
        self.manage_signing.unwrap_or(false)
    }

    pub fn clear_manage_signing(&mut self) {
        self.manage_signing = ::std::option::Option::None;
    }

    pub fn has_manage_signing(&self) -> bool {
        self.manage_signing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manage_signing(&mut self, v: bool) {
        self.manage_signing = ::std::option::Option::Some(v);
    }

    // optional bool manage_cdkeys = 10;

    pub fn manage_cdkeys(&self) -> bool {
        self.manage_cdkeys.unwrap_or(false)
    }

    pub fn clear_manage_cdkeys(&mut self) {
        self.manage_cdkeys = ::std::option::Option::None;
    }

    pub fn has_manage_cdkeys(&self) -> bool {
        self.manage_cdkeys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manage_cdkeys(&mut self, v: bool) {
        self.manage_cdkeys = ::std::option::Option::Some(v);
    }

    // optional bool edit_marketing = 11;

    pub fn edit_marketing(&self) -> bool {
        self.edit_marketing.unwrap_or(false)
    }

    pub fn clear_edit_marketing(&mut self) {
        self.edit_marketing = ::std::option::Option::None;
    }

    pub fn has_edit_marketing(&self) -> bool {
        self.edit_marketing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edit_marketing(&mut self, v: bool) {
        self.edit_marketing = ::std::option::Option::Some(v);
    }

    // optional bool economy_support = 12;

    pub fn economy_support(&self) -> bool {
        self.economy_support.unwrap_or(false)
    }

    pub fn clear_economy_support(&mut self) {
        self.economy_support = ::std::option::Option::None;
    }

    pub fn has_economy_support(&self) -> bool {
        self.economy_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_economy_support(&mut self, v: bool) {
        self.economy_support = ::std::option::Option::Some(v);
    }

    // optional bool economy_support_supervisor = 13;

    pub fn economy_support_supervisor(&self) -> bool {
        self.economy_support_supervisor.unwrap_or(false)
    }

    pub fn clear_economy_support_supervisor(&mut self) {
        self.economy_support_supervisor = ::std::option::Option::None;
    }

    pub fn has_economy_support_supervisor(&self) -> bool {
        self.economy_support_supervisor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_economy_support_supervisor(&mut self, v: bool) {
        self.economy_support_supervisor = ::std::option::Option::Some(v);
    }

    // optional bool manage_pricing = 14;

    pub fn manage_pricing(&self) -> bool {
        self.manage_pricing.unwrap_or(false)
    }

    pub fn clear_manage_pricing(&mut self) {
        self.manage_pricing = ::std::option::Option::None;
    }

    pub fn has_manage_pricing(&self) -> bool {
        self.manage_pricing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manage_pricing(&mut self, v: bool) {
        self.manage_pricing = ::std::option::Option::Some(v);
    }

    // optional bool broadcast_live = 15;

    pub fn broadcast_live(&self) -> bool {
        self.broadcast_live.unwrap_or(false)
    }

    pub fn clear_broadcast_live(&mut self) {
        self.broadcast_live = ::std::option::Option::None;
    }

    pub fn has_broadcast_live(&self) -> bool {
        self.broadcast_live.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_live(&mut self, v: bool) {
        self.broadcast_live = ::std::option::Option::Some(v);
    }

    // optional bool view_marketing_traffic = 16;

    pub fn view_marketing_traffic(&self) -> bool {
        self.view_marketing_traffic.unwrap_or(false)
    }

    pub fn clear_view_marketing_traffic(&mut self) {
        self.view_marketing_traffic = ::std::option::Option::None;
    }

    pub fn has_view_marketing_traffic(&self) -> bool {
        self.view_marketing_traffic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_marketing_traffic(&mut self, v: bool) {
        self.view_marketing_traffic = ::std::option::Option::Some(v);
    }

    // optional bool edit_store_display_content = 17;

    pub fn edit_store_display_content(&self) -> bool {
        self.edit_store_display_content.unwrap_or(false)
    }

    pub fn clear_edit_store_display_content(&mut self) {
        self.edit_store_display_content = ::std::option::Option::None;
    }

    pub fn has_edit_store_display_content(&self) -> bool {
        self.edit_store_display_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edit_store_display_content(&mut self, v: bool) {
        self.edit_store_display_content = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAppRights {
    const NAME: &'static str = "CMsgAppRights";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.edit_info = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.publish = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.view_error_data = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.download = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.upload_cdkeys = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.generate_cdkeys = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.view_financials = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.manage_ceg = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.manage_signing = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.manage_cdkeys = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.edit_marketing = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.economy_support = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.economy_support_supervisor = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.manage_pricing = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.broadcast_live = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.view_marketing_traffic = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.edit_store_display_content = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.edit_info {
            my_size += 1 + 1;
        }
        if let Some(v) = self.publish {
            my_size += 1 + 1;
        }
        if let Some(v) = self.view_error_data {
            my_size += 1 + 1;
        }
        if let Some(v) = self.download {
            my_size += 1 + 1;
        }
        if let Some(v) = self.upload_cdkeys {
            my_size += 1 + 1;
        }
        if let Some(v) = self.generate_cdkeys {
            my_size += 1 + 1;
        }
        if let Some(v) = self.view_financials {
            my_size += 1 + 1;
        }
        if let Some(v) = self.manage_ceg {
            my_size += 1 + 1;
        }
        if let Some(v) = self.manage_signing {
            my_size += 1 + 1;
        }
        if let Some(v) = self.manage_cdkeys {
            my_size += 1 + 1;
        }
        if let Some(v) = self.edit_marketing {
            my_size += 1 + 1;
        }
        if let Some(v) = self.economy_support {
            my_size += 1 + 1;
        }
        if let Some(v) = self.economy_support_supervisor {
            my_size += 1 + 1;
        }
        if let Some(v) = self.manage_pricing {
            my_size += 1 + 1;
        }
        if let Some(v) = self.broadcast_live {
            my_size += 1 + 1;
        }
        if let Some(v) = self.view_marketing_traffic {
            my_size += 2 + 1;
        }
        if let Some(v) = self.edit_store_display_content {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.edit_info {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.publish {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.view_error_data {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.download {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.upload_cdkeys {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.generate_cdkeys {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.view_financials {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.manage_ceg {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.manage_signing {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.manage_cdkeys {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.edit_marketing {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.economy_support {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.economy_support_supervisor {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.manage_pricing {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.broadcast_live {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.view_marketing_traffic {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.edit_store_display_content {
            os.write_bool(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAppRights {
        CMsgAppRights::new()
    }

    fn clear(&mut self) {
        self.edit_info = ::std::option::Option::None;
        self.publish = ::std::option::Option::None;
        self.view_error_data = ::std::option::Option::None;
        self.download = ::std::option::Option::None;
        self.upload_cdkeys = ::std::option::Option::None;
        self.generate_cdkeys = ::std::option::Option::None;
        self.view_financials = ::std::option::Option::None;
        self.manage_ceg = ::std::option::Option::None;
        self.manage_signing = ::std::option::Option::None;
        self.manage_cdkeys = ::std::option::Option::None;
        self.edit_marketing = ::std::option::Option::None;
        self.economy_support = ::std::option::Option::None;
        self.economy_support_supervisor = ::std::option::Option::None;
        self.manage_pricing = ::std::option::Option::None;
        self.broadcast_live = ::std::option::Option::None;
        self.view_marketing_traffic = ::std::option::Option::None;
        self.edit_store_display_content = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAppRights {
        static instance: CMsgAppRights = CMsgAppRights {
            edit_info: ::std::option::Option::None,
            publish: ::std::option::Option::None,
            view_error_data: ::std::option::Option::None,
            download: ::std::option::Option::None,
            upload_cdkeys: ::std::option::Option::None,
            generate_cdkeys: ::std::option::Option::None,
            view_financials: ::std::option::Option::None,
            manage_ceg: ::std::option::Option::None,
            manage_signing: ::std::option::Option::None,
            manage_cdkeys: ::std::option::Option::None,
            edit_marketing: ::std::option::Option::None,
            economy_support: ::std::option::Option::None,
            economy_support_supervisor: ::std::option::Option::None,
            manage_pricing: ::std::option::Option::None,
            broadcast_live: ::std::option::Option::None,
            view_marketing_traffic: ::std::option::Option::None,
            edit_store_display_content: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CCuratorPreferences)
pub struct CCuratorPreferences {
    // message fields
    // @@protoc_insertion_point(field:CCuratorPreferences.supported_languages)
    pub supported_languages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCuratorPreferences.platform_windows)
    pub platform_windows: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.platform_mac)
    pub platform_mac: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.platform_linux)
    pub platform_linux: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.vr_content)
    pub vr_content: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.adult_content_violence)
    pub adult_content_violence: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.adult_content_sex)
    pub adult_content_sex: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.timestamp_updated)
    pub timestamp_updated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCuratorPreferences.tagids_curated)
    pub tagids_curated: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CCuratorPreferences.tagids_filtered)
    pub tagids_filtered: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CCuratorPreferences.website_title)
    pub website_title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCuratorPreferences.website_url)
    pub website_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCuratorPreferences.discussion_url)
    pub discussion_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCuratorPreferences.show_broadcast)
    pub show_broadcast: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCuratorPreferences.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCuratorPreferences {
    fn default() -> &'a CCuratorPreferences {
        <CCuratorPreferences as ::protobuf::Message>::default_instance()
    }
}

impl CCuratorPreferences {
    pub fn new() -> CCuratorPreferences {
        ::std::default::Default::default()
    }

    // optional uint32 supported_languages = 1;

    pub fn supported_languages(&self) -> u32 {
        self.supported_languages.unwrap_or(0)
    }

    pub fn clear_supported_languages(&mut self) {
        self.supported_languages = ::std::option::Option::None;
    }

    pub fn has_supported_languages(&self) -> bool {
        self.supported_languages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supported_languages(&mut self, v: u32) {
        self.supported_languages = ::std::option::Option::Some(v);
    }

    // optional bool platform_windows = 2;

    pub fn platform_windows(&self) -> bool {
        self.platform_windows.unwrap_or(false)
    }

    pub fn clear_platform_windows(&mut self) {
        self.platform_windows = ::std::option::Option::None;
    }

    pub fn has_platform_windows(&self) -> bool {
        self.platform_windows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_windows(&mut self, v: bool) {
        self.platform_windows = ::std::option::Option::Some(v);
    }

    // optional bool platform_mac = 3;

    pub fn platform_mac(&self) -> bool {
        self.platform_mac.unwrap_or(false)
    }

    pub fn clear_platform_mac(&mut self) {
        self.platform_mac = ::std::option::Option::None;
    }

    pub fn has_platform_mac(&self) -> bool {
        self.platform_mac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_mac(&mut self, v: bool) {
        self.platform_mac = ::std::option::Option::Some(v);
    }

    // optional bool platform_linux = 4;

    pub fn platform_linux(&self) -> bool {
        self.platform_linux.unwrap_or(false)
    }

    pub fn clear_platform_linux(&mut self) {
        self.platform_linux = ::std::option::Option::None;
    }

    pub fn has_platform_linux(&self) -> bool {
        self.platform_linux.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_linux(&mut self, v: bool) {
        self.platform_linux = ::std::option::Option::Some(v);
    }

    // optional bool vr_content = 5;

    pub fn vr_content(&self) -> bool {
        self.vr_content.unwrap_or(false)
    }

    pub fn clear_vr_content(&mut self) {
        self.vr_content = ::std::option::Option::None;
    }

    pub fn has_vr_content(&self) -> bool {
        self.vr_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_content(&mut self, v: bool) {
        self.vr_content = ::std::option::Option::Some(v);
    }

    // optional bool adult_content_violence = 6;

    pub fn adult_content_violence(&self) -> bool {
        self.adult_content_violence.unwrap_or(false)
    }

    pub fn clear_adult_content_violence(&mut self) {
        self.adult_content_violence = ::std::option::Option::None;
    }

    pub fn has_adult_content_violence(&self) -> bool {
        self.adult_content_violence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adult_content_violence(&mut self, v: bool) {
        self.adult_content_violence = ::std::option::Option::Some(v);
    }

    // optional bool adult_content_sex = 7;

    pub fn adult_content_sex(&self) -> bool {
        self.adult_content_sex.unwrap_or(false)
    }

    pub fn clear_adult_content_sex(&mut self) {
        self.adult_content_sex = ::std::option::Option::None;
    }

    pub fn has_adult_content_sex(&self) -> bool {
        self.adult_content_sex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adult_content_sex(&mut self, v: bool) {
        self.adult_content_sex = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_updated = 8;

    pub fn timestamp_updated(&self) -> u32 {
        self.timestamp_updated.unwrap_or(0)
    }

    pub fn clear_timestamp_updated(&mut self) {
        self.timestamp_updated = ::std::option::Option::None;
    }

    pub fn has_timestamp_updated(&self) -> bool {
        self.timestamp_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_updated(&mut self, v: u32) {
        self.timestamp_updated = ::std::option::Option::Some(v);
    }

    // optional string website_title = 11;

    pub fn website_title(&self) -> &str {
        match self.website_title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_website_title(&mut self) {
        self.website_title = ::std::option::Option::None;
    }

    pub fn has_website_title(&self) -> bool {
        self.website_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_website_title(&mut self, v: ::std::string::String) {
        self.website_title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_website_title(&mut self) -> &mut ::std::string::String {
        if self.website_title.is_none() {
            self.website_title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.website_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_website_title(&mut self) -> ::std::string::String {
        self.website_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string website_url = 12;

    pub fn website_url(&self) -> &str {
        match self.website_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_website_url(&mut self) {
        self.website_url = ::std::option::Option::None;
    }

    pub fn has_website_url(&self) -> bool {
        self.website_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_website_url(&mut self, v: ::std::string::String) {
        self.website_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_website_url(&mut self) -> &mut ::std::string::String {
        if self.website_url.is_none() {
            self.website_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.website_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_website_url(&mut self) -> ::std::string::String {
        self.website_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string discussion_url = 13;

    pub fn discussion_url(&self) -> &str {
        match self.discussion_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_discussion_url(&mut self) {
        self.discussion_url = ::std::option::Option::None;
    }

    pub fn has_discussion_url(&self) -> bool {
        self.discussion_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discussion_url(&mut self, v: ::std::string::String) {
        self.discussion_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discussion_url(&mut self) -> &mut ::std::string::String {
        if self.discussion_url.is_none() {
            self.discussion_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.discussion_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_discussion_url(&mut self) -> ::std::string::String {
        self.discussion_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool show_broadcast = 14;

    pub fn show_broadcast(&self) -> bool {
        self.show_broadcast.unwrap_or(false)
    }

    pub fn clear_show_broadcast(&mut self) {
        self.show_broadcast = ::std::option::Option::None;
    }

    pub fn has_show_broadcast(&self) -> bool {
        self.show_broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_broadcast(&mut self, v: bool) {
        self.show_broadcast = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCuratorPreferences {
    const NAME: &'static str = "CCuratorPreferences";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.supported_languages = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.platform_windows = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.platform_mac = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.platform_linux = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.vr_content = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.adult_content_violence = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.adult_content_sex = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.timestamp_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.tagids_curated)?;
                },
                72 => {
                    self.tagids_curated.push(is.read_uint32()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.tagids_filtered)?;
                },
                80 => {
                    self.tagids_filtered.push(is.read_uint32()?);
                },
                90 => {
                    self.website_title = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.website_url = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.discussion_url = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.show_broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.supported_languages {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.platform_windows {
            my_size += 1 + 1;
        }
        if let Some(v) = self.platform_mac {
            my_size += 1 + 1;
        }
        if let Some(v) = self.platform_linux {
            my_size += 1 + 1;
        }
        if let Some(v) = self.vr_content {
            my_size += 1 + 1;
        }
        if let Some(v) = self.adult_content_violence {
            my_size += 1 + 1;
        }
        if let Some(v) = self.adult_content_sex {
            my_size += 1 + 1;
        }
        if let Some(v) = self.timestamp_updated {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        for value in &self.tagids_curated {
            my_size += ::protobuf::rt::uint32_size(9, *value);
        };
        for value in &self.tagids_filtered {
            my_size += ::protobuf::rt::uint32_size(10, *value);
        };
        if let Some(v) = self.website_title.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.website_url.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.discussion_url.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.show_broadcast {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.supported_languages {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.platform_windows {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.platform_mac {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.platform_linux {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.vr_content {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.adult_content_violence {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.adult_content_sex {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.timestamp_updated {
            os.write_uint32(8, v)?;
        }
        for v in &self.tagids_curated {
            os.write_uint32(9, *v)?;
        };
        for v in &self.tagids_filtered {
            os.write_uint32(10, *v)?;
        };
        if let Some(v) = self.website_title.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.website_url.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.discussion_url.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.show_broadcast {
            os.write_bool(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCuratorPreferences {
        CCuratorPreferences::new()
    }

    fn clear(&mut self) {
        self.supported_languages = ::std::option::Option::None;
        self.platform_windows = ::std::option::Option::None;
        self.platform_mac = ::std::option::Option::None;
        self.platform_linux = ::std::option::Option::None;
        self.vr_content = ::std::option::Option::None;
        self.adult_content_violence = ::std::option::Option::None;
        self.adult_content_sex = ::std::option::Option::None;
        self.timestamp_updated = ::std::option::Option::None;
        self.tagids_curated.clear();
        self.tagids_filtered.clear();
        self.website_title = ::std::option::Option::None;
        self.website_url = ::std::option::Option::None;
        self.discussion_url = ::std::option::Option::None;
        self.show_broadcast = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCuratorPreferences {
        static instance: CCuratorPreferences = CCuratorPreferences {
            supported_languages: ::std::option::Option::None,
            platform_windows: ::std::option::Option::None,
            platform_mac: ::std::option::Option::None,
            platform_linux: ::std::option::Option::None,
            vr_content: ::std::option::Option::None,
            adult_content_violence: ::std::option::Option::None,
            adult_content_sex: ::std::option::Option::None,
            timestamp_updated: ::std::option::Option::None,
            tagids_curated: ::std::vec::Vec::new(),
            tagids_filtered: ::std::vec::Vec::new(),
            website_title: ::std::option::Option::None,
            website_url: ::std::option::Option::None,
            discussion_url: ::std::option::Option::None,
            show_broadcast: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CLocalizationToken)
pub struct CLocalizationToken {
    // message fields
    // @@protoc_insertion_point(field:CLocalizationToken.language)
    pub language: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLocalizationToken.localized_string)
    pub localized_string: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CLocalizationToken.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLocalizationToken {
    fn default() -> &'a CLocalizationToken {
        <CLocalizationToken as ::protobuf::Message>::default_instance()
    }
}

impl CLocalizationToken {
    pub fn new() -> CLocalizationToken {
        ::std::default::Default::default()
    }

    // optional uint32 language = 1;

    pub fn language(&self) -> u32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: u32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional string localized_string = 2;

    pub fn localized_string(&self) -> &str {
        match self.localized_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_localized_string(&mut self) {
        self.localized_string = ::std::option::Option::None;
    }

    pub fn has_localized_string(&self) -> bool {
        self.localized_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localized_string(&mut self, v: ::std::string::String) {
        self.localized_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localized_string(&mut self) -> &mut ::std::string::String {
        if self.localized_string.is_none() {
            self.localized_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.localized_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_localized_string(&mut self) -> ::std::string::String {
        self.localized_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CLocalizationToken {
    const NAME: &'static str = "CLocalizationToken";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.language = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.localized_string = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.localized_string.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.language {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.localized_string.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLocalizationToken {
        CLocalizationToken::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.localized_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLocalizationToken {
        static instance: CLocalizationToken = CLocalizationToken {
            language: ::std::option::Option::None,
            localized_string: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CClanEventUserNewsTuple)
pub struct CClanEventUserNewsTuple {
    // message fields
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.clanid)
    pub clanid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.event_gid)
    pub event_gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.announcement_gid)
    pub announcement_gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.rtime_start)
    pub rtime_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.rtime_end)
    pub rtime_end: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.priority_score)
    pub priority_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.clamp_range_slot)
    pub clamp_range_slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.rtime32_last_modified)
    pub rtime32_last_modified: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanEventUserNewsTuple.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanEventUserNewsTuple {
    fn default() -> &'a CClanEventUserNewsTuple {
        <CClanEventUserNewsTuple as ::protobuf::Message>::default_instance()
    }
}

impl CClanEventUserNewsTuple {
    pub fn new() -> CClanEventUserNewsTuple {
        ::std::default::Default::default()
    }

    // optional uint32 clanid = 1;

    pub fn clanid(&self) -> u32 {
        self.clanid.unwrap_or(0)
    }

    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u32) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional fixed64 event_gid = 2;

    pub fn event_gid(&self) -> u64 {
        self.event_gid.unwrap_or(0)
    }

    pub fn clear_event_gid(&mut self) {
        self.event_gid = ::std::option::Option::None;
    }

    pub fn has_event_gid(&self) -> bool {
        self.event_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_gid(&mut self, v: u64) {
        self.event_gid = ::std::option::Option::Some(v);
    }

    // optional fixed64 announcement_gid = 3;

    pub fn announcement_gid(&self) -> u64 {
        self.announcement_gid.unwrap_or(0)
    }

    pub fn clear_announcement_gid(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
    }

    pub fn has_announcement_gid(&self) -> bool {
        self.announcement_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_gid(&mut self, v: u64) {
        self.announcement_gid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_start = 4;

    pub fn rtime_start(&self) -> u32 {
        self.rtime_start.unwrap_or(0)
    }

    pub fn clear_rtime_start(&mut self) {
        self.rtime_start = ::std::option::Option::None;
    }

    pub fn has_rtime_start(&self) -> bool {
        self.rtime_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_start(&mut self, v: u32) {
        self.rtime_start = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_end = 5;

    pub fn rtime_end(&self) -> u32 {
        self.rtime_end.unwrap_or(0)
    }

    pub fn clear_rtime_end(&mut self) {
        self.rtime_end = ::std::option::Option::None;
    }

    pub fn has_rtime_end(&self) -> bool {
        self.rtime_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_end(&mut self, v: u32) {
        self.rtime_end = ::std::option::Option::Some(v);
    }

    // optional uint32 priority_score = 6;

    pub fn priority_score(&self) -> u32 {
        self.priority_score.unwrap_or(0)
    }

    pub fn clear_priority_score(&mut self) {
        self.priority_score = ::std::option::Option::None;
    }

    pub fn has_priority_score(&self) -> bool {
        self.priority_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority_score(&mut self, v: u32) {
        self.priority_score = ::std::option::Option::Some(v);
    }

    // optional uint32 type = 7;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional uint32 clamp_range_slot = 8;

    pub fn clamp_range_slot(&self) -> u32 {
        self.clamp_range_slot.unwrap_or(0)
    }

    pub fn clear_clamp_range_slot(&mut self) {
        self.clamp_range_slot = ::std::option::Option::None;
    }

    pub fn has_clamp_range_slot(&self) -> bool {
        self.clamp_range_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clamp_range_slot(&mut self, v: u32) {
        self.clamp_range_slot = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 9;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_last_modified = 10;

    pub fn rtime32_last_modified(&self) -> u32 {
        self.rtime32_last_modified.unwrap_or(0)
    }

    pub fn clear_rtime32_last_modified(&mut self) {
        self.rtime32_last_modified = ::std::option::Option::None;
    }

    pub fn has_rtime32_last_modified(&self) -> bool {
        self.rtime32_last_modified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_last_modified(&mut self, v: u32) {
        self.rtime32_last_modified = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClanEventUserNewsTuple {
    const NAME: &'static str = "CClanEventUserNewsTuple";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.clanid = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.event_gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.announcement_gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.rtime_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rtime_end = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.priority_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.clamp_range_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.rtime32_last_modified = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clanid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.announcement_gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.rtime_start {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rtime_end {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.priority_score {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.clamp_range_slot {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.rtime32_last_modified {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.clanid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_gid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.announcement_gid {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.rtime_start {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rtime_end {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.priority_score {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.clamp_range_slot {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.rtime32_last_modified {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanEventUserNewsTuple {
        CClanEventUserNewsTuple::new()
    }

    fn clear(&mut self) {
        self.clanid = ::std::option::Option::None;
        self.event_gid = ::std::option::Option::None;
        self.announcement_gid = ::std::option::Option::None;
        self.rtime_start = ::std::option::Option::None;
        self.rtime_end = ::std::option::Option::None;
        self.priority_score = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.clamp_range_slot = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.rtime32_last_modified = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanEventUserNewsTuple {
        static instance: CClanEventUserNewsTuple = CClanEventUserNewsTuple {
            clanid: ::std::option::Option::None,
            event_gid: ::std::option::Option::None,
            announcement_gid: ::std::option::Option::None,
            rtime_start: ::std::option::Option::None,
            rtime_end: ::std::option::Option::None,
            priority_score: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            clamp_range_slot: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            rtime32_last_modified: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CClanMatchEventByRange)
pub struct CClanMatchEventByRange {
    // message fields
    // @@protoc_insertion_point(field:CClanMatchEventByRange.rtime_before)
    pub rtime_before: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanMatchEventByRange.rtime_after)
    pub rtime_after: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanMatchEventByRange.qualified)
    pub qualified: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanMatchEventByRange.events)
    pub events: ::std::vec::Vec<CClanEventUserNewsTuple>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanMatchEventByRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanMatchEventByRange {
    fn default() -> &'a CClanMatchEventByRange {
        <CClanMatchEventByRange as ::protobuf::Message>::default_instance()
    }
}

impl CClanMatchEventByRange {
    pub fn new() -> CClanMatchEventByRange {
        ::std::default::Default::default()
    }

    // optional uint32 rtime_before = 1;

    pub fn rtime_before(&self) -> u32 {
        self.rtime_before.unwrap_or(0)
    }

    pub fn clear_rtime_before(&mut self) {
        self.rtime_before = ::std::option::Option::None;
    }

    pub fn has_rtime_before(&self) -> bool {
        self.rtime_before.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_before(&mut self, v: u32) {
        self.rtime_before = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_after = 2;

    pub fn rtime_after(&self) -> u32 {
        self.rtime_after.unwrap_or(0)
    }

    pub fn clear_rtime_after(&mut self) {
        self.rtime_after = ::std::option::Option::None;
    }

    pub fn has_rtime_after(&self) -> bool {
        self.rtime_after.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_after(&mut self, v: u32) {
        self.rtime_after = ::std::option::Option::Some(v);
    }

    // optional uint32 qualified = 3;

    pub fn qualified(&self) -> u32 {
        self.qualified.unwrap_or(0)
    }

    pub fn clear_qualified(&mut self) {
        self.qualified = ::std::option::Option::None;
    }

    pub fn has_qualified(&self) -> bool {
        self.qualified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qualified(&mut self, v: u32) {
        self.qualified = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClanMatchEventByRange {
    const NAME: &'static str = "CClanMatchEventByRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rtime_before = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rtime_after = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.qualified = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rtime_before {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rtime_after {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.qualified {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rtime_before {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rtime_after {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.qualified {
            os.write_uint32(3, v)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanMatchEventByRange {
        CClanMatchEventByRange::new()
    }

    fn clear(&mut self) {
        self.rtime_before = ::std::option::Option::None;
        self.rtime_after = ::std::option::Option::None;
        self.qualified = ::std::option::Option::None;
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanMatchEventByRange {
        static instance: CClanMatchEventByRange = CClanMatchEventByRange {
            rtime_before: ::std::option::Option::None,
            rtime_after: ::std::option::Option::None,
            qualified: ::std::option::Option::None,
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CCommunity_ClanAnnouncementInfo)
pub struct CCommunity_ClanAnnouncementInfo {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.clanid)
    pub clanid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.posterid)
    pub posterid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.headline)
    pub headline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.posttime)
    pub posttime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.updatetime)
    pub updatetime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.commentcount)
    pub commentcount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.language)
    pub language: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.hidden)
    pub hidden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.forum_topic_id)
    pub forum_topic_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.event_gid)
    pub event_gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.voteupcount)
    pub voteupcount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.votedowncount)
    pub votedowncount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.ban_check_result)
    pub ban_check_result: ::std::option::Option<::protobuf::EnumOrUnknown<EBanContentCheckResult>>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.banned)
    pub banned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_ClanAnnouncementInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_ClanAnnouncementInfo {
    fn default() -> &'a CCommunity_ClanAnnouncementInfo {
        <CCommunity_ClanAnnouncementInfo as ::protobuf::Message>::default_instance()
    }
}

impl CCommunity_ClanAnnouncementInfo {
    pub fn new() -> CCommunity_ClanAnnouncementInfo {
        ::std::default::Default::default()
    }

    // optional uint64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional uint64 clanid = 2;

    pub fn clanid(&self) -> u64 {
        self.clanid.unwrap_or(0)
    }

    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u64) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional uint64 posterid = 3;

    pub fn posterid(&self) -> u64 {
        self.posterid.unwrap_or(0)
    }

    pub fn clear_posterid(&mut self) {
        self.posterid = ::std::option::Option::None;
    }

    pub fn has_posterid(&self) -> bool {
        self.posterid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_posterid(&mut self, v: u64) {
        self.posterid = ::std::option::Option::Some(v);
    }

    // optional string headline = 4;

    pub fn headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_headline(&mut self) {
        self.headline = ::std::option::Option::None;
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 posttime = 5;

    pub fn posttime(&self) -> u32 {
        self.posttime.unwrap_or(0)
    }

    pub fn clear_posttime(&mut self) {
        self.posttime = ::std::option::Option::None;
    }

    pub fn has_posttime(&self) -> bool {
        self.posttime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_posttime(&mut self, v: u32) {
        self.posttime = ::std::option::Option::Some(v);
    }

    // optional uint32 updatetime = 6;

    pub fn updatetime(&self) -> u32 {
        self.updatetime.unwrap_or(0)
    }

    pub fn clear_updatetime(&mut self) {
        self.updatetime = ::std::option::Option::None;
    }

    pub fn has_updatetime(&self) -> bool {
        self.updatetime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatetime(&mut self, v: u32) {
        self.updatetime = ::std::option::Option::Some(v);
    }

    // optional string body = 7;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 commentcount = 8;

    pub fn commentcount(&self) -> i32 {
        self.commentcount.unwrap_or(0)
    }

    pub fn clear_commentcount(&mut self) {
        self.commentcount = ::std::option::Option::None;
    }

    pub fn has_commentcount(&self) -> bool {
        self.commentcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commentcount(&mut self, v: i32) {
        self.commentcount = ::std::option::Option::Some(v);
    }

    // optional int32 language = 10;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 11;

    pub fn hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }

    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }

    // optional fixed64 forum_topic_id = 12;

    pub fn forum_topic_id(&self) -> u64 {
        self.forum_topic_id.unwrap_or(0)
    }

    pub fn clear_forum_topic_id(&mut self) {
        self.forum_topic_id = ::std::option::Option::None;
    }

    pub fn has_forum_topic_id(&self) -> bool {
        self.forum_topic_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forum_topic_id(&mut self, v: u64) {
        self.forum_topic_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 event_gid = 13;

    pub fn event_gid(&self) -> u64 {
        self.event_gid.unwrap_or(0)
    }

    pub fn clear_event_gid(&mut self) {
        self.event_gid = ::std::option::Option::None;
    }

    pub fn has_event_gid(&self) -> bool {
        self.event_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_gid(&mut self, v: u64) {
        self.event_gid = ::std::option::Option::Some(v);
    }

    // optional int32 voteupcount = 14;

    pub fn voteupcount(&self) -> i32 {
        self.voteupcount.unwrap_or(0)
    }

    pub fn clear_voteupcount(&mut self) {
        self.voteupcount = ::std::option::Option::None;
    }

    pub fn has_voteupcount(&self) -> bool {
        self.voteupcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voteupcount(&mut self, v: i32) {
        self.voteupcount = ::std::option::Option::Some(v);
    }

    // optional int32 votedowncount = 15;

    pub fn votedowncount(&self) -> i32 {
        self.votedowncount.unwrap_or(0)
    }

    pub fn clear_votedowncount(&mut self) {
        self.votedowncount = ::std::option::Option::None;
    }

    pub fn has_votedowncount(&self) -> bool {
        self.votedowncount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_votedowncount(&mut self, v: i32) {
        self.votedowncount = ::std::option::Option::Some(v);
    }

    // optional .EBanContentCheckResult ban_check_result = 16;

    pub fn ban_check_result(&self) -> EBanContentCheckResult {
        match self.ban_check_result {
            Some(e) => e.enum_value_or(EBanContentCheckResult::k_EBanContentCheckResult_NotScanned),
            None => EBanContentCheckResult::k_EBanContentCheckResult_NotScanned,
        }
    }

    pub fn clear_ban_check_result(&mut self) {
        self.ban_check_result = ::std::option::Option::None;
    }

    pub fn has_ban_check_result(&self) -> bool {
        self.ban_check_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_check_result(&mut self, v: EBanContentCheckResult) {
        self.ban_check_result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool banned = 17;

    pub fn banned(&self) -> bool {
        self.banned.unwrap_or(false)
    }

    pub fn clear_banned(&mut self) {
        self.banned = ::std::option::Option::None;
    }

    pub fn has_banned(&self) -> bool {
        self.banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned(&mut self, v: bool) {
        self.banned = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCommunity_ClanAnnouncementInfo {
    const NAME: &'static str = "CCommunity_ClanAnnouncementInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.clanid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.posterid = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.headline = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.posttime = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.updatetime = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.commentcount = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    self.tags.push(is.read_string()?);
                },
                80 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                97 => {
                    self.forum_topic_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                105 => {
                    self.event_gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                112 => {
                    self.voteupcount = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.votedowncount = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.ban_check_result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                136 => {
                    self.banned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.clanid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.posterid {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.headline.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.posttime {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.updatetime {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.commentcount {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.hidden {
            my_size += 1 + 1;
        }
        if let Some(v) = self.forum_topic_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.event_gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.voteupcount {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.votedowncount {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.ban_check_result {
            my_size += ::protobuf::rt::int32_size(16, v.value());
        }
        if let Some(v) = self.banned {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.clanid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.posterid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.headline.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.posttime {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.updatetime {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.commentcount {
            os.write_int32(8, v)?;
        }
        for v in &self.tags {
            os.write_string(9, &v)?;
        };
        if let Some(v) = self.language {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.forum_topic_id {
            os.write_fixed64(12, v)?;
        }
        if let Some(v) = self.event_gid {
            os.write_fixed64(13, v)?;
        }
        if let Some(v) = self.voteupcount {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.votedowncount {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.ban_check_result {
            os.write_enum(16, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.banned {
            os.write_bool(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_ClanAnnouncementInfo {
        CCommunity_ClanAnnouncementInfo::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.clanid = ::std::option::Option::None;
        self.posterid = ::std::option::Option::None;
        self.headline = ::std::option::Option::None;
        self.posttime = ::std::option::Option::None;
        self.updatetime = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.commentcount = ::std::option::Option::None;
        self.tags.clear();
        self.language = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.forum_topic_id = ::std::option::Option::None;
        self.event_gid = ::std::option::Option::None;
        self.voteupcount = ::std::option::Option::None;
        self.votedowncount = ::std::option::Option::None;
        self.ban_check_result = ::std::option::Option::None;
        self.banned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_ClanAnnouncementInfo {
        static instance: CCommunity_ClanAnnouncementInfo = CCommunity_ClanAnnouncementInfo {
            gid: ::std::option::Option::None,
            clanid: ::std::option::Option::None,
            posterid: ::std::option::Option::None,
            headline: ::std::option::Option::None,
            posttime: ::std::option::Option::None,
            updatetime: ::std::option::Option::None,
            body: ::std::option::Option::None,
            commentcount: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            language: ::std::option::Option::None,
            hidden: ::std::option::Option::None,
            forum_topic_id: ::std::option::Option::None,
            event_gid: ::std::option::Option::None,
            voteupcount: ::std::option::Option::None,
            votedowncount: ::std::option::Option::None,
            ban_check_result: ::std::option::Option::None,
            banned: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CClanEventData)
pub struct CClanEventData {
    // message fields
    // @@protoc_insertion_point(field:CClanEventData.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.clan_steamid)
    pub clan_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.event_name)
    pub event_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClanEventData.event_type)
    pub event_type: ::std::option::Option<::protobuf::EnumOrUnknown<EProtoClanEventType>>,
    // @@protoc_insertion_point(field:CClanEventData.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.server_address)
    pub server_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClanEventData.server_password)
    pub server_password: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClanEventData.rtime32_start_time)
    pub rtime32_start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.rtime32_end_time)
    pub rtime32_end_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.comment_count)
    pub comment_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CClanEventData.creator_steamid)
    pub creator_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.last_update_steamid)
    pub last_update_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.event_notes)
    pub event_notes: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClanEventData.jsondata)
    pub jsondata: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClanEventData.announcement_body)
    pub announcement_body: ::protobuf::MessageField<CCommunity_ClanAnnouncementInfo>,
    // @@protoc_insertion_point(field:CClanEventData.published)
    pub published: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClanEventData.hidden)
    pub hidden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClanEventData.rtime32_visibility_start)
    pub rtime32_visibility_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.rtime32_visibility_end)
    pub rtime32_visibility_end: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.broadcaster_accountid)
    pub broadcaster_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.follower_count)
    pub follower_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.ignore_count)
    pub ignore_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.forum_topic_id)
    pub forum_topic_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.rtime32_last_modified)
    pub rtime32_last_modified: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.news_post_gid)
    pub news_post_gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.rtime_mod_reviewed)
    pub rtime_mod_reviewed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.featured_app_tagid)
    pub featured_app_tagid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.referenced_appids)
    pub referenced_appids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CClanEventData.build_id)
    pub build_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.build_branch)
    pub build_branch: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanEventData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanEventData {
    fn default() -> &'a CClanEventData {
        <CClanEventData as ::protobuf::Message>::default_instance()
    }
}

impl CClanEventData {
    pub fn new() -> CClanEventData {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional fixed64 clan_steamid = 2;

    pub fn clan_steamid(&self) -> u64 {
        self.clan_steamid.unwrap_or(0)
    }

    pub fn clear_clan_steamid(&mut self) {
        self.clan_steamid = ::std::option::Option::None;
    }

    pub fn has_clan_steamid(&self) -> bool {
        self.clan_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_steamid(&mut self, v: u64) {
        self.clan_steamid = ::std::option::Option::Some(v);
    }

    // optional string event_name = 3;

    pub fn event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name = ::std::option::Option::None;
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .EProtoClanEventType event_type = 4;

    pub fn event_type(&self) -> EProtoClanEventType {
        match self.event_type {
            Some(e) => e.enum_value_or(EProtoClanEventType::k_EClanOtherEvent),
            None => EProtoClanEventType::k_EClanOtherEvent,
        }
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: EProtoClanEventType) {
        self.event_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 appid = 5;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string server_address = 6;

    pub fn server_address(&self) -> &str {
        match self.server_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_address(&mut self) {
        self.server_address = ::std::option::Option::None;
    }

    pub fn has_server_address(&self) -> bool {
        self.server_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_address(&mut self, v: ::std::string::String) {
        self.server_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_address(&mut self) -> &mut ::std::string::String {
        if self.server_address.is_none() {
            self.server_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_address(&mut self) -> ::std::string::String {
        self.server_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string server_password = 7;

    pub fn server_password(&self) -> &str {
        match self.server_password.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_password(&mut self) {
        self.server_password = ::std::option::Option::None;
    }

    pub fn has_server_password(&self) -> bool {
        self.server_password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_password(&mut self, v: ::std::string::String) {
        self.server_password = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_password(&mut self) -> &mut ::std::string::String {
        if self.server_password.is_none() {
            self.server_password = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_password.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_password(&mut self) -> ::std::string::String {
        self.server_password.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 rtime32_start_time = 8;

    pub fn rtime32_start_time(&self) -> u32 {
        self.rtime32_start_time.unwrap_or(0)
    }

    pub fn clear_rtime32_start_time(&mut self) {
        self.rtime32_start_time = ::std::option::Option::None;
    }

    pub fn has_rtime32_start_time(&self) -> bool {
        self.rtime32_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_start_time(&mut self, v: u32) {
        self.rtime32_start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_end_time = 9;

    pub fn rtime32_end_time(&self) -> u32 {
        self.rtime32_end_time.unwrap_or(0)
    }

    pub fn clear_rtime32_end_time(&mut self) {
        self.rtime32_end_time = ::std::option::Option::None;
    }

    pub fn has_rtime32_end_time(&self) -> bool {
        self.rtime32_end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_end_time(&mut self, v: u32) {
        self.rtime32_end_time = ::std::option::Option::Some(v);
    }

    // optional int32 comment_count = 10;

    pub fn comment_count(&self) -> i32 {
        self.comment_count.unwrap_or(0)
    }

    pub fn clear_comment_count(&mut self) {
        self.comment_count = ::std::option::Option::None;
    }

    pub fn has_comment_count(&self) -> bool {
        self.comment_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment_count(&mut self, v: i32) {
        self.comment_count = ::std::option::Option::Some(v);
    }

    // optional fixed64 creator_steamid = 11;

    pub fn creator_steamid(&self) -> u64 {
        self.creator_steamid.unwrap_or(0)
    }

    pub fn clear_creator_steamid(&mut self) {
        self.creator_steamid = ::std::option::Option::None;
    }

    pub fn has_creator_steamid(&self) -> bool {
        self.creator_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_steamid(&mut self, v: u64) {
        self.creator_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 last_update_steamid = 12;

    pub fn last_update_steamid(&self) -> u64 {
        self.last_update_steamid.unwrap_or(0)
    }

    pub fn clear_last_update_steamid(&mut self) {
        self.last_update_steamid = ::std::option::Option::None;
    }

    pub fn has_last_update_steamid(&self) -> bool {
        self.last_update_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_update_steamid(&mut self, v: u64) {
        self.last_update_steamid = ::std::option::Option::Some(v);
    }

    // optional string event_notes = 13;

    pub fn event_notes(&self) -> &str {
        match self.event_notes.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_notes(&mut self) {
        self.event_notes = ::std::option::Option::None;
    }

    pub fn has_event_notes(&self) -> bool {
        self.event_notes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_notes(&mut self, v: ::std::string::String) {
        self.event_notes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_notes(&mut self) -> &mut ::std::string::String {
        if self.event_notes.is_none() {
            self.event_notes = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_notes.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_notes(&mut self) -> ::std::string::String {
        self.event_notes.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string jsondata = 14;

    pub fn jsondata(&self) -> &str {
        match self.jsondata.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_jsondata(&mut self) {
        self.jsondata = ::std::option::Option::None;
    }

    pub fn has_jsondata(&self) -> bool {
        self.jsondata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jsondata(&mut self, v: ::std::string::String) {
        self.jsondata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jsondata(&mut self) -> &mut ::std::string::String {
        if self.jsondata.is_none() {
            self.jsondata = ::std::option::Option::Some(::std::string::String::new());
        }
        self.jsondata.as_mut().unwrap()
    }

    // Take field
    pub fn take_jsondata(&mut self) -> ::std::string::String {
        self.jsondata.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool published = 16;

    pub fn published(&self) -> bool {
        self.published.unwrap_or(false)
    }

    pub fn clear_published(&mut self) {
        self.published = ::std::option::Option::None;
    }

    pub fn has_published(&self) -> bool {
        self.published.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published(&mut self, v: bool) {
        self.published = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 17;

    pub fn hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }

    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_visibility_start = 18;

    pub fn rtime32_visibility_start(&self) -> u32 {
        self.rtime32_visibility_start.unwrap_or(0)
    }

    pub fn clear_rtime32_visibility_start(&mut self) {
        self.rtime32_visibility_start = ::std::option::Option::None;
    }

    pub fn has_rtime32_visibility_start(&self) -> bool {
        self.rtime32_visibility_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_visibility_start(&mut self, v: u32) {
        self.rtime32_visibility_start = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_visibility_end = 19;

    pub fn rtime32_visibility_end(&self) -> u32 {
        self.rtime32_visibility_end.unwrap_or(0)
    }

    pub fn clear_rtime32_visibility_end(&mut self) {
        self.rtime32_visibility_end = ::std::option::Option::None;
    }

    pub fn has_rtime32_visibility_end(&self) -> bool {
        self.rtime32_visibility_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_visibility_end(&mut self, v: u32) {
        self.rtime32_visibility_end = ::std::option::Option::Some(v);
    }

    // optional uint32 broadcaster_accountid = 20;

    pub fn broadcaster_accountid(&self) -> u32 {
        self.broadcaster_accountid.unwrap_or(0)
    }

    pub fn clear_broadcaster_accountid(&mut self) {
        self.broadcaster_accountid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_accountid(&self) -> bool {
        self.broadcaster_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_accountid(&mut self, v: u32) {
        self.broadcaster_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 follower_count = 21;

    pub fn follower_count(&self) -> u32 {
        self.follower_count.unwrap_or(0)
    }

    pub fn clear_follower_count(&mut self) {
        self.follower_count = ::std::option::Option::None;
    }

    pub fn has_follower_count(&self) -> bool {
        self.follower_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_follower_count(&mut self, v: u32) {
        self.follower_count = ::std::option::Option::Some(v);
    }

    // optional uint32 ignore_count = 22;

    pub fn ignore_count(&self) -> u32 {
        self.ignore_count.unwrap_or(0)
    }

    pub fn clear_ignore_count(&mut self) {
        self.ignore_count = ::std::option::Option::None;
    }

    pub fn has_ignore_count(&self) -> bool {
        self.ignore_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignore_count(&mut self, v: u32) {
        self.ignore_count = ::std::option::Option::Some(v);
    }

    // optional fixed64 forum_topic_id = 23;

    pub fn forum_topic_id(&self) -> u64 {
        self.forum_topic_id.unwrap_or(0)
    }

    pub fn clear_forum_topic_id(&mut self) {
        self.forum_topic_id = ::std::option::Option::None;
    }

    pub fn has_forum_topic_id(&self) -> bool {
        self.forum_topic_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forum_topic_id(&mut self, v: u64) {
        self.forum_topic_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_last_modified = 24;

    pub fn rtime32_last_modified(&self) -> u32 {
        self.rtime32_last_modified.unwrap_or(0)
    }

    pub fn clear_rtime32_last_modified(&mut self) {
        self.rtime32_last_modified = ::std::option::Option::None;
    }

    pub fn has_rtime32_last_modified(&self) -> bool {
        self.rtime32_last_modified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_last_modified(&mut self, v: u32) {
        self.rtime32_last_modified = ::std::option::Option::Some(v);
    }

    // optional fixed64 news_post_gid = 25;

    pub fn news_post_gid(&self) -> u64 {
        self.news_post_gid.unwrap_or(0)
    }

    pub fn clear_news_post_gid(&mut self) {
        self.news_post_gid = ::std::option::Option::None;
    }

    pub fn has_news_post_gid(&self) -> bool {
        self.news_post_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_news_post_gid(&mut self, v: u64) {
        self.news_post_gid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_mod_reviewed = 26;

    pub fn rtime_mod_reviewed(&self) -> u32 {
        self.rtime_mod_reviewed.unwrap_or(0)
    }

    pub fn clear_rtime_mod_reviewed(&mut self) {
        self.rtime_mod_reviewed = ::std::option::Option::None;
    }

    pub fn has_rtime_mod_reviewed(&self) -> bool {
        self.rtime_mod_reviewed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_mod_reviewed(&mut self, v: u32) {
        self.rtime_mod_reviewed = ::std::option::Option::Some(v);
    }

    // optional uint32 featured_app_tagid = 27;

    pub fn featured_app_tagid(&self) -> u32 {
        self.featured_app_tagid.unwrap_or(0)
    }

    pub fn clear_featured_app_tagid(&mut self) {
        self.featured_app_tagid = ::std::option::Option::None;
    }

    pub fn has_featured_app_tagid(&self) -> bool {
        self.featured_app_tagid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featured_app_tagid(&mut self, v: u32) {
        self.featured_app_tagid = ::std::option::Option::Some(v);
    }

    // optional uint32 build_id = 29;

    pub fn build_id(&self) -> u32 {
        self.build_id.unwrap_or(0)
    }

    pub fn clear_build_id(&mut self) {
        self.build_id = ::std::option::Option::None;
    }

    pub fn has_build_id(&self) -> bool {
        self.build_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_id(&mut self, v: u32) {
        self.build_id = ::std::option::Option::Some(v);
    }

    // optional string build_branch = 30;

    pub fn build_branch(&self) -> &str {
        match self.build_branch.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_build_branch(&mut self) {
        self.build_branch = ::std::option::Option::None;
    }

    pub fn has_build_branch(&self) -> bool {
        self.build_branch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_branch(&mut self, v: ::std::string::String) {
        self.build_branch = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_build_branch(&mut self) -> &mut ::std::string::String {
        if self.build_branch.is_none() {
            self.build_branch = ::std::option::Option::Some(::std::string::String::new());
        }
        self.build_branch.as_mut().unwrap()
    }

    // Take field
    pub fn take_build_branch(&mut self) -> ::std::string::String {
        self.build_branch.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CClanEventData {
    const NAME: &'static str = "CClanEventData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.clan_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.event_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.event_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.server_address = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.server_password = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.rtime32_start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.rtime32_end_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.comment_count = ::std::option::Option::Some(is.read_int32()?);
                },
                89 => {
                    self.creator_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                97 => {
                    self.last_update_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                106 => {
                    self.event_notes = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.jsondata = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.announcement_body)?;
                },
                128 => {
                    self.published = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.rtime32_visibility_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.rtime32_visibility_end = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.broadcaster_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.follower_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.ignore_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                185 => {
                    self.forum_topic_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                192 => {
                    self.rtime32_last_modified = ::std::option::Option::Some(is.read_uint32()?);
                },
                201 => {
                    self.news_post_gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                208 => {
                    self.rtime_mod_reviewed = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.featured_app_tagid = ::std::option::Option::Some(is.read_uint32()?);
                },
                226 => {
                    is.read_repeated_packed_uint32_into(&mut self.referenced_appids)?;
                },
                224 => {
                    self.referenced_appids.push(is.read_uint32()?);
                },
                232 => {
                    self.build_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                242 => {
                    self.build_branch = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.clan_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.event_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.server_address.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.server_password.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.rtime32_start_time {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.rtime32_end_time {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.comment_count {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.creator_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.last_update_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.event_notes.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.jsondata.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.announcement_body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.published {
            my_size += 2 + 1;
        }
        if let Some(v) = self.hidden {
            my_size += 2 + 1;
        }
        if let Some(v) = self.rtime32_visibility_start {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.rtime32_visibility_end {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.broadcaster_accountid {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.follower_count {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.ignore_count {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.forum_topic_id {
            my_size += 2 + 8;
        }
        if let Some(v) = self.rtime32_last_modified {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.news_post_gid {
            my_size += 2 + 8;
        }
        if let Some(v) = self.rtime_mod_reviewed {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.featured_app_tagid {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        for value in &self.referenced_appids {
            my_size += ::protobuf::rt::uint32_size(28, *value);
        };
        if let Some(v) = self.build_id {
            my_size += ::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.build_branch.as_ref() {
            my_size += ::protobuf::rt::string_size(30, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.clan_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.event_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.server_address.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.server_password.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.rtime32_start_time {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.rtime32_end_time {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.comment_count {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.creator_steamid {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.last_update_steamid {
            os.write_fixed64(12, v)?;
        }
        if let Some(v) = self.event_notes.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.jsondata.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.announcement_body.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.published {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.rtime32_visibility_start {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.rtime32_visibility_end {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.broadcaster_accountid {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.follower_count {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.ignore_count {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.forum_topic_id {
            os.write_fixed64(23, v)?;
        }
        if let Some(v) = self.rtime32_last_modified {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.news_post_gid {
            os.write_fixed64(25, v)?;
        }
        if let Some(v) = self.rtime_mod_reviewed {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.featured_app_tagid {
            os.write_uint32(27, v)?;
        }
        for v in &self.referenced_appids {
            os.write_uint32(28, *v)?;
        };
        if let Some(v) = self.build_id {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.build_branch.as_ref() {
            os.write_string(30, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanEventData {
        CClanEventData::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.clan_steamid = ::std::option::Option::None;
        self.event_name = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.server_address = ::std::option::Option::None;
        self.server_password = ::std::option::Option::None;
        self.rtime32_start_time = ::std::option::Option::None;
        self.rtime32_end_time = ::std::option::Option::None;
        self.comment_count = ::std::option::Option::None;
        self.creator_steamid = ::std::option::Option::None;
        self.last_update_steamid = ::std::option::Option::None;
        self.event_notes = ::std::option::Option::None;
        self.jsondata = ::std::option::Option::None;
        self.announcement_body.clear();
        self.published = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.rtime32_visibility_start = ::std::option::Option::None;
        self.rtime32_visibility_end = ::std::option::Option::None;
        self.broadcaster_accountid = ::std::option::Option::None;
        self.follower_count = ::std::option::Option::None;
        self.ignore_count = ::std::option::Option::None;
        self.forum_topic_id = ::std::option::Option::None;
        self.rtime32_last_modified = ::std::option::Option::None;
        self.news_post_gid = ::std::option::Option::None;
        self.rtime_mod_reviewed = ::std::option::Option::None;
        self.featured_app_tagid = ::std::option::Option::None;
        self.referenced_appids.clear();
        self.build_id = ::std::option::Option::None;
        self.build_branch = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanEventData {
        static instance: CClanEventData = CClanEventData {
            gid: ::std::option::Option::None,
            clan_steamid: ::std::option::Option::None,
            event_name: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            server_address: ::std::option::Option::None,
            server_password: ::std::option::Option::None,
            rtime32_start_time: ::std::option::Option::None,
            rtime32_end_time: ::std::option::Option::None,
            comment_count: ::std::option::Option::None,
            creator_steamid: ::std::option::Option::None,
            last_update_steamid: ::std::option::Option::None,
            event_notes: ::std::option::Option::None,
            jsondata: ::std::option::Option::None,
            announcement_body: ::protobuf::MessageField::none(),
            published: ::std::option::Option::None,
            hidden: ::std::option::Option::None,
            rtime32_visibility_start: ::std::option::Option::None,
            rtime32_visibility_end: ::std::option::Option::None,
            broadcaster_accountid: ::std::option::Option::None,
            follower_count: ::std::option::Option::None,
            ignore_count: ::std::option::Option::None,
            forum_topic_id: ::std::option::Option::None,
            rtime32_last_modified: ::std::option::Option::None,
            news_post_gid: ::std::option::Option::None,
            rtime_mod_reviewed: ::std::option::Option::None,
            featured_app_tagid: ::std::option::Option::None,
            referenced_appids: ::std::vec::Vec::new(),
            build_id: ::std::option::Option::None,
            build_branch: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CBilling_Address)
pub struct CBilling_Address {
    // message fields
    // @@protoc_insertion_point(field:CBilling_Address.first_name)
    pub first_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.last_name)
    pub last_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.address1)
    pub address1: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.address2)
    pub address2: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.city)
    pub city: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.us_state)
    pub us_state: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.postcode)
    pub postcode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.zip_plus4)
    pub zip_plus4: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBilling_Address.phone)
    pub phone: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBilling_Address.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBilling_Address {
    fn default() -> &'a CBilling_Address {
        <CBilling_Address as ::protobuf::Message>::default_instance()
    }
}

impl CBilling_Address {
    pub fn new() -> CBilling_Address {
        ::std::default::Default::default()
    }

    // optional string first_name = 1;

    pub fn first_name(&self) -> &str {
        match self.first_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_first_name(&mut self) {
        self.first_name = ::std::option::Option::None;
    }

    pub fn has_first_name(&self) -> bool {
        self.first_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_name(&mut self, v: ::std::string::String) {
        self.first_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_first_name(&mut self) -> &mut ::std::string::String {
        if self.first_name.is_none() {
            self.first_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.first_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_first_name(&mut self) -> ::std::string::String {
        self.first_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string last_name = 2;

    pub fn last_name(&self) -> &str {
        match self.last_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_last_name(&mut self) {
        self.last_name = ::std::option::Option::None;
    }

    pub fn has_last_name(&self) -> bool {
        self.last_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_name(&mut self, v: ::std::string::String) {
        self.last_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_name(&mut self) -> &mut ::std::string::String {
        if self.last_name.is_none() {
            self.last_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.last_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_name(&mut self) -> ::std::string::String {
        self.last_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address1 = 3;

    pub fn address1(&self) -> &str {
        match self.address1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_address1(&mut self) {
        self.address1 = ::std::option::Option::None;
    }

    pub fn has_address1(&self) -> bool {
        self.address1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address1(&mut self, v: ::std::string::String) {
        self.address1 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address1(&mut self) -> &mut ::std::string::String {
        if self.address1.is_none() {
            self.address1 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.address1.as_mut().unwrap()
    }

    // Take field
    pub fn take_address1(&mut self) -> ::std::string::String {
        self.address1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address2 = 4;

    pub fn address2(&self) -> &str {
        match self.address2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_address2(&mut self) {
        self.address2 = ::std::option::Option::None;
    }

    pub fn has_address2(&self) -> bool {
        self.address2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address2(&mut self, v: ::std::string::String) {
        self.address2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address2(&mut self) -> &mut ::std::string::String {
        if self.address2.is_none() {
            self.address2 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.address2.as_mut().unwrap()
    }

    // Take field
    pub fn take_address2(&mut self) -> ::std::string::String {
        self.address2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string city = 5;

    pub fn city(&self) -> &str {
        match self.city.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_city(&mut self) {
        self.city = ::std::option::Option::None;
    }

    pub fn has_city(&self) -> bool {
        self.city.is_some()
    }

    // Param is passed by value, moved
    pub fn set_city(&mut self, v: ::std::string::String) {
        self.city = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_city(&mut self) -> &mut ::std::string::String {
        if self.city.is_none() {
            self.city = ::std::option::Option::Some(::std::string::String::new());
        }
        self.city.as_mut().unwrap()
    }

    // Take field
    pub fn take_city(&mut self) -> ::std::string::String {
        self.city.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string us_state = 6;

    pub fn us_state(&self) -> &str {
        match self.us_state.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_us_state(&mut self) {
        self.us_state = ::std::option::Option::None;
    }

    pub fn has_us_state(&self) -> bool {
        self.us_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_us_state(&mut self, v: ::std::string::String) {
        self.us_state = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_us_state(&mut self) -> &mut ::std::string::String {
        if self.us_state.is_none() {
            self.us_state = ::std::option::Option::Some(::std::string::String::new());
        }
        self.us_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_us_state(&mut self) -> ::std::string::String {
        self.us_state.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string country_code = 7;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string postcode = 8;

    pub fn postcode(&self) -> &str {
        match self.postcode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_postcode(&mut self) {
        self.postcode = ::std::option::Option::None;
    }

    pub fn has_postcode(&self) -> bool {
        self.postcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postcode(&mut self, v: ::std::string::String) {
        self.postcode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postcode(&mut self) -> &mut ::std::string::String {
        if self.postcode.is_none() {
            self.postcode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.postcode.as_mut().unwrap()
    }

    // Take field
    pub fn take_postcode(&mut self) -> ::std::string::String {
        self.postcode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 zip_plus4 = 9;

    pub fn zip_plus4(&self) -> i32 {
        self.zip_plus4.unwrap_or(0)
    }

    pub fn clear_zip_plus4(&mut self) {
        self.zip_plus4 = ::std::option::Option::None;
    }

    pub fn has_zip_plus4(&self) -> bool {
        self.zip_plus4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zip_plus4(&mut self, v: i32) {
        self.zip_plus4 = ::std::option::Option::Some(v);
    }

    // optional string phone = 10;

    pub fn phone(&self) -> &str {
        match self.phone.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phone(&mut self) {
        self.phone = ::std::option::Option::None;
    }

    pub fn has_phone(&self) -> bool {
        self.phone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phone(&mut self, v: ::std::string::String) {
        self.phone = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phone(&mut self) -> &mut ::std::string::String {
        if self.phone.is_none() {
            self.phone = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phone.as_mut().unwrap()
    }

    // Take field
    pub fn take_phone(&mut self) -> ::std::string::String {
        self.phone.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBilling_Address {
    const NAME: &'static str = "CBilling_Address";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.first_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.last_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.address1 = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.address2 = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.city = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.us_state = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.postcode = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.zip_plus4 = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.phone = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.first_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.last_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.address1.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.address2.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.city.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.us_state.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.postcode.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.zip_plus4 {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.phone.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.first_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.last_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.address1.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.address2.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.city.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.us_state.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.postcode.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.zip_plus4 {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.phone.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBilling_Address {
        CBilling_Address::new()
    }

    fn clear(&mut self) {
        self.first_name = ::std::option::Option::None;
        self.last_name = ::std::option::Option::None;
        self.address1 = ::std::option::Option::None;
        self.address2 = ::std::option::Option::None;
        self.city = ::std::option::Option::None;
        self.us_state = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.postcode = ::std::option::Option::None;
        self.zip_plus4 = ::std::option::Option::None;
        self.phone = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBilling_Address {
        static instance: CBilling_Address = CBilling_Address {
            first_name: ::std::option::Option::None,
            last_name: ::std::option::Option::None,
            address1: ::std::option::Option::None,
            address2: ::std::option::Option::None,
            city: ::std::option::Option::None,
            us_state: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            postcode: ::std::option::Option::None,
            zip_plus4: ::std::option::Option::None,
            phone: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CPackageReservationStatus)
pub struct CPackageReservationStatus {
    // message fields
    // @@protoc_insertion_point(field:CPackageReservationStatus.packageid)
    pub packageid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.reservation_state)
    pub reservation_state: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.queue_position)
    pub queue_position: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.total_queue_size)
    pub total_queue_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.reservation_country_code)
    pub reservation_country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.expired)
    pub expired: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.time_expires)
    pub time_expires: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.time_reserved)
    pub time_reserved: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CPackageReservationStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CPackageReservationStatus {
    fn default() -> &'a CPackageReservationStatus {
        <CPackageReservationStatus as ::protobuf::Message>::default_instance()
    }
}

impl CPackageReservationStatus {
    pub fn new() -> CPackageReservationStatus {
        ::std::default::Default::default()
    }

    // optional uint32 packageid = 1;

    pub fn packageid(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }

    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    // optional int32 reservation_state = 2;

    pub fn reservation_state(&self) -> i32 {
        self.reservation_state.unwrap_or(0)
    }

    pub fn clear_reservation_state(&mut self) {
        self.reservation_state = ::std::option::Option::None;
    }

    pub fn has_reservation_state(&self) -> bool {
        self.reservation_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_state(&mut self, v: i32) {
        self.reservation_state = ::std::option::Option::Some(v);
    }

    // optional int32 queue_position = 3;

    pub fn queue_position(&self) -> i32 {
        self.queue_position.unwrap_or(0)
    }

    pub fn clear_queue_position(&mut self) {
        self.queue_position = ::std::option::Option::None;
    }

    pub fn has_queue_position(&self) -> bool {
        self.queue_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_position(&mut self, v: i32) {
        self.queue_position = ::std::option::Option::Some(v);
    }

    // optional int32 total_queue_size = 4;

    pub fn total_queue_size(&self) -> i32 {
        self.total_queue_size.unwrap_or(0)
    }

    pub fn clear_total_queue_size(&mut self) {
        self.total_queue_size = ::std::option::Option::None;
    }

    pub fn has_total_queue_size(&self) -> bool {
        self.total_queue_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_queue_size(&mut self, v: i32) {
        self.total_queue_size = ::std::option::Option::Some(v);
    }

    // optional string reservation_country_code = 5;

    pub fn reservation_country_code(&self) -> &str {
        match self.reservation_country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reservation_country_code(&mut self) {
        self.reservation_country_code = ::std::option::Option::None;
    }

    pub fn has_reservation_country_code(&self) -> bool {
        self.reservation_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_country_code(&mut self, v: ::std::string::String) {
        self.reservation_country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation_country_code(&mut self) -> &mut ::std::string::String {
        if self.reservation_country_code.is_none() {
            self.reservation_country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reservation_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation_country_code(&mut self) -> ::std::string::String {
        self.reservation_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool expired = 6;

    pub fn expired(&self) -> bool {
        self.expired.unwrap_or(false)
    }

    pub fn clear_expired(&mut self) {
        self.expired = ::std::option::Option::None;
    }

    pub fn has_expired(&self) -> bool {
        self.expired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expired(&mut self, v: bool) {
        self.expired = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expires = 7;

    pub fn time_expires(&self) -> u32 {
        self.time_expires.unwrap_or(0)
    }

    pub fn clear_time_expires(&mut self) {
        self.time_expires = ::std::option::Option::None;
    }

    pub fn has_time_expires(&self) -> bool {
        self.time_expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expires(&mut self, v: u32) {
        self.time_expires = ::std::option::Option::Some(v);
    }

    // optional uint32 time_reserved = 8;

    pub fn time_reserved(&self) -> u32 {
        self.time_reserved.unwrap_or(0)
    }

    pub fn clear_time_reserved(&mut self) {
        self.time_reserved = ::std::option::Option::None;
    }

    pub fn has_time_reserved(&self) -> bool {
        self.time_reserved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_reserved(&mut self, v: u32) {
        self.time_reserved = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPackageReservationStatus {
    const NAME: &'static str = "CPackageReservationStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reservation_state = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.queue_position = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.total_queue_size = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.reservation_country_code = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.expired = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.time_expires = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.time_reserved = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.packageid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reservation_state {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.queue_position {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.total_queue_size {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.reservation_country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.expired {
            my_size += 1 + 1;
        }
        if let Some(v) = self.time_expires {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.time_reserved {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.packageid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reservation_state {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.queue_position {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.total_queue_size {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.reservation_country_code.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.expired {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.time_expires {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.time_reserved {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CPackageReservationStatus {
        CPackageReservationStatus::new()
    }

    fn clear(&mut self) {
        self.packageid = ::std::option::Option::None;
        self.reservation_state = ::std::option::Option::None;
        self.queue_position = ::std::option::Option::None;
        self.total_queue_size = ::std::option::Option::None;
        self.reservation_country_code = ::std::option::Option::None;
        self.expired = ::std::option::Option::None;
        self.time_expires = ::std::option::Option::None;
        self.time_reserved = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CPackageReservationStatus {
        static instance: CPackageReservationStatus = CPackageReservationStatus {
            packageid: ::std::option::Option::None,
            reservation_state: ::std::option::Option::None,
            queue_position: ::std::option::Option::None,
            total_queue_size: ::std::option::Option::None,
            reservation_country_code: ::std::option::Option::None,
            expired: ::std::option::Option::None,
            time_expires: ::std::option::Option::None,
            time_reserved: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgKeyValuePair)
pub struct CMsgKeyValuePair {
    // message fields
    // @@protoc_insertion_point(field:CMsgKeyValuePair.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgKeyValuePair.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKeyValuePair.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKeyValuePair {
    fn default() -> &'a CMsgKeyValuePair {
        <CMsgKeyValuePair as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKeyValuePair {
    pub fn new() -> CMsgKeyValuePair {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgKeyValuePair {
    const NAME: &'static str = "CMsgKeyValuePair";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKeyValuePair {
        CMsgKeyValuePair::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKeyValuePair {
        static instance: CMsgKeyValuePair = CMsgKeyValuePair {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgKeyValueSet)
pub struct CMsgKeyValueSet {
    // message fields
    // @@protoc_insertion_point(field:CMsgKeyValueSet.pairs)
    pub pairs: ::std::vec::Vec<CMsgKeyValuePair>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKeyValueSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKeyValueSet {
    fn default() -> &'a CMsgKeyValueSet {
        <CMsgKeyValueSet as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKeyValueSet {
    pub fn new() -> CMsgKeyValueSet {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgKeyValueSet {
    const NAME: &'static str = "CMsgKeyValueSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pairs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pairs {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKeyValueSet {
        CMsgKeyValueSet::new()
    }

    fn clear(&mut self) {
        self.pairs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKeyValueSet {
        static instance: CMsgKeyValueSet = CMsgKeyValueSet {
            pairs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:UserContentDescriptorPreferences)
pub struct UserContentDescriptorPreferences {
    // message fields
    // @@protoc_insertion_point(field:UserContentDescriptorPreferences.content_descriptors_to_exclude)
    pub content_descriptors_to_exclude: ::std::vec::Vec<user_content_descriptor_preferences::ContentDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:UserContentDescriptorPreferences.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserContentDescriptorPreferences {
    fn default() -> &'a UserContentDescriptorPreferences {
        <UserContentDescriptorPreferences as ::protobuf::Message>::default_instance()
    }
}

impl UserContentDescriptorPreferences {
    pub fn new() -> UserContentDescriptorPreferences {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UserContentDescriptorPreferences {
    const NAME: &'static str = "UserContentDescriptorPreferences";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.content_descriptors_to_exclude.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.content_descriptors_to_exclude {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.content_descriptors_to_exclude {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserContentDescriptorPreferences {
        UserContentDescriptorPreferences::new()
    }

    fn clear(&mut self) {
        self.content_descriptors_to_exclude.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserContentDescriptorPreferences {
        static instance: UserContentDescriptorPreferences = UserContentDescriptorPreferences {
            content_descriptors_to_exclude: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `UserContentDescriptorPreferences`
pub mod user_content_descriptor_preferences {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:UserContentDescriptorPreferences.ContentDescriptor)
    pub struct ContentDescriptor {
        // message fields
        // @@protoc_insertion_point(field:UserContentDescriptorPreferences.ContentDescriptor.content_descriptorid)
        pub content_descriptorid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:UserContentDescriptorPreferences.ContentDescriptor.timestamp_added)
        pub timestamp_added: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:UserContentDescriptorPreferences.ContentDescriptor.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ContentDescriptor {
        fn default() -> &'a ContentDescriptor {
            <ContentDescriptor as ::protobuf::Message>::default_instance()
        }
    }

    impl ContentDescriptor {
        pub fn new() -> ContentDescriptor {
            ::std::default::Default::default()
        }

        // optional uint32 content_descriptorid = 1;

        pub fn content_descriptorid(&self) -> u32 {
            self.content_descriptorid.unwrap_or(0)
        }

        pub fn clear_content_descriptorid(&mut self) {
            self.content_descriptorid = ::std::option::Option::None;
        }

        pub fn has_content_descriptorid(&self) -> bool {
            self.content_descriptorid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_content_descriptorid(&mut self, v: u32) {
            self.content_descriptorid = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp_added = 2;

        pub fn timestamp_added(&self) -> u32 {
            self.timestamp_added.unwrap_or(0)
        }

        pub fn clear_timestamp_added(&mut self) {
            self.timestamp_added = ::std::option::Option::None;
        }

        pub fn has_timestamp_added(&self) -> bool {
            self.timestamp_added.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp_added(&mut self, v: u32) {
            self.timestamp_added = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ContentDescriptor {
        const NAME: &'static str = "ContentDescriptor";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.content_descriptorid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.timestamp_added = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.content_descriptorid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.timestamp_added {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.content_descriptorid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.timestamp_added {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ContentDescriptor {
            ContentDescriptor::new()
        }

        fn clear(&mut self) {
            self.content_descriptorid = ::std::option::Option::None;
            self.timestamp_added = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ContentDescriptor {
            static instance: ContentDescriptor = ContentDescriptor {
                content_descriptorid: ::std::option::Option::None,
                timestamp_added: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBanContentCheckResult)
pub enum EBanContentCheckResult {
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_NotScanned)
    k_EBanContentCheckResult_NotScanned = 0,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_Reset)
    k_EBanContentCheckResult_Reset = 1,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_NeedsChecking)
    k_EBanContentCheckResult_NeedsChecking = 2,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_VeryUnlikely)
    k_EBanContentCheckResult_VeryUnlikely = 5,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_Unlikely)
    k_EBanContentCheckResult_Unlikely = 30,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_Possible)
    k_EBanContentCheckResult_Possible = 50,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_Likely)
    k_EBanContentCheckResult_Likely = 75,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_VeryLikely)
    k_EBanContentCheckResult_VeryLikely = 100,
}

impl ::protobuf::Enum for EBanContentCheckResult {
    const NAME: &'static str = "EBanContentCheckResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBanContentCheckResult> {
        match value {
            0 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_NotScanned),
            1 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Reset),
            2 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_NeedsChecking),
            5 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_VeryUnlikely),
            30 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Unlikely),
            50 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Possible),
            75 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Likely),
            100 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_VeryLikely),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBanContentCheckResult] = &[
        EBanContentCheckResult::k_EBanContentCheckResult_NotScanned,
        EBanContentCheckResult::k_EBanContentCheckResult_Reset,
        EBanContentCheckResult::k_EBanContentCheckResult_NeedsChecking,
        EBanContentCheckResult::k_EBanContentCheckResult_VeryUnlikely,
        EBanContentCheckResult::k_EBanContentCheckResult_Unlikely,
        EBanContentCheckResult::k_EBanContentCheckResult_Possible,
        EBanContentCheckResult::k_EBanContentCheckResult_Likely,
        EBanContentCheckResult::k_EBanContentCheckResult_VeryLikely,
    ];
}

impl ::std::default::Default for EBanContentCheckResult {
    fn default() -> Self {
        EBanContentCheckResult::k_EBanContentCheckResult_NotScanned
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EProtoClanEventType)
pub enum EProtoClanEventType {
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanOtherEvent)
    k_EClanOtherEvent = 1,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanGameEvent)
    k_EClanGameEvent = 2,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanPartyEvent)
    k_EClanPartyEvent = 3,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanMeetingEvent)
    k_EClanMeetingEvent = 4,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanSpecialCauseEvent)
    k_EClanSpecialCauseEvent = 5,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanMusicAndArtsEvent)
    k_EClanMusicAndArtsEvent = 6,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanSportsEvent)
    k_EClanSportsEvent = 7,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanTripEvent)
    k_EClanTripEvent = 8,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanChatEvent)
    k_EClanChatEvent = 9,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanGameReleaseEvent)
    k_EClanGameReleaseEvent = 10,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanBroadcastEvent)
    k_EClanBroadcastEvent = 11,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanSmallUpdateEvent)
    k_EClanSmallUpdateEvent = 12,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanPreAnnounceMajorUpdateEvent)
    k_EClanPreAnnounceMajorUpdateEvent = 13,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanMajorUpdateEvent)
    k_EClanMajorUpdateEvent = 14,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanDLCReleaseEvent)
    k_EClanDLCReleaseEvent = 15,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanFutureReleaseEvent)
    k_EClanFutureReleaseEvent = 16,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanESportTournamentStreamEvent)
    k_EClanESportTournamentStreamEvent = 17,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanDevStreamEvent)
    k_EClanDevStreamEvent = 18,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanFamousStreamEvent)
    k_EClanFamousStreamEvent = 19,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanGameSalesEvent)
    k_EClanGameSalesEvent = 20,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanGameItemSalesEvent)
    k_EClanGameItemSalesEvent = 21,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameBonusXPEvent)
    k_EClanInGameBonusXPEvent = 22,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameLootEvent)
    k_EClanInGameLootEvent = 23,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGamePerksEvent)
    k_EClanInGamePerksEvent = 24,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameChallengeEvent)
    k_EClanInGameChallengeEvent = 25,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameContestEvent)
    k_EClanInGameContestEvent = 26,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanIRLEvent)
    k_EClanIRLEvent = 27,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanNewsEvent)
    k_EClanNewsEvent = 28,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanBetaReleaseEvent)
    k_EClanBetaReleaseEvent = 29,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameContentReleaseEvent)
    k_EClanInGameContentReleaseEvent = 30,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanFreeTrial)
    k_EClanFreeTrial = 31,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanSeasonRelease)
    k_EClanSeasonRelease = 32,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanSeasonUpdate)
    k_EClanSeasonUpdate = 33,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanCrosspostEvent)
    k_EClanCrosspostEvent = 34,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameEventGeneral)
    k_EClanInGameEventGeneral = 35,
}

impl ::protobuf::Enum for EProtoClanEventType {
    const NAME: &'static str = "EProtoClanEventType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProtoClanEventType> {
        match value {
            1 => ::std::option::Option::Some(EProtoClanEventType::k_EClanOtherEvent),
            2 => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameEvent),
            3 => ::std::option::Option::Some(EProtoClanEventType::k_EClanPartyEvent),
            4 => ::std::option::Option::Some(EProtoClanEventType::k_EClanMeetingEvent),
            5 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSpecialCauseEvent),
            6 => ::std::option::Option::Some(EProtoClanEventType::k_EClanMusicAndArtsEvent),
            7 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSportsEvent),
            8 => ::std::option::Option::Some(EProtoClanEventType::k_EClanTripEvent),
            9 => ::std::option::Option::Some(EProtoClanEventType::k_EClanChatEvent),
            10 => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameReleaseEvent),
            11 => ::std::option::Option::Some(EProtoClanEventType::k_EClanBroadcastEvent),
            12 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSmallUpdateEvent),
            13 => ::std::option::Option::Some(EProtoClanEventType::k_EClanPreAnnounceMajorUpdateEvent),
            14 => ::std::option::Option::Some(EProtoClanEventType::k_EClanMajorUpdateEvent),
            15 => ::std::option::Option::Some(EProtoClanEventType::k_EClanDLCReleaseEvent),
            16 => ::std::option::Option::Some(EProtoClanEventType::k_EClanFutureReleaseEvent),
            17 => ::std::option::Option::Some(EProtoClanEventType::k_EClanESportTournamentStreamEvent),
            18 => ::std::option::Option::Some(EProtoClanEventType::k_EClanDevStreamEvent),
            19 => ::std::option::Option::Some(EProtoClanEventType::k_EClanFamousStreamEvent),
            20 => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameSalesEvent),
            21 => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameItemSalesEvent),
            22 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameBonusXPEvent),
            23 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameLootEvent),
            24 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGamePerksEvent),
            25 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameChallengeEvent),
            26 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameContestEvent),
            27 => ::std::option::Option::Some(EProtoClanEventType::k_EClanIRLEvent),
            28 => ::std::option::Option::Some(EProtoClanEventType::k_EClanNewsEvent),
            29 => ::std::option::Option::Some(EProtoClanEventType::k_EClanBetaReleaseEvent),
            30 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameContentReleaseEvent),
            31 => ::std::option::Option::Some(EProtoClanEventType::k_EClanFreeTrial),
            32 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSeasonRelease),
            33 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSeasonUpdate),
            34 => ::std::option::Option::Some(EProtoClanEventType::k_EClanCrosspostEvent),
            35 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameEventGeneral),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EProtoClanEventType] = &[
        EProtoClanEventType::k_EClanOtherEvent,
        EProtoClanEventType::k_EClanGameEvent,
        EProtoClanEventType::k_EClanPartyEvent,
        EProtoClanEventType::k_EClanMeetingEvent,
        EProtoClanEventType::k_EClanSpecialCauseEvent,
        EProtoClanEventType::k_EClanMusicAndArtsEvent,
        EProtoClanEventType::k_EClanSportsEvent,
        EProtoClanEventType::k_EClanTripEvent,
        EProtoClanEventType::k_EClanChatEvent,
        EProtoClanEventType::k_EClanGameReleaseEvent,
        EProtoClanEventType::k_EClanBroadcastEvent,
        EProtoClanEventType::k_EClanSmallUpdateEvent,
        EProtoClanEventType::k_EClanPreAnnounceMajorUpdateEvent,
        EProtoClanEventType::k_EClanMajorUpdateEvent,
        EProtoClanEventType::k_EClanDLCReleaseEvent,
        EProtoClanEventType::k_EClanFutureReleaseEvent,
        EProtoClanEventType::k_EClanESportTournamentStreamEvent,
        EProtoClanEventType::k_EClanDevStreamEvent,
        EProtoClanEventType::k_EClanFamousStreamEvent,
        EProtoClanEventType::k_EClanGameSalesEvent,
        EProtoClanEventType::k_EClanGameItemSalesEvent,
        EProtoClanEventType::k_EClanInGameBonusXPEvent,
        EProtoClanEventType::k_EClanInGameLootEvent,
        EProtoClanEventType::k_EClanInGamePerksEvent,
        EProtoClanEventType::k_EClanInGameChallengeEvent,
        EProtoClanEventType::k_EClanInGameContestEvent,
        EProtoClanEventType::k_EClanIRLEvent,
        EProtoClanEventType::k_EClanNewsEvent,
        EProtoClanEventType::k_EClanBetaReleaseEvent,
        EProtoClanEventType::k_EClanInGameContentReleaseEvent,
        EProtoClanEventType::k_EClanFreeTrial,
        EProtoClanEventType::k_EClanSeasonRelease,
        EProtoClanEventType::k_EClanSeasonUpdate,
        EProtoClanEventType::k_EClanCrosspostEvent,
        EProtoClanEventType::k_EClanInGameEventGeneral,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EProtoClanEventType {
    fn default() -> Self {
        EProtoClanEventType::k_EClanOtherEvent
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:PartnerEventNotificationType)
pub enum PartnerEventNotificationType {
    // @@protoc_insertion_point(enum_value:PartnerEventNotificationType.k_EEventStart)
    k_EEventStart = 0,
    // @@protoc_insertion_point(enum_value:PartnerEventNotificationType.k_EEventBroadcastStart)
    k_EEventBroadcastStart = 1,
    // @@protoc_insertion_point(enum_value:PartnerEventNotificationType.k_EEventMatchStart)
    k_EEventMatchStart = 2,
    // @@protoc_insertion_point(enum_value:PartnerEventNotificationType.k_EEventPartnerMaxType)
    k_EEventPartnerMaxType = 3,
}

impl ::protobuf::Enum for PartnerEventNotificationType {
    const NAME: &'static str = "PartnerEventNotificationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartnerEventNotificationType> {
        match value {
            0 => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventStart),
            1 => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventBroadcastStart),
            2 => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventMatchStart),
            3 => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventPartnerMaxType),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PartnerEventNotificationType] = &[
        PartnerEventNotificationType::k_EEventStart,
        PartnerEventNotificationType::k_EEventBroadcastStart,
        PartnerEventNotificationType::k_EEventMatchStart,
        PartnerEventNotificationType::k_EEventPartnerMaxType,
    ];
}

impl ::std::default::Default for PartnerEventNotificationType {
    fn default() -> Self {
        PartnerEventNotificationType::k_EEventStart
    }
}


// Extension generation with lite runtime is not supported
impl crate::RpcMessage for CMsgIPAddress {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgIPAddressBucket {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgGCRoutingProtoBufHeader {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgProtoBufHeader {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgMulti {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgProtobufWrapped {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgAuthTicket {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CCDDBAppDetailCommon {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgAppRights {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CCuratorPreferences {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CLocalizationToken {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClanEventUserNewsTuple {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClanMatchEventByRange {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CCommunity_ClanAnnouncementInfo {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClanEventData {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CBilling_Address {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CPackageReservationStatus {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgKeyValuePair {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CMsgKeyValueSet {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for UserContentDescriptorPreferences {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
