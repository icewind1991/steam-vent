// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_clientnotificationtypes.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CClientNotificationCloudSyncFailure)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationCloudSyncFailure {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationCloudSyncFailure.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationCloudSyncFailure.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationCloudSyncFailure {
    fn default() -> &'a CClientNotificationCloudSyncFailure {
        <CClientNotificationCloudSyncFailure as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationCloudSyncFailure {
    pub fn new() -> CClientNotificationCloudSyncFailure {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationCloudSyncFailure {
    const NAME: &'static str = "CClientNotificationCloudSyncFailure";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationCloudSyncFailure {
        CClientNotificationCloudSyncFailure::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationCloudSyncFailure {
        static instance: CClientNotificationCloudSyncFailure = CClientNotificationCloudSyncFailure {
            appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationCloudSyncConflict)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationCloudSyncConflict {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationCloudSyncConflict.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationCloudSyncConflict.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationCloudSyncConflict {
    fn default() -> &'a CClientNotificationCloudSyncConflict {
        <CClientNotificationCloudSyncConflict as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationCloudSyncConflict {
    pub fn new() -> CClientNotificationCloudSyncConflict {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationCloudSyncConflict {
    const NAME: &'static str = "CClientNotificationCloudSyncConflict";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationCloudSyncConflict {
        CClientNotificationCloudSyncConflict::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationCloudSyncConflict {
        static instance: CClientNotificationCloudSyncConflict = CClientNotificationCloudSyncConflict {
            appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationScreenshot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationScreenshot {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationScreenshot.screenshot_handle)
    pub screenshot_handle: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationScreenshot.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationScreenshot.local_url)
    pub local_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationScreenshot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationScreenshot {
    fn default() -> &'a CClientNotificationScreenshot {
        <CClientNotificationScreenshot as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationScreenshot {
    pub fn new() -> CClientNotificationScreenshot {
        ::std::default::Default::default()
    }

    // optional string screenshot_handle = 1;

    pub fn screenshot_handle(&self) -> &str {
        match self.screenshot_handle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_screenshot_handle(&mut self) {
        self.screenshot_handle = ::std::option::Option::None;
    }

    pub fn has_screenshot_handle(&self) -> bool {
        self.screenshot_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot_handle(&mut self, v: ::std::string::String) {
        self.screenshot_handle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenshot_handle(&mut self) -> &mut ::std::string::String {
        if self.screenshot_handle.is_none() {
            self.screenshot_handle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.screenshot_handle.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenshot_handle(&mut self) -> ::std::string::String {
        self.screenshot_handle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 2;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string local_url = 3;

    pub fn local_url(&self) -> &str {
        match self.local_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_local_url(&mut self) {
        self.local_url = ::std::option::Option::None;
    }

    pub fn has_local_url(&self) -> bool {
        self.local_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_url(&mut self, v: ::std::string::String) {
        self.local_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_url(&mut self) -> &mut ::std::string::String {
        if self.local_url.is_none() {
            self.local_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.local_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_url(&mut self) -> ::std::string::String {
        self.local_url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CClientNotificationScreenshot {
    const NAME: &'static str = "CClientNotificationScreenshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.screenshot_handle = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.local_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.screenshot_handle.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.local_url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.screenshot_handle.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.local_url.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationScreenshot {
        CClientNotificationScreenshot::new()
    }

    fn clear(&mut self) {
        self.screenshot_handle = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.local_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationScreenshot {
        static instance: CClientNotificationScreenshot = CClientNotificationScreenshot {
            screenshot_handle: ::std::option::Option::None,
            description: ::std::option::Option::None,
            local_url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationDownloadCompleted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationDownloadCompleted {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationDownloadCompleted.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationDownloadCompleted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationDownloadCompleted {
    fn default() -> &'a CClientNotificationDownloadCompleted {
        <CClientNotificationDownloadCompleted as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationDownloadCompleted {
    pub fn new() -> CClientNotificationDownloadCompleted {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationDownloadCompleted {
    const NAME: &'static str = "CClientNotificationDownloadCompleted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationDownloadCompleted {
        CClientNotificationDownloadCompleted::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationDownloadCompleted {
        static instance: CClientNotificationDownloadCompleted = CClientNotificationDownloadCompleted {
            appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationFriendInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationFriendInvite {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationFriendInvite.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationFriendInvite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationFriendInvite {
    fn default() -> &'a CClientNotificationFriendInvite {
        <CClientNotificationFriendInvite as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationFriendInvite {
    pub fn new() -> CClientNotificationFriendInvite {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationFriendInvite {
    const NAME: &'static str = "CClientNotificationFriendInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationFriendInvite {
        CClientNotificationFriendInvite::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationFriendInvite {
        static instance: CClientNotificationFriendInvite = CClientNotificationFriendInvite {
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationFriendInviteRollup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationFriendInviteRollup {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationFriendInviteRollup.new_invite_count)
    pub new_invite_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationFriendInviteRollup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationFriendInviteRollup {
    fn default() -> &'a CClientNotificationFriendInviteRollup {
        <CClientNotificationFriendInviteRollup as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationFriendInviteRollup {
    pub fn new() -> CClientNotificationFriendInviteRollup {
        ::std::default::Default::default()
    }

    // optional uint32 new_invite_count = 1;

    pub fn new_invite_count(&self) -> u32 {
        self.new_invite_count.unwrap_or(0)
    }

    pub fn clear_new_invite_count(&mut self) {
        self.new_invite_count = ::std::option::Option::None;
    }

    pub fn has_new_invite_count(&self) -> bool {
        self.new_invite_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_invite_count(&mut self, v: u32) {
        self.new_invite_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationFriendInviteRollup {
    const NAME: &'static str = "CClientNotificationFriendInviteRollup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.new_invite_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_invite_count {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.new_invite_count {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationFriendInviteRollup {
        CClientNotificationFriendInviteRollup::new()
    }

    fn clear(&mut self) {
        self.new_invite_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationFriendInviteRollup {
        static instance: CClientNotificationFriendInviteRollup = CClientNotificationFriendInviteRollup {
            new_invite_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationFriendInGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationFriendInGame {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationFriendInGame.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClientNotificationFriendInGame.game_name)
    pub game_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationFriendInGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationFriendInGame {
    fn default() -> &'a CClientNotificationFriendInGame {
        <CClientNotificationFriendInGame as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationFriendInGame {
    pub fn new() -> CClientNotificationFriendInGame {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string game_name = 2;

    pub fn game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_name(&mut self) {
        self.game_name = ::std::option::Option::None;
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CClientNotificationFriendInGame {
    const NAME: &'static str = "CClientNotificationFriendInGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.game_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.game_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationFriendInGame {
        CClientNotificationFriendInGame::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.game_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationFriendInGame {
        static instance: CClientNotificationFriendInGame = CClientNotificationFriendInGame {
            steamid: ::std::option::Option::None,
            game_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationFriendOnline)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationFriendOnline {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationFriendOnline.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationFriendOnline.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationFriendOnline {
    fn default() -> &'a CClientNotificationFriendOnline {
        <CClientNotificationFriendOnline as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationFriendOnline {
    pub fn new() -> CClientNotificationFriendOnline {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationFriendOnline {
    const NAME: &'static str = "CClientNotificationFriendOnline";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationFriendOnline {
        CClientNotificationFriendOnline::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationFriendOnline {
        static instance: CClientNotificationFriendOnline = CClientNotificationFriendOnline {
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationAchievement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationAchievement {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationAchievement.achievement_id)
    pub achievement_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.image_url)
    pub image_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.achieved)
    pub achieved: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.rtime_unlocked)
    pub rtime_unlocked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.min_progress)
    pub min_progress: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.current_progress)
    pub current_progress: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.max_progress)
    pub max_progress: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CClientNotificationAchievement.global_achieved_pct)
    pub global_achieved_pct: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationAchievement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationAchievement {
    fn default() -> &'a CClientNotificationAchievement {
        <CClientNotificationAchievement as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationAchievement {
    pub fn new() -> CClientNotificationAchievement {
        ::std::default::Default::default()
    }

    // optional string achievement_id = 1;

    pub fn achievement_id(&self) -> &str {
        match self.achievement_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_achievement_id(&mut self) {
        self.achievement_id = ::std::option::Option::None;
    }

    pub fn has_achievement_id(&self) -> bool {
        self.achievement_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement_id(&mut self, v: ::std::string::String) {
        self.achievement_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_achievement_id(&mut self) -> &mut ::std::string::String {
        if self.achievement_id.is_none() {
            self.achievement_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.achievement_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_achievement_id(&mut self) -> ::std::string::String {
        self.achievement_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 4;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string image_url = 5;

    pub fn image_url(&self) -> &str {
        match self.image_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_image_url(&mut self) {
        self.image_url = ::std::option::Option::None;
    }

    pub fn has_image_url(&self) -> bool {
        self.image_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_url(&mut self, v: ::std::string::String) {
        self.image_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_url(&mut self) -> &mut ::std::string::String {
        if self.image_url.is_none() {
            self.image_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.image_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_url(&mut self) -> ::std::string::String {
        self.image_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool achieved = 6;

    pub fn achieved(&self) -> bool {
        self.achieved.unwrap_or(false)
    }

    pub fn clear_achieved(&mut self) {
        self.achieved = ::std::option::Option::None;
    }

    pub fn has_achieved(&self) -> bool {
        self.achieved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achieved(&mut self, v: bool) {
        self.achieved = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_unlocked = 7;

    pub fn rtime_unlocked(&self) -> u32 {
        self.rtime_unlocked.unwrap_or(0)
    }

    pub fn clear_rtime_unlocked(&mut self) {
        self.rtime_unlocked = ::std::option::Option::None;
    }

    pub fn has_rtime_unlocked(&self) -> bool {
        self.rtime_unlocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_unlocked(&mut self, v: u32) {
        self.rtime_unlocked = ::std::option::Option::Some(v);
    }

    // optional float min_progress = 8;

    pub fn min_progress(&self) -> f32 {
        self.min_progress.unwrap_or(0.)
    }

    pub fn clear_min_progress(&mut self) {
        self.min_progress = ::std::option::Option::None;
    }

    pub fn has_min_progress(&self) -> bool {
        self.min_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_progress(&mut self, v: f32) {
        self.min_progress = ::std::option::Option::Some(v);
    }

    // optional float current_progress = 9;

    pub fn current_progress(&self) -> f32 {
        self.current_progress.unwrap_or(0.)
    }

    pub fn clear_current_progress(&mut self) {
        self.current_progress = ::std::option::Option::None;
    }

    pub fn has_current_progress(&self) -> bool {
        self.current_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_progress(&mut self, v: f32) {
        self.current_progress = ::std::option::Option::Some(v);
    }

    // optional float max_progress = 10;

    pub fn max_progress(&self) -> f32 {
        self.max_progress.unwrap_or(0.)
    }

    pub fn clear_max_progress(&mut self) {
        self.max_progress = ::std::option::Option::None;
    }

    pub fn has_max_progress(&self) -> bool {
        self.max_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_progress(&mut self, v: f32) {
        self.max_progress = ::std::option::Option::Some(v);
    }

    // optional float global_achieved_pct = 11;

    pub fn global_achieved_pct(&self) -> f32 {
        self.global_achieved_pct.unwrap_or(0.)
    }

    pub fn clear_global_achieved_pct(&mut self) {
        self.global_achieved_pct = ::std::option::Option::None;
    }

    pub fn has_global_achieved_pct(&self) -> bool {
        self.global_achieved_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_achieved_pct(&mut self, v: f32) {
        self.global_achieved_pct = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationAchievement {
    const NAME: &'static str = "CClientNotificationAchievement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.achievement_id = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.image_url = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.achieved = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.rtime_unlocked = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.min_progress = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.current_progress = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.max_progress = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.global_achieved_pct = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.achievement_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.image_url.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.achieved {
            my_size += 1 + 1;
        }
        if let Some(v) = self.rtime_unlocked {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.min_progress {
            my_size += 1 + 4;
        }
        if let Some(v) = self.current_progress {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_progress {
            my_size += 1 + 4;
        }
        if let Some(v) = self.global_achieved_pct {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.achievement_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.image_url.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.achieved {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.rtime_unlocked {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.min_progress {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.current_progress {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.max_progress {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.global_achieved_pct {
            os.write_float(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationAchievement {
        CClientNotificationAchievement::new()
    }

    fn clear(&mut self) {
        self.achievement_id = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.image_url = ::std::option::Option::None;
        self.achieved = ::std::option::Option::None;
        self.rtime_unlocked = ::std::option::Option::None;
        self.min_progress = ::std::option::Option::None;
        self.current_progress = ::std::option::Option::None;
        self.max_progress = ::std::option::Option::None;
        self.global_achieved_pct = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationAchievement {
        static instance: CClientNotificationAchievement = CClientNotificationAchievement {
            achievement_id: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            description: ::std::option::Option::None,
            image_url: ::std::option::Option::None,
            achieved: ::std::option::Option::None,
            rtime_unlocked: ::std::option::Option::None,
            min_progress: ::std::option::Option::None,
            current_progress: ::std::option::Option::None,
            max_progress: ::std::option::Option::None,
            global_achieved_pct: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationLowBattery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationLowBattery {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationLowBattery.pct_remaining)
    pub pct_remaining: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationLowBattery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationLowBattery {
    fn default() -> &'a CClientNotificationLowBattery {
        <CClientNotificationLowBattery as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationLowBattery {
    pub fn new() -> CClientNotificationLowBattery {
        ::std::default::Default::default()
    }

    // optional float pct_remaining = 1;

    pub fn pct_remaining(&self) -> f32 {
        self.pct_remaining.unwrap_or(0.)
    }

    pub fn clear_pct_remaining(&mut self) {
        self.pct_remaining = ::std::option::Option::None;
    }

    pub fn has_pct_remaining(&self) -> bool {
        self.pct_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pct_remaining(&mut self, v: f32) {
        self.pct_remaining = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationLowBattery {
    const NAME: &'static str = "CClientNotificationLowBattery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.pct_remaining = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pct_remaining {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pct_remaining {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationLowBattery {
        CClientNotificationLowBattery::new()
    }

    fn clear(&mut self) {
        self.pct_remaining = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationLowBattery {
        static instance: CClientNotificationLowBattery = CClientNotificationLowBattery {
            pct_remaining: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationSystemUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationSystemUpdate {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationSystemUpdate.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<ESystemUpdateNotificationType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationSystemUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationSystemUpdate {
    fn default() -> &'a CClientNotificationSystemUpdate {
        <CClientNotificationSystemUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationSystemUpdate {
    pub fn new() -> CClientNotificationSystemUpdate {
        ::std::default::Default::default()
    }

    // optional .ESystemUpdateNotificationType type = 1;

    pub fn type_(&self) -> ESystemUpdateNotificationType {
        match self.type_ {
            Some(e) => e.enum_value_or(ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Invalid),
            None => ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Invalid,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ESystemUpdateNotificationType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CClientNotificationSystemUpdate {
    const NAME: &'static str = "CClientNotificationSystemUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationSystemUpdate {
        CClientNotificationSystemUpdate::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationSystemUpdate {
        static instance: CClientNotificationSystemUpdate = CClientNotificationSystemUpdate {
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationFriendMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationFriendMessage {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationFriendMessage.tag)
    pub tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationFriendMessage.steamid)
    pub steamid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationFriendMessage.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationFriendMessage.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationFriendMessage.icon)
    pub icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationFriendMessage.notificationid)
    pub notificationid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationFriendMessage.response_steamurl)
    pub response_steamurl: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationFriendMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationFriendMessage {
    fn default() -> &'a CClientNotificationFriendMessage {
        <CClientNotificationFriendMessage as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationFriendMessage {
    pub fn new() -> CClientNotificationFriendMessage {
        ::std::default::Default::default()
    }

    // optional string tag = 1;

    pub fn tag(&self) -> &str {
        match self.tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        if self.tag.is_none() {
            self.tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        self.tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string steamid = 2;

    pub fn steamid(&self) -> &str {
        match self.steamid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: ::std::string::String) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_steamid(&mut self) -> &mut ::std::string::String {
        if self.steamid.is_none() {
            self.steamid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.steamid.as_mut().unwrap()
    }

    // Take field
    pub fn take_steamid(&mut self) -> ::std::string::String {
        self.steamid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 3;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string body = 4;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon = 5;

    pub fn icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 notificationid = 6;

    pub fn notificationid(&self) -> u32 {
        self.notificationid.unwrap_or(0)
    }

    pub fn clear_notificationid(&mut self) {
        self.notificationid = ::std::option::Option::None;
    }

    pub fn has_notificationid(&self) -> bool {
        self.notificationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notificationid(&mut self, v: u32) {
        self.notificationid = ::std::option::Option::Some(v);
    }

    // optional string response_steamurl = 7;

    pub fn response_steamurl(&self) -> &str {
        match self.response_steamurl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_response_steamurl(&mut self) {
        self.response_steamurl = ::std::option::Option::None;
    }

    pub fn has_response_steamurl(&self) -> bool {
        self.response_steamurl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_steamurl(&mut self, v: ::std::string::String) {
        self.response_steamurl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response_steamurl(&mut self) -> &mut ::std::string::String {
        if self.response_steamurl.is_none() {
            self.response_steamurl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.response_steamurl.as_mut().unwrap()
    }

    // Take field
    pub fn take_response_steamurl(&mut self) -> ::std::string::String {
        self.response_steamurl.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CClientNotificationFriendMessage {
    const NAME: &'static str = "CClientNotificationFriendMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tag = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.steamid = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.icon = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.notificationid = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.response_steamurl = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tag.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.steamid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.notificationid {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.response_steamurl.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tag.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.steamid.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.notificationid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.response_steamurl.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationFriendMessage {
        CClientNotificationFriendMessage::new()
    }

    fn clear(&mut self) {
        self.tag = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.notificationid = ::std::option::Option::None;
        self.response_steamurl = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationFriendMessage {
        static instance: CClientNotificationFriendMessage = CClientNotificationFriendMessage {
            tag: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            title: ::std::option::Option::None,
            body: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            notificationid: ::std::option::Option::None,
            response_steamurl: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationGroupChatMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationGroupChatMessage {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.tag)
    pub tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.steamid_sender)
    pub steamid_sender: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.chat_group_id)
    pub chat_group_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.chat_id)
    pub chat_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.rawbody)
    pub rawbody: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.icon)
    pub icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationGroupChatMessage.notificationid)
    pub notificationid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationGroupChatMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationGroupChatMessage {
    fn default() -> &'a CClientNotificationGroupChatMessage {
        <CClientNotificationGroupChatMessage as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationGroupChatMessage {
    pub fn new() -> CClientNotificationGroupChatMessage {
        ::std::default::Default::default()
    }

    // optional string tag = 1;

    pub fn tag(&self) -> &str {
        match self.tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        if self.tag.is_none() {
            self.tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        self.tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string steamid_sender = 2;

    pub fn steamid_sender(&self) -> &str {
        match self.steamid_sender.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_steamid_sender(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
    }

    pub fn has_steamid_sender(&self) -> bool {
        self.steamid_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_sender(&mut self, v: ::std::string::String) {
        self.steamid_sender = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_steamid_sender(&mut self) -> &mut ::std::string::String {
        if self.steamid_sender.is_none() {
            self.steamid_sender = ::std::option::Option::Some(::std::string::String::new());
        }
        self.steamid_sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_steamid_sender(&mut self) -> ::std::string::String {
        self.steamid_sender.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string chat_group_id = 3;

    pub fn chat_group_id(&self) -> &str {
        match self.chat_group_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: ::std::string::String) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_id(&mut self) -> &mut ::std::string::String {
        if self.chat_group_id.is_none() {
            self.chat_group_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_group_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_id(&mut self) -> ::std::string::String {
        self.chat_group_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string chat_id = 4;

    pub fn chat_id(&self) -> &str {
        match self.chat_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: ::std::string::String) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_id(&mut self) -> &mut ::std::string::String {
        if self.chat_id.is_none() {
            self.chat_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_id(&mut self) -> ::std::string::String {
        self.chat_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 5;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string body = 6;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string rawbody = 7;

    pub fn rawbody(&self) -> &str {
        match self.rawbody.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rawbody(&mut self) {
        self.rawbody = ::std::option::Option::None;
    }

    pub fn has_rawbody(&self) -> bool {
        self.rawbody.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rawbody(&mut self, v: ::std::string::String) {
        self.rawbody = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rawbody(&mut self) -> &mut ::std::string::String {
        if self.rawbody.is_none() {
            self.rawbody = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rawbody.as_mut().unwrap()
    }

    // Take field
    pub fn take_rawbody(&mut self) -> ::std::string::String {
        self.rawbody.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon = 8;

    pub fn icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 notificationid = 9;

    pub fn notificationid(&self) -> u32 {
        self.notificationid.unwrap_or(0)
    }

    pub fn clear_notificationid(&mut self) {
        self.notificationid = ::std::option::Option::None;
    }

    pub fn has_notificationid(&self) -> bool {
        self.notificationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notificationid(&mut self, v: u32) {
        self.notificationid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationGroupChatMessage {
    const NAME: &'static str = "CClientNotificationGroupChatMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tag = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.steamid_sender = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.chat_id = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.rawbody = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.icon = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.notificationid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tag.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.steamid_sender.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.chat_group_id.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.chat_id.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.rawbody.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.notificationid {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tag.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.steamid_sender.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.chat_group_id.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.chat_id.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.rawbody.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.notificationid {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationGroupChatMessage {
        CClientNotificationGroupChatMessage::new()
    }

    fn clear(&mut self) {
        self.tag = ::std::option::Option::None;
        self.steamid_sender = ::std::option::Option::None;
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.rawbody = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.notificationid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationGroupChatMessage {
        static instance: CClientNotificationGroupChatMessage = CClientNotificationGroupChatMessage {
            tag: ::std::option::Option::None,
            steamid_sender: ::std::option::Option::None,
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            title: ::std::option::Option::None,
            body: ::std::option::Option::None,
            rawbody: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            notificationid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationFamilySharingDeviceAuthorizationChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationFamilySharingDeviceAuthorizationChanged {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationFamilySharingDeviceAuthorizationChanged.accountid_owner)
    pub accountid_owner: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationFamilySharingDeviceAuthorizationChanged.authorized)
    pub authorized: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationFamilySharingDeviceAuthorizationChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationFamilySharingDeviceAuthorizationChanged {
    fn default() -> &'a CClientNotificationFamilySharingDeviceAuthorizationChanged {
        <CClientNotificationFamilySharingDeviceAuthorizationChanged as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationFamilySharingDeviceAuthorizationChanged {
    pub fn new() -> CClientNotificationFamilySharingDeviceAuthorizationChanged {
        ::std::default::Default::default()
    }

    // optional uint32 accountid_owner = 1;

    pub fn accountid_owner(&self) -> u32 {
        self.accountid_owner.unwrap_or(0)
    }

    pub fn clear_accountid_owner(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
    }

    pub fn has_accountid_owner(&self) -> bool {
        self.accountid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_owner(&mut self, v: u32) {
        self.accountid_owner = ::std::option::Option::Some(v);
    }

    // optional bool authorized = 2;

    pub fn authorized(&self) -> bool {
        self.authorized.unwrap_or(false)
    }

    pub fn clear_authorized(&mut self) {
        self.authorized = ::std::option::Option::None;
    }

    pub fn has_authorized(&self) -> bool {
        self.authorized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorized(&mut self, v: bool) {
        self.authorized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationFamilySharingDeviceAuthorizationChanged {
    const NAME: &'static str = "CClientNotificationFamilySharingDeviceAuthorizationChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid_owner = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.authorized = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid_owner {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.authorized {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid_owner {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.authorized {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationFamilySharingDeviceAuthorizationChanged {
        CClientNotificationFamilySharingDeviceAuthorizationChanged::new()
    }

    fn clear(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
        self.authorized = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationFamilySharingDeviceAuthorizationChanged {
        static instance: CClientNotificationFamilySharingDeviceAuthorizationChanged = CClientNotificationFamilySharingDeviceAuthorizationChanged {
            accountid_owner: ::std::option::Option::None,
            authorized: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationFamilySharingStopPlaying)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationFamilySharingStopPlaying {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationFamilySharingStopPlaying.accountid_owner)
    pub accountid_owner: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationFamilySharingStopPlaying.seconds_remaining)
    pub seconds_remaining: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationFamilySharingStopPlaying.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationFamilySharingStopPlaying {
    fn default() -> &'a CClientNotificationFamilySharingStopPlaying {
        <CClientNotificationFamilySharingStopPlaying as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationFamilySharingStopPlaying {
    pub fn new() -> CClientNotificationFamilySharingStopPlaying {
        ::std::default::Default::default()
    }

    // optional uint32 accountid_owner = 1;

    pub fn accountid_owner(&self) -> u32 {
        self.accountid_owner.unwrap_or(0)
    }

    pub fn clear_accountid_owner(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
    }

    pub fn has_accountid_owner(&self) -> bool {
        self.accountid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_owner(&mut self, v: u32) {
        self.accountid_owner = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_remaining = 2;

    pub fn seconds_remaining(&self) -> u32 {
        self.seconds_remaining.unwrap_or(0)
    }

    pub fn clear_seconds_remaining(&mut self) {
        self.seconds_remaining = ::std::option::Option::None;
    }

    pub fn has_seconds_remaining(&self) -> bool {
        self.seconds_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_remaining(&mut self, v: u32) {
        self.seconds_remaining = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationFamilySharingStopPlaying {
    const NAME: &'static str = "CClientNotificationFamilySharingStopPlaying";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid_owner = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.seconds_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid_owner {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.seconds_remaining {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid_owner {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.seconds_remaining {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationFamilySharingStopPlaying {
        CClientNotificationFamilySharingStopPlaying::new()
    }

    fn clear(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
        self.seconds_remaining = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationFamilySharingStopPlaying {
        static instance: CClientNotificationFamilySharingStopPlaying = CClientNotificationFamilySharingStopPlaying {
            accountid_owner: ::std::option::Option::None,
            seconds_remaining: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationFamilySharingLibraryAvailable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationFamilySharingLibraryAvailable {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationFamilySharingLibraryAvailable.accountid_owner)
    pub accountid_owner: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationFamilySharingLibraryAvailable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationFamilySharingLibraryAvailable {
    fn default() -> &'a CClientNotificationFamilySharingLibraryAvailable {
        <CClientNotificationFamilySharingLibraryAvailable as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationFamilySharingLibraryAvailable {
    pub fn new() -> CClientNotificationFamilySharingLibraryAvailable {
        ::std::default::Default::default()
    }

    // optional uint32 accountid_owner = 1;

    pub fn accountid_owner(&self) -> u32 {
        self.accountid_owner.unwrap_or(0)
    }

    pub fn clear_accountid_owner(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
    }

    pub fn has_accountid_owner(&self) -> bool {
        self.accountid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_owner(&mut self, v: u32) {
        self.accountid_owner = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationFamilySharingLibraryAvailable {
    const NAME: &'static str = "CClientNotificationFamilySharingLibraryAvailable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid_owner = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid_owner {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid_owner {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationFamilySharingLibraryAvailable {
        CClientNotificationFamilySharingLibraryAvailable::new()
    }

    fn clear(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationFamilySharingLibraryAvailable {
        static instance: CClientNotificationFamilySharingLibraryAvailable = CClientNotificationFamilySharingLibraryAvailable {
            accountid_owner: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationIncomingVoiceChat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationIncomingVoiceChat {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationIncomingVoiceChat.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationIncomingVoiceChat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationIncomingVoiceChat {
    fn default() -> &'a CClientNotificationIncomingVoiceChat {
        <CClientNotificationIncomingVoiceChat as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationIncomingVoiceChat {
    pub fn new() -> CClientNotificationIncomingVoiceChat {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationIncomingVoiceChat {
    const NAME: &'static str = "CClientNotificationIncomingVoiceChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationIncomingVoiceChat {
        CClientNotificationIncomingVoiceChat::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationIncomingVoiceChat {
        static instance: CClientNotificationIncomingVoiceChat = CClientNotificationIncomingVoiceChat {
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationClaimSteamDeckRewards)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationClaimSteamDeckRewards {
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationClaimSteamDeckRewards.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationClaimSteamDeckRewards {
    fn default() -> &'a CClientNotificationClaimSteamDeckRewards {
        <CClientNotificationClaimSteamDeckRewards as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationClaimSteamDeckRewards {
    pub fn new() -> CClientNotificationClaimSteamDeckRewards {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CClientNotificationClaimSteamDeckRewards {
    const NAME: &'static str = "CClientNotificationClaimSteamDeckRewards";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationClaimSteamDeckRewards {
        CClientNotificationClaimSteamDeckRewards::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationClaimSteamDeckRewards {
        static instance: CClientNotificationClaimSteamDeckRewards = CClientNotificationClaimSteamDeckRewards {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationGiftReceived)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationGiftReceived {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationGiftReceived.sender_name)
    pub sender_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationGiftReceived.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationGiftReceived {
    fn default() -> &'a CClientNotificationGiftReceived {
        <CClientNotificationGiftReceived as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationGiftReceived {
    pub fn new() -> CClientNotificationGiftReceived {
        ::std::default::Default::default()
    }

    // optional string sender_name = 1;

    pub fn sender_name(&self) -> &str {
        match self.sender_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sender_name(&mut self) {
        self.sender_name = ::std::option::Option::None;
    }

    pub fn has_sender_name(&self) -> bool {
        self.sender_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_name(&mut self, v: ::std::string::String) {
        self.sender_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_name(&mut self) -> &mut ::std::string::String {
        if self.sender_name.is_none() {
            self.sender_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sender_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_name(&mut self) -> ::std::string::String {
        self.sender_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CClientNotificationGiftReceived {
    const NAME: &'static str = "CClientNotificationGiftReceived";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sender_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sender_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sender_name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationGiftReceived {
        CClientNotificationGiftReceived::new()
    }

    fn clear(&mut self) {
        self.sender_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationGiftReceived {
        static instance: CClientNotificationGiftReceived = CClientNotificationGiftReceived {
            sender_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationItemAnnouncement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationItemAnnouncement {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationItemAnnouncement.new_item_count)
    pub new_item_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationItemAnnouncement.new_backpack_items)
    pub new_backpack_items: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationItemAnnouncement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationItemAnnouncement {
    fn default() -> &'a CClientNotificationItemAnnouncement {
        <CClientNotificationItemAnnouncement as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationItemAnnouncement {
    pub fn new() -> CClientNotificationItemAnnouncement {
        ::std::default::Default::default()
    }

    // optional uint32 new_item_count = 1;

    pub fn new_item_count(&self) -> u32 {
        self.new_item_count.unwrap_or(0)
    }

    pub fn clear_new_item_count(&mut self) {
        self.new_item_count = ::std::option::Option::None;
    }

    pub fn has_new_item_count(&self) -> bool {
        self.new_item_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_item_count(&mut self, v: u32) {
        self.new_item_count = ::std::option::Option::Some(v);
    }

    // optional bool new_backpack_items = 2;

    pub fn new_backpack_items(&self) -> bool {
        self.new_backpack_items.unwrap_or(false)
    }

    pub fn clear_new_backpack_items(&mut self) {
        self.new_backpack_items = ::std::option::Option::None;
    }

    pub fn has_new_backpack_items(&self) -> bool {
        self.new_backpack_items.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_backpack_items(&mut self, v: bool) {
        self.new_backpack_items = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationItemAnnouncement {
    const NAME: &'static str = "CClientNotificationItemAnnouncement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.new_item_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.new_backpack_items = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_item_count {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.new_backpack_items {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.new_item_count {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.new_backpack_items {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationItemAnnouncement {
        CClientNotificationItemAnnouncement::new()
    }

    fn clear(&mut self) {
        self.new_item_count = ::std::option::Option::None;
        self.new_backpack_items = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationItemAnnouncement {
        static instance: CClientNotificationItemAnnouncement = CClientNotificationItemAnnouncement {
            new_item_count: ::std::option::Option::None,
            new_backpack_items: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationHardwareSurveyPending)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationHardwareSurveyPending {
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationHardwareSurveyPending.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationHardwareSurveyPending {
    fn default() -> &'a CClientNotificationHardwareSurveyPending {
        <CClientNotificationHardwareSurveyPending as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationHardwareSurveyPending {
    pub fn new() -> CClientNotificationHardwareSurveyPending {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CClientNotificationHardwareSurveyPending {
    const NAME: &'static str = "CClientNotificationHardwareSurveyPending";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationHardwareSurveyPending {
        CClientNotificationHardwareSurveyPending::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationHardwareSurveyPending {
        static instance: CClientNotificationHardwareSurveyPending = CClientNotificationHardwareSurveyPending {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationLowDiskSpace)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationLowDiskSpace {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationLowDiskSpace.folder_index)
    pub folder_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationLowDiskSpace.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationLowDiskSpace {
    fn default() -> &'a CClientNotificationLowDiskSpace {
        <CClientNotificationLowDiskSpace as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationLowDiskSpace {
    pub fn new() -> CClientNotificationLowDiskSpace {
        ::std::default::Default::default()
    }

    // optional uint32 folder_index = 1;

    pub fn folder_index(&self) -> u32 {
        self.folder_index.unwrap_or(0)
    }

    pub fn clear_folder_index(&mut self) {
        self.folder_index = ::std::option::Option::None;
    }

    pub fn has_folder_index(&self) -> bool {
        self.folder_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_folder_index(&mut self, v: u32) {
        self.folder_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationLowDiskSpace {
    const NAME: &'static str = "CClientNotificationLowDiskSpace";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.folder_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.folder_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.folder_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationLowDiskSpace {
        CClientNotificationLowDiskSpace::new()
    }

    fn clear(&mut self) {
        self.folder_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationLowDiskSpace {
        static instance: CClientNotificationLowDiskSpace = CClientNotificationLowDiskSpace {
            folder_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationBatteryTemperature)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationBatteryTemperature {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationBatteryTemperature.temperature)
    pub temperature: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationBatteryTemperature.notification_type)
    pub notification_type: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationBatteryTemperature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationBatteryTemperature {
    fn default() -> &'a CClientNotificationBatteryTemperature {
        <CClientNotificationBatteryTemperature as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationBatteryTemperature {
    pub fn new() -> CClientNotificationBatteryTemperature {
        ::std::default::Default::default()
    }

    // optional uint32 temperature = 1;

    pub fn temperature(&self) -> u32 {
        self.temperature.unwrap_or(0)
    }

    pub fn clear_temperature(&mut self) {
        self.temperature = ::std::option::Option::None;
    }

    pub fn has_temperature(&self) -> bool {
        self.temperature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_temperature(&mut self, v: u32) {
        self.temperature = ::std::option::Option::Some(v);
    }

    // optional string notification_type = 2;

    pub fn notification_type(&self) -> &str {
        match self.notification_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_notification_type(&mut self) {
        self.notification_type = ::std::option::Option::None;
    }

    pub fn has_notification_type(&self) -> bool {
        self.notification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_type(&mut self, v: ::std::string::String) {
        self.notification_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_type(&mut self) -> &mut ::std::string::String {
        if self.notification_type.is_none() {
            self.notification_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.notification_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_type(&mut self) -> ::std::string::String {
        self.notification_type.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CClientNotificationBatteryTemperature {
    const NAME: &'static str = "CClientNotificationBatteryTemperature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.temperature = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.notification_type = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.temperature {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.notification_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.temperature {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.notification_type.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationBatteryTemperature {
        CClientNotificationBatteryTemperature::new()
    }

    fn clear(&mut self) {
        self.temperature = ::std::option::Option::None;
        self.notification_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationBatteryTemperature {
        static instance: CClientNotificationBatteryTemperature = CClientNotificationBatteryTemperature {
            temperature: ::std::option::Option::None,
            notification_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationDockUnsupportedFirmware)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationDockUnsupportedFirmware {
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationDockUnsupportedFirmware.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationDockUnsupportedFirmware {
    fn default() -> &'a CClientNotificationDockUnsupportedFirmware {
        <CClientNotificationDockUnsupportedFirmware as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationDockUnsupportedFirmware {
    pub fn new() -> CClientNotificationDockUnsupportedFirmware {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CClientNotificationDockUnsupportedFirmware {
    const NAME: &'static str = "CClientNotificationDockUnsupportedFirmware";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationDockUnsupportedFirmware {
        CClientNotificationDockUnsupportedFirmware::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationDockUnsupportedFirmware {
        static instance: CClientNotificationDockUnsupportedFirmware = CClientNotificationDockUnsupportedFirmware {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationPeerContentUpload)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationPeerContentUpload {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationPeerContentUpload.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationPeerContentUpload.peer_name)
    pub peer_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationPeerContentUpload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationPeerContentUpload {
    fn default() -> &'a CClientNotificationPeerContentUpload {
        <CClientNotificationPeerContentUpload as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationPeerContentUpload {
    pub fn new() -> CClientNotificationPeerContentUpload {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string peer_name = 2;

    pub fn peer_name(&self) -> &str {
        match self.peer_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_peer_name(&mut self) {
        self.peer_name = ::std::option::Option::None;
    }

    pub fn has_peer_name(&self) -> bool {
        self.peer_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_name(&mut self, v: ::std::string::String) {
        self.peer_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer_name(&mut self) -> &mut ::std::string::String {
        if self.peer_name.is_none() {
            self.peer_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.peer_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_peer_name(&mut self) -> ::std::string::String {
        self.peer_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CClientNotificationPeerContentUpload {
    const NAME: &'static str = "CClientNotificationPeerContentUpload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.peer_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.peer_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.peer_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationPeerContentUpload {
        CClientNotificationPeerContentUpload::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.peer_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationPeerContentUpload {
        static instance: CClientNotificationPeerContentUpload = CClientNotificationPeerContentUpload {
            appid: ::std::option::Option::None,
            peer_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationCannotReadControllerGuideButton)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationCannotReadControllerGuideButton {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationCannotReadControllerGuideButton.controller_index)
    pub controller_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationCannotReadControllerGuideButton.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationCannotReadControllerGuideButton {
    fn default() -> &'a CClientNotificationCannotReadControllerGuideButton {
        <CClientNotificationCannotReadControllerGuideButton as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationCannotReadControllerGuideButton {
    pub fn new() -> CClientNotificationCannotReadControllerGuideButton {
        ::std::default::Default::default()
    }

    // optional int32 controller_index = 1;

    pub fn controller_index(&self) -> i32 {
        self.controller_index.unwrap_or(0)
    }

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: i32) {
        self.controller_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationCannotReadControllerGuideButton {
    const NAME: &'static str = "CClientNotificationCannotReadControllerGuideButton";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.controller_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.controller_index {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationCannotReadControllerGuideButton {
        CClientNotificationCannotReadControllerGuideButton::new()
    }

    fn clear(&mut self) {
        self.controller_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationCannotReadControllerGuideButton {
        static instance: CClientNotificationCannotReadControllerGuideButton = CClientNotificationCannotReadControllerGuideButton {
            controller_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationOverlaySplashScreen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationOverlaySplashScreen {
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationOverlaySplashScreen.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationOverlaySplashScreen {
    fn default() -> &'a CClientNotificationOverlaySplashScreen {
        <CClientNotificationOverlaySplashScreen as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationOverlaySplashScreen {
    pub fn new() -> CClientNotificationOverlaySplashScreen {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CClientNotificationOverlaySplashScreen {
    const NAME: &'static str = "CClientNotificationOverlaySplashScreen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationOverlaySplashScreen {
        CClientNotificationOverlaySplashScreen::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationOverlaySplashScreen {
        static instance: CClientNotificationOverlaySplashScreen = CClientNotificationOverlaySplashScreen {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationBroadcastAvailableToWatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationBroadcastAvailableToWatch {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationBroadcastAvailableToWatch.broadcast_permission)
    pub broadcast_permission: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationBroadcastAvailableToWatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationBroadcastAvailableToWatch {
    fn default() -> &'a CClientNotificationBroadcastAvailableToWatch {
        <CClientNotificationBroadcastAvailableToWatch as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationBroadcastAvailableToWatch {
    pub fn new() -> CClientNotificationBroadcastAvailableToWatch {
        ::std::default::Default::default()
    }

    // optional int32 broadcast_permission = 1;

    pub fn broadcast_permission(&self) -> i32 {
        self.broadcast_permission.unwrap_or(0)
    }

    pub fn clear_broadcast_permission(&mut self) {
        self.broadcast_permission = ::std::option::Option::None;
    }

    pub fn has_broadcast_permission(&self) -> bool {
        self.broadcast_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_permission(&mut self, v: i32) {
        self.broadcast_permission = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationBroadcastAvailableToWatch {
    const NAME: &'static str = "CClientNotificationBroadcastAvailableToWatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.broadcast_permission = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_permission {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast_permission {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationBroadcastAvailableToWatch {
        CClientNotificationBroadcastAvailableToWatch::new()
    }

    fn clear(&mut self) {
        self.broadcast_permission = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationBroadcastAvailableToWatch {
        static instance: CClientNotificationBroadcastAvailableToWatch = CClientNotificationBroadcastAvailableToWatch {
            broadcast_permission: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationTimedTrialRemaining)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationTimedTrialRemaining {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationTimedTrialRemaining.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationTimedTrialRemaining.icon)
    pub icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClientNotificationTimedTrialRemaining.offline)
    pub offline: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClientNotificationTimedTrialRemaining.allowed_seconds)
    pub allowed_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientNotificationTimedTrialRemaining.played_seconds)
    pub played_seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationTimedTrialRemaining.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationTimedTrialRemaining {
    fn default() -> &'a CClientNotificationTimedTrialRemaining {
        <CClientNotificationTimedTrialRemaining as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationTimedTrialRemaining {
    pub fn new() -> CClientNotificationTimedTrialRemaining {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string icon = 2;

    pub fn icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool offline = 3;

    pub fn offline(&self) -> bool {
        self.offline.unwrap_or(false)
    }

    pub fn clear_offline(&mut self) {
        self.offline = ::std::option::Option::None;
    }

    pub fn has_offline(&self) -> bool {
        self.offline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offline(&mut self, v: bool) {
        self.offline = ::std::option::Option::Some(v);
    }

    // optional uint32 allowed_seconds = 4;

    pub fn allowed_seconds(&self) -> u32 {
        self.allowed_seconds.unwrap_or(0)
    }

    pub fn clear_allowed_seconds(&mut self) {
        self.allowed_seconds = ::std::option::Option::None;
    }

    pub fn has_allowed_seconds(&self) -> bool {
        self.allowed_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowed_seconds(&mut self, v: u32) {
        self.allowed_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 played_seconds = 5;

    pub fn played_seconds(&self) -> u32 {
        self.played_seconds.unwrap_or(0)
    }

    pub fn clear_played_seconds(&mut self) {
        self.played_seconds = ::std::option::Option::None;
    }

    pub fn has_played_seconds(&self) -> bool {
        self.played_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_played_seconds(&mut self, v: u32) {
        self.played_seconds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientNotificationTimedTrialRemaining {
    const NAME: &'static str = "CClientNotificationTimedTrialRemaining";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.icon = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.offline = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.allowed_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.played_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.offline {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allowed_seconds {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.played_seconds {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.offline {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.allowed_seconds {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.played_seconds {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationTimedTrialRemaining {
        CClientNotificationTimedTrialRemaining::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.offline = ::std::option::Option::None;
        self.allowed_seconds = ::std::option::Option::None;
        self.played_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationTimedTrialRemaining {
        static instance: CClientNotificationTimedTrialRemaining = CClientNotificationTimedTrialRemaining {
            appid: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            offline: ::std::option::Option::None,
            allowed_seconds: ::std::option::Option::None,
            played_seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationLoginRefresh)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationLoginRefresh {
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationLoginRefresh.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationLoginRefresh {
    fn default() -> &'a CClientNotificationLoginRefresh {
        <CClientNotificationLoginRefresh as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationLoginRefresh {
    pub fn new() -> CClientNotificationLoginRefresh {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CClientNotificationLoginRefresh {
    const NAME: &'static str = "CClientNotificationLoginRefresh";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationLoginRefresh {
        CClientNotificationLoginRefresh::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationLoginRefresh {
        static instance: CClientNotificationLoginRefresh = CClientNotificationLoginRefresh {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationTimerExpired)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationTimerExpired {
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationTimerExpired.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationTimerExpired {
    fn default() -> &'a CClientNotificationTimerExpired {
        <CClientNotificationTimerExpired as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationTimerExpired {
    pub fn new() -> CClientNotificationTimerExpired {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CClientNotificationTimerExpired {
    const NAME: &'static str = "CClientNotificationTimerExpired";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationTimerExpired {
        CClientNotificationTimerExpired::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationTimerExpired {
        static instance: CClientNotificationTimerExpired = CClientNotificationTimerExpired {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CClientNotificationSteamInputActionSetChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientNotificationSteamInputActionSetChanged {
    // message fields
    // @@protoc_insertion_point(field:CClientNotificationSteamInputActionSetChanged.controller_index)
    pub controller_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CClientNotificationSteamInputActionSetChanged.action_set_name)
    pub action_set_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientNotificationSteamInputActionSetChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientNotificationSteamInputActionSetChanged {
    fn default() -> &'a CClientNotificationSteamInputActionSetChanged {
        <CClientNotificationSteamInputActionSetChanged as ::protobuf::Message>::default_instance()
    }
}

impl CClientNotificationSteamInputActionSetChanged {
    pub fn new() -> CClientNotificationSteamInputActionSetChanged {
        ::std::default::Default::default()
    }

    // optional int32 controller_index = 1;

    pub fn controller_index(&self) -> i32 {
        self.controller_index.unwrap_or(0)
    }

    pub fn clear_controller_index(&mut self) {
        self.controller_index = ::std::option::Option::None;
    }

    pub fn has_controller_index(&self) -> bool {
        self.controller_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_index(&mut self, v: i32) {
        self.controller_index = ::std::option::Option::Some(v);
    }

    // optional string action_set_name = 2;

    pub fn action_set_name(&self) -> &str {
        match self.action_set_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_action_set_name(&mut self) {
        self.action_set_name = ::std::option::Option::None;
    }

    pub fn has_action_set_name(&self) -> bool {
        self.action_set_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_set_name(&mut self, v: ::std::string::String) {
        self.action_set_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action_set_name(&mut self) -> &mut ::std::string::String {
        if self.action_set_name.is_none() {
            self.action_set_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.action_set_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_action_set_name(&mut self) -> ::std::string::String {
        self.action_set_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CClientNotificationSteamInputActionSetChanged {
    const NAME: &'static str = "CClientNotificationSteamInputActionSetChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.controller_index = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.action_set_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.controller_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.action_set_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.controller_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.action_set_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientNotificationSteamInputActionSetChanged {
        CClientNotificationSteamInputActionSetChanged::new()
    }

    fn clear(&mut self) {
        self.controller_index = ::std::option::Option::None;
        self.action_set_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientNotificationSteamInputActionSetChanged {
        static instance: CClientNotificationSteamInputActionSetChanged = CClientNotificationSteamInputActionSetChanged {
            controller_index: ::std::option::Option::None,
            action_set_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EClientNotificationType)
pub enum EClientNotificationType {
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_Invalid)
    k_EClientNotificationType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_DownloadCompleted)
    k_EClientNotificationType_DownloadCompleted = 1,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FriendInvite)
    k_EClientNotificationType_FriendInvite = 2,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FriendInGame)
    k_EClientNotificationType_FriendInGame = 3,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FriendOnline)
    k_EClientNotificationType_FriendOnline = 4,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_Achievement)
    k_EClientNotificationType_Achievement = 5,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_LowBattery)
    k_EClientNotificationType_LowBattery = 6,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_SystemUpdate)
    k_EClientNotificationType_SystemUpdate = 7,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FriendMessage)
    k_EClientNotificationType_FriendMessage = 8,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_GroupChatMessage)
    k_EClientNotificationType_GroupChatMessage = 9,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FriendInviteRollup)
    k_EClientNotificationType_FriendInviteRollup = 10,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FamilySharingDeviceAuthorizationChanged)
    k_EClientNotificationType_FamilySharingDeviceAuthorizationChanged = 11,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FamilySharingStopPlaying)
    k_EClientNotificationType_FamilySharingStopPlaying = 12,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_FamilySharingLibraryAvailable)
    k_EClientNotificationType_FamilySharingLibraryAvailable = 13,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_Screenshot)
    k_EClientNotificationType_Screenshot = 14,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_CloudSyncFailure)
    k_EClientNotificationType_CloudSyncFailure = 15,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_CloudSyncConflict)
    k_EClientNotificationType_CloudSyncConflict = 16,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_IncomingVoiceChat)
    k_EClientNotificationType_IncomingVoiceChat = 17,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_ClaimSteamDeckRewards)
    k_EClientNotificationType_ClaimSteamDeckRewards = 18,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_GiftReceived)
    k_EClientNotificationType_GiftReceived = 19,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_ItemAnnouncement)
    k_EClientNotificationType_ItemAnnouncement = 20,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_HardwareSurvey)
    k_EClientNotificationType_HardwareSurvey = 21,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_LowDiskSpace)
    k_EClientNotificationType_LowDiskSpace = 22,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_BatteryTemperature)
    k_EClientNotificationType_BatteryTemperature = 23,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_DockUnsupportedFirmware)
    k_EClientNotificationType_DockUnsupportedFirmware = 24,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_PeerContentUpload)
    k_EClientNotificationType_PeerContentUpload = 25,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_CannotReadControllerGuideButton)
    k_EClientNotificationType_CannotReadControllerGuideButton = 26,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_Comment)
    k_EClientNotificationType_Comment = 27,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_Wishlist)
    k_EClientNotificationType_Wishlist = 28,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_TradeOffer)
    k_EClientNotificationType_TradeOffer = 29,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_AsyncGame)
    k_EClientNotificationType_AsyncGame = 30,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_General)
    k_EClientNotificationType_General = 31,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_HelpRequest)
    k_EClientNotificationType_HelpRequest = 32,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_OverlaySplashScreen)
    k_EClientNotificationType_OverlaySplashScreen = 33,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_BroadcastAvailableToWatch)
    k_EClientNotificationType_BroadcastAvailableToWatch = 34,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_TimedTrialRemaining)
    k_EClientNotificationType_TimedTrialRemaining = 35,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_LoginRefresh)
    k_EClientNotificationType_LoginRefresh = 36,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_MajorSale)
    k_EClientNotificationType_MajorSale = 37,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_TimerExpired)
    k_EClientNotificationType_TimerExpired = 38,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_ModeratorMsg)
    k_EClientNotificationType_ModeratorMsg = 39,
    // @@protoc_insertion_point(enum_value:EClientNotificationType.k_EClientNotificationType_SteamInputActionSetChanged)
    k_EClientNotificationType_SteamInputActionSetChanged = 40,
}

impl ::protobuf::Enum for EClientNotificationType {
    const NAME: &'static str = "EClientNotificationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EClientNotificationType> {
        match value {
            0 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Invalid),
            1 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_DownloadCompleted),
            2 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendInvite),
            3 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendInGame),
            4 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendOnline),
            5 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Achievement),
            6 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_LowBattery),
            7 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_SystemUpdate),
            8 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendMessage),
            9 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_GroupChatMessage),
            10 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendInviteRollup),
            11 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilySharingDeviceAuthorizationChanged),
            12 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilySharingStopPlaying),
            13 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilySharingLibraryAvailable),
            14 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Screenshot),
            15 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_CloudSyncFailure),
            16 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_CloudSyncConflict),
            17 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_IncomingVoiceChat),
            18 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_ClaimSteamDeckRewards),
            19 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_GiftReceived),
            20 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_ItemAnnouncement),
            21 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_HardwareSurvey),
            22 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_LowDiskSpace),
            23 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_BatteryTemperature),
            24 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_DockUnsupportedFirmware),
            25 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_PeerContentUpload),
            26 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_CannotReadControllerGuideButton),
            27 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Comment),
            28 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Wishlist),
            29 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_TradeOffer),
            30 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_AsyncGame),
            31 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_General),
            32 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_HelpRequest),
            33 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_OverlaySplashScreen),
            34 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_BroadcastAvailableToWatch),
            35 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_TimedTrialRemaining),
            36 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_LoginRefresh),
            37 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_MajorSale),
            38 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_TimerExpired),
            39 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_ModeratorMsg),
            40 => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_SteamInputActionSetChanged),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EClientNotificationType> {
        match str {
            "k_EClientNotificationType_Invalid" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Invalid),
            "k_EClientNotificationType_DownloadCompleted" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_DownloadCompleted),
            "k_EClientNotificationType_FriendInvite" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendInvite),
            "k_EClientNotificationType_FriendInGame" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendInGame),
            "k_EClientNotificationType_FriendOnline" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendOnline),
            "k_EClientNotificationType_Achievement" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Achievement),
            "k_EClientNotificationType_LowBattery" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_LowBattery),
            "k_EClientNotificationType_SystemUpdate" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_SystemUpdate),
            "k_EClientNotificationType_FriendMessage" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendMessage),
            "k_EClientNotificationType_GroupChatMessage" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_GroupChatMessage),
            "k_EClientNotificationType_FriendInviteRollup" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FriendInviteRollup),
            "k_EClientNotificationType_FamilySharingDeviceAuthorizationChanged" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilySharingDeviceAuthorizationChanged),
            "k_EClientNotificationType_FamilySharingStopPlaying" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilySharingStopPlaying),
            "k_EClientNotificationType_FamilySharingLibraryAvailable" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_FamilySharingLibraryAvailable),
            "k_EClientNotificationType_Screenshot" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Screenshot),
            "k_EClientNotificationType_CloudSyncFailure" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_CloudSyncFailure),
            "k_EClientNotificationType_CloudSyncConflict" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_CloudSyncConflict),
            "k_EClientNotificationType_IncomingVoiceChat" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_IncomingVoiceChat),
            "k_EClientNotificationType_ClaimSteamDeckRewards" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_ClaimSteamDeckRewards),
            "k_EClientNotificationType_GiftReceived" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_GiftReceived),
            "k_EClientNotificationType_ItemAnnouncement" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_ItemAnnouncement),
            "k_EClientNotificationType_HardwareSurvey" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_HardwareSurvey),
            "k_EClientNotificationType_LowDiskSpace" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_LowDiskSpace),
            "k_EClientNotificationType_BatteryTemperature" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_BatteryTemperature),
            "k_EClientNotificationType_DockUnsupportedFirmware" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_DockUnsupportedFirmware),
            "k_EClientNotificationType_PeerContentUpload" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_PeerContentUpload),
            "k_EClientNotificationType_CannotReadControllerGuideButton" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_CannotReadControllerGuideButton),
            "k_EClientNotificationType_Comment" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Comment),
            "k_EClientNotificationType_Wishlist" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_Wishlist),
            "k_EClientNotificationType_TradeOffer" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_TradeOffer),
            "k_EClientNotificationType_AsyncGame" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_AsyncGame),
            "k_EClientNotificationType_General" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_General),
            "k_EClientNotificationType_HelpRequest" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_HelpRequest),
            "k_EClientNotificationType_OverlaySplashScreen" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_OverlaySplashScreen),
            "k_EClientNotificationType_BroadcastAvailableToWatch" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_BroadcastAvailableToWatch),
            "k_EClientNotificationType_TimedTrialRemaining" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_TimedTrialRemaining),
            "k_EClientNotificationType_LoginRefresh" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_LoginRefresh),
            "k_EClientNotificationType_MajorSale" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_MajorSale),
            "k_EClientNotificationType_TimerExpired" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_TimerExpired),
            "k_EClientNotificationType_ModeratorMsg" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_ModeratorMsg),
            "k_EClientNotificationType_SteamInputActionSetChanged" => ::std::option::Option::Some(EClientNotificationType::k_EClientNotificationType_SteamInputActionSetChanged),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EClientNotificationType] = &[
        EClientNotificationType::k_EClientNotificationType_Invalid,
        EClientNotificationType::k_EClientNotificationType_DownloadCompleted,
        EClientNotificationType::k_EClientNotificationType_FriendInvite,
        EClientNotificationType::k_EClientNotificationType_FriendInGame,
        EClientNotificationType::k_EClientNotificationType_FriendOnline,
        EClientNotificationType::k_EClientNotificationType_Achievement,
        EClientNotificationType::k_EClientNotificationType_LowBattery,
        EClientNotificationType::k_EClientNotificationType_SystemUpdate,
        EClientNotificationType::k_EClientNotificationType_FriendMessage,
        EClientNotificationType::k_EClientNotificationType_GroupChatMessage,
        EClientNotificationType::k_EClientNotificationType_FriendInviteRollup,
        EClientNotificationType::k_EClientNotificationType_FamilySharingDeviceAuthorizationChanged,
        EClientNotificationType::k_EClientNotificationType_FamilySharingStopPlaying,
        EClientNotificationType::k_EClientNotificationType_FamilySharingLibraryAvailable,
        EClientNotificationType::k_EClientNotificationType_Screenshot,
        EClientNotificationType::k_EClientNotificationType_CloudSyncFailure,
        EClientNotificationType::k_EClientNotificationType_CloudSyncConflict,
        EClientNotificationType::k_EClientNotificationType_IncomingVoiceChat,
        EClientNotificationType::k_EClientNotificationType_ClaimSteamDeckRewards,
        EClientNotificationType::k_EClientNotificationType_GiftReceived,
        EClientNotificationType::k_EClientNotificationType_ItemAnnouncement,
        EClientNotificationType::k_EClientNotificationType_HardwareSurvey,
        EClientNotificationType::k_EClientNotificationType_LowDiskSpace,
        EClientNotificationType::k_EClientNotificationType_BatteryTemperature,
        EClientNotificationType::k_EClientNotificationType_DockUnsupportedFirmware,
        EClientNotificationType::k_EClientNotificationType_PeerContentUpload,
        EClientNotificationType::k_EClientNotificationType_CannotReadControllerGuideButton,
        EClientNotificationType::k_EClientNotificationType_Comment,
        EClientNotificationType::k_EClientNotificationType_Wishlist,
        EClientNotificationType::k_EClientNotificationType_TradeOffer,
        EClientNotificationType::k_EClientNotificationType_AsyncGame,
        EClientNotificationType::k_EClientNotificationType_General,
        EClientNotificationType::k_EClientNotificationType_HelpRequest,
        EClientNotificationType::k_EClientNotificationType_OverlaySplashScreen,
        EClientNotificationType::k_EClientNotificationType_BroadcastAvailableToWatch,
        EClientNotificationType::k_EClientNotificationType_TimedTrialRemaining,
        EClientNotificationType::k_EClientNotificationType_LoginRefresh,
        EClientNotificationType::k_EClientNotificationType_MajorSale,
        EClientNotificationType::k_EClientNotificationType_TimerExpired,
        EClientNotificationType::k_EClientNotificationType_ModeratorMsg,
        EClientNotificationType::k_EClientNotificationType_SteamInputActionSetChanged,
    ];
}

impl ::std::default::Default for EClientNotificationType {
    fn default() -> Self {
        EClientNotificationType::k_EClientNotificationType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemUpdateNotificationType)
pub enum ESystemUpdateNotificationType {
    // @@protoc_insertion_point(enum_value:ESystemUpdateNotificationType.k_ESystemUpdateNotificationType_Invalid)
    k_ESystemUpdateNotificationType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemUpdateNotificationType.k_ESystemUpdateNotificationType_Available)
    k_ESystemUpdateNotificationType_Available = 1,
    // @@protoc_insertion_point(enum_value:ESystemUpdateNotificationType.k_ESystemUpdateNotificationType_NeedsRestart)
    k_ESystemUpdateNotificationType_NeedsRestart = 2,
}

impl ::protobuf::Enum for ESystemUpdateNotificationType {
    const NAME: &'static str = "ESystemUpdateNotificationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemUpdateNotificationType> {
        match value {
            0 => ::std::option::Option::Some(ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Invalid),
            1 => ::std::option::Option::Some(ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Available),
            2 => ::std::option::Option::Some(ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_NeedsRestart),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemUpdateNotificationType> {
        match str {
            "k_ESystemUpdateNotificationType_Invalid" => ::std::option::Option::Some(ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Invalid),
            "k_ESystemUpdateNotificationType_Available" => ::std::option::Option::Some(ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Available),
            "k_ESystemUpdateNotificationType_NeedsRestart" => ::std::option::Option::Some(ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_NeedsRestart),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemUpdateNotificationType] = &[
        ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Invalid,
        ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Available,
        ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_NeedsRestart,
    ];
}

impl ::std::default::Default for ESystemUpdateNotificationType {
    fn default() -> Self {
        ESystemUpdateNotificationType::k_ESystemUpdateNotificationType_Invalid
    }
}

impl crate::RpcMessage for CClientNotificationCloudSyncFailure {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationCloudSyncConflict {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationScreenshot {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationDownloadCompleted {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationFriendInvite {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationFriendInviteRollup {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationFriendInGame {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationFriendOnline {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationAchievement {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationLowBattery {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationSystemUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationFriendMessage {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationGroupChatMessage {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationFamilySharingDeviceAuthorizationChanged {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationFamilySharingStopPlaying {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationFamilySharingLibraryAvailable {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationIncomingVoiceChat {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationClaimSteamDeckRewards {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationGiftReceived {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationItemAnnouncement {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationHardwareSurveyPending {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationLowDiskSpace {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationBatteryTemperature {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationDockUnsupportedFirmware {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationPeerContentUpload {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationCannotReadControllerGuideButton {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationOverlaySplashScreen {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationBroadcastAvailableToWatch {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationTimedTrialRemaining {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationLoginRefresh {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationTimerExpired {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
impl crate::RpcMessage for CClientNotificationSteamInputActionSetChanged {
    fn parse(reader: &mut dyn std::io::Read) -> protobuf::Result<Self> {
        <Self as protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> protobuf::Result<()> {
        use protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use protobuf::Message;
        self.compute_size() as usize
    }
}
