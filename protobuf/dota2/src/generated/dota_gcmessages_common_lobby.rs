// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_common_lobby.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:CMsgLobbyCoachFriendRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyCoachFriendRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgLobbyCoachFriendRequest.coach_account_id)
    pub coach_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLobbyCoachFriendRequest.player_account_id)
    pub player_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLobbyCoachFriendRequest.request_state)
    pub request_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ELobbyMemberCoachRequestState>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLobbyCoachFriendRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyCoachFriendRequest {
    fn default() -> &'a CMsgLobbyCoachFriendRequest {
        <CMsgLobbyCoachFriendRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyCoachFriendRequest {
    pub fn new() -> CMsgLobbyCoachFriendRequest {
        ::std::default::Default::default()
    }

    // optional uint32 coach_account_id = 1;

    pub fn coach_account_id(&self) -> u32 {
        self.coach_account_id.unwrap_or(0)
    }

    pub fn clear_coach_account_id(&mut self) {
        self.coach_account_id = ::std::option::Option::None;
    }

    pub fn has_coach_account_id(&self) -> bool {
        self.coach_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coach_account_id(&mut self, v: u32) {
        self.coach_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 player_account_id = 2;

    pub fn player_account_id(&self) -> u32 {
        self.player_account_id.unwrap_or(0)
    }

    pub fn clear_player_account_id(&mut self) {
        self.player_account_id = ::std::option::Option::None;
    }

    pub fn has_player_account_id(&self) -> bool {
        self.player_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id(&mut self, v: u32) {
        self.player_account_id = ::std::option::Option::Some(v);
    }

    // optional .ELobbyMemberCoachRequestState request_state = 3;

    pub fn request_state(&self) -> ELobbyMemberCoachRequestState {
        match self.request_state {
            Some(e) => e.enum_value_or(ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_None),
            None => ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_None,
        }
    }

    pub fn clear_request_state(&mut self) {
        self.request_state = ::std::option::Option::None;
    }

    pub fn has_request_state(&self) -> bool {
        self.request_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_state(&mut self, v: ELobbyMemberCoachRequestState) {
        self.request_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLobbyCoachFriendRequest {
    const NAME: &'static str = "CMsgLobbyCoachFriendRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coach_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.player_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.request_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coach_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.player_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.request_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.coach_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.request_state {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyCoachFriendRequest {
        CMsgLobbyCoachFriendRequest::new()
    }

    fn clear(&mut self) {
        self.coach_account_id = ::std::option::Option::None;
        self.player_account_id = ::std::option::Option::None;
        self.request_state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyCoachFriendRequest {
        static instance: CMsgLobbyCoachFriendRequest = CMsgLobbyCoachFriendRequest {
            coach_account_id: ::std::option::Option::None,
            player_account_id: ::std::option::Option::None,
            request_state: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLobbyPlayerPlusSubscriptionData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyPlayerPlusSubscriptionData {
    // message fields
    // @@protoc_insertion_point(field:CMsgLobbyPlayerPlusSubscriptionData.hero_badges)
    pub hero_badges: ::std::vec::Vec<cmsg_lobby_player_plus_subscription_data::HeroBadge>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLobbyPlayerPlusSubscriptionData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyPlayerPlusSubscriptionData {
    fn default() -> &'a CMsgLobbyPlayerPlusSubscriptionData {
        <CMsgLobbyPlayerPlusSubscriptionData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyPlayerPlusSubscriptionData {
    pub fn new() -> CMsgLobbyPlayerPlusSubscriptionData {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLobbyPlayerPlusSubscriptionData {
    const NAME: &'static str = "CMsgLobbyPlayerPlusSubscriptionData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hero_badges.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hero_badges {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.hero_badges {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyPlayerPlusSubscriptionData {
        CMsgLobbyPlayerPlusSubscriptionData::new()
    }

    fn clear(&mut self) {
        self.hero_badges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyPlayerPlusSubscriptionData {
        static instance: CMsgLobbyPlayerPlusSubscriptionData = CMsgLobbyPlayerPlusSubscriptionData {
            hero_badges: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgLobbyPlayerPlusSubscriptionData`
pub mod cmsg_lobby_player_plus_subscription_data {
    // @@protoc_insertion_point(message:CMsgLobbyPlayerPlusSubscriptionData.HeroBadge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HeroBadge {
        // message fields
        // @@protoc_insertion_point(field:CMsgLobbyPlayerPlusSubscriptionData.HeroBadge.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgLobbyPlayerPlusSubscriptionData.HeroBadge.hero_badge_xp)
        pub hero_badge_xp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgLobbyPlayerPlusSubscriptionData.HeroBadge.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HeroBadge {
        fn default() -> &'a HeroBadge {
            <HeroBadge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl HeroBadge {
        pub fn new() -> HeroBadge {
            ::std::default::Default::default()
        }

        // optional int32 hero_id = 1;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_badge_xp = 2;

        pub fn hero_badge_xp(&self) -> u32 {
            self.hero_badge_xp.unwrap_or(0)
        }

        pub fn clear_hero_badge_xp(&mut self) {
            self.hero_badge_xp = ::std::option::Option::None;
        }

        pub fn has_hero_badge_xp(&self) -> bool {
            self.hero_badge_xp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_badge_xp(&mut self, v: u32) {
            self.hero_badge_xp = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for HeroBadge {
        const NAME: &'static str = "HeroBadge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.hero_badge_xp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.hero_badge_xp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.hero_badge_xp {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HeroBadge {
            HeroBadge::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.hero_badge_xp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HeroBadge {
            static instance: HeroBadge = HeroBadge {
                hero_id: ::std::option::Option::None,
                hero_badge_xp: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgEventActionData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgEventActionData {
    // message fields
    // @@protoc_insertion_point(field:CMsgEventActionData.action_id)
    pub action_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEventActionData.action_score)
    pub action_score: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgEventActionData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgEventActionData {
    fn default() -> &'a CMsgEventActionData {
        <CMsgEventActionData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgEventActionData {
    pub fn new() -> CMsgEventActionData {
        ::std::default::Default::default()
    }

    // optional uint32 action_id = 1;

    pub fn action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }

    // optional uint32 action_score = 2;

    pub fn action_score(&self) -> u32 {
        self.action_score.unwrap_or(0)
    }

    pub fn clear_action_score(&mut self) {
        self.action_score = ::std::option::Option::None;
    }

    pub fn has_action_score(&self) -> bool {
        self.action_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_score(&mut self, v: u32) {
        self.action_score = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgEventActionData {
    const NAME: &'static str = "CMsgEventActionData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.action_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.action_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.action_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.action_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.action_score {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgEventActionData {
        CMsgEventActionData::new()
    }

    fn clear(&mut self) {
        self.action_id = ::std::option::Option::None;
        self.action_score = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgEventActionData {
        static instance: CMsgEventActionData = CMsgEventActionData {
            action_id: ::std::option::Option::None,
            action_score: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPeriodicResourceData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPeriodicResourceData {
    // message fields
    // @@protoc_insertion_point(field:CMsgPeriodicResourceData.periodic_resource_id)
    pub periodic_resource_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPeriodicResourceData.remaining)
    pub remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPeriodicResourceData.max)
    pub max: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPeriodicResourceData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPeriodicResourceData {
    fn default() -> &'a CMsgPeriodicResourceData {
        <CMsgPeriodicResourceData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPeriodicResourceData {
    pub fn new() -> CMsgPeriodicResourceData {
        ::std::default::Default::default()
    }

    // optional uint32 periodic_resource_id = 1;

    pub fn periodic_resource_id(&self) -> u32 {
        self.periodic_resource_id.unwrap_or(0)
    }

    pub fn clear_periodic_resource_id(&mut self) {
        self.periodic_resource_id = ::std::option::Option::None;
    }

    pub fn has_periodic_resource_id(&self) -> bool {
        self.periodic_resource_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_periodic_resource_id(&mut self, v: u32) {
        self.periodic_resource_id = ::std::option::Option::Some(v);
    }

    // optional uint32 remaining = 2;

    pub fn remaining(&self) -> u32 {
        self.remaining.unwrap_or(0)
    }

    pub fn clear_remaining(&mut self) {
        self.remaining = ::std::option::Option::None;
    }

    pub fn has_remaining(&self) -> bool {
        self.remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remaining(&mut self, v: u32) {
        self.remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 max = 3;

    pub fn max(&self) -> u32 {
        self.max.unwrap_or(0)
    }

    pub fn clear_max(&mut self) {
        self.max = ::std::option::Option::None;
    }

    pub fn has_max(&self) -> bool {
        self.max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: u32) {
        self.max = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPeriodicResourceData {
    const NAME: &'static str = "CMsgPeriodicResourceData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.periodic_resource_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.max = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.periodic_resource_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.periodic_resource_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.remaining {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.max {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPeriodicResourceData {
        CMsgPeriodicResourceData::new()
    }

    fn clear(&mut self) {
        self.periodic_resource_id = ::std::option::Option::None;
        self.remaining = ::std::option::Option::None;
        self.max = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPeriodicResourceData {
        static instance: CMsgPeriodicResourceData = CMsgPeriodicResourceData {
            periodic_resource_id: ::std::option::Option::None,
            remaining: ::std::option::Option::None,
            max: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLobbyEventPoints)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyEventPoints {
    // message fields
    // @@protoc_insertion_point(field:CMsgLobbyEventPoints.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLobbyEventPoints.account_points)
    pub account_points: ::std::vec::Vec<cmsg_lobby_event_points::AccountPoints>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLobbyEventPoints.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyEventPoints {
    fn default() -> &'a CMsgLobbyEventPoints {
        <CMsgLobbyEventPoints as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyEventPoints {
    pub fn new() -> CMsgLobbyEventPoints {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLobbyEventPoints {
    const NAME: &'static str = "CMsgLobbyEventPoints";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.account_points.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.account_points {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_points {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyEventPoints {
        CMsgLobbyEventPoints::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.account_points.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyEventPoints {
        static instance: CMsgLobbyEventPoints = CMsgLobbyEventPoints {
            event_id: ::std::option::Option::None,
            account_points: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgLobbyEventPoints`
pub mod cmsg_lobby_event_points {
    // @@protoc_insertion_point(message:CMsgLobbyEventPoints.AccountPoints)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AccountPoints {
        // message fields
        // @@protoc_insertion_point(field:CMsgLobbyEventPoints.AccountPoints.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgLobbyEventPoints.AccountPoints.normal_points)
        pub normal_points: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgLobbyEventPoints.AccountPoints.premium_points)
        pub premium_points: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgLobbyEventPoints.AccountPoints.owned)
        pub owned: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgLobbyEventPoints.AccountPoints.event_level)
        pub event_level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgLobbyEventPoints.AccountPoints.active_effects_mask)
        pub active_effects_mask: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgLobbyEventPoints.AccountPoints.wager_streak)
        pub wager_streak: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgLobbyEventPoints.AccountPoints.event_game_custom_actions)
        pub event_game_custom_actions: ::std::vec::Vec<super::CMsgEventActionData>,
        // @@protoc_insertion_point(field:CMsgLobbyEventPoints.AccountPoints.tip_amount_index)
        pub tip_amount_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgLobbyEventPoints.AccountPoints.active_event_season_id)
        pub active_event_season_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgLobbyEventPoints.AccountPoints.teleport_fx_level)
        pub teleport_fx_level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgLobbyEventPoints.AccountPoints.networked_event_actions)
        pub networked_event_actions: ::std::vec::Vec<super::CMsgEventActionData>,
        // @@protoc_insertion_point(field:CMsgLobbyEventPoints.AccountPoints.periodic_resources)
        pub periodic_resources: ::std::vec::Vec<super::CMsgPeriodicResourceData>,
        // @@protoc_insertion_point(field:CMsgLobbyEventPoints.AccountPoints.extra_event_messages)
        pub extra_event_messages: ::std::vec::Vec<super::super::gcsdk_gcmessages::CExtraMsgBlock>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgLobbyEventPoints.AccountPoints.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AccountPoints {
        fn default() -> &'a AccountPoints {
            <AccountPoints as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl AccountPoints {
        pub fn new() -> AccountPoints {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 normal_points = 2;

        pub fn normal_points(&self) -> u32 {
            self.normal_points.unwrap_or(0)
        }

        pub fn clear_normal_points(&mut self) {
            self.normal_points = ::std::option::Option::None;
        }

        pub fn has_normal_points(&self) -> bool {
            self.normal_points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_normal_points(&mut self, v: u32) {
            self.normal_points = ::std::option::Option::Some(v);
        }

        // optional uint32 premium_points = 3;

        pub fn premium_points(&self) -> u32 {
            self.premium_points.unwrap_or(0)
        }

        pub fn clear_premium_points(&mut self) {
            self.premium_points = ::std::option::Option::None;
        }

        pub fn has_premium_points(&self) -> bool {
            self.premium_points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_premium_points(&mut self, v: u32) {
            self.premium_points = ::std::option::Option::Some(v);
        }

        // optional bool owned = 4;

        pub fn owned(&self) -> bool {
            self.owned.unwrap_or(false)
        }

        pub fn clear_owned(&mut self) {
            self.owned = ::std::option::Option::None;
        }

        pub fn has_owned(&self) -> bool {
            self.owned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owned(&mut self, v: bool) {
            self.owned = ::std::option::Option::Some(v);
        }

        // optional uint32 event_level = 7;

        pub fn event_level(&self) -> u32 {
            self.event_level.unwrap_or(0)
        }

        pub fn clear_event_level(&mut self) {
            self.event_level = ::std::option::Option::None;
        }

        pub fn has_event_level(&self) -> bool {
            self.event_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_level(&mut self, v: u32) {
            self.event_level = ::std::option::Option::Some(v);
        }

        // optional uint64 active_effects_mask = 12;

        pub fn active_effects_mask(&self) -> u64 {
            self.active_effects_mask.unwrap_or(0)
        }

        pub fn clear_active_effects_mask(&mut self) {
            self.active_effects_mask = ::std::option::Option::None;
        }

        pub fn has_active_effects_mask(&self) -> bool {
            self.active_effects_mask.is_some()
        }

        // Param is passed by value, moved
        pub fn set_active_effects_mask(&mut self, v: u64) {
            self.active_effects_mask = ::std::option::Option::Some(v);
        }

        // optional uint32 wager_streak = 23;

        pub fn wager_streak(&self) -> u32 {
            self.wager_streak.unwrap_or(0)
        }

        pub fn clear_wager_streak(&mut self) {
            self.wager_streak = ::std::option::Option::None;
        }

        pub fn has_wager_streak(&self) -> bool {
            self.wager_streak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wager_streak(&mut self, v: u32) {
            self.wager_streak = ::std::option::Option::Some(v);
        }

        // optional uint32 tip_amount_index = 26;

        pub fn tip_amount_index(&self) -> u32 {
            self.tip_amount_index.unwrap_or(0)
        }

        pub fn clear_tip_amount_index(&mut self) {
            self.tip_amount_index = ::std::option::Option::None;
        }

        pub fn has_tip_amount_index(&self) -> bool {
            self.tip_amount_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tip_amount_index(&mut self, v: u32) {
            self.tip_amount_index = ::std::option::Option::Some(v);
        }

        // optional uint32 active_event_season_id = 27;

        pub fn active_event_season_id(&self) -> u32 {
            self.active_event_season_id.unwrap_or(0)
        }

        pub fn clear_active_event_season_id(&mut self) {
            self.active_event_season_id = ::std::option::Option::None;
        }

        pub fn has_active_event_season_id(&self) -> bool {
            self.active_event_season_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_active_event_season_id(&mut self, v: u32) {
            self.active_event_season_id = ::std::option::Option::Some(v);
        }

        // optional uint32 teleport_fx_level = 28;

        pub fn teleport_fx_level(&self) -> u32 {
            self.teleport_fx_level.unwrap_or(0)
        }

        pub fn clear_teleport_fx_level(&mut self) {
            self.teleport_fx_level = ::std::option::Option::None;
        }

        pub fn has_teleport_fx_level(&self) -> bool {
            self.teleport_fx_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_teleport_fx_level(&mut self, v: u32) {
            self.teleport_fx_level = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for AccountPoints {
        const NAME: &'static str = "AccountPoints";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.normal_points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.premium_points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.owned = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.event_level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.active_effects_mask = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    184 => {
                        self.wager_streak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    202 => {
                        self.event_game_custom_actions.push(is.read_message()?);
                    },
                    208 => {
                        self.tip_amount_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    216 => {
                        self.active_event_season_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    224 => {
                        self.teleport_fx_level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    242 => {
                        self.networked_event_actions.push(is.read_message()?);
                    },
                    250 => {
                        self.periodic_resources.push(is.read_message()?);
                    },
                    258 => {
                        self.extra_event_messages.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.normal_points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.premium_points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.owned {
                my_size += 1 + 1;
            }
            if let Some(v) = self.event_level {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.active_effects_mask {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(12, v);
            }
            if let Some(v) = self.wager_streak {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
            }
            for value in &self.event_game_custom_actions {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.tip_amount_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(26, v);
            }
            if let Some(v) = self.active_event_season_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
            }
            if let Some(v) = self.teleport_fx_level {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
            }
            for value in &self.networked_event_actions {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.periodic_resources {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.extra_event_messages {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.normal_points {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.premium_points {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.owned {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.event_level {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.active_effects_mask {
                os.write_uint64(12, v)?;
            }
            if let Some(v) = self.wager_streak {
                os.write_uint32(23, v)?;
            }
            for v in &self.event_game_custom_actions {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
            };
            if let Some(v) = self.tip_amount_index {
                os.write_uint32(26, v)?;
            }
            if let Some(v) = self.active_event_season_id {
                os.write_uint32(27, v)?;
            }
            if let Some(v) = self.teleport_fx_level {
                os.write_uint32(28, v)?;
            }
            for v in &self.networked_event_actions {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
            };
            for v in &self.periodic_resources {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
            };
            for v in &self.extra_event_messages {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AccountPoints {
            AccountPoints::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.normal_points = ::std::option::Option::None;
            self.premium_points = ::std::option::Option::None;
            self.owned = ::std::option::Option::None;
            self.event_level = ::std::option::Option::None;
            self.active_effects_mask = ::std::option::Option::None;
            self.wager_streak = ::std::option::Option::None;
            self.event_game_custom_actions.clear();
            self.tip_amount_index = ::std::option::Option::None;
            self.active_event_season_id = ::std::option::Option::None;
            self.teleport_fx_level = ::std::option::Option::None;
            self.networked_event_actions.clear();
            self.periodic_resources.clear();
            self.extra_event_messages.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AccountPoints {
            static instance: AccountPoints = AccountPoints {
                account_id: ::std::option::Option::None,
                normal_points: ::std::option::Option::None,
                premium_points: ::std::option::Option::None,
                owned: ::std::option::Option::None,
                event_level: ::std::option::Option::None,
                active_effects_mask: ::std::option::Option::None,
                wager_streak: ::std::option::Option::None,
                event_game_custom_actions: ::std::vec::Vec::new(),
                tip_amount_index: ::std::option::Option::None,
                active_event_season_id: ::std::option::Option::None,
                teleport_fx_level: ::std::option::Option::None,
                networked_event_actions: ::std::vec::Vec::new(),
                periodic_resources: ::std::vec::Vec::new(),
                extra_event_messages: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgLobbyEventGameData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyEventGameData {
    // message fields
    // @@protoc_insertion_point(field:CMsgLobbyEventGameData.game_seed)
    pub game_seed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLobbyEventGameData.event_window_start_time)
    pub event_window_start_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLobbyEventGameData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyEventGameData {
    fn default() -> &'a CMsgLobbyEventGameData {
        <CMsgLobbyEventGameData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyEventGameData {
    pub fn new() -> CMsgLobbyEventGameData {
        ::std::default::Default::default()
    }

    // optional uint32 game_seed = 1;

    pub fn game_seed(&self) -> u32 {
        self.game_seed.unwrap_or(0)
    }

    pub fn clear_game_seed(&mut self) {
        self.game_seed = ::std::option::Option::None;
    }

    pub fn has_game_seed(&self) -> bool {
        self.game_seed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_seed(&mut self, v: u32) {
        self.game_seed = ::std::option::Option::Some(v);
    }

    // optional uint32 event_window_start_time = 2;

    pub fn event_window_start_time(&self) -> u32 {
        self.event_window_start_time.unwrap_or(0)
    }

    pub fn clear_event_window_start_time(&mut self) {
        self.event_window_start_time = ::std::option::Option::None;
    }

    pub fn has_event_window_start_time(&self) -> bool {
        self.event_window_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_window_start_time(&mut self, v: u32) {
        self.event_window_start_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLobbyEventGameData {
    const NAME: &'static str = "CMsgLobbyEventGameData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_seed = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_window_start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_seed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_window_start_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_seed {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_window_start_time {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyEventGameData {
        CMsgLobbyEventGameData::new()
    }

    fn clear(&mut self) {
        self.game_seed = ::std::option::Option::None;
        self.event_window_start_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyEventGameData {
        static instance: CMsgLobbyEventGameData = CMsgLobbyEventGameData {
            game_seed: ::std::option::Option::None,
            event_window_start_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSODOTALobbyInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTALobbyInvite {
    // message fields
    // @@protoc_insertion_point(field:CSODOTALobbyInvite.group_id)
    pub group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobbyInvite.sender_id)
    pub sender_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobbyInvite.sender_name)
    pub sender_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSODOTALobbyInvite.members)
    pub members: ::std::vec::Vec<csodotalobby_invite::LobbyMember>,
    // @@protoc_insertion_point(field:CSODOTALobbyInvite.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobbyInvite.invite_gid)
    pub invite_gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobbyInvite.custom_game_crc)
    pub custom_game_crc: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobbyInvite.custom_game_timestamp)
    pub custom_game_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSODOTALobbyInvite.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTALobbyInvite {
    fn default() -> &'a CSODOTALobbyInvite {
        <CSODOTALobbyInvite as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSODOTALobbyInvite {
    pub fn new() -> CSODOTALobbyInvite {
        ::std::default::Default::default()
    }

    // optional uint64 group_id = 1;

    pub fn group_id(&self) -> u64 {
        self.group_id.unwrap_or(0)
    }

    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u64) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sender_id = 2;

    pub fn sender_id(&self) -> u64 {
        self.sender_id.unwrap_or(0)
    }

    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: u64) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    // optional string sender_name = 3;

    pub fn sender_name(&self) -> &str {
        match self.sender_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sender_name(&mut self) {
        self.sender_name = ::std::option::Option::None;
    }

    pub fn has_sender_name(&self) -> bool {
        self.sender_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_name(&mut self, v: ::std::string::String) {
        self.sender_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_name(&mut self) -> &mut ::std::string::String {
        if self.sender_name.is_none() {
            self.sender_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sender_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_name(&mut self) -> ::std::string::String {
        self.sender_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 custom_game_id = 5;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 invite_gid = 6;

    pub fn invite_gid(&self) -> u64 {
        self.invite_gid.unwrap_or(0)
    }

    pub fn clear_invite_gid(&mut self) {
        self.invite_gid = ::std::option::Option::None;
    }

    pub fn has_invite_gid(&self) -> bool {
        self.invite_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_gid(&mut self, v: u64) {
        self.invite_gid = ::std::option::Option::Some(v);
    }

    // optional fixed64 custom_game_crc = 7;

    pub fn custom_game_crc(&self) -> u64 {
        self.custom_game_crc.unwrap_or(0)
    }

    pub fn clear_custom_game_crc(&mut self) {
        self.custom_game_crc = ::std::option::Option::None;
    }

    pub fn has_custom_game_crc(&self) -> bool {
        self.custom_game_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_crc(&mut self, v: u64) {
        self.custom_game_crc = ::std::option::Option::Some(v);
    }

    // optional fixed32 custom_game_timestamp = 8;

    pub fn custom_game_timestamp(&self) -> u32 {
        self.custom_game_timestamp.unwrap_or(0)
    }

    pub fn clear_custom_game_timestamp(&mut self) {
        self.custom_game_timestamp = ::std::option::Option::None;
    }

    pub fn has_custom_game_timestamp(&self) -> bool {
        self.custom_game_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_timestamp(&mut self, v: u32) {
        self.custom_game_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSODOTALobbyInvite {
    const NAME: &'static str = "CSODOTALobbyInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.sender_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.sender_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.members.push(is.read_message()?);
                },
                40 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                49 => {
                    self.invite_gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                57 => {
                    self.custom_game_crc = ::std::option::Option::Some(is.read_fixed64()?);
                },
                69 => {
                    self.custom_game_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.sender_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.sender_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.custom_game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.invite_gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.custom_game_crc {
            my_size += 1 + 8;
        }
        if let Some(v) = self.custom_game_timestamp {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.sender_name.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.custom_game_id {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.invite_gid {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.custom_game_crc {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.custom_game_timestamp {
            os.write_fixed32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTALobbyInvite {
        CSODOTALobbyInvite::new()
    }

    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.sender_id = ::std::option::Option::None;
        self.sender_name = ::std::option::Option::None;
        self.members.clear();
        self.custom_game_id = ::std::option::Option::None;
        self.invite_gid = ::std::option::Option::None;
        self.custom_game_crc = ::std::option::Option::None;
        self.custom_game_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTALobbyInvite {
        static instance: CSODOTALobbyInvite = CSODOTALobbyInvite {
            group_id: ::std::option::Option::None,
            sender_id: ::std::option::Option::None,
            sender_name: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            custom_game_id: ::std::option::Option::None,
            invite_gid: ::std::option::Option::None,
            custom_game_crc: ::std::option::Option::None,
            custom_game_timestamp: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSODOTALobbyInvite`
pub mod csodotalobby_invite {
    // @@protoc_insertion_point(message:CSODOTALobbyInvite.LobbyMember)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LobbyMember {
        // message fields
        // @@protoc_insertion_point(field:CSODOTALobbyInvite.LobbyMember.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSODOTALobbyInvite.LobbyMember.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CSODOTALobbyInvite.LobbyMember.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LobbyMember {
        fn default() -> &'a LobbyMember {
            <LobbyMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl LobbyMember {
        pub fn new() -> LobbyMember {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 steam_id = 2;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for LobbyMember {
        const NAME: &'static str = "LobbyMember";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    17 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.steam_id {
                os.write_fixed64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LobbyMember {
            LobbyMember::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.steam_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LobbyMember {
            static instance: LobbyMember = LobbyMember {
                name: ::std::option::Option::None,
                steam_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CSODOTALobbyMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTALobbyMember {
    // message fields
    // @@protoc_insertion_point(field:CSODOTALobbyMember.id)
    pub id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.team)
    pub team: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GC_TEAM>>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.slot)
    pub slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.meta_level)
    pub meta_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.meta_xp)
    pub meta_xp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.meta_xp_awarded)
    pub meta_xp_awarded: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.leaver_status)
    pub leaver_status: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTALeaverStatus_t>>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.leaver_actions)
    pub leaver_actions: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.channel)
    pub channel: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.disabled_hero_id)
    pub disabled_hero_id: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.enabled_hero_id)
    pub enabled_hero_id: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.coach_team)
    pub coach_team: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GC_TEAM>>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.coached_account_ids)
    pub coached_account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.coach_rating)
    pub coach_rating: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.pwrd_cyber_cafe_id)
    pub pwrd_cyber_cafe_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.pwrd_cyber_cafe_name)
    pub pwrd_cyber_cafe_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.disabled_random_hero_bits)
    pub disabled_random_hero_bits: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.rank_change)
    pub rank_change: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.cameraman)
    pub cameraman: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.custom_game_product_ids)
    pub custom_game_product_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.search_match_type)
    pub search_match_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::MatchType>>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.favorite_team_packed)
    pub favorite_team_packed: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.is_plus_subscriber)
    pub is_plus_subscriber: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.lane_selection_flags)
    pub lane_selection_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.can_earn_rewards)
    pub can_earn_rewards: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.live_spectator_team)
    pub live_spectator_team: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GC_TEAM>>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.was_mvp_last_game)
    pub was_mvp_last_game: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.pending_awards)
    pub pending_awards: ::std::vec::Vec<super::dota_shared_enums::CMsgPendingEventAward>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.pending_awards_on_victory)
    pub pending_awards_on_victory: ::std::vec::Vec<super::dota_shared_enums::CMsgPendingEventAward>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.rank_mmr_boost_type)
    pub rank_mmr_boost_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EDOTAMMRBoostType>>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.queue_point_adjustment)
    pub queue_point_adjustment: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.rank_tier)
    pub rank_tier: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.title)
    pub title: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.reports_available)
    pub reports_available: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.is_steam_china)
    pub is_steam_china: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.live_spectator_account_id)
    pub live_spectator_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.comms_reports_available)
    pub comms_reports_available: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobbyMember.banned_hero_ids)
    pub banned_hero_ids: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSODOTALobbyMember.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTALobbyMember {
    fn default() -> &'a CSODOTALobbyMember {
        <CSODOTALobbyMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSODOTALobbyMember {
    pub fn new() -> CSODOTALobbyMember {
        ::std::default::Default::default()
    }

    // optional fixed64 id = 1;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 2;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional .DOTA_GC_TEAM team = 3;

    pub fn team(&self) -> super::dota_shared_enums::DOTA_GC_TEAM {
        match self.team {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            None => super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
        }
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: super::dota_shared_enums::DOTA_GC_TEAM) {
        self.team = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string name = 6;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 slot = 7;

    pub fn slot(&self) -> u32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: u32) {
        self.slot = ::std::option::Option::Some(v);
    }

    // optional uint64 party_id = 12;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional uint32 meta_level = 13;

    pub fn meta_level(&self) -> u32 {
        self.meta_level.unwrap_or(0)
    }

    pub fn clear_meta_level(&mut self) {
        self.meta_level = ::std::option::Option::None;
    }

    pub fn has_meta_level(&self) -> bool {
        self.meta_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_level(&mut self, v: u32) {
        self.meta_level = ::std::option::Option::Some(v);
    }

    // optional uint32 meta_xp = 14;

    pub fn meta_xp(&self) -> u32 {
        self.meta_xp.unwrap_or(0)
    }

    pub fn clear_meta_xp(&mut self) {
        self.meta_xp = ::std::option::Option::None;
    }

    pub fn has_meta_xp(&self) -> bool {
        self.meta_xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_xp(&mut self, v: u32) {
        self.meta_xp = ::std::option::Option::Some(v);
    }

    // optional uint32 meta_xp_awarded = 15;

    pub fn meta_xp_awarded(&self) -> u32 {
        self.meta_xp_awarded.unwrap_or(0)
    }

    pub fn clear_meta_xp_awarded(&mut self) {
        self.meta_xp_awarded = ::std::option::Option::None;
    }

    pub fn has_meta_xp_awarded(&self) -> bool {
        self.meta_xp_awarded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_xp_awarded(&mut self, v: u32) {
        self.meta_xp_awarded = ::std::option::Option::Some(v);
    }

    // optional .DOTALeaverStatus_t leaver_status = 16;

    pub fn leaver_status(&self) -> super::dota_shared_enums::DOTALeaverStatus_t {
        match self.leaver_status {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTALeaverStatus_t::DOTA_LEAVER_NONE),
            None => super::dota_shared_enums::DOTALeaverStatus_t::DOTA_LEAVER_NONE,
        }
    }

    pub fn clear_leaver_status(&mut self) {
        self.leaver_status = ::std::option::Option::None;
    }

    pub fn has_leaver_status(&self) -> bool {
        self.leaver_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_status(&mut self, v: super::dota_shared_enums::DOTALeaverStatus_t) {
        self.leaver_status = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 leaver_actions = 28;

    pub fn leaver_actions(&self) -> u32 {
        self.leaver_actions.unwrap_or(0)
    }

    pub fn clear_leaver_actions(&mut self) {
        self.leaver_actions = ::std::option::Option::None;
    }

    pub fn has_leaver_actions(&self) -> bool {
        self.leaver_actions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_actions(&mut self, v: u32) {
        self.leaver_actions = ::std::option::Option::Some(v);
    }

    // optional uint32 channel = 17;

    pub fn channel(&self) -> u32 {
        self.channel.unwrap_or(6u32)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional .DOTA_GC_TEAM coach_team = 23;

    pub fn coach_team(&self) -> super::dota_shared_enums::DOTA_GC_TEAM {
        match self.coach_team {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_NOTEAM),
            None => super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_NOTEAM,
        }
    }

    pub fn clear_coach_team(&mut self) {
        self.coach_team = ::std::option::Option::None;
    }

    pub fn has_coach_team(&self) -> bool {
        self.coach_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coach_team(&mut self, v: super::dota_shared_enums::DOTA_GC_TEAM) {
        self.coach_team = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 coach_rating = 42;

    pub fn coach_rating(&self) -> u32 {
        self.coach_rating.unwrap_or(0)
    }

    pub fn clear_coach_rating(&mut self) {
        self.coach_rating = ::std::option::Option::None;
    }

    pub fn has_coach_rating(&self) -> bool {
        self.coach_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coach_rating(&mut self, v: u32) {
        self.coach_rating = ::std::option::Option::Some(v);
    }

    // optional uint32 pwrd_cyber_cafe_id = 24;

    pub fn pwrd_cyber_cafe_id(&self) -> u32 {
        self.pwrd_cyber_cafe_id.unwrap_or(0)
    }

    pub fn clear_pwrd_cyber_cafe_id(&mut self) {
        self.pwrd_cyber_cafe_id = ::std::option::Option::None;
    }

    pub fn has_pwrd_cyber_cafe_id(&self) -> bool {
        self.pwrd_cyber_cafe_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pwrd_cyber_cafe_id(&mut self, v: u32) {
        self.pwrd_cyber_cafe_id = ::std::option::Option::Some(v);
    }

    // optional string pwrd_cyber_cafe_name = 25;

    pub fn pwrd_cyber_cafe_name(&self) -> &str {
        match self.pwrd_cyber_cafe_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pwrd_cyber_cafe_name(&mut self) {
        self.pwrd_cyber_cafe_name = ::std::option::Option::None;
    }

    pub fn has_pwrd_cyber_cafe_name(&self) -> bool {
        self.pwrd_cyber_cafe_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pwrd_cyber_cafe_name(&mut self, v: ::std::string::String) {
        self.pwrd_cyber_cafe_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pwrd_cyber_cafe_name(&mut self) -> &mut ::std::string::String {
        if self.pwrd_cyber_cafe_name.is_none() {
            self.pwrd_cyber_cafe_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pwrd_cyber_cafe_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_pwrd_cyber_cafe_name(&mut self) -> ::std::string::String {
        self.pwrd_cyber_cafe_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint32 rank_change = 29;

    pub fn rank_change(&self) -> i32 {
        self.rank_change.unwrap_or(0)
    }

    pub fn clear_rank_change(&mut self) {
        self.rank_change = ::std::option::Option::None;
    }

    pub fn has_rank_change(&self) -> bool {
        self.rank_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_change(&mut self, v: i32) {
        self.rank_change = ::std::option::Option::Some(v);
    }

    // optional bool cameraman = 30;

    pub fn cameraman(&self) -> bool {
        self.cameraman.unwrap_or(false)
    }

    pub fn clear_cameraman(&mut self) {
        self.cameraman = ::std::option::Option::None;
    }

    pub fn has_cameraman(&self) -> bool {
        self.cameraman.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cameraman(&mut self, v: bool) {
        self.cameraman = ::std::option::Option::Some(v);
    }

    // optional .MatchType search_match_type = 33;

    pub fn search_match_type(&self) -> super::dota_shared_enums::MatchType {
        match self.search_match_type {
            Some(e) => e.enum_value_or(super::dota_shared_enums::MatchType::MATCH_TYPE_CASUAL),
            None => super::dota_shared_enums::MatchType::MATCH_TYPE_CASUAL,
        }
    }

    pub fn clear_search_match_type(&mut self) {
        self.search_match_type = ::std::option::Option::None;
    }

    pub fn has_search_match_type(&self) -> bool {
        self.search_match_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_match_type(&mut self, v: super::dota_shared_enums::MatchType) {
        self.search_match_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 favorite_team_packed = 35;

    pub fn favorite_team_packed(&self) -> u64 {
        self.favorite_team_packed.unwrap_or(0)
    }

    pub fn clear_favorite_team_packed(&mut self) {
        self.favorite_team_packed = ::std::option::Option::None;
    }

    pub fn has_favorite_team_packed(&self) -> bool {
        self.favorite_team_packed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_team_packed(&mut self, v: u64) {
        self.favorite_team_packed = ::std::option::Option::Some(v);
    }

    // optional bool is_plus_subscriber = 36;

    pub fn is_plus_subscriber(&self) -> bool {
        self.is_plus_subscriber.unwrap_or(false)
    }

    pub fn clear_is_plus_subscriber(&mut self) {
        self.is_plus_subscriber = ::std::option::Option::None;
    }

    pub fn has_is_plus_subscriber(&self) -> bool {
        self.is_plus_subscriber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_plus_subscriber(&mut self, v: bool) {
        self.is_plus_subscriber = ::std::option::Option::Some(v);
    }

    // optional uint32 lane_selection_flags = 38;

    pub fn lane_selection_flags(&self) -> u32 {
        self.lane_selection_flags.unwrap_or(0)
    }

    pub fn clear_lane_selection_flags(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
    }

    pub fn has_lane_selection_flags(&self) -> bool {
        self.lane_selection_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane_selection_flags(&mut self, v: u32) {
        self.lane_selection_flags = ::std::option::Option::Some(v);
    }

    // optional bool can_earn_rewards = 39;

    pub fn can_earn_rewards(&self) -> bool {
        self.can_earn_rewards.unwrap_or(false)
    }

    pub fn clear_can_earn_rewards(&mut self) {
        self.can_earn_rewards = ::std::option::Option::None;
    }

    pub fn has_can_earn_rewards(&self) -> bool {
        self.can_earn_rewards.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_earn_rewards(&mut self, v: bool) {
        self.can_earn_rewards = ::std::option::Option::Some(v);
    }

    // optional .DOTA_GC_TEAM live_spectator_team = 40;

    pub fn live_spectator_team(&self) -> super::dota_shared_enums::DOTA_GC_TEAM {
        match self.live_spectator_team {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_NOTEAM),
            None => super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_NOTEAM,
        }
    }

    pub fn clear_live_spectator_team(&mut self) {
        self.live_spectator_team = ::std::option::Option::None;
    }

    pub fn has_live_spectator_team(&self) -> bool {
        self.live_spectator_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_live_spectator_team(&mut self, v: super::dota_shared_enums::DOTA_GC_TEAM) {
        self.live_spectator_team = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool was_mvp_last_game = 43;

    pub fn was_mvp_last_game(&self) -> bool {
        self.was_mvp_last_game.unwrap_or(false)
    }

    pub fn clear_was_mvp_last_game(&mut self) {
        self.was_mvp_last_game = ::std::option::Option::None;
    }

    pub fn has_was_mvp_last_game(&self) -> bool {
        self.was_mvp_last_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_mvp_last_game(&mut self, v: bool) {
        self.was_mvp_last_game = ::std::option::Option::Some(v);
    }

    // optional .EDOTAMMRBoostType rank_mmr_boost_type = 46;

    pub fn rank_mmr_boost_type(&self) -> super::dota_shared_enums::EDOTAMMRBoostType {
        match self.rank_mmr_boost_type {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EDOTAMMRBoostType::k_EDOTAMMRBoostType_None),
            None => super::dota_shared_enums::EDOTAMMRBoostType::k_EDOTAMMRBoostType_None,
        }
    }

    pub fn clear_rank_mmr_boost_type(&mut self) {
        self.rank_mmr_boost_type = ::std::option::Option::None;
    }

    pub fn has_rank_mmr_boost_type(&self) -> bool {
        self.rank_mmr_boost_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_mmr_boost_type(&mut self, v: super::dota_shared_enums::EDOTAMMRBoostType) {
        self.rank_mmr_boost_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional sint32 queue_point_adjustment = 47;

    pub fn queue_point_adjustment(&self) -> i32 {
        self.queue_point_adjustment.unwrap_or(0)
    }

    pub fn clear_queue_point_adjustment(&mut self) {
        self.queue_point_adjustment = ::std::option::Option::None;
    }

    pub fn has_queue_point_adjustment(&self) -> bool {
        self.queue_point_adjustment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_point_adjustment(&mut self, v: i32) {
        self.queue_point_adjustment = ::std::option::Option::Some(v);
    }

    // optional int32 rank_tier = 48;

    pub fn rank_tier(&self) -> i32 {
        self.rank_tier.unwrap_or(0)
    }

    pub fn clear_rank_tier(&mut self) {
        self.rank_tier = ::std::option::Option::None;
    }

    pub fn has_rank_tier(&self) -> bool {
        self.rank_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_tier(&mut self, v: i32) {
        self.rank_tier = ::std::option::Option::Some(v);
    }

    // optional uint32 title = 50;

    pub fn title(&self) -> u32 {
        self.title.unwrap_or(0)
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: u32) {
        self.title = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_id = 51;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 reports_available = 52;

    pub fn reports_available(&self) -> u32 {
        self.reports_available.unwrap_or(0)
    }

    pub fn clear_reports_available(&mut self) {
        self.reports_available = ::std::option::Option::None;
    }

    pub fn has_reports_available(&self) -> bool {
        self.reports_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reports_available(&mut self, v: u32) {
        self.reports_available = ::std::option::Option::Some(v);
    }

    // optional bool is_steam_china = 54;

    pub fn is_steam_china(&self) -> bool {
        self.is_steam_china.unwrap_or(false)
    }

    pub fn clear_is_steam_china(&mut self) {
        self.is_steam_china = ::std::option::Option::None;
    }

    pub fn has_is_steam_china(&self) -> bool {
        self.is_steam_china.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_steam_china(&mut self, v: bool) {
        self.is_steam_china = ::std::option::Option::Some(v);
    }

    // optional uint32 live_spectator_account_id = 55;

    pub fn live_spectator_account_id(&self) -> u32 {
        self.live_spectator_account_id.unwrap_or(0)
    }

    pub fn clear_live_spectator_account_id(&mut self) {
        self.live_spectator_account_id = ::std::option::Option::None;
    }

    pub fn has_live_spectator_account_id(&self) -> bool {
        self.live_spectator_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_live_spectator_account_id(&mut self, v: u32) {
        self.live_spectator_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 comms_reports_available = 56;

    pub fn comms_reports_available(&self) -> u32 {
        self.comms_reports_available.unwrap_or(0)
    }

    pub fn clear_comms_reports_available(&mut self) {
        self.comms_reports_available = ::std::option::Option::None;
    }

    pub fn has_comms_reports_available(&self) -> bool {
        self.comms_reports_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comms_reports_available(&mut self, v: u32) {
        self.comms_reports_available = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSODOTALobbyMember {
    const NAME: &'static str = "CSODOTALobbyMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.party_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                104 => {
                    self.meta_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.meta_xp = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.meta_xp_awarded = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.leaver_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                224 => {
                    self.leaver_actions = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.channel = ::std::option::Option::Some(is.read_uint32()?);
                },
                162 => {
                    is.read_repeated_packed_int32_into(&mut self.disabled_hero_id)?;
                },
                160 => {
                    self.disabled_hero_id.push(is.read_int32()?);
                },
                178 => {
                    is.read_repeated_packed_int32_into(&mut self.enabled_hero_id)?;
                },
                176 => {
                    self.enabled_hero_id.push(is.read_int32()?);
                },
                184 => {
                    self.coach_team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                426 => {
                    is.read_repeated_packed_uint32_into(&mut self.coached_account_ids)?;
                },
                424 => {
                    self.coached_account_ids.push(is.read_uint32()?);
                },
                336 => {
                    self.coach_rating = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.pwrd_cyber_cafe_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                202 => {
                    self.pwrd_cyber_cafe_name = ::std::option::Option::Some(is.read_string()?);
                },
                330 => {
                    is.read_repeated_packed_fixed32_into(&mut self.disabled_random_hero_bits)?;
                },
                333 => {
                    self.disabled_random_hero_bits.push(is.read_fixed32()?);
                },
                232 => {
                    self.rank_change = ::std::option::Option::Some(is.read_sint32()?);
                },
                240 => {
                    self.cameraman = ::std::option::Option::Some(is.read_bool()?);
                },
                250 => {
                    is.read_repeated_packed_uint32_into(&mut self.custom_game_product_ids)?;
                },
                248 => {
                    self.custom_game_product_ids.push(is.read_uint32()?);
                },
                264 => {
                    self.search_match_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                280 => {
                    self.favorite_team_packed = ::std::option::Option::Some(is.read_uint64()?);
                },
                288 => {
                    self.is_plus_subscriber = ::std::option::Option::Some(is.read_bool()?);
                },
                304 => {
                    self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                312 => {
                    self.can_earn_rewards = ::std::option::Option::Some(is.read_bool()?);
                },
                320 => {
                    self.live_spectator_team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                344 => {
                    self.was_mvp_last_game = ::std::option::Option::Some(is.read_bool()?);
                },
                354 => {
                    self.pending_awards.push(is.read_message()?);
                },
                362 => {
                    self.pending_awards_on_victory.push(is.read_message()?);
                },
                368 => {
                    self.rank_mmr_boost_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                376 => {
                    self.queue_point_adjustment = ::std::option::Option::Some(is.read_sint32()?);
                },
                384 => {
                    self.rank_tier = ::std::option::Option::Some(is.read_int32()?);
                },
                400 => {
                    self.title = ::std::option::Option::Some(is.read_uint32()?);
                },
                408 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                416 => {
                    self.reports_available = ::std::option::Option::Some(is.read_uint32()?);
                },
                432 => {
                    self.is_steam_china = ::std::option::Option::Some(is.read_bool()?);
                },
                440 => {
                    self.live_spectator_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                448 => {
                    self.comms_reports_available = ::std::option::Option::Some(is.read_uint32()?);
                },
                458 => {
                    is.read_repeated_packed_int32_into(&mut self.banned_hero_ids)?;
                },
                456 => {
                    self.banned_hero_ids.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.party_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(12, v);
        }
        if let Some(v) = self.meta_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.meta_xp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.meta_xp_awarded {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.leaver_status {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(16, v.value());
        }
        if let Some(v) = self.leaver_actions {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.channel {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        for value in &self.disabled_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(20, *value);
        };
        for value in &self.enabled_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(22, *value);
        };
        if let Some(v) = self.coach_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(23, v.value());
        }
        for value in &self.coached_account_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(53, *value);
        };
        if let Some(v) = self.coach_rating {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(42, v);
        }
        if let Some(v) = self.pwrd_cyber_cafe_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.pwrd_cyber_cafe_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(25, &v);
        }
        my_size += 6 * self.disabled_random_hero_bits.len() as u64;
        if let Some(v) = self.rank_change {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(29, v);
        }
        if let Some(v) = self.cameraman {
            my_size += 2 + 1;
        }
        for value in &self.custom_game_product_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(31, *value);
        };
        if let Some(v) = self.search_match_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(33, v.value());
        }
        if let Some(v) = self.favorite_team_packed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(35, v);
        }
        if let Some(v) = self.is_plus_subscriber {
            my_size += 2 + 1;
        }
        if let Some(v) = self.lane_selection_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(38, v);
        }
        if let Some(v) = self.can_earn_rewards {
            my_size += 2 + 1;
        }
        if let Some(v) = self.live_spectator_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(40, v.value());
        }
        if let Some(v) = self.was_mvp_last_game {
            my_size += 2 + 1;
        }
        for value in &self.pending_awards {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.pending_awards_on_victory {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.rank_mmr_boost_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(46, v.value());
        }
        if let Some(v) = self.queue_point_adjustment {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(47, v);
        }
        if let Some(v) = self.rank_tier {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(48, v);
        }
        if let Some(v) = self.title {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(50, v);
        }
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(51, v);
        }
        if let Some(v) = self.reports_available {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(52, v);
        }
        if let Some(v) = self.is_steam_china {
            my_size += 2 + 1;
        }
        if let Some(v) = self.live_spectator_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(55, v);
        }
        if let Some(v) = self.comms_reports_available {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(56, v);
        }
        for value in &self.banned_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(57, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.team {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.slot {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.party_id {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.meta_level {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.meta_xp {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.meta_xp_awarded {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.leaver_status {
            os.write_enum(16, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.leaver_actions {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.channel {
            os.write_uint32(17, v)?;
        }
        for v in &self.disabled_hero_id {
            os.write_int32(20, *v)?;
        };
        for v in &self.enabled_hero_id {
            os.write_int32(22, *v)?;
        };
        if let Some(v) = self.coach_team {
            os.write_enum(23, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.coached_account_ids {
            os.write_uint32(53, *v)?;
        };
        if let Some(v) = self.coach_rating {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.pwrd_cyber_cafe_id {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.pwrd_cyber_cafe_name.as_ref() {
            os.write_string(25, v)?;
        }
        for v in &self.disabled_random_hero_bits {
            os.write_fixed32(41, *v)?;
        };
        if let Some(v) = self.rank_change {
            os.write_sint32(29, v)?;
        }
        if let Some(v) = self.cameraman {
            os.write_bool(30, v)?;
        }
        for v in &self.custom_game_product_ids {
            os.write_uint32(31, *v)?;
        };
        if let Some(v) = self.search_match_type {
            os.write_enum(33, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.favorite_team_packed {
            os.write_uint64(35, v)?;
        }
        if let Some(v) = self.is_plus_subscriber {
            os.write_bool(36, v)?;
        }
        if let Some(v) = self.lane_selection_flags {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.can_earn_rewards {
            os.write_bool(39, v)?;
        }
        if let Some(v) = self.live_spectator_team {
            os.write_enum(40, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.was_mvp_last_game {
            os.write_bool(43, v)?;
        }
        for v in &self.pending_awards {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        };
        for v in &self.pending_awards_on_victory {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
        };
        if let Some(v) = self.rank_mmr_boost_type {
            os.write_enum(46, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.queue_point_adjustment {
            os.write_sint32(47, v)?;
        }
        if let Some(v) = self.rank_tier {
            os.write_int32(48, v)?;
        }
        if let Some(v) = self.title {
            os.write_uint32(50, v)?;
        }
        if let Some(v) = self.guild_id {
            os.write_uint32(51, v)?;
        }
        if let Some(v) = self.reports_available {
            os.write_uint32(52, v)?;
        }
        if let Some(v) = self.is_steam_china {
            os.write_bool(54, v)?;
        }
        if let Some(v) = self.live_spectator_account_id {
            os.write_uint32(55, v)?;
        }
        if let Some(v) = self.comms_reports_available {
            os.write_uint32(56, v)?;
        }
        for v in &self.banned_hero_ids {
            os.write_int32(57, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTALobbyMember {
        CSODOTALobbyMember::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.slot = ::std::option::Option::None;
        self.party_id = ::std::option::Option::None;
        self.meta_level = ::std::option::Option::None;
        self.meta_xp = ::std::option::Option::None;
        self.meta_xp_awarded = ::std::option::Option::None;
        self.leaver_status = ::std::option::Option::None;
        self.leaver_actions = ::std::option::Option::None;
        self.channel = ::std::option::Option::None;
        self.disabled_hero_id.clear();
        self.enabled_hero_id.clear();
        self.coach_team = ::std::option::Option::None;
        self.coached_account_ids.clear();
        self.coach_rating = ::std::option::Option::None;
        self.pwrd_cyber_cafe_id = ::std::option::Option::None;
        self.pwrd_cyber_cafe_name = ::std::option::Option::None;
        self.disabled_random_hero_bits.clear();
        self.rank_change = ::std::option::Option::None;
        self.cameraman = ::std::option::Option::None;
        self.custom_game_product_ids.clear();
        self.search_match_type = ::std::option::Option::None;
        self.favorite_team_packed = ::std::option::Option::None;
        self.is_plus_subscriber = ::std::option::Option::None;
        self.lane_selection_flags = ::std::option::Option::None;
        self.can_earn_rewards = ::std::option::Option::None;
        self.live_spectator_team = ::std::option::Option::None;
        self.was_mvp_last_game = ::std::option::Option::None;
        self.pending_awards.clear();
        self.pending_awards_on_victory.clear();
        self.rank_mmr_boost_type = ::std::option::Option::None;
        self.queue_point_adjustment = ::std::option::Option::None;
        self.rank_tier = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.guild_id = ::std::option::Option::None;
        self.reports_available = ::std::option::Option::None;
        self.is_steam_china = ::std::option::Option::None;
        self.live_spectator_account_id = ::std::option::Option::None;
        self.comms_reports_available = ::std::option::Option::None;
        self.banned_hero_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTALobbyMember {
        static instance: CSODOTALobbyMember = CSODOTALobbyMember {
            id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            team: ::std::option::Option::None,
            name: ::std::option::Option::None,
            slot: ::std::option::Option::None,
            party_id: ::std::option::Option::None,
            meta_level: ::std::option::Option::None,
            meta_xp: ::std::option::Option::None,
            meta_xp_awarded: ::std::option::Option::None,
            leaver_status: ::std::option::Option::None,
            leaver_actions: ::std::option::Option::None,
            channel: ::std::option::Option::None,
            disabled_hero_id: ::std::vec::Vec::new(),
            enabled_hero_id: ::std::vec::Vec::new(),
            coach_team: ::std::option::Option::None,
            coached_account_ids: ::std::vec::Vec::new(),
            coach_rating: ::std::option::Option::None,
            pwrd_cyber_cafe_id: ::std::option::Option::None,
            pwrd_cyber_cafe_name: ::std::option::Option::None,
            disabled_random_hero_bits: ::std::vec::Vec::new(),
            rank_change: ::std::option::Option::None,
            cameraman: ::std::option::Option::None,
            custom_game_product_ids: ::std::vec::Vec::new(),
            search_match_type: ::std::option::Option::None,
            favorite_team_packed: ::std::option::Option::None,
            is_plus_subscriber: ::std::option::Option::None,
            lane_selection_flags: ::std::option::Option::None,
            can_earn_rewards: ::std::option::Option::None,
            live_spectator_team: ::std::option::Option::None,
            was_mvp_last_game: ::std::option::Option::None,
            pending_awards: ::std::vec::Vec::new(),
            pending_awards_on_victory: ::std::vec::Vec::new(),
            rank_mmr_boost_type: ::std::option::Option::None,
            queue_point_adjustment: ::std::option::Option::None,
            rank_tier: ::std::option::Option::None,
            title: ::std::option::Option::None,
            guild_id: ::std::option::Option::None,
            reports_available: ::std::option::Option::None,
            is_steam_china: ::std::option::Option::None,
            live_spectator_account_id: ::std::option::Option::None,
            comms_reports_available: ::std::option::Option::None,
            banned_hero_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSODOTAServerLobbyMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAServerLobbyMember {
    // special fields
    // @@protoc_insertion_point(special_field:CSODOTAServerLobbyMember.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAServerLobbyMember {
    fn default() -> &'a CSODOTAServerLobbyMember {
        <CSODOTAServerLobbyMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSODOTAServerLobbyMember {
    pub fn new() -> CSODOTAServerLobbyMember {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSODOTAServerLobbyMember {
    const NAME: &'static str = "CSODOTAServerLobbyMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAServerLobbyMember {
        CSODOTAServerLobbyMember::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAServerLobbyMember {
        static instance: CSODOTAServerLobbyMember = CSODOTAServerLobbyMember {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSODOTAStaticLobbyMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAStaticLobbyMember {
    // special fields
    // @@protoc_insertion_point(special_field:CSODOTAStaticLobbyMember.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAStaticLobbyMember {
    fn default() -> &'a CSODOTAStaticLobbyMember {
        <CSODOTAStaticLobbyMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSODOTAStaticLobbyMember {
    pub fn new() -> CSODOTAStaticLobbyMember {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSODOTAStaticLobbyMember {
    const NAME: &'static str = "CSODOTAStaticLobbyMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAStaticLobbyMember {
        CSODOTAStaticLobbyMember::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAStaticLobbyMember {
        static instance: CSODOTAStaticLobbyMember = CSODOTAStaticLobbyMember {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSODOTAServerStaticLobbyMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAServerStaticLobbyMember {
    // message fields
    // @@protoc_insertion_point(field:CSODOTAServerStaticLobbyMember.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSODOTAServerStaticLobbyMember.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAServerStaticLobbyMember {
    fn default() -> &'a CSODOTAServerStaticLobbyMember {
        <CSODOTAServerStaticLobbyMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSODOTAServerStaticLobbyMember {
    pub fn new() -> CSODOTAServerStaticLobbyMember {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSODOTAServerStaticLobbyMember {
    const NAME: &'static str = "CSODOTAServerStaticLobbyMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAServerStaticLobbyMember {
        CSODOTAServerStaticLobbyMember::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAServerStaticLobbyMember {
        static instance: CSODOTAServerStaticLobbyMember = CSODOTAServerStaticLobbyMember {
            steam_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CLobbyTeamDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CLobbyTeamDetails {
    // message fields
    // @@protoc_insertion_point(field:CLobbyTeamDetails.team_name)
    pub team_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CLobbyTeamDetails.team_tag)
    pub team_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CLobbyTeamDetails.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyTeamDetails.team_logo)
    pub team_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CLobbyTeamDetails.team_base_logo)
    pub team_base_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CLobbyTeamDetails.team_banner_logo)
    pub team_banner_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CLobbyTeamDetails.team_complete)
    pub team_complete: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CLobbyTeamDetails.rank)
    pub rank: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyTeamDetails.rank_change)
    pub rank_change: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CLobbyTeamDetails.is_home_team)
    pub is_home_team: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CLobbyTeamDetails.is_challenge_match)
    pub is_challenge_match: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CLobbyTeamDetails.challenge_match_token_account)
    pub challenge_match_token_account: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CLobbyTeamDetails.team_logo_url)
    pub team_logo_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CLobbyTeamDetails.team_abbreviation)
    pub team_abbreviation: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CLobbyTeamDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLobbyTeamDetails {
    fn default() -> &'a CLobbyTeamDetails {
        <CLobbyTeamDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CLobbyTeamDetails {
    pub fn new() -> CLobbyTeamDetails {
        ::std::default::Default::default()
    }

    // optional string team_name = 1;

    pub fn team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_name(&mut self) {
        self.team_name = ::std::option::Option::None;
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string team_tag = 3;

    pub fn team_tag(&self) -> &str {
        match self.team_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_tag(&mut self) {
        self.team_tag = ::std::option::Option::None;
    }

    pub fn has_team_tag(&self) -> bool {
        self.team_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_tag(&mut self, v: ::std::string::String) {
        self.team_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_tag(&mut self) -> &mut ::std::string::String {
        if self.team_tag.is_none() {
            self.team_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_tag(&mut self) -> ::std::string::String {
        self.team_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 team_id = 4;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional uint64 team_logo = 5;

    pub fn team_logo(&self) -> u64 {
        self.team_logo.unwrap_or(0)
    }

    pub fn clear_team_logo(&mut self) {
        self.team_logo = ::std::option::Option::None;
    }

    pub fn has_team_logo(&self) -> bool {
        self.team_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_logo(&mut self, v: u64) {
        self.team_logo = ::std::option::Option::Some(v);
    }

    // optional uint64 team_base_logo = 6;

    pub fn team_base_logo(&self) -> u64 {
        self.team_base_logo.unwrap_or(0)
    }

    pub fn clear_team_base_logo(&mut self) {
        self.team_base_logo = ::std::option::Option::None;
    }

    pub fn has_team_base_logo(&self) -> bool {
        self.team_base_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_base_logo(&mut self, v: u64) {
        self.team_base_logo = ::std::option::Option::Some(v);
    }

    // optional uint64 team_banner_logo = 7;

    pub fn team_banner_logo(&self) -> u64 {
        self.team_banner_logo.unwrap_or(0)
    }

    pub fn clear_team_banner_logo(&mut self) {
        self.team_banner_logo = ::std::option::Option::None;
    }

    pub fn has_team_banner_logo(&self) -> bool {
        self.team_banner_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_banner_logo(&mut self, v: u64) {
        self.team_banner_logo = ::std::option::Option::Some(v);
    }

    // optional bool team_complete = 8;

    pub fn team_complete(&self) -> bool {
        self.team_complete.unwrap_or(false)
    }

    pub fn clear_team_complete(&mut self) {
        self.team_complete = ::std::option::Option::None;
    }

    pub fn has_team_complete(&self) -> bool {
        self.team_complete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_complete(&mut self, v: bool) {
        self.team_complete = ::std::option::Option::Some(v);
    }

    // optional uint32 rank = 15;

    pub fn rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional sint32 rank_change = 16;

    pub fn rank_change(&self) -> i32 {
        self.rank_change.unwrap_or(0)
    }

    pub fn clear_rank_change(&mut self) {
        self.rank_change = ::std::option::Option::None;
    }

    pub fn has_rank_change(&self) -> bool {
        self.rank_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_change(&mut self, v: i32) {
        self.rank_change = ::std::option::Option::Some(v);
    }

    // optional bool is_home_team = 17;

    pub fn is_home_team(&self) -> bool {
        self.is_home_team.unwrap_or(false)
    }

    pub fn clear_is_home_team(&mut self) {
        self.is_home_team = ::std::option::Option::None;
    }

    pub fn has_is_home_team(&self) -> bool {
        self.is_home_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_home_team(&mut self, v: bool) {
        self.is_home_team = ::std::option::Option::Some(v);
    }

    // optional bool is_challenge_match = 18;

    pub fn is_challenge_match(&self) -> bool {
        self.is_challenge_match.unwrap_or(false)
    }

    pub fn clear_is_challenge_match(&mut self) {
        self.is_challenge_match = ::std::option::Option::None;
    }

    pub fn has_is_challenge_match(&self) -> bool {
        self.is_challenge_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_challenge_match(&mut self, v: bool) {
        self.is_challenge_match = ::std::option::Option::Some(v);
    }

    // optional uint64 challenge_match_token_account = 19;

    pub fn challenge_match_token_account(&self) -> u64 {
        self.challenge_match_token_account.unwrap_or(0)
    }

    pub fn clear_challenge_match_token_account(&mut self) {
        self.challenge_match_token_account = ::std::option::Option::None;
    }

    pub fn has_challenge_match_token_account(&self) -> bool {
        self.challenge_match_token_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_match_token_account(&mut self, v: u64) {
        self.challenge_match_token_account = ::std::option::Option::Some(v);
    }

    // optional string team_logo_url = 20;

    pub fn team_logo_url(&self) -> &str {
        match self.team_logo_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_logo_url(&mut self) {
        self.team_logo_url = ::std::option::Option::None;
    }

    pub fn has_team_logo_url(&self) -> bool {
        self.team_logo_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_logo_url(&mut self, v: ::std::string::String) {
        self.team_logo_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_logo_url(&mut self) -> &mut ::std::string::String {
        if self.team_logo_url.is_none() {
            self.team_logo_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_logo_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_logo_url(&mut self) -> ::std::string::String {
        self.team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string team_abbreviation = 21;

    pub fn team_abbreviation(&self) -> &str {
        match self.team_abbreviation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_abbreviation(&mut self) {
        self.team_abbreviation = ::std::option::Option::None;
    }

    pub fn has_team_abbreviation(&self) -> bool {
        self.team_abbreviation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_abbreviation(&mut self, v: ::std::string::String) {
        self.team_abbreviation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_abbreviation(&mut self) -> &mut ::std::string::String {
        if self.team_abbreviation.is_none() {
            self.team_abbreviation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_abbreviation.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_abbreviation(&mut self) -> ::std::string::String {
        self.team_abbreviation.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CLobbyTeamDetails {
    const NAME: &'static str = "CLobbyTeamDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.team_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.team_tag = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.team_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.team_base_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.team_banner_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.team_complete = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.rank_change = ::std::option::Option::Some(is.read_sint32()?);
                },
                136 => {
                    self.is_home_team = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.is_challenge_match = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.challenge_match_token_account = ::std::option::Option::Some(is.read_uint64()?);
                },
                162 => {
                    self.team_logo_url = ::std::option::Option::Some(is.read_string()?);
                },
                170 => {
                    self.team_abbreviation = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.team_tag.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.team_logo {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.team_base_logo {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.team_banner_logo {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.team_complete {
            my_size += 1 + 1;
        }
        if let Some(v) = self.rank {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.rank_change {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(16, v);
        }
        if let Some(v) = self.is_home_team {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_challenge_match {
            my_size += 2 + 1;
        }
        if let Some(v) = self.challenge_match_token_account {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(19, v);
        }
        if let Some(v) = self.team_logo_url.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.team_abbreviation.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(21, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.team_tag.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.team_logo {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.team_base_logo {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.team_banner_logo {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.team_complete {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.rank_change {
            os.write_sint32(16, v)?;
        }
        if let Some(v) = self.is_home_team {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.is_challenge_match {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.challenge_match_token_account {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.team_logo_url.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.team_abbreviation.as_ref() {
            os.write_string(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLobbyTeamDetails {
        CLobbyTeamDetails::new()
    }

    fn clear(&mut self) {
        self.team_name = ::std::option::Option::None;
        self.team_tag = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.team_logo = ::std::option::Option::None;
        self.team_base_logo = ::std::option::Option::None;
        self.team_banner_logo = ::std::option::Option::None;
        self.team_complete = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.rank_change = ::std::option::Option::None;
        self.is_home_team = ::std::option::Option::None;
        self.is_challenge_match = ::std::option::Option::None;
        self.challenge_match_token_account = ::std::option::Option::None;
        self.team_logo_url = ::std::option::Option::None;
        self.team_abbreviation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLobbyTeamDetails {
        static instance: CLobbyTeamDetails = CLobbyTeamDetails {
            team_name: ::std::option::Option::None,
            team_tag: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            team_logo: ::std::option::Option::None,
            team_base_logo: ::std::option::Option::None,
            team_banner_logo: ::std::option::Option::None,
            team_complete: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            rank_change: ::std::option::Option::None,
            is_home_team: ::std::option::Option::None,
            is_challenge_match: ::std::option::Option::None,
            challenge_match_token_account: ::std::option::Option::None,
            team_logo_url: ::std::option::Option::None,
            team_abbreviation: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CLobbyGuildDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CLobbyGuildDetails {
    // message fields
    // @@protoc_insertion_point(field:CLobbyGuildDetails.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyGuildDetails.guild_primary_color)
    pub guild_primary_color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyGuildDetails.guild_secondary_color)
    pub guild_secondary_color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyGuildDetails.guild_pattern)
    pub guild_pattern: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyGuildDetails.guild_logo)
    pub guild_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CLobbyGuildDetails.guild_points)
    pub guild_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyGuildDetails.guild_event)
    pub guild_event: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyGuildDetails.guild_flags)
    pub guild_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyGuildDetails.team_for_guild)
    pub team_for_guild: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GC_TEAM>>,
    // @@protoc_insertion_point(field:CLobbyGuildDetails.guild_tag)
    pub guild_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CLobbyGuildDetails.guild_weekly_percentile)
    pub guild_weekly_percentile: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CLobbyGuildDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLobbyGuildDetails {
    fn default() -> &'a CLobbyGuildDetails {
        <CLobbyGuildDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CLobbyGuildDetails {
    pub fn new() -> CLobbyGuildDetails {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_primary_color = 2;

    pub fn guild_primary_color(&self) -> u32 {
        self.guild_primary_color.unwrap_or(0)
    }

    pub fn clear_guild_primary_color(&mut self) {
        self.guild_primary_color = ::std::option::Option::None;
    }

    pub fn has_guild_primary_color(&self) -> bool {
        self.guild_primary_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_primary_color(&mut self, v: u32) {
        self.guild_primary_color = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_secondary_color = 3;

    pub fn guild_secondary_color(&self) -> u32 {
        self.guild_secondary_color.unwrap_or(0)
    }

    pub fn clear_guild_secondary_color(&mut self) {
        self.guild_secondary_color = ::std::option::Option::None;
    }

    pub fn has_guild_secondary_color(&self) -> bool {
        self.guild_secondary_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_secondary_color(&mut self, v: u32) {
        self.guild_secondary_color = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_pattern = 4;

    pub fn guild_pattern(&self) -> u32 {
        self.guild_pattern.unwrap_or(0)
    }

    pub fn clear_guild_pattern(&mut self) {
        self.guild_pattern = ::std::option::Option::None;
    }

    pub fn has_guild_pattern(&self) -> bool {
        self.guild_pattern.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_pattern(&mut self, v: u32) {
        self.guild_pattern = ::std::option::Option::Some(v);
    }

    // optional uint64 guild_logo = 5;

    pub fn guild_logo(&self) -> u64 {
        self.guild_logo.unwrap_or(0)
    }

    pub fn clear_guild_logo(&mut self) {
        self.guild_logo = ::std::option::Option::None;
    }

    pub fn has_guild_logo(&self) -> bool {
        self.guild_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_logo(&mut self, v: u64) {
        self.guild_logo = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_points = 6;

    pub fn guild_points(&self) -> u32 {
        self.guild_points.unwrap_or(0)
    }

    pub fn clear_guild_points(&mut self) {
        self.guild_points = ::std::option::Option::None;
    }

    pub fn has_guild_points(&self) -> bool {
        self.guild_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_points(&mut self, v: u32) {
        self.guild_points = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_event = 7;

    pub fn guild_event(&self) -> u32 {
        self.guild_event.unwrap_or(0)
    }

    pub fn clear_guild_event(&mut self) {
        self.guild_event = ::std::option::Option::None;
    }

    pub fn has_guild_event(&self) -> bool {
        self.guild_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_event(&mut self, v: u32) {
        self.guild_event = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_flags = 8;

    pub fn guild_flags(&self) -> u32 {
        self.guild_flags.unwrap_or(0)
    }

    pub fn clear_guild_flags(&mut self) {
        self.guild_flags = ::std::option::Option::None;
    }

    pub fn has_guild_flags(&self) -> bool {
        self.guild_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_flags(&mut self, v: u32) {
        self.guild_flags = ::std::option::Option::Some(v);
    }

    // optional .DOTA_GC_TEAM team_for_guild = 9;

    pub fn team_for_guild(&self) -> super::dota_shared_enums::DOTA_GC_TEAM {
        match self.team_for_guild {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            None => super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
        }
    }

    pub fn clear_team_for_guild(&mut self) {
        self.team_for_guild = ::std::option::Option::None;
    }

    pub fn has_team_for_guild(&self) -> bool {
        self.team_for_guild.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_for_guild(&mut self, v: super::dota_shared_enums::DOTA_GC_TEAM) {
        self.team_for_guild = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string guild_tag = 10;

    pub fn guild_tag(&self) -> &str {
        match self.guild_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_guild_tag(&mut self) {
        self.guild_tag = ::std::option::Option::None;
    }

    pub fn has_guild_tag(&self) -> bool {
        self.guild_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_tag(&mut self, v: ::std::string::String) {
        self.guild_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guild_tag(&mut self) -> &mut ::std::string::String {
        if self.guild_tag.is_none() {
            self.guild_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.guild_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_guild_tag(&mut self) -> ::std::string::String {
        self.guild_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 guild_weekly_percentile = 11;

    pub fn guild_weekly_percentile(&self) -> u32 {
        self.guild_weekly_percentile.unwrap_or(0)
    }

    pub fn clear_guild_weekly_percentile(&mut self) {
        self.guild_weekly_percentile = ::std::option::Option::None;
    }

    pub fn has_guild_weekly_percentile(&self) -> bool {
        self.guild_weekly_percentile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_weekly_percentile(&mut self, v: u32) {
        self.guild_weekly_percentile = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CLobbyGuildDetails {
    const NAME: &'static str = "CLobbyGuildDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.guild_primary_color = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.guild_secondary_color = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.guild_pattern = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.guild_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.guild_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.guild_event = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.guild_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.team_for_guild = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                82 => {
                    self.guild_tag = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.guild_weekly_percentile = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.guild_primary_color {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.guild_secondary_color {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.guild_pattern {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.guild_logo {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.guild_points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.guild_event {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.guild_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.team_for_guild {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.guild_tag.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.guild_weekly_percentile {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.guild_primary_color {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.guild_secondary_color {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.guild_pattern {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.guild_logo {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.guild_points {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.guild_event {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.guild_flags {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.team_for_guild {
            os.write_enum(9, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.guild_tag.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.guild_weekly_percentile {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLobbyGuildDetails {
        CLobbyGuildDetails::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.guild_primary_color = ::std::option::Option::None;
        self.guild_secondary_color = ::std::option::Option::None;
        self.guild_pattern = ::std::option::Option::None;
        self.guild_logo = ::std::option::Option::None;
        self.guild_points = ::std::option::Option::None;
        self.guild_event = ::std::option::Option::None;
        self.guild_flags = ::std::option::Option::None;
        self.team_for_guild = ::std::option::Option::None;
        self.guild_tag = ::std::option::Option::None;
        self.guild_weekly_percentile = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLobbyGuildDetails {
        static instance: CLobbyGuildDetails = CLobbyGuildDetails {
            guild_id: ::std::option::Option::None,
            guild_primary_color: ::std::option::Option::None,
            guild_secondary_color: ::std::option::Option::None,
            guild_pattern: ::std::option::Option::None,
            guild_logo: ::std::option::Option::None,
            guild_points: ::std::option::Option::None,
            guild_event: ::std::option::Option::None,
            guild_flags: ::std::option::Option::None,
            team_for_guild: ::std::option::Option::None,
            guild_tag: ::std::option::Option::None,
            guild_weekly_percentile: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CLobbyTimedRewardDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CLobbyTimedRewardDetails {
    // message fields
    // @@protoc_insertion_point(field:CLobbyTimedRewardDetails.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyTimedRewardDetails.is_supply_crate)
    pub is_supply_crate: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CLobbyTimedRewardDetails.is_timed_drop)
    pub is_timed_drop: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CLobbyTimedRewardDetails.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyTimedRewardDetails.origin)
    pub origin: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CLobbyTimedRewardDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLobbyTimedRewardDetails {
    fn default() -> &'a CLobbyTimedRewardDetails {
        <CLobbyTimedRewardDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CLobbyTimedRewardDetails {
    pub fn new() -> CLobbyTimedRewardDetails {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 2;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional bool is_supply_crate = 3;

    pub fn is_supply_crate(&self) -> bool {
        self.is_supply_crate.unwrap_or(false)
    }

    pub fn clear_is_supply_crate(&mut self) {
        self.is_supply_crate = ::std::option::Option::None;
    }

    pub fn has_is_supply_crate(&self) -> bool {
        self.is_supply_crate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_supply_crate(&mut self, v: bool) {
        self.is_supply_crate = ::std::option::Option::Some(v);
    }

    // optional bool is_timed_drop = 4;

    pub fn is_timed_drop(&self) -> bool {
        self.is_timed_drop.unwrap_or(false)
    }

    pub fn clear_is_timed_drop(&mut self) {
        self.is_timed_drop = ::std::option::Option::None;
    }

    pub fn has_is_timed_drop(&self) -> bool {
        self.is_timed_drop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_timed_drop(&mut self, v: bool) {
        self.is_timed_drop = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 5;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 6;

    pub fn origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }

    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CLobbyTimedRewardDetails {
    const NAME: &'static str = "CLobbyTimedRewardDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.is_supply_crate = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.is_timed_drop = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.origin = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.is_supply_crate {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_timed_drop {
            my_size += 1 + 1;
        }
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.origin {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.is_supply_crate {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.is_timed_drop {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLobbyTimedRewardDetails {
        CLobbyTimedRewardDetails::new()
    }

    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.is_supply_crate = ::std::option::Option::None;
        self.is_timed_drop = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLobbyTimedRewardDetails {
        static instance: CLobbyTimedRewardDetails = CLobbyTimedRewardDetails {
            item_def_index: ::std::option::Option::None,
            is_supply_crate: ::std::option::Option::None,
            is_timed_drop: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            origin: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CLobbyBroadcastChannelInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CLobbyBroadcastChannelInfo {
    // message fields
    // @@protoc_insertion_point(field:CLobbyBroadcastChannelInfo.channel_id)
    pub channel_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyBroadcastChannelInfo.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CLobbyBroadcastChannelInfo.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CLobbyBroadcastChannelInfo.language_code)
    pub language_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CLobbyBroadcastChannelInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLobbyBroadcastChannelInfo {
    fn default() -> &'a CLobbyBroadcastChannelInfo {
        <CLobbyBroadcastChannelInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CLobbyBroadcastChannelInfo {
    pub fn new() -> CLobbyBroadcastChannelInfo {
        ::std::default::Default::default()
    }

    // optional uint32 channel_id = 1;

    pub fn channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional string country_code = 2;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 3;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string language_code = 4;

    pub fn language_code(&self) -> &str {
        match self.language_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language_code(&mut self) {
        self.language_code = ::std::option::Option::None;
    }

    pub fn has_language_code(&self) -> bool {
        self.language_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language_code(&mut self, v: ::std::string::String) {
        self.language_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language_code(&mut self) -> &mut ::std::string::String {
        if self.language_code.is_none() {
            self.language_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_language_code(&mut self) -> ::std::string::String {
        self.language_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CLobbyBroadcastChannelInfo {
    const NAME: &'static str = "CLobbyBroadcastChannelInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.language_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.language_code.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.channel_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.language_code.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLobbyBroadcastChannelInfo {
        CLobbyBroadcastChannelInfo::new()
    }

    fn clear(&mut self) {
        self.channel_id = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.language_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLobbyBroadcastChannelInfo {
        static instance: CLobbyBroadcastChannelInfo = CLobbyBroadcastChannelInfo {
            channel_id: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            description: ::std::option::Option::None,
            language_code: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CLobbyGuildChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CLobbyGuildChallenge {
    // message fields
    // @@protoc_insertion_point(field:CLobbyGuildChallenge.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyGuildChallenge.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CLobbyGuildChallenge.challenge_instance_id)
    pub challenge_instance_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyGuildChallenge.challenge_parameter)
    pub challenge_parameter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyGuildChallenge.challenge_timestamp)
    pub challenge_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyGuildChallenge.challenge_period_serial)
    pub challenge_period_serial: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyGuildChallenge.challenge_progress_at_start)
    pub challenge_progress_at_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLobbyGuildChallenge.eligible_account_ids)
    pub eligible_account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CLobbyGuildChallenge.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLobbyGuildChallenge {
    fn default() -> &'a CLobbyGuildChallenge {
        <CLobbyGuildChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CLobbyGuildChallenge {
    pub fn new() -> CLobbyGuildChallenge {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 challenge_instance_id = 3;

    pub fn challenge_instance_id(&self) -> u32 {
        self.challenge_instance_id.unwrap_or(0)
    }

    pub fn clear_challenge_instance_id(&mut self) {
        self.challenge_instance_id = ::std::option::Option::None;
    }

    pub fn has_challenge_instance_id(&self) -> bool {
        self.challenge_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_instance_id(&mut self, v: u32) {
        self.challenge_instance_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_parameter = 4;

    pub fn challenge_parameter(&self) -> u32 {
        self.challenge_parameter.unwrap_or(0)
    }

    pub fn clear_challenge_parameter(&mut self) {
        self.challenge_parameter = ::std::option::Option::None;
    }

    pub fn has_challenge_parameter(&self) -> bool {
        self.challenge_parameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_parameter(&mut self, v: u32) {
        self.challenge_parameter = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_timestamp = 5;

    pub fn challenge_timestamp(&self) -> u32 {
        self.challenge_timestamp.unwrap_or(0)
    }

    pub fn clear_challenge_timestamp(&mut self) {
        self.challenge_timestamp = ::std::option::Option::None;
    }

    pub fn has_challenge_timestamp(&self) -> bool {
        self.challenge_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_timestamp(&mut self, v: u32) {
        self.challenge_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_period_serial = 6;

    pub fn challenge_period_serial(&self) -> u32 {
        self.challenge_period_serial.unwrap_or(0)
    }

    pub fn clear_challenge_period_serial(&mut self) {
        self.challenge_period_serial = ::std::option::Option::None;
    }

    pub fn has_challenge_period_serial(&self) -> bool {
        self.challenge_period_serial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_period_serial(&mut self, v: u32) {
        self.challenge_period_serial = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_progress_at_start = 7;

    pub fn challenge_progress_at_start(&self) -> u32 {
        self.challenge_progress_at_start.unwrap_or(0)
    }

    pub fn clear_challenge_progress_at_start(&mut self) {
        self.challenge_progress_at_start = ::std::option::Option::None;
    }

    pub fn has_challenge_progress_at_start(&self) -> bool {
        self.challenge_progress_at_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_progress_at_start(&mut self, v: u32) {
        self.challenge_progress_at_start = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CLobbyGuildChallenge {
    const NAME: &'static str = "CLobbyGuildChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.challenge_parameter = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.challenge_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.challenge_period_serial = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.challenge_progress_at_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.eligible_account_ids)?;
                },
                64 => {
                    self.eligible_account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.challenge_instance_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.challenge_parameter {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.challenge_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.challenge_period_serial {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.challenge_progress_at_start {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        for value in &self.eligible_account_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.challenge_instance_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.challenge_parameter {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.challenge_timestamp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.challenge_period_serial {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.challenge_progress_at_start {
            os.write_uint32(7, v)?;
        }
        for v in &self.eligible_account_ids {
            os.write_uint32(8, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLobbyGuildChallenge {
        CLobbyGuildChallenge::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.challenge_instance_id = ::std::option::Option::None;
        self.challenge_parameter = ::std::option::Option::None;
        self.challenge_timestamp = ::std::option::Option::None;
        self.challenge_period_serial = ::std::option::Option::None;
        self.challenge_progress_at_start = ::std::option::Option::None;
        self.eligible_account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLobbyGuildChallenge {
        static instance: CLobbyGuildChallenge = CLobbyGuildChallenge {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            challenge_instance_id: ::std::option::Option::None,
            challenge_parameter: ::std::option::Option::None,
            challenge_timestamp: ::std::option::Option::None,
            challenge_period_serial: ::std::option::Option::None,
            challenge_progress_at_start: ::std::option::Option::None,
            eligible_account_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTALobbyMatchQualityData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTALobbyMatchQualityData {
    // message fields
    // @@protoc_insertion_point(field:CDOTALobbyMatchQualityData.overall_quality)
    pub overall_quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTALobbyMatchQualityData.team_balance)
    pub team_balance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTALobbyMatchQualityData.match_skill_range)
    pub match_skill_range: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTALobbyMatchQualityData.match_behavior)
    pub match_behavior: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTALobbyMatchQualityData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTALobbyMatchQualityData {
    fn default() -> &'a CDOTALobbyMatchQualityData {
        <CDOTALobbyMatchQualityData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTALobbyMatchQualityData {
    pub fn new() -> CDOTALobbyMatchQualityData {
        ::std::default::Default::default()
    }

    // optional uint32 overall_quality = 1;

    pub fn overall_quality(&self) -> u32 {
        self.overall_quality.unwrap_or(0)
    }

    pub fn clear_overall_quality(&mut self) {
        self.overall_quality = ::std::option::Option::None;
    }

    pub fn has_overall_quality(&self) -> bool {
        self.overall_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overall_quality(&mut self, v: u32) {
        self.overall_quality = ::std::option::Option::Some(v);
    }

    // optional uint32 team_balance = 2;

    pub fn team_balance(&self) -> u32 {
        self.team_balance.unwrap_or(0)
    }

    pub fn clear_team_balance(&mut self) {
        self.team_balance = ::std::option::Option::None;
    }

    pub fn has_team_balance(&self) -> bool {
        self.team_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_balance(&mut self, v: u32) {
        self.team_balance = ::std::option::Option::Some(v);
    }

    // optional uint32 match_skill_range = 3;

    pub fn match_skill_range(&self) -> u32 {
        self.match_skill_range.unwrap_or(0)
    }

    pub fn clear_match_skill_range(&mut self) {
        self.match_skill_range = ::std::option::Option::None;
    }

    pub fn has_match_skill_range(&self) -> bool {
        self.match_skill_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_skill_range(&mut self, v: u32) {
        self.match_skill_range = ::std::option::Option::Some(v);
    }

    // optional uint32 match_behavior = 4;

    pub fn match_behavior(&self) -> u32 {
        self.match_behavior.unwrap_or(0)
    }

    pub fn clear_match_behavior(&mut self) {
        self.match_behavior = ::std::option::Option::None;
    }

    pub fn has_match_behavior(&self) -> bool {
        self.match_behavior.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_behavior(&mut self, v: u32) {
        self.match_behavior = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTALobbyMatchQualityData {
    const NAME: &'static str = "CDOTALobbyMatchQualityData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overall_quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.team_balance = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.match_skill_range = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.match_behavior = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overall_quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.team_balance {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.match_skill_range {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.match_behavior {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overall_quality {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.team_balance {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.match_skill_range {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.match_behavior {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTALobbyMatchQualityData {
        CDOTALobbyMatchQualityData::new()
    }

    fn clear(&mut self) {
        self.overall_quality = ::std::option::Option::None;
        self.team_balance = ::std::option::Option::None;
        self.match_skill_range = ::std::option::Option::None;
        self.match_behavior = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTALobbyMatchQualityData {
        static instance: CDOTALobbyMatchQualityData = CDOTALobbyMatchQualityData {
            overall_quality: ::std::option::Option::None,
            team_balance: ::std::option::Option::None,
            match_skill_range: ::std::option::Option::None,
            match_behavior: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSODOTALobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTALobby {
    // message fields
    // @@protoc_insertion_point(field:CSODOTALobby.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobby.all_members)
    pub all_members: ::std::vec::Vec<CSODOTALobbyMember>,
    // @@protoc_insertion_point(field:CSODOTALobby.member_indices)
    pub member_indices: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.left_member_indices)
    pub left_member_indices: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.free_member_indices)
    pub free_member_indices: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.leader_id)
    pub leader_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobby.server_id)
    pub server_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobby.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.pending_invites)
    pub pending_invites: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CSODOTALobby.state)
    pub state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<csodotalobby::State>>,
    // @@protoc_insertion_point(field:CSODOTALobby.connect)
    pub connect: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSODOTALobby.lobby_type)
    pub lobby_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<csodotalobby::LobbyType>>,
    // @@protoc_insertion_point(field:CSODOTALobby.allow_cheats)
    pub allow_cheats: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobby.fill_with_bots)
    pub fill_with_bots: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobby.intro_mode)
    pub intro_mode: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobby.game_name)
    pub game_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSODOTALobby.team_details)
    pub team_details: ::std::vec::Vec<CLobbyTeamDetails>,
    // @@protoc_insertion_point(field:CSODOTALobby.tutorial_lesson)
    pub tutorial_lesson: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.tournament_id)
    pub tournament_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.tournament_game_id)
    pub tournament_game_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.game_state)
    pub game_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameState>>,
    // @@protoc_insertion_point(field:CSODOTALobby.num_spectators)
    pub num_spectators: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.matchgroup)
    pub matchgroup: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.cm_pick)
    pub cm_pick: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_CM_PICK>>,
    // @@protoc_insertion_point(field:CSODOTALobby.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobby.allow_spectating)
    pub allow_spectating: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobby.bot_difficulty_radiant)
    pub bot_difficulty_radiant: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // @@protoc_insertion_point(field:CSODOTALobby.timed_reward_details)
    pub timed_reward_details: ::std::vec::Vec<CLobbyTimedRewardDetails>,
    // @@protoc_insertion_point(field:CSODOTALobby.pass_key)
    pub pass_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSODOTALobby.leagueid)
    pub leagueid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.penalty_level_radiant)
    pub penalty_level_radiant: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.penalty_level_dire)
    pub penalty_level_dire: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.load_game_id)
    pub load_game_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.series_type)
    pub series_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.radiant_series_wins)
    pub radiant_series_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.dire_series_wins)
    pub dire_series_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.loot_generated)
    pub loot_generated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.loot_awarded)
    pub loot_awarded: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.allchat)
    pub allchat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobby.dota_tv_delay)
    pub dota_tv_delay: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<LobbyDotaTVDelay>>,
    // @@protoc_insertion_point(field:CSODOTALobby.custom_game_mode)
    pub custom_game_mode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSODOTALobby.custom_map_name)
    pub custom_map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSODOTALobby.custom_difficulty)
    pub custom_difficulty: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.lan)
    pub lan: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobby.broadcast_channel_info)
    pub broadcast_channel_info: ::std::vec::Vec<CLobbyBroadcastChannelInfo>,
    // @@protoc_insertion_point(field:CSODOTALobby.first_leaver_accountid)
    pub first_leaver_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.series_id)
    pub series_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.low_priority)
    pub low_priority: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobby.extra_messages)
    pub extra_messages: ::std::vec::Vec<csodotalobby::CExtraMsg>,
    // @@protoc_insertion_point(field:CSODOTALobby.save_game)
    pub save_game: ::steam_vent_proto_common::protobuf::MessageField<super::dota_shared_enums::CDOTASaveGame>,
    // @@protoc_insertion_point(field:CSODOTALobby.first_blood_happened)
    pub first_blood_happened: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobby.match_outcome)
    pub match_outcome: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EMatchOutcome>>,
    // @@protoc_insertion_point(field:CSODOTALobby.mass_disconnect)
    pub mass_disconnect: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobby.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobby.custom_min_players)
    pub custom_min_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.custom_max_players)
    pub custom_max_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.visibility)
    pub visibility: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTALobbyVisibility>>,
    // @@protoc_insertion_point(field:CSODOTALobby.custom_game_crc)
    pub custom_game_crc: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobby.custom_game_auto_created_lobby)
    pub custom_game_auto_created_lobby: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobby.custom_game_timestamp)
    pub custom_game_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.previous_series_matches)
    pub previous_series_matches: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CSODOTALobby.previous_match_override)
    pub previous_match_override: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobby.game_start_time)
    pub game_start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.pause_setting)
    pub pause_setting: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<LobbyDotaPauseSetting>>,
    // @@protoc_insertion_point(field:CSODOTALobby.weekend_tourney_division_id)
    pub weekend_tourney_division_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.weekend_tourney_skill_level)
    pub weekend_tourney_skill_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.weekend_tourney_bracket_round)
    pub weekend_tourney_bracket_round: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.bot_difficulty_dire)
    pub bot_difficulty_dire: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // @@protoc_insertion_point(field:CSODOTALobby.bot_radiant)
    pub bot_radiant: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobby.bot_dire)
    pub bot_dire: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobby.event_progression_enabled)
    pub event_progression_enabled: ::std::vec::Vec<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CSODOTALobby.selection_priority_rules)
    pub selection_priority_rules: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTASelectionPriorityRules>>,
    // @@protoc_insertion_point(field:CSODOTALobby.series_previous_selection_priority_team_id)
    pub series_previous_selection_priority_team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.series_current_selection_priority_team_id)
    pub series_current_selection_priority_team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.series_current_priority_team_choice)
    pub series_current_priority_team_choice: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTASelectionPriorityChoice>>,
    // @@protoc_insertion_point(field:CSODOTALobby.series_current_non_priority_team_choice)
    pub series_current_non_priority_team_choice: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTASelectionPriorityChoice>>,
    // @@protoc_insertion_point(field:CSODOTALobby.series_current_selection_priority_used_coin_toss)
    pub series_current_selection_priority_used_coin_toss: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobby.current_primary_event)
    pub current_primary_event: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CSODOTALobby.emergency_disabled_hero_ids)
    pub emergency_disabled_hero_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CSODOTALobby.custom_game_private_key)
    pub custom_game_private_key: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSODOTALobby.custom_game_penalties)
    pub custom_game_penalties: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobby.lan_host_ping_location)
    pub lan_host_ping_location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSODOTALobby.league_node_id)
    pub league_node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.match_duration)
    pub match_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.league_phase)
    pub league_phase: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.experimental_gameplay_enabled)
    pub experimental_gameplay_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobby.guild_challenges)
    pub guild_challenges: ::std::vec::Vec<CLobbyGuildChallenge>,
    // @@protoc_insertion_point(field:CSODOTALobby.guild_details)
    pub guild_details: ::std::vec::Vec<CLobbyGuildDetails>,
    // @@protoc_insertion_point(field:CSODOTALobby.lobby_event_points)
    pub lobby_event_points: ::std::vec::Vec<CMsgLobbyEventPoints>,
    // @@protoc_insertion_point(field:CSODOTALobby.requested_hero_ids)
    pub requested_hero_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CSODOTALobby.coach_friend_requests)
    pub coach_friend_requests: ::std::vec::Vec<CMsgLobbyCoachFriendRequest>,
    // @@protoc_insertion_point(field:CSODOTALobby.is_in_steam_china)
    pub is_in_steam_china: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobby.with_scenario_save)
    pub with_scenario_save: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTALobby.lobby_creation_time)
    pub lobby_creation_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTALobby.event_game_definition)
    pub event_game_definition: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSODOTALobby.extra_startup_messages)
    pub extra_startup_messages: ::std::vec::Vec<csodotalobby::CExtraMsg>,
    // @@protoc_insertion_point(field:CSODOTALobby.match_quality_data)
    pub match_quality_data: ::steam_vent_proto_common::protobuf::MessageField<CDOTALobbyMatchQualityData>,
    // special fields
    // @@protoc_insertion_point(special_field:CSODOTALobby.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTALobby {
    fn default() -> &'a CSODOTALobby {
        <CSODOTALobby as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSODOTALobby {
    pub fn new() -> CSODOTALobby {
        ::std::default::Default::default()
    }

    // optional uint64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 leader_id = 11;

    pub fn leader_id(&self) -> u64 {
        self.leader_id.unwrap_or(0)
    }

    pub fn clear_leader_id(&mut self) {
        self.leader_id = ::std::option::Option::None;
    }

    pub fn has_leader_id(&self) -> bool {
        self.leader_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: u64) {
        self.leader_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 server_id = 6;

    pub fn server_id(&self) -> u64 {
        self.server_id.unwrap_or(0u64)
    }

    pub fn clear_server_id(&mut self) {
        self.server_id = ::std::option::Option::None;
    }

    pub fn has_server_id(&self) -> bool {
        self.server_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_id(&mut self, v: u64) {
        self.server_id = ::std::option::Option::Some(v);
    }

    // optional uint32 game_mode = 3;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional .CSODOTALobby.State state = 4;

    pub fn state(&self) -> csodotalobby::State {
        match self.state {
            Some(e) => e.enum_value_or(csodotalobby::State::UI),
            None => csodotalobby::State::UI,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: csodotalobby::State) {
        self.state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string connect = 5;

    pub fn connect(&self) -> &str {
        match self.connect.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_connect(&mut self) {
        self.connect = ::std::option::Option::None;
    }

    pub fn has_connect(&self) -> bool {
        self.connect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect(&mut self, v: ::std::string::String) {
        self.connect = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect(&mut self) -> &mut ::std::string::String {
        if self.connect.is_none() {
            self.connect = ::std::option::Option::Some(::std::string::String::new());
        }
        self.connect.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect(&mut self) -> ::std::string::String {
        self.connect.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CSODOTALobby.LobbyType lobby_type = 12;

    pub fn lobby_type(&self) -> csodotalobby::LobbyType {
        match self.lobby_type {
            Some(e) => e.enum_value_or(csodotalobby::LobbyType::INVALID),
            None => csodotalobby::LobbyType::INVALID,
        }
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: csodotalobby::LobbyType) {
        self.lobby_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool allow_cheats = 13;

    pub fn allow_cheats(&self) -> bool {
        self.allow_cheats.unwrap_or(false)
    }

    pub fn clear_allow_cheats(&mut self) {
        self.allow_cheats = ::std::option::Option::None;
    }

    pub fn has_allow_cheats(&self) -> bool {
        self.allow_cheats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_cheats(&mut self, v: bool) {
        self.allow_cheats = ::std::option::Option::Some(v);
    }

    // optional bool fill_with_bots = 14;

    pub fn fill_with_bots(&self) -> bool {
        self.fill_with_bots.unwrap_or(false)
    }

    pub fn clear_fill_with_bots(&mut self) {
        self.fill_with_bots = ::std::option::Option::None;
    }

    pub fn has_fill_with_bots(&self) -> bool {
        self.fill_with_bots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fill_with_bots(&mut self, v: bool) {
        self.fill_with_bots = ::std::option::Option::Some(v);
    }

    // optional bool intro_mode = 15;

    pub fn intro_mode(&self) -> bool {
        self.intro_mode.unwrap_or(false)
    }

    pub fn clear_intro_mode(&mut self) {
        self.intro_mode = ::std::option::Option::None;
    }

    pub fn has_intro_mode(&self) -> bool {
        self.intro_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_intro_mode(&mut self, v: bool) {
        self.intro_mode = ::std::option::Option::Some(v);
    }

    // optional string game_name = 16;

    pub fn game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_name(&mut self) {
        self.game_name = ::std::option::Option::None;
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 tutorial_lesson = 18;

    pub fn tutorial_lesson(&self) -> u32 {
        self.tutorial_lesson.unwrap_or(0)
    }

    pub fn clear_tutorial_lesson(&mut self) {
        self.tutorial_lesson = ::std::option::Option::None;
    }

    pub fn has_tutorial_lesson(&self) -> bool {
        self.tutorial_lesson.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tutorial_lesson(&mut self, v: u32) {
        self.tutorial_lesson = ::std::option::Option::Some(v);
    }

    // optional uint32 tournament_id = 19;

    pub fn tournament_id(&self) -> u32 {
        self.tournament_id.unwrap_or(0)
    }

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id = ::std::option::Option::None;
    }

    pub fn has_tournament_id(&self) -> bool {
        self.tournament_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: u32) {
        self.tournament_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tournament_game_id = 20;

    pub fn tournament_game_id(&self) -> u32 {
        self.tournament_game_id.unwrap_or(0)
    }

    pub fn clear_tournament_game_id(&mut self) {
        self.tournament_game_id = ::std::option::Option::None;
    }

    pub fn has_tournament_game_id(&self) -> bool {
        self.tournament_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_game_id(&mut self, v: u32) {
        self.tournament_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_region = 21;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0u32)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional .DOTA_GameState game_state = 22;

    pub fn game_state(&self) -> super::dota_shared_enums::DOTA_GameState {
        match self.game_state {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameState::DOTA_GAMERULES_STATE_INIT),
            None => super::dota_shared_enums::DOTA_GameState::DOTA_GAMERULES_STATE_INIT,
        }
    }

    pub fn clear_game_state(&mut self) {
        self.game_state = ::std::option::Option::None;
    }

    pub fn has_game_state(&self) -> bool {
        self.game_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_state(&mut self, v: super::dota_shared_enums::DOTA_GameState) {
        self.game_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 num_spectators = 23;

    pub fn num_spectators(&self) -> u32 {
        self.num_spectators.unwrap_or(0)
    }

    pub fn clear_num_spectators(&mut self) {
        self.num_spectators = ::std::option::Option::None;
    }

    pub fn has_num_spectators(&self) -> bool {
        self.num_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_spectators(&mut self, v: u32) {
        self.num_spectators = ::std::option::Option::Some(v);
    }

    // optional uint32 matchgroup = 25;

    pub fn matchgroup(&self) -> u32 {
        self.matchgroup.unwrap_or(0)
    }

    pub fn clear_matchgroup(&mut self) {
        self.matchgroup = ::std::option::Option::None;
    }

    pub fn has_matchgroup(&self) -> bool {
        self.matchgroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchgroup(&mut self, v: u32) {
        self.matchgroup = ::std::option::Option::Some(v);
    }

    // optional .DOTA_CM_PICK cm_pick = 28;

    pub fn cm_pick(&self) -> super::dota_shared_enums::DOTA_CM_PICK {
        match self.cm_pick {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_CM_PICK::DOTA_CM_RANDOM),
            None => super::dota_shared_enums::DOTA_CM_PICK::DOTA_CM_RANDOM,
        }
    }

    pub fn clear_cm_pick(&mut self) {
        self.cm_pick = ::std::option::Option::None;
    }

    pub fn has_cm_pick(&self) -> bool {
        self.cm_pick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cm_pick(&mut self, v: super::dota_shared_enums::DOTA_CM_PICK) {
        self.cm_pick = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 match_id = 30;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional bool allow_spectating = 31;

    pub fn allow_spectating(&self) -> bool {
        self.allow_spectating.unwrap_or(true)
    }

    pub fn clear_allow_spectating(&mut self) {
        self.allow_spectating = ::std::option::Option::None;
    }

    pub fn has_allow_spectating(&self) -> bool {
        self.allow_spectating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_spectating(&mut self, v: bool) {
        self.allow_spectating = ::std::option::Option::Some(v);
    }

    // optional .DOTABotDifficulty bot_difficulty_radiant = 36;

    pub fn bot_difficulty_radiant(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.bot_difficulty_radiant {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_HARD),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_HARD,
        }
    }

    pub fn clear_bot_difficulty_radiant(&mut self) {
        self.bot_difficulty_radiant = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty_radiant(&self) -> bool {
        self.bot_difficulty_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty_radiant(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.bot_difficulty_radiant = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string pass_key = 39;

    pub fn pass_key(&self) -> &str {
        match self.pass_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pass_key(&mut self) {
        self.pass_key = ::std::option::Option::None;
    }

    pub fn has_pass_key(&self) -> bool {
        self.pass_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pass_key(&mut self, v: ::std::string::String) {
        self.pass_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pass_key(&mut self) -> &mut ::std::string::String {
        if self.pass_key.is_none() {
            self.pass_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pass_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_pass_key(&mut self) -> ::std::string::String {
        self.pass_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 leagueid = 42;

    pub fn leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_level_radiant = 43;

    pub fn penalty_level_radiant(&self) -> u32 {
        self.penalty_level_radiant.unwrap_or(0u32)
    }

    pub fn clear_penalty_level_radiant(&mut self) {
        self.penalty_level_radiant = ::std::option::Option::None;
    }

    pub fn has_penalty_level_radiant(&self) -> bool {
        self.penalty_level_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_level_radiant(&mut self, v: u32) {
        self.penalty_level_radiant = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_level_dire = 44;

    pub fn penalty_level_dire(&self) -> u32 {
        self.penalty_level_dire.unwrap_or(0u32)
    }

    pub fn clear_penalty_level_dire(&mut self) {
        self.penalty_level_dire = ::std::option::Option::None;
    }

    pub fn has_penalty_level_dire(&self) -> bool {
        self.penalty_level_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_level_dire(&mut self, v: u32) {
        self.penalty_level_dire = ::std::option::Option::Some(v);
    }

    // optional uint32 load_game_id = 45;

    pub fn load_game_id(&self) -> u32 {
        self.load_game_id.unwrap_or(0)
    }

    pub fn clear_load_game_id(&mut self) {
        self.load_game_id = ::std::option::Option::None;
    }

    pub fn has_load_game_id(&self) -> bool {
        self.load_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_game_id(&mut self, v: u32) {
        self.load_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 series_type = 46;

    pub fn series_type(&self) -> u32 {
        self.series_type.unwrap_or(0)
    }

    pub fn clear_series_type(&mut self) {
        self.series_type = ::std::option::Option::None;
    }

    pub fn has_series_type(&self) -> bool {
        self.series_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_type(&mut self, v: u32) {
        self.series_type = ::std::option::Option::Some(v);
    }

    // optional uint32 radiant_series_wins = 47;

    pub fn radiant_series_wins(&self) -> u32 {
        self.radiant_series_wins.unwrap_or(0)
    }

    pub fn clear_radiant_series_wins(&mut self) {
        self.radiant_series_wins = ::std::option::Option::None;
    }

    pub fn has_radiant_series_wins(&self) -> bool {
        self.radiant_series_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_series_wins(&mut self, v: u32) {
        self.radiant_series_wins = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_series_wins = 48;

    pub fn dire_series_wins(&self) -> u32 {
        self.dire_series_wins.unwrap_or(0)
    }

    pub fn clear_dire_series_wins(&mut self) {
        self.dire_series_wins = ::std::option::Option::None;
    }

    pub fn has_dire_series_wins(&self) -> bool {
        self.dire_series_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_series_wins(&mut self, v: u32) {
        self.dire_series_wins = ::std::option::Option::Some(v);
    }

    // optional uint32 loot_generated = 49;

    pub fn loot_generated(&self) -> u32 {
        self.loot_generated.unwrap_or(0)
    }

    pub fn clear_loot_generated(&mut self) {
        self.loot_generated = ::std::option::Option::None;
    }

    pub fn has_loot_generated(&self) -> bool {
        self.loot_generated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_generated(&mut self, v: u32) {
        self.loot_generated = ::std::option::Option::Some(v);
    }

    // optional uint32 loot_awarded = 50;

    pub fn loot_awarded(&self) -> u32 {
        self.loot_awarded.unwrap_or(0)
    }

    pub fn clear_loot_awarded(&mut self) {
        self.loot_awarded = ::std::option::Option::None;
    }

    pub fn has_loot_awarded(&self) -> bool {
        self.loot_awarded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_awarded(&mut self, v: u32) {
        self.loot_awarded = ::std::option::Option::Some(v);
    }

    // optional bool allchat = 51;

    pub fn allchat(&self) -> bool {
        self.allchat.unwrap_or(false)
    }

    pub fn clear_allchat(&mut self) {
        self.allchat = ::std::option::Option::None;
    }

    pub fn has_allchat(&self) -> bool {
        self.allchat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allchat(&mut self, v: bool) {
        self.allchat = ::std::option::Option::Some(v);
    }

    // optional .LobbyDotaTVDelay dota_tv_delay = 53;

    pub fn dota_tv_delay(&self) -> LobbyDotaTVDelay {
        match self.dota_tv_delay {
            Some(e) => e.enum_value_or(LobbyDotaTVDelay::LobbyDotaTV_10),
            None => LobbyDotaTVDelay::LobbyDotaTV_10,
        }
    }

    pub fn clear_dota_tv_delay(&mut self) {
        self.dota_tv_delay = ::std::option::Option::None;
    }

    pub fn has_dota_tv_delay(&self) -> bool {
        self.dota_tv_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dota_tv_delay(&mut self, v: LobbyDotaTVDelay) {
        self.dota_tv_delay = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string custom_game_mode = 54;

    pub fn custom_game_mode(&self) -> &str {
        match self.custom_game_mode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_game_mode(&mut self) {
        self.custom_game_mode = ::std::option::Option::None;
    }

    pub fn has_custom_game_mode(&self) -> bool {
        self.custom_game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_mode(&mut self, v: ::std::string::String) {
        self.custom_game_mode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_game_mode(&mut self) -> &mut ::std::string::String {
        if self.custom_game_mode.is_none() {
            self.custom_game_mode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_game_mode.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_game_mode(&mut self) -> ::std::string::String {
        self.custom_game_mode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_map_name = 55;

    pub fn custom_map_name(&self) -> &str {
        match self.custom_map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_map_name(&mut self) {
        self.custom_map_name = ::std::option::Option::None;
    }

    pub fn has_custom_map_name(&self) -> bool {
        self.custom_map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_map_name(&mut self, v: ::std::string::String) {
        self.custom_map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_map_name(&mut self) -> &mut ::std::string::String {
        if self.custom_map_name.is_none() {
            self.custom_map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_map_name(&mut self) -> ::std::string::String {
        self.custom_map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 custom_difficulty = 56;

    pub fn custom_difficulty(&self) -> u32 {
        self.custom_difficulty.unwrap_or(0)
    }

    pub fn clear_custom_difficulty(&mut self) {
        self.custom_difficulty = ::std::option::Option::None;
    }

    pub fn has_custom_difficulty(&self) -> bool {
        self.custom_difficulty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_difficulty(&mut self, v: u32) {
        self.custom_difficulty = ::std::option::Option::Some(v);
    }

    // optional bool lan = 57;

    pub fn lan(&self) -> bool {
        self.lan.unwrap_or(false)
    }

    pub fn clear_lan(&mut self) {
        self.lan = ::std::option::Option::None;
    }

    pub fn has_lan(&self) -> bool {
        self.lan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lan(&mut self, v: bool) {
        self.lan = ::std::option::Option::Some(v);
    }

    // optional uint32 first_leaver_accountid = 59;

    pub fn first_leaver_accountid(&self) -> u32 {
        self.first_leaver_accountid.unwrap_or(0)
    }

    pub fn clear_first_leaver_accountid(&mut self) {
        self.first_leaver_accountid = ::std::option::Option::None;
    }

    pub fn has_first_leaver_accountid(&self) -> bool {
        self.first_leaver_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_leaver_accountid(&mut self, v: u32) {
        self.first_leaver_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 series_id = 60;

    pub fn series_id(&self) -> u32 {
        self.series_id.unwrap_or(0)
    }

    pub fn clear_series_id(&mut self) {
        self.series_id = ::std::option::Option::None;
    }

    pub fn has_series_id(&self) -> bool {
        self.series_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_id(&mut self, v: u32) {
        self.series_id = ::std::option::Option::Some(v);
    }

    // optional bool low_priority = 61;

    pub fn low_priority(&self) -> bool {
        self.low_priority.unwrap_or(false)
    }

    pub fn clear_low_priority(&mut self) {
        self.low_priority = ::std::option::Option::None;
    }

    pub fn has_low_priority(&self) -> bool {
        self.low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority(&mut self, v: bool) {
        self.low_priority = ::std::option::Option::Some(v);
    }

    // optional bool first_blood_happened = 65;

    pub fn first_blood_happened(&self) -> bool {
        self.first_blood_happened.unwrap_or(false)
    }

    pub fn clear_first_blood_happened(&mut self) {
        self.first_blood_happened = ::std::option::Option::None;
    }

    pub fn has_first_blood_happened(&self) -> bool {
        self.first_blood_happened.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_happened(&mut self, v: bool) {
        self.first_blood_happened = ::std::option::Option::Some(v);
    }

    // optional .EMatchOutcome match_outcome = 70;

    pub fn match_outcome(&self) -> super::dota_shared_enums::EMatchOutcome {
        match self.match_outcome {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown),
            None => super::dota_shared_enums::EMatchOutcome::k_EMatchOutcome_Unknown,
        }
    }

    pub fn clear_match_outcome(&mut self) {
        self.match_outcome = ::std::option::Option::None;
    }

    pub fn has_match_outcome(&self) -> bool {
        self.match_outcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_outcome(&mut self, v: super::dota_shared_enums::EMatchOutcome) {
        self.match_outcome = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool mass_disconnect = 67;

    pub fn mass_disconnect(&self) -> bool {
        self.mass_disconnect.unwrap_or(false)
    }

    pub fn clear_mass_disconnect(&mut self) {
        self.mass_disconnect = ::std::option::Option::None;
    }

    pub fn has_mass_disconnect(&self) -> bool {
        self.mass_disconnect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mass_disconnect(&mut self, v: bool) {
        self.mass_disconnect = ::std::option::Option::Some(v);
    }

    // optional uint64 custom_game_id = 68;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_min_players = 71;

    pub fn custom_min_players(&self) -> u32 {
        self.custom_min_players.unwrap_or(0)
    }

    pub fn clear_custom_min_players(&mut self) {
        self.custom_min_players = ::std::option::Option::None;
    }

    pub fn has_custom_min_players(&self) -> bool {
        self.custom_min_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_min_players(&mut self, v: u32) {
        self.custom_min_players = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_max_players = 72;

    pub fn custom_max_players(&self) -> u32 {
        self.custom_max_players.unwrap_or(0)
    }

    pub fn clear_custom_max_players(&mut self) {
        self.custom_max_players = ::std::option::Option::None;
    }

    pub fn has_custom_max_players(&self) -> bool {
        self.custom_max_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_max_players(&mut self, v: u32) {
        self.custom_max_players = ::std::option::Option::Some(v);
    }

    // optional .DOTALobbyVisibility visibility = 75;

    pub fn visibility(&self) -> super::dota_shared_enums::DOTALobbyVisibility {
        match self.visibility {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTALobbyVisibility::DOTALobbyVisibility_Public),
            None => super::dota_shared_enums::DOTALobbyVisibility::DOTALobbyVisibility_Public,
        }
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: super::dota_shared_enums::DOTALobbyVisibility) {
        self.visibility = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 custom_game_crc = 76;

    pub fn custom_game_crc(&self) -> u64 {
        self.custom_game_crc.unwrap_or(0)
    }

    pub fn clear_custom_game_crc(&mut self) {
        self.custom_game_crc = ::std::option::Option::None;
    }

    pub fn has_custom_game_crc(&self) -> bool {
        self.custom_game_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_crc(&mut self, v: u64) {
        self.custom_game_crc = ::std::option::Option::Some(v);
    }

    // optional bool custom_game_auto_created_lobby = 77;

    pub fn custom_game_auto_created_lobby(&self) -> bool {
        self.custom_game_auto_created_lobby.unwrap_or(false)
    }

    pub fn clear_custom_game_auto_created_lobby(&mut self) {
        self.custom_game_auto_created_lobby = ::std::option::Option::None;
    }

    pub fn has_custom_game_auto_created_lobby(&self) -> bool {
        self.custom_game_auto_created_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_auto_created_lobby(&mut self, v: bool) {
        self.custom_game_auto_created_lobby = ::std::option::Option::Some(v);
    }

    // optional fixed32 custom_game_timestamp = 80;

    pub fn custom_game_timestamp(&self) -> u32 {
        self.custom_game_timestamp.unwrap_or(0)
    }

    pub fn clear_custom_game_timestamp(&mut self) {
        self.custom_game_timestamp = ::std::option::Option::None;
    }

    pub fn has_custom_game_timestamp(&self) -> bool {
        self.custom_game_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_timestamp(&mut self, v: u32) {
        self.custom_game_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 previous_match_override = 82;

    pub fn previous_match_override(&self) -> u64 {
        self.previous_match_override.unwrap_or(0)
    }

    pub fn clear_previous_match_override(&mut self) {
        self.previous_match_override = ::std::option::Option::None;
    }

    pub fn has_previous_match_override(&self) -> bool {
        self.previous_match_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous_match_override(&mut self, v: u64) {
        self.previous_match_override = ::std::option::Option::Some(v);
    }

    // optional uint32 game_start_time = 87;

    pub fn game_start_time(&self) -> u32 {
        self.game_start_time.unwrap_or(0)
    }

    pub fn clear_game_start_time(&mut self) {
        self.game_start_time = ::std::option::Option::None;
    }

    pub fn has_game_start_time(&self) -> bool {
        self.game_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_start_time(&mut self, v: u32) {
        self.game_start_time = ::std::option::Option::Some(v);
    }

    // optional .LobbyDotaPauseSetting pause_setting = 88;

    pub fn pause_setting(&self) -> LobbyDotaPauseSetting {
        match self.pause_setting {
            Some(e) => e.enum_value_or(LobbyDotaPauseSetting::LobbyDotaPauseSetting_Unlimited),
            None => LobbyDotaPauseSetting::LobbyDotaPauseSetting_Unlimited,
        }
    }

    pub fn clear_pause_setting(&mut self) {
        self.pause_setting = ::std::option::Option::None;
    }

    pub fn has_pause_setting(&self) -> bool {
        self.pause_setting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pause_setting(&mut self, v: LobbyDotaPauseSetting) {
        self.pause_setting = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 weekend_tourney_division_id = 90;

    pub fn weekend_tourney_division_id(&self) -> u32 {
        self.weekend_tourney_division_id.unwrap_or(0)
    }

    pub fn clear_weekend_tourney_division_id(&mut self) {
        self.weekend_tourney_division_id = ::std::option::Option::None;
    }

    pub fn has_weekend_tourney_division_id(&self) -> bool {
        self.weekend_tourney_division_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weekend_tourney_division_id(&mut self, v: u32) {
        self.weekend_tourney_division_id = ::std::option::Option::Some(v);
    }

    // optional uint32 weekend_tourney_skill_level = 91;

    pub fn weekend_tourney_skill_level(&self) -> u32 {
        self.weekend_tourney_skill_level.unwrap_or(0)
    }

    pub fn clear_weekend_tourney_skill_level(&mut self) {
        self.weekend_tourney_skill_level = ::std::option::Option::None;
    }

    pub fn has_weekend_tourney_skill_level(&self) -> bool {
        self.weekend_tourney_skill_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weekend_tourney_skill_level(&mut self, v: u32) {
        self.weekend_tourney_skill_level = ::std::option::Option::Some(v);
    }

    // optional uint32 weekend_tourney_bracket_round = 92;

    pub fn weekend_tourney_bracket_round(&self) -> u32 {
        self.weekend_tourney_bracket_round.unwrap_or(0)
    }

    pub fn clear_weekend_tourney_bracket_round(&mut self) {
        self.weekend_tourney_bracket_round = ::std::option::Option::None;
    }

    pub fn has_weekend_tourney_bracket_round(&self) -> bool {
        self.weekend_tourney_bracket_round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weekend_tourney_bracket_round(&mut self, v: u32) {
        self.weekend_tourney_bracket_round = ::std::option::Option::Some(v);
    }

    // optional .DOTABotDifficulty bot_difficulty_dire = 93;

    pub fn bot_difficulty_dire(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.bot_difficulty_dire {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_HARD),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_HARD,
        }
    }

    pub fn clear_bot_difficulty_dire(&mut self) {
        self.bot_difficulty_dire = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty_dire(&self) -> bool {
        self.bot_difficulty_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty_dire(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.bot_difficulty_dire = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 bot_radiant = 94;

    pub fn bot_radiant(&self) -> u64 {
        self.bot_radiant.unwrap_or(0)
    }

    pub fn clear_bot_radiant(&mut self) {
        self.bot_radiant = ::std::option::Option::None;
    }

    pub fn has_bot_radiant(&self) -> bool {
        self.bot_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_radiant(&mut self, v: u64) {
        self.bot_radiant = ::std::option::Option::Some(v);
    }

    // optional uint64 bot_dire = 95;

    pub fn bot_dire(&self) -> u64 {
        self.bot_dire.unwrap_or(0)
    }

    pub fn clear_bot_dire(&mut self) {
        self.bot_dire = ::std::option::Option::None;
    }

    pub fn has_bot_dire(&self) -> bool {
        self.bot_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_dire(&mut self, v: u64) {
        self.bot_dire = ::std::option::Option::Some(v);
    }

    // optional .DOTASelectionPriorityRules selection_priority_rules = 97;

    pub fn selection_priority_rules(&self) -> super::dota_shared_enums::DOTASelectionPriorityRules {
        match self.selection_priority_rules {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Manual),
            None => super::dota_shared_enums::DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Manual,
        }
    }

    pub fn clear_selection_priority_rules(&mut self) {
        self.selection_priority_rules = ::std::option::Option::None;
    }

    pub fn has_selection_priority_rules(&self) -> bool {
        self.selection_priority_rules.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_priority_rules(&mut self, v: super::dota_shared_enums::DOTASelectionPriorityRules) {
        self.selection_priority_rules = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 series_previous_selection_priority_team_id = 98;

    pub fn series_previous_selection_priority_team_id(&self) -> u32 {
        self.series_previous_selection_priority_team_id.unwrap_or(0)
    }

    pub fn clear_series_previous_selection_priority_team_id(&mut self) {
        self.series_previous_selection_priority_team_id = ::std::option::Option::None;
    }

    pub fn has_series_previous_selection_priority_team_id(&self) -> bool {
        self.series_previous_selection_priority_team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_previous_selection_priority_team_id(&mut self, v: u32) {
        self.series_previous_selection_priority_team_id = ::std::option::Option::Some(v);
    }

    // optional uint32 series_current_selection_priority_team_id = 99;

    pub fn series_current_selection_priority_team_id(&self) -> u32 {
        self.series_current_selection_priority_team_id.unwrap_or(0)
    }

    pub fn clear_series_current_selection_priority_team_id(&mut self) {
        self.series_current_selection_priority_team_id = ::std::option::Option::None;
    }

    pub fn has_series_current_selection_priority_team_id(&self) -> bool {
        self.series_current_selection_priority_team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_current_selection_priority_team_id(&mut self, v: u32) {
        self.series_current_selection_priority_team_id = ::std::option::Option::Some(v);
    }

    // optional .DOTASelectionPriorityChoice series_current_priority_team_choice = 100;

    pub fn series_current_priority_team_choice(&self) -> super::dota_shared_enums::DOTASelectionPriorityChoice {
        match self.series_current_priority_team_choice {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid),
            None => super::dota_shared_enums::DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid,
        }
    }

    pub fn clear_series_current_priority_team_choice(&mut self) {
        self.series_current_priority_team_choice = ::std::option::Option::None;
    }

    pub fn has_series_current_priority_team_choice(&self) -> bool {
        self.series_current_priority_team_choice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_current_priority_team_choice(&mut self, v: super::dota_shared_enums::DOTASelectionPriorityChoice) {
        self.series_current_priority_team_choice = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .DOTASelectionPriorityChoice series_current_non_priority_team_choice = 101;

    pub fn series_current_non_priority_team_choice(&self) -> super::dota_shared_enums::DOTASelectionPriorityChoice {
        match self.series_current_non_priority_team_choice {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid),
            None => super::dota_shared_enums::DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid,
        }
    }

    pub fn clear_series_current_non_priority_team_choice(&mut self) {
        self.series_current_non_priority_team_choice = ::std::option::Option::None;
    }

    pub fn has_series_current_non_priority_team_choice(&self) -> bool {
        self.series_current_non_priority_team_choice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_current_non_priority_team_choice(&mut self, v: super::dota_shared_enums::DOTASelectionPriorityChoice) {
        self.series_current_non_priority_team_choice = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool series_current_selection_priority_used_coin_toss = 102;

    pub fn series_current_selection_priority_used_coin_toss(&self) -> bool {
        self.series_current_selection_priority_used_coin_toss.unwrap_or(false)
    }

    pub fn clear_series_current_selection_priority_used_coin_toss(&mut self) {
        self.series_current_selection_priority_used_coin_toss = ::std::option::Option::None;
    }

    pub fn has_series_current_selection_priority_used_coin_toss(&self) -> bool {
        self.series_current_selection_priority_used_coin_toss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_current_selection_priority_used_coin_toss(&mut self, v: bool) {
        self.series_current_selection_priority_used_coin_toss = ::std::option::Option::Some(v);
    }

    // optional .EEvent current_primary_event = 103;

    pub fn current_primary_event(&self) -> super::dota_shared_enums::EEvent {
        match self.current_primary_event {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_current_primary_event(&mut self) {
        self.current_primary_event = ::std::option::Option::None;
    }

    pub fn has_current_primary_event(&self) -> bool {
        self.current_primary_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_primary_event(&mut self, v: super::dota_shared_enums::EEvent) {
        self.current_primary_event = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 custom_game_private_key = 106;

    pub fn custom_game_private_key(&self) -> u64 {
        self.custom_game_private_key.unwrap_or(0)
    }

    pub fn clear_custom_game_private_key(&mut self) {
        self.custom_game_private_key = ::std::option::Option::None;
    }

    pub fn has_custom_game_private_key(&self) -> bool {
        self.custom_game_private_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_private_key(&mut self, v: u64) {
        self.custom_game_private_key = ::std::option::Option::Some(v);
    }

    // optional bool custom_game_penalties = 107;

    pub fn custom_game_penalties(&self) -> bool {
        self.custom_game_penalties.unwrap_or(false)
    }

    pub fn clear_custom_game_penalties(&mut self) {
        self.custom_game_penalties = ::std::option::Option::None;
    }

    pub fn has_custom_game_penalties(&self) -> bool {
        self.custom_game_penalties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_penalties(&mut self, v: bool) {
        self.custom_game_penalties = ::std::option::Option::Some(v);
    }

    // optional string lan_host_ping_location = 109;

    pub fn lan_host_ping_location(&self) -> &str {
        match self.lan_host_ping_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lan_host_ping_location(&mut self) {
        self.lan_host_ping_location = ::std::option::Option::None;
    }

    pub fn has_lan_host_ping_location(&self) -> bool {
        self.lan_host_ping_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lan_host_ping_location(&mut self, v: ::std::string::String) {
        self.lan_host_ping_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lan_host_ping_location(&mut self) -> &mut ::std::string::String {
        if self.lan_host_ping_location.is_none() {
            self.lan_host_ping_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lan_host_ping_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_lan_host_ping_location(&mut self) -> ::std::string::String {
        self.lan_host_ping_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 league_node_id = 110;

    pub fn league_node_id(&self) -> u32 {
        self.league_node_id.unwrap_or(0)
    }

    pub fn clear_league_node_id(&mut self) {
        self.league_node_id = ::std::option::Option::None;
    }

    pub fn has_league_node_id(&self) -> bool {
        self.league_node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_node_id(&mut self, v: u32) {
        self.league_node_id = ::std::option::Option::Some(v);
    }

    // optional uint32 match_duration = 111;

    pub fn match_duration(&self) -> u32 {
        self.match_duration.unwrap_or(0)
    }

    pub fn clear_match_duration(&mut self) {
        self.match_duration = ::std::option::Option::None;
    }

    pub fn has_match_duration(&self) -> bool {
        self.match_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_duration(&mut self, v: u32) {
        self.match_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 league_phase = 113;

    pub fn league_phase(&self) -> u32 {
        self.league_phase.unwrap_or(0)
    }

    pub fn clear_league_phase(&mut self) {
        self.league_phase = ::std::option::Option::None;
    }

    pub fn has_league_phase(&self) -> bool {
        self.league_phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_phase(&mut self, v: u32) {
        self.league_phase = ::std::option::Option::Some(v);
    }

    // optional bool experimental_gameplay_enabled = 116;

    pub fn experimental_gameplay_enabled(&self) -> bool {
        self.experimental_gameplay_enabled.unwrap_or(false)
    }

    pub fn clear_experimental_gameplay_enabled(&mut self) {
        self.experimental_gameplay_enabled = ::std::option::Option::None;
    }

    pub fn has_experimental_gameplay_enabled(&self) -> bool {
        self.experimental_gameplay_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimental_gameplay_enabled(&mut self, v: bool) {
        self.experimental_gameplay_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_in_steam_china = 126;

    pub fn is_in_steam_china(&self) -> bool {
        self.is_in_steam_china.unwrap_or(false)
    }

    pub fn clear_is_in_steam_china(&mut self) {
        self.is_in_steam_china = ::std::option::Option::None;
    }

    pub fn has_is_in_steam_china(&self) -> bool {
        self.is_in_steam_china.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_in_steam_china(&mut self, v: bool) {
        self.is_in_steam_china = ::std::option::Option::Some(v);
    }

    // optional bool with_scenario_save = 127;

    pub fn with_scenario_save(&self) -> bool {
        self.with_scenario_save.unwrap_or(false)
    }

    pub fn clear_with_scenario_save(&mut self) {
        self.with_scenario_save = ::std::option::Option::None;
    }

    pub fn has_with_scenario_save(&self) -> bool {
        self.with_scenario_save.is_some()
    }

    // Param is passed by value, moved
    pub fn set_with_scenario_save(&mut self, v: bool) {
        self.with_scenario_save = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_creation_time = 128;

    pub fn lobby_creation_time(&self) -> u32 {
        self.lobby_creation_time.unwrap_or(0)
    }

    pub fn clear_lobby_creation_time(&mut self) {
        self.lobby_creation_time = ::std::option::Option::None;
    }

    pub fn has_lobby_creation_time(&self) -> bool {
        self.lobby_creation_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_creation_time(&mut self, v: u32) {
        self.lobby_creation_time = ::std::option::Option::Some(v);
    }

    // optional string event_game_definition = 129;

    pub fn event_game_definition(&self) -> &str {
        match self.event_game_definition.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_game_definition(&mut self) {
        self.event_game_definition = ::std::option::Option::None;
    }

    pub fn has_event_game_definition(&self) -> bool {
        self.event_game_definition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_game_definition(&mut self, v: ::std::string::String) {
        self.event_game_definition = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_game_definition(&mut self) -> &mut ::std::string::String {
        if self.event_game_definition.is_none() {
            self.event_game_definition = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_game_definition.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_game_definition(&mut self) -> ::std::string::String {
        self.event_game_definition.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSODOTALobby {
    const NAME: &'static str = "CSODOTALobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                962 => {
                    self.all_members.push(is.read_message()?);
                },
                970 => {
                    is.read_repeated_packed_uint32_into(&mut self.member_indices)?;
                },
                968 => {
                    self.member_indices.push(is.read_uint32()?);
                },
                978 => {
                    is.read_repeated_packed_uint32_into(&mut self.left_member_indices)?;
                },
                976 => {
                    self.left_member_indices.push(is.read_uint32()?);
                },
                986 => {
                    is.read_repeated_packed_uint32_into(&mut self.free_member_indices)?;
                },
                984 => {
                    self.free_member_indices.push(is.read_uint32()?);
                },
                89 => {
                    self.leader_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                49 => {
                    self.server_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    is.read_repeated_packed_fixed64_into(&mut self.pending_invites)?;
                },
                81 => {
                    self.pending_invites.push(is.read_fixed64()?);
                },
                32 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.connect = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.allow_cheats = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.fill_with_bots = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.intro_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                130 => {
                    self.game_name = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    self.team_details.push(is.read_message()?);
                },
                144 => {
                    self.tutorial_lesson = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.tournament_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.tournament_game_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.game_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                184 => {
                    self.num_spectators = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.matchgroup = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.cm_pick = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                240 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                248 => {
                    self.allow_spectating = ::std::option::Option::Some(is.read_bool()?);
                },
                288 => {
                    self.bot_difficulty_radiant = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                306 => {
                    self.timed_reward_details.push(is.read_message()?);
                },
                314 => {
                    self.pass_key = ::std::option::Option::Some(is.read_string()?);
                },
                336 => {
                    self.leagueid = ::std::option::Option::Some(is.read_uint32()?);
                },
                344 => {
                    self.penalty_level_radiant = ::std::option::Option::Some(is.read_uint32()?);
                },
                352 => {
                    self.penalty_level_dire = ::std::option::Option::Some(is.read_uint32()?);
                },
                360 => {
                    self.load_game_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                368 => {
                    self.series_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                376 => {
                    self.radiant_series_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                384 => {
                    self.dire_series_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                392 => {
                    self.loot_generated = ::std::option::Option::Some(is.read_uint32()?);
                },
                400 => {
                    self.loot_awarded = ::std::option::Option::Some(is.read_uint32()?);
                },
                408 => {
                    self.allchat = ::std::option::Option::Some(is.read_bool()?);
                },
                424 => {
                    self.dota_tv_delay = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                434 => {
                    self.custom_game_mode = ::std::option::Option::Some(is.read_string()?);
                },
                442 => {
                    self.custom_map_name = ::std::option::Option::Some(is.read_string()?);
                },
                448 => {
                    self.custom_difficulty = ::std::option::Option::Some(is.read_uint32()?);
                },
                456 => {
                    self.lan = ::std::option::Option::Some(is.read_bool()?);
                },
                466 => {
                    self.broadcast_channel_info.push(is.read_message()?);
                },
                472 => {
                    self.first_leaver_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                480 => {
                    self.series_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                488 => {
                    self.low_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                498 => {
                    self.extra_messages.push(is.read_message()?);
                },
                506 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.save_game)?;
                },
                520 => {
                    self.first_blood_happened = ::std::option::Option::Some(is.read_bool()?);
                },
                560 => {
                    self.match_outcome = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                536 => {
                    self.mass_disconnect = ::std::option::Option::Some(is.read_bool()?);
                },
                544 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                568 => {
                    self.custom_min_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                576 => {
                    self.custom_max_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                600 => {
                    self.visibility = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                609 => {
                    self.custom_game_crc = ::std::option::Option::Some(is.read_fixed64()?);
                },
                616 => {
                    self.custom_game_auto_created_lobby = ::std::option::Option::Some(is.read_bool()?);
                },
                645 => {
                    self.custom_game_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                650 => {
                    is.read_repeated_packed_uint64_into(&mut self.previous_series_matches)?;
                },
                648 => {
                    self.previous_series_matches.push(is.read_uint64()?);
                },
                656 => {
                    self.previous_match_override = ::std::option::Option::Some(is.read_uint64()?);
                },
                696 => {
                    self.game_start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                704 => {
                    self.pause_setting = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                720 => {
                    self.weekend_tourney_division_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                728 => {
                    self.weekend_tourney_skill_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                736 => {
                    self.weekend_tourney_bracket_round = ::std::option::Option::Some(is.read_uint32()?);
                },
                744 => {
                    self.bot_difficulty_dire = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                752 => {
                    self.bot_radiant = ::std::option::Option::Some(is.read_uint64()?);
                },
                760 => {
                    self.bot_dire = ::std::option::Option::Some(is.read_uint64()?);
                },
                768 => {
                    self.event_progression_enabled.push(is.read_enum_or_unknown()?);
                },
                770 => {
                    ::steam_vent_proto_common::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.event_progression_enabled)?
                },
                776 => {
                    self.selection_priority_rules = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                784 => {
                    self.series_previous_selection_priority_team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                792 => {
                    self.series_current_selection_priority_team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                800 => {
                    self.series_current_priority_team_choice = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                808 => {
                    self.series_current_non_priority_team_choice = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                816 => {
                    self.series_current_selection_priority_used_coin_toss = ::std::option::Option::Some(is.read_bool()?);
                },
                824 => {
                    self.current_primary_event = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                842 => {
                    is.read_repeated_packed_int32_into(&mut self.emergency_disabled_hero_ids)?;
                },
                840 => {
                    self.emergency_disabled_hero_ids.push(is.read_int32()?);
                },
                849 => {
                    self.custom_game_private_key = ::std::option::Option::Some(is.read_fixed64()?);
                },
                856 => {
                    self.custom_game_penalties = ::std::option::Option::Some(is.read_bool()?);
                },
                874 => {
                    self.lan_host_ping_location = ::std::option::Option::Some(is.read_string()?);
                },
                880 => {
                    self.league_node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                888 => {
                    self.match_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                904 => {
                    self.league_phase = ::std::option::Option::Some(is.read_uint32()?);
                },
                928 => {
                    self.experimental_gameplay_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                938 => {
                    self.guild_challenges.push(is.read_message()?);
                },
                946 => {
                    self.guild_details.push(is.read_message()?);
                },
                954 => {
                    self.lobby_event_points.push(is.read_message()?);
                },
                994 => {
                    is.read_repeated_packed_int32_into(&mut self.requested_hero_ids)?;
                },
                992 => {
                    self.requested_hero_ids.push(is.read_int32()?);
                },
                1002 => {
                    self.coach_friend_requests.push(is.read_message()?);
                },
                1008 => {
                    self.is_in_steam_china = ::std::option::Option::Some(is.read_bool()?);
                },
                1016 => {
                    self.with_scenario_save = ::std::option::Option::Some(is.read_bool()?);
                },
                1024 => {
                    self.lobby_creation_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                1034 => {
                    self.event_game_definition = ::std::option::Option::Some(is.read_string()?);
                },
                1042 => {
                    self.extra_startup_messages.push(is.read_message()?);
                },
                1050 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.match_quality_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.all_members {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.member_indices {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(121, *value);
        };
        for value in &self.left_member_indices {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(122, *value);
        };
        for value in &self.free_member_indices {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(123, *value);
        };
        if let Some(v) = self.leader_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.server_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += 9 * self.pending_invites.len() as u64;
        if let Some(v) = self.state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.connect.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.allow_cheats {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fill_with_bots {
            my_size += 1 + 1;
        }
        if let Some(v) = self.intro_mode {
            my_size += 1 + 1;
        }
        if let Some(v) = self.game_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(16, &v);
        }
        for value in &self.team_details {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tutorial_lesson {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.tournament_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.tournament_game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.server_region {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.game_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(22, v.value());
        }
        if let Some(v) = self.num_spectators {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.matchgroup {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.cm_pick {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(28, v.value());
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(30, v);
        }
        if let Some(v) = self.allow_spectating {
            my_size += 2 + 1;
        }
        if let Some(v) = self.bot_difficulty_radiant {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(36, v.value());
        }
        for value in &self.timed_reward_details {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pass_key.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(39, &v);
        }
        if let Some(v) = self.leagueid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(42, v);
        }
        if let Some(v) = self.penalty_level_radiant {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(43, v);
        }
        if let Some(v) = self.penalty_level_dire {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(44, v);
        }
        if let Some(v) = self.load_game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(45, v);
        }
        if let Some(v) = self.series_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(46, v);
        }
        if let Some(v) = self.radiant_series_wins {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(47, v);
        }
        if let Some(v) = self.dire_series_wins {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(48, v);
        }
        if let Some(v) = self.loot_generated {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(49, v);
        }
        if let Some(v) = self.loot_awarded {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(50, v);
        }
        if let Some(v) = self.allchat {
            my_size += 2 + 1;
        }
        if let Some(v) = self.dota_tv_delay {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(53, v.value());
        }
        if let Some(v) = self.custom_game_mode.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(54, &v);
        }
        if let Some(v) = self.custom_map_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(55, &v);
        }
        if let Some(v) = self.custom_difficulty {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(56, v);
        }
        if let Some(v) = self.lan {
            my_size += 2 + 1;
        }
        for value in &self.broadcast_channel_info {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.first_leaver_accountid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(59, v);
        }
        if let Some(v) = self.series_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(60, v);
        }
        if let Some(v) = self.low_priority {
            my_size += 2 + 1;
        }
        for value in &self.extra_messages {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.save_game.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.first_blood_happened {
            my_size += 2 + 1;
        }
        if let Some(v) = self.match_outcome {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(70, v.value());
        }
        if let Some(v) = self.mass_disconnect {
            my_size += 2 + 1;
        }
        if let Some(v) = self.custom_game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(68, v);
        }
        if let Some(v) = self.custom_min_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(71, v);
        }
        if let Some(v) = self.custom_max_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(72, v);
        }
        if let Some(v) = self.visibility {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(75, v.value());
        }
        if let Some(v) = self.custom_game_crc {
            my_size += 2 + 8;
        }
        if let Some(v) = self.custom_game_auto_created_lobby {
            my_size += 2 + 1;
        }
        if let Some(v) = self.custom_game_timestamp {
            my_size += 2 + 4;
        }
        for value in &self.previous_series_matches {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(81, *value);
        };
        if let Some(v) = self.previous_match_override {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(82, v);
        }
        if let Some(v) = self.game_start_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(87, v);
        }
        if let Some(v) = self.pause_setting {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(88, v.value());
        }
        if let Some(v) = self.weekend_tourney_division_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(90, v);
        }
        if let Some(v) = self.weekend_tourney_skill_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(91, v);
        }
        if let Some(v) = self.weekend_tourney_bracket_round {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(92, v);
        }
        if let Some(v) = self.bot_difficulty_dire {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(93, v.value());
        }
        if let Some(v) = self.bot_radiant {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(94, v);
        }
        if let Some(v) = self.bot_dire {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(95, v);
        }
        for value in &self.event_progression_enabled {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(96, value.value());
        };
        if let Some(v) = self.selection_priority_rules {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(97, v.value());
        }
        if let Some(v) = self.series_previous_selection_priority_team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(98, v);
        }
        if let Some(v) = self.series_current_selection_priority_team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(99, v);
        }
        if let Some(v) = self.series_current_priority_team_choice {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(100, v.value());
        }
        if let Some(v) = self.series_current_non_priority_team_choice {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(101, v.value());
        }
        if let Some(v) = self.series_current_selection_priority_used_coin_toss {
            my_size += 2 + 1;
        }
        if let Some(v) = self.current_primary_event {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(103, v.value());
        }
        for value in &self.emergency_disabled_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(105, *value);
        };
        if let Some(v) = self.custom_game_private_key {
            my_size += 2 + 8;
        }
        if let Some(v) = self.custom_game_penalties {
            my_size += 2 + 1;
        }
        if let Some(v) = self.lan_host_ping_location.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(109, &v);
        }
        if let Some(v) = self.league_node_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(110, v);
        }
        if let Some(v) = self.match_duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(111, v);
        }
        if let Some(v) = self.league_phase {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(113, v);
        }
        if let Some(v) = self.experimental_gameplay_enabled {
            my_size += 2 + 1;
        }
        for value in &self.guild_challenges {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.guild_details {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.lobby_event_points {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.requested_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(124, *value);
        };
        for value in &self.coach_friend_requests {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_in_steam_china {
            my_size += 2 + 1;
        }
        if let Some(v) = self.with_scenario_save {
            my_size += 2 + 1;
        }
        if let Some(v) = self.lobby_creation_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(128, v);
        }
        if let Some(v) = self.event_game_definition.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(129, &v);
        }
        for value in &self.extra_startup_messages {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.match_quality_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.all_members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(120, v, os)?;
        };
        for v in &self.member_indices {
            os.write_uint32(121, *v)?;
        };
        for v in &self.left_member_indices {
            os.write_uint32(122, *v)?;
        };
        for v in &self.free_member_indices {
            os.write_uint32(123, *v)?;
        };
        if let Some(v) = self.leader_id {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.server_id {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(3, v)?;
        }
        for v in &self.pending_invites {
            os.write_fixed64(10, *v)?;
        };
        if let Some(v) = self.state {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.connect.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_enum(12, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.allow_cheats {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.fill_with_bots {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.intro_mode {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.game_name.as_ref() {
            os.write_string(16, v)?;
        }
        for v in &self.team_details {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        if let Some(v) = self.tutorial_lesson {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.tournament_id {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.tournament_game_id {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.server_region {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.game_state {
            os.write_enum(22, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.num_spectators {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.matchgroup {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.cm_pick {
            os.write_enum(28, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(30, v)?;
        }
        if let Some(v) = self.allow_spectating {
            os.write_bool(31, v)?;
        }
        if let Some(v) = self.bot_difficulty_radiant {
            os.write_enum(36, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.timed_reward_details {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(38, v, os)?;
        };
        if let Some(v) = self.pass_key.as_ref() {
            os.write_string(39, v)?;
        }
        if let Some(v) = self.leagueid {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.penalty_level_radiant {
            os.write_uint32(43, v)?;
        }
        if let Some(v) = self.penalty_level_dire {
            os.write_uint32(44, v)?;
        }
        if let Some(v) = self.load_game_id {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.series_type {
            os.write_uint32(46, v)?;
        }
        if let Some(v) = self.radiant_series_wins {
            os.write_uint32(47, v)?;
        }
        if let Some(v) = self.dire_series_wins {
            os.write_uint32(48, v)?;
        }
        if let Some(v) = self.loot_generated {
            os.write_uint32(49, v)?;
        }
        if let Some(v) = self.loot_awarded {
            os.write_uint32(50, v)?;
        }
        if let Some(v) = self.allchat {
            os.write_bool(51, v)?;
        }
        if let Some(v) = self.dota_tv_delay {
            os.write_enum(53, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.custom_game_mode.as_ref() {
            os.write_string(54, v)?;
        }
        if let Some(v) = self.custom_map_name.as_ref() {
            os.write_string(55, v)?;
        }
        if let Some(v) = self.custom_difficulty {
            os.write_uint32(56, v)?;
        }
        if let Some(v) = self.lan {
            os.write_bool(57, v)?;
        }
        for v in &self.broadcast_channel_info {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(58, v, os)?;
        };
        if let Some(v) = self.first_leaver_accountid {
            os.write_uint32(59, v)?;
        }
        if let Some(v) = self.series_id {
            os.write_uint32(60, v)?;
        }
        if let Some(v) = self.low_priority {
            os.write_bool(61, v)?;
        }
        for v in &self.extra_messages {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(62, v, os)?;
        };
        if let Some(v) = self.save_game.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(63, v, os)?;
        }
        if let Some(v) = self.first_blood_happened {
            os.write_bool(65, v)?;
        }
        if let Some(v) = self.match_outcome {
            os.write_enum(70, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mass_disconnect {
            os.write_bool(67, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_uint64(68, v)?;
        }
        if let Some(v) = self.custom_min_players {
            os.write_uint32(71, v)?;
        }
        if let Some(v) = self.custom_max_players {
            os.write_uint32(72, v)?;
        }
        if let Some(v) = self.visibility {
            os.write_enum(75, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.custom_game_crc {
            os.write_fixed64(76, v)?;
        }
        if let Some(v) = self.custom_game_auto_created_lobby {
            os.write_bool(77, v)?;
        }
        if let Some(v) = self.custom_game_timestamp {
            os.write_fixed32(80, v)?;
        }
        for v in &self.previous_series_matches {
            os.write_uint64(81, *v)?;
        };
        if let Some(v) = self.previous_match_override {
            os.write_uint64(82, v)?;
        }
        if let Some(v) = self.game_start_time {
            os.write_uint32(87, v)?;
        }
        if let Some(v) = self.pause_setting {
            os.write_enum(88, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.weekend_tourney_division_id {
            os.write_uint32(90, v)?;
        }
        if let Some(v) = self.weekend_tourney_skill_level {
            os.write_uint32(91, v)?;
        }
        if let Some(v) = self.weekend_tourney_bracket_round {
            os.write_uint32(92, v)?;
        }
        if let Some(v) = self.bot_difficulty_dire {
            os.write_enum(93, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.bot_radiant {
            os.write_uint64(94, v)?;
        }
        if let Some(v) = self.bot_dire {
            os.write_uint64(95, v)?;
        }
        for v in &self.event_progression_enabled {
            os.write_enum(96, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.selection_priority_rules {
            os.write_enum(97, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.series_previous_selection_priority_team_id {
            os.write_uint32(98, v)?;
        }
        if let Some(v) = self.series_current_selection_priority_team_id {
            os.write_uint32(99, v)?;
        }
        if let Some(v) = self.series_current_priority_team_choice {
            os.write_enum(100, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.series_current_non_priority_team_choice {
            os.write_enum(101, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.series_current_selection_priority_used_coin_toss {
            os.write_bool(102, v)?;
        }
        if let Some(v) = self.current_primary_event {
            os.write_enum(103, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.emergency_disabled_hero_ids {
            os.write_int32(105, *v)?;
        };
        if let Some(v) = self.custom_game_private_key {
            os.write_fixed64(106, v)?;
        }
        if let Some(v) = self.custom_game_penalties {
            os.write_bool(107, v)?;
        }
        if let Some(v) = self.lan_host_ping_location.as_ref() {
            os.write_string(109, v)?;
        }
        if let Some(v) = self.league_node_id {
            os.write_uint32(110, v)?;
        }
        if let Some(v) = self.match_duration {
            os.write_uint32(111, v)?;
        }
        if let Some(v) = self.league_phase {
            os.write_uint32(113, v)?;
        }
        if let Some(v) = self.experimental_gameplay_enabled {
            os.write_bool(116, v)?;
        }
        for v in &self.guild_challenges {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(117, v, os)?;
        };
        for v in &self.guild_details {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(118, v, os)?;
        };
        for v in &self.lobby_event_points {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(119, v, os)?;
        };
        for v in &self.requested_hero_ids {
            os.write_int32(124, *v)?;
        };
        for v in &self.coach_friend_requests {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(125, v, os)?;
        };
        if let Some(v) = self.is_in_steam_china {
            os.write_bool(126, v)?;
        }
        if let Some(v) = self.with_scenario_save {
            os.write_bool(127, v)?;
        }
        if let Some(v) = self.lobby_creation_time {
            os.write_uint32(128, v)?;
        }
        if let Some(v) = self.event_game_definition.as_ref() {
            os.write_string(129, v)?;
        }
        for v in &self.extra_startup_messages {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(130, v, os)?;
        };
        if let Some(v) = self.match_quality_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(131, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTALobby {
        CSODOTALobby::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.all_members.clear();
        self.member_indices.clear();
        self.left_member_indices.clear();
        self.free_member_indices.clear();
        self.leader_id = ::std::option::Option::None;
        self.server_id = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.pending_invites.clear();
        self.state = ::std::option::Option::None;
        self.connect = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.allow_cheats = ::std::option::Option::None;
        self.fill_with_bots = ::std::option::Option::None;
        self.intro_mode = ::std::option::Option::None;
        self.game_name = ::std::option::Option::None;
        self.team_details.clear();
        self.tutorial_lesson = ::std::option::Option::None;
        self.tournament_id = ::std::option::Option::None;
        self.tournament_game_id = ::std::option::Option::None;
        self.server_region = ::std::option::Option::None;
        self.game_state = ::std::option::Option::None;
        self.num_spectators = ::std::option::Option::None;
        self.matchgroup = ::std::option::Option::None;
        self.cm_pick = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.allow_spectating = ::std::option::Option::None;
        self.bot_difficulty_radiant = ::std::option::Option::None;
        self.timed_reward_details.clear();
        self.pass_key = ::std::option::Option::None;
        self.leagueid = ::std::option::Option::None;
        self.penalty_level_radiant = ::std::option::Option::None;
        self.penalty_level_dire = ::std::option::Option::None;
        self.load_game_id = ::std::option::Option::None;
        self.series_type = ::std::option::Option::None;
        self.radiant_series_wins = ::std::option::Option::None;
        self.dire_series_wins = ::std::option::Option::None;
        self.loot_generated = ::std::option::Option::None;
        self.loot_awarded = ::std::option::Option::None;
        self.allchat = ::std::option::Option::None;
        self.dota_tv_delay = ::std::option::Option::None;
        self.custom_game_mode = ::std::option::Option::None;
        self.custom_map_name = ::std::option::Option::None;
        self.custom_difficulty = ::std::option::Option::None;
        self.lan = ::std::option::Option::None;
        self.broadcast_channel_info.clear();
        self.first_leaver_accountid = ::std::option::Option::None;
        self.series_id = ::std::option::Option::None;
        self.low_priority = ::std::option::Option::None;
        self.extra_messages.clear();
        self.save_game.clear();
        self.first_blood_happened = ::std::option::Option::None;
        self.match_outcome = ::std::option::Option::None;
        self.mass_disconnect = ::std::option::Option::None;
        self.custom_game_id = ::std::option::Option::None;
        self.custom_min_players = ::std::option::Option::None;
        self.custom_max_players = ::std::option::Option::None;
        self.visibility = ::std::option::Option::None;
        self.custom_game_crc = ::std::option::Option::None;
        self.custom_game_auto_created_lobby = ::std::option::Option::None;
        self.custom_game_timestamp = ::std::option::Option::None;
        self.previous_series_matches.clear();
        self.previous_match_override = ::std::option::Option::None;
        self.game_start_time = ::std::option::Option::None;
        self.pause_setting = ::std::option::Option::None;
        self.weekend_tourney_division_id = ::std::option::Option::None;
        self.weekend_tourney_skill_level = ::std::option::Option::None;
        self.weekend_tourney_bracket_round = ::std::option::Option::None;
        self.bot_difficulty_dire = ::std::option::Option::None;
        self.bot_radiant = ::std::option::Option::None;
        self.bot_dire = ::std::option::Option::None;
        self.event_progression_enabled.clear();
        self.selection_priority_rules = ::std::option::Option::None;
        self.series_previous_selection_priority_team_id = ::std::option::Option::None;
        self.series_current_selection_priority_team_id = ::std::option::Option::None;
        self.series_current_priority_team_choice = ::std::option::Option::None;
        self.series_current_non_priority_team_choice = ::std::option::Option::None;
        self.series_current_selection_priority_used_coin_toss = ::std::option::Option::None;
        self.current_primary_event = ::std::option::Option::None;
        self.emergency_disabled_hero_ids.clear();
        self.custom_game_private_key = ::std::option::Option::None;
        self.custom_game_penalties = ::std::option::Option::None;
        self.lan_host_ping_location = ::std::option::Option::None;
        self.league_node_id = ::std::option::Option::None;
        self.match_duration = ::std::option::Option::None;
        self.league_phase = ::std::option::Option::None;
        self.experimental_gameplay_enabled = ::std::option::Option::None;
        self.guild_challenges.clear();
        self.guild_details.clear();
        self.lobby_event_points.clear();
        self.requested_hero_ids.clear();
        self.coach_friend_requests.clear();
        self.is_in_steam_china = ::std::option::Option::None;
        self.with_scenario_save = ::std::option::Option::None;
        self.lobby_creation_time = ::std::option::Option::None;
        self.event_game_definition = ::std::option::Option::None;
        self.extra_startup_messages.clear();
        self.match_quality_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTALobby {
        static instance: CSODOTALobby = CSODOTALobby {
            lobby_id: ::std::option::Option::None,
            all_members: ::std::vec::Vec::new(),
            member_indices: ::std::vec::Vec::new(),
            left_member_indices: ::std::vec::Vec::new(),
            free_member_indices: ::std::vec::Vec::new(),
            leader_id: ::std::option::Option::None,
            server_id: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            pending_invites: ::std::vec::Vec::new(),
            state: ::std::option::Option::None,
            connect: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            allow_cheats: ::std::option::Option::None,
            fill_with_bots: ::std::option::Option::None,
            intro_mode: ::std::option::Option::None,
            game_name: ::std::option::Option::None,
            team_details: ::std::vec::Vec::new(),
            tutorial_lesson: ::std::option::Option::None,
            tournament_id: ::std::option::Option::None,
            tournament_game_id: ::std::option::Option::None,
            server_region: ::std::option::Option::None,
            game_state: ::std::option::Option::None,
            num_spectators: ::std::option::Option::None,
            matchgroup: ::std::option::Option::None,
            cm_pick: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            allow_spectating: ::std::option::Option::None,
            bot_difficulty_radiant: ::std::option::Option::None,
            timed_reward_details: ::std::vec::Vec::new(),
            pass_key: ::std::option::Option::None,
            leagueid: ::std::option::Option::None,
            penalty_level_radiant: ::std::option::Option::None,
            penalty_level_dire: ::std::option::Option::None,
            load_game_id: ::std::option::Option::None,
            series_type: ::std::option::Option::None,
            radiant_series_wins: ::std::option::Option::None,
            dire_series_wins: ::std::option::Option::None,
            loot_generated: ::std::option::Option::None,
            loot_awarded: ::std::option::Option::None,
            allchat: ::std::option::Option::None,
            dota_tv_delay: ::std::option::Option::None,
            custom_game_mode: ::std::option::Option::None,
            custom_map_name: ::std::option::Option::None,
            custom_difficulty: ::std::option::Option::None,
            lan: ::std::option::Option::None,
            broadcast_channel_info: ::std::vec::Vec::new(),
            first_leaver_accountid: ::std::option::Option::None,
            series_id: ::std::option::Option::None,
            low_priority: ::std::option::Option::None,
            extra_messages: ::std::vec::Vec::new(),
            save_game: ::steam_vent_proto_common::protobuf::MessageField::none(),
            first_blood_happened: ::std::option::Option::None,
            match_outcome: ::std::option::Option::None,
            mass_disconnect: ::std::option::Option::None,
            custom_game_id: ::std::option::Option::None,
            custom_min_players: ::std::option::Option::None,
            custom_max_players: ::std::option::Option::None,
            visibility: ::std::option::Option::None,
            custom_game_crc: ::std::option::Option::None,
            custom_game_auto_created_lobby: ::std::option::Option::None,
            custom_game_timestamp: ::std::option::Option::None,
            previous_series_matches: ::std::vec::Vec::new(),
            previous_match_override: ::std::option::Option::None,
            game_start_time: ::std::option::Option::None,
            pause_setting: ::std::option::Option::None,
            weekend_tourney_division_id: ::std::option::Option::None,
            weekend_tourney_skill_level: ::std::option::Option::None,
            weekend_tourney_bracket_round: ::std::option::Option::None,
            bot_difficulty_dire: ::std::option::Option::None,
            bot_radiant: ::std::option::Option::None,
            bot_dire: ::std::option::Option::None,
            event_progression_enabled: ::std::vec::Vec::new(),
            selection_priority_rules: ::std::option::Option::None,
            series_previous_selection_priority_team_id: ::std::option::Option::None,
            series_current_selection_priority_team_id: ::std::option::Option::None,
            series_current_priority_team_choice: ::std::option::Option::None,
            series_current_non_priority_team_choice: ::std::option::Option::None,
            series_current_selection_priority_used_coin_toss: ::std::option::Option::None,
            current_primary_event: ::std::option::Option::None,
            emergency_disabled_hero_ids: ::std::vec::Vec::new(),
            custom_game_private_key: ::std::option::Option::None,
            custom_game_penalties: ::std::option::Option::None,
            lan_host_ping_location: ::std::option::Option::None,
            league_node_id: ::std::option::Option::None,
            match_duration: ::std::option::Option::None,
            league_phase: ::std::option::Option::None,
            experimental_gameplay_enabled: ::std::option::Option::None,
            guild_challenges: ::std::vec::Vec::new(),
            guild_details: ::std::vec::Vec::new(),
            lobby_event_points: ::std::vec::Vec::new(),
            requested_hero_ids: ::std::vec::Vec::new(),
            coach_friend_requests: ::std::vec::Vec::new(),
            is_in_steam_china: ::std::option::Option::None,
            with_scenario_save: ::std::option::Option::None,
            lobby_creation_time: ::std::option::Option::None,
            event_game_definition: ::std::option::Option::None,
            extra_startup_messages: ::std::vec::Vec::new(),
            match_quality_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSODOTALobby`
pub mod csodotalobby {
    // @@protoc_insertion_point(message:CSODOTALobby.CExtraMsg)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CExtraMsg {
        // message fields
        // @@protoc_insertion_point(field:CSODOTALobby.CExtraMsg.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSODOTALobby.CExtraMsg.contents)
        pub contents: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CSODOTALobby.CExtraMsg.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CExtraMsg {
        fn default() -> &'a CExtraMsg {
            <CExtraMsg as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CExtraMsg {
        pub fn new() -> CExtraMsg {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional bytes contents = 2;

        pub fn contents(&self) -> &[u8] {
            match self.contents.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_contents(&mut self) {
            self.contents = ::std::option::Option::None;
        }

        pub fn has_contents(&self) -> bool {
            self.contents.is_some()
        }

        // Param is passed by value, moved
        pub fn set_contents(&mut self, v: ::std::vec::Vec<u8>) {
            self.contents = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_contents(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.contents.is_none() {
                self.contents = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.contents.as_mut().unwrap()
        }

        // Take field
        pub fn take_contents(&mut self) -> ::std::vec::Vec<u8> {
            self.contents.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CExtraMsg {
        const NAME: &'static str = "CExtraMsg";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.contents = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.contents.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.contents.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CExtraMsg {
            CExtraMsg::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.contents = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CExtraMsg {
            static instance: CExtraMsg = CExtraMsg {
                id: ::std::option::Option::None,
                contents: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CSODOTALobby.State)
    pub enum State {
        // @@protoc_insertion_point(enum_value:CSODOTALobby.State.UI)
        UI = 0,
        // @@protoc_insertion_point(enum_value:CSODOTALobby.State.READYUP)
        READYUP = 4,
        // @@protoc_insertion_point(enum_value:CSODOTALobby.State.SERVERSETUP)
        SERVERSETUP = 1,
        // @@protoc_insertion_point(enum_value:CSODOTALobby.State.RUN)
        RUN = 2,
        // @@protoc_insertion_point(enum_value:CSODOTALobby.State.POSTGAME)
        POSTGAME = 3,
        // @@protoc_insertion_point(enum_value:CSODOTALobby.State.NOTREADY)
        NOTREADY = 5,
        // @@protoc_insertion_point(enum_value:CSODOTALobby.State.SERVERASSIGN)
        SERVERASSIGN = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for State {
        const NAME: &'static str = "State";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<State> {
            match value {
                0 => ::std::option::Option::Some(State::UI),
                4 => ::std::option::Option::Some(State::READYUP),
                1 => ::std::option::Option::Some(State::SERVERSETUP),
                2 => ::std::option::Option::Some(State::RUN),
                3 => ::std::option::Option::Some(State::POSTGAME),
                5 => ::std::option::Option::Some(State::NOTREADY),
                6 => ::std::option::Option::Some(State::SERVERASSIGN),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<State> {
            match str {
                "UI" => ::std::option::Option::Some(State::UI),
                "READYUP" => ::std::option::Option::Some(State::READYUP),
                "SERVERSETUP" => ::std::option::Option::Some(State::SERVERSETUP),
                "RUN" => ::std::option::Option::Some(State::RUN),
                "POSTGAME" => ::std::option::Option::Some(State::POSTGAME),
                "NOTREADY" => ::std::option::Option::Some(State::NOTREADY),
                "SERVERASSIGN" => ::std::option::Option::Some(State::SERVERASSIGN),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [State] = &[
            State::UI,
            State::READYUP,
            State::SERVERSETUP,
            State::RUN,
            State::POSTGAME,
            State::NOTREADY,
            State::SERVERASSIGN,
        ];
    }

    impl ::std::default::Default for State {
        fn default() -> Self {
            State::UI
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CSODOTALobby.LobbyType)
    pub enum LobbyType {
        // @@protoc_insertion_point(enum_value:CSODOTALobby.LobbyType.INVALID)
        INVALID = -1,
        // @@protoc_insertion_point(enum_value:CSODOTALobby.LobbyType.CASUAL_MATCH)
        CASUAL_MATCH = 0,
        // @@protoc_insertion_point(enum_value:CSODOTALobby.LobbyType.PRACTICE)
        PRACTICE = 1,
        // @@protoc_insertion_point(enum_value:CSODOTALobby.LobbyType.COOP_BOT_MATCH)
        COOP_BOT_MATCH = 4,
        // @@protoc_insertion_point(enum_value:CSODOTALobby.LobbyType.COMPETITIVE_MATCH)
        COMPETITIVE_MATCH = 7,
        // @@protoc_insertion_point(enum_value:CSODOTALobby.LobbyType.WEEKEND_TOURNEY)
        WEEKEND_TOURNEY = 9,
        // @@protoc_insertion_point(enum_value:CSODOTALobby.LobbyType.LOCAL_BOT_MATCH)
        LOCAL_BOT_MATCH = 10,
        // @@protoc_insertion_point(enum_value:CSODOTALobby.LobbyType.SPECTATOR)
        SPECTATOR = 11,
        // @@protoc_insertion_point(enum_value:CSODOTALobby.LobbyType.EVENT_MATCH)
        EVENT_MATCH = 12,
        // @@protoc_insertion_point(enum_value:CSODOTALobby.LobbyType.NEW_PLAYER_POOL)
        NEW_PLAYER_POOL = 14,
        // @@protoc_insertion_point(enum_value:CSODOTALobby.LobbyType.FEATURED_GAMEMODE)
        FEATURED_GAMEMODE = 15,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for LobbyType {
        const NAME: &'static str = "LobbyType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<LobbyType> {
            match value {
                -1 => ::std::option::Option::Some(LobbyType::INVALID),
                0 => ::std::option::Option::Some(LobbyType::CASUAL_MATCH),
                1 => ::std::option::Option::Some(LobbyType::PRACTICE),
                4 => ::std::option::Option::Some(LobbyType::COOP_BOT_MATCH),
                7 => ::std::option::Option::Some(LobbyType::COMPETITIVE_MATCH),
                9 => ::std::option::Option::Some(LobbyType::WEEKEND_TOURNEY),
                10 => ::std::option::Option::Some(LobbyType::LOCAL_BOT_MATCH),
                11 => ::std::option::Option::Some(LobbyType::SPECTATOR),
                12 => ::std::option::Option::Some(LobbyType::EVENT_MATCH),
                14 => ::std::option::Option::Some(LobbyType::NEW_PLAYER_POOL),
                15 => ::std::option::Option::Some(LobbyType::FEATURED_GAMEMODE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<LobbyType> {
            match str {
                "INVALID" => ::std::option::Option::Some(LobbyType::INVALID),
                "CASUAL_MATCH" => ::std::option::Option::Some(LobbyType::CASUAL_MATCH),
                "PRACTICE" => ::std::option::Option::Some(LobbyType::PRACTICE),
                "COOP_BOT_MATCH" => ::std::option::Option::Some(LobbyType::COOP_BOT_MATCH),
                "COMPETITIVE_MATCH" => ::std::option::Option::Some(LobbyType::COMPETITIVE_MATCH),
                "WEEKEND_TOURNEY" => ::std::option::Option::Some(LobbyType::WEEKEND_TOURNEY),
                "LOCAL_BOT_MATCH" => ::std::option::Option::Some(LobbyType::LOCAL_BOT_MATCH),
                "SPECTATOR" => ::std::option::Option::Some(LobbyType::SPECTATOR),
                "EVENT_MATCH" => ::std::option::Option::Some(LobbyType::EVENT_MATCH),
                "NEW_PLAYER_POOL" => ::std::option::Option::Some(LobbyType::NEW_PLAYER_POOL),
                "FEATURED_GAMEMODE" => ::std::option::Option::Some(LobbyType::FEATURED_GAMEMODE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [LobbyType] = &[
            LobbyType::INVALID,
            LobbyType::CASUAL_MATCH,
            LobbyType::PRACTICE,
            LobbyType::COOP_BOT_MATCH,
            LobbyType::COMPETITIVE_MATCH,
            LobbyType::WEEKEND_TOURNEY,
            LobbyType::LOCAL_BOT_MATCH,
            LobbyType::SPECTATOR,
            LobbyType::EVENT_MATCH,
            LobbyType::NEW_PLAYER_POOL,
            LobbyType::FEATURED_GAMEMODE,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for LobbyType {
        fn default() -> Self {
            LobbyType::INVALID
        }
    }

}

// @@protoc_insertion_point(message:CSODOTAServerLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAServerLobby {
    // message fields
    // @@protoc_insertion_point(field:CSODOTAServerLobby.all_members)
    pub all_members: ::std::vec::Vec<CSODOTAServerLobbyMember>,
    // special fields
    // @@protoc_insertion_point(special_field:CSODOTAServerLobby.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAServerLobby {
    fn default() -> &'a CSODOTAServerLobby {
        <CSODOTAServerLobby as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSODOTAServerLobby {
    pub fn new() -> CSODOTAServerLobby {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSODOTAServerLobby {
    const NAME: &'static str = "CSODOTAServerLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.all_members.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.all_members {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.all_members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAServerLobby {
        CSODOTAServerLobby::new()
    }

    fn clear(&mut self) {
        self.all_members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAServerLobby {
        static instance: CSODOTAServerLobby = CSODOTAServerLobby {
            all_members: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSODOTAStaticLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAStaticLobby {
    // message fields
    // @@protoc_insertion_point(field:CSODOTAStaticLobby.all_members)
    pub all_members: ::std::vec::Vec<CSODOTAStaticLobbyMember>,
    // @@protoc_insertion_point(field:CSODOTAStaticLobby.is_player_draft)
    pub is_player_draft: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSODOTAStaticLobby.is_last_match_in_series)
    pub is_last_match_in_series: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSODOTAStaticLobby.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAStaticLobby {
    fn default() -> &'a CSODOTAStaticLobby {
        <CSODOTAStaticLobby as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSODOTAStaticLobby {
    pub fn new() -> CSODOTAStaticLobby {
        ::std::default::Default::default()
    }

    // optional bool is_player_draft = 2;

    pub fn is_player_draft(&self) -> bool {
        self.is_player_draft.unwrap_or(false)
    }

    pub fn clear_is_player_draft(&mut self) {
        self.is_player_draft = ::std::option::Option::None;
    }

    pub fn has_is_player_draft(&self) -> bool {
        self.is_player_draft.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_player_draft(&mut self, v: bool) {
        self.is_player_draft = ::std::option::Option::Some(v);
    }

    // optional bool is_last_match_in_series = 3;

    pub fn is_last_match_in_series(&self) -> bool {
        self.is_last_match_in_series.unwrap_or(false)
    }

    pub fn clear_is_last_match_in_series(&mut self) {
        self.is_last_match_in_series = ::std::option::Option::None;
    }

    pub fn has_is_last_match_in_series(&self) -> bool {
        self.is_last_match_in_series.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_last_match_in_series(&mut self, v: bool) {
        self.is_last_match_in_series = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSODOTAStaticLobby {
    const NAME: &'static str = "CSODOTAStaticLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.all_members.push(is.read_message()?);
                },
                16 => {
                    self.is_player_draft = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.is_last_match_in_series = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.all_members {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_player_draft {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_last_match_in_series {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.all_members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.is_player_draft {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.is_last_match_in_series {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAStaticLobby {
        CSODOTAStaticLobby::new()
    }

    fn clear(&mut self) {
        self.all_members.clear();
        self.is_player_draft = ::std::option::Option::None;
        self.is_last_match_in_series = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAStaticLobby {
        static instance: CSODOTAStaticLobby = CSODOTAStaticLobby {
            all_members: ::std::vec::Vec::new(),
            is_player_draft: ::std::option::Option::None,
            is_last_match_in_series: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSODOTAServerStaticLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAServerStaticLobby {
    // message fields
    // @@protoc_insertion_point(field:CSODOTAServerStaticLobby.all_members)
    pub all_members: ::std::vec::Vec<CSODOTAServerStaticLobbyMember>,
    // @@protoc_insertion_point(field:CSODOTAServerStaticLobby.post_patch_strategy_time_buffer)
    pub post_patch_strategy_time_buffer: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSODOTAServerStaticLobby.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAServerStaticLobby {
    fn default() -> &'a CSODOTAServerStaticLobby {
        <CSODOTAServerStaticLobby as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSODOTAServerStaticLobby {
    pub fn new() -> CSODOTAServerStaticLobby {
        ::std::default::Default::default()
    }

    // optional float post_patch_strategy_time_buffer = 2;

    pub fn post_patch_strategy_time_buffer(&self) -> f32 {
        self.post_patch_strategy_time_buffer.unwrap_or(0.)
    }

    pub fn clear_post_patch_strategy_time_buffer(&mut self) {
        self.post_patch_strategy_time_buffer = ::std::option::Option::None;
    }

    pub fn has_post_patch_strategy_time_buffer(&self) -> bool {
        self.post_patch_strategy_time_buffer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_post_patch_strategy_time_buffer(&mut self, v: f32) {
        self.post_patch_strategy_time_buffer = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSODOTAServerStaticLobby {
    const NAME: &'static str = "CSODOTAServerStaticLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.all_members.push(is.read_message()?);
                },
                21 => {
                    self.post_patch_strategy_time_buffer = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.all_members {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.post_patch_strategy_time_buffer {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.all_members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.post_patch_strategy_time_buffer {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAServerStaticLobby {
        CSODOTAServerStaticLobby::new()
    }

    fn clear(&mut self) {
        self.all_members.clear();
        self.post_patch_strategy_time_buffer = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAServerStaticLobby {
        static instance: CSODOTAServerStaticLobby = CSODOTAServerStaticLobby {
            all_members: ::std::vec::Vec::new(),
            post_patch_strategy_time_buffer: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAdditionalLobbyStartupAccountData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAdditionalLobbyStartupAccountData {
    // message fields
    // @@protoc_insertion_point(field:CMsgAdditionalLobbyStartupAccountData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAdditionalLobbyStartupAccountData.plus_data)
    pub plus_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgLobbyPlayerPlusSubscriptionData>,
    // @@protoc_insertion_point(field:CMsgAdditionalLobbyStartupAccountData.unlocked_chat_wheel_message_ranges)
    pub unlocked_chat_wheel_message_ranges: ::std::vec::Vec<cmsg_additional_lobby_startup_account_data::ChatWheelMessageRange>,
    // @@protoc_insertion_point(field:CMsgAdditionalLobbyStartupAccountData.unlocked_ping_wheel_message_ranges)
    pub unlocked_ping_wheel_message_ranges: ::std::vec::Vec<cmsg_additional_lobby_startup_account_data::PingWheelMessageRange>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAdditionalLobbyStartupAccountData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAdditionalLobbyStartupAccountData {
    fn default() -> &'a CMsgAdditionalLobbyStartupAccountData {
        <CMsgAdditionalLobbyStartupAccountData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAdditionalLobbyStartupAccountData {
    pub fn new() -> CMsgAdditionalLobbyStartupAccountData {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAdditionalLobbyStartupAccountData {
    const NAME: &'static str = "CMsgAdditionalLobbyStartupAccountData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.plus_data)?;
                },
                26 => {
                    self.unlocked_chat_wheel_message_ranges.push(is.read_message()?);
                },
                34 => {
                    self.unlocked_ping_wheel_message_ranges.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.plus_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.unlocked_chat_wheel_message_ranges {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.unlocked_ping_wheel_message_ranges {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.plus_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.unlocked_chat_wheel_message_ranges {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.unlocked_ping_wheel_message_ranges {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAdditionalLobbyStartupAccountData {
        CMsgAdditionalLobbyStartupAccountData::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.plus_data.clear();
        self.unlocked_chat_wheel_message_ranges.clear();
        self.unlocked_ping_wheel_message_ranges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAdditionalLobbyStartupAccountData {
        static instance: CMsgAdditionalLobbyStartupAccountData = CMsgAdditionalLobbyStartupAccountData {
            account_id: ::std::option::Option::None,
            plus_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            unlocked_chat_wheel_message_ranges: ::std::vec::Vec::new(),
            unlocked_ping_wheel_message_ranges: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgAdditionalLobbyStartupAccountData`
pub mod cmsg_additional_lobby_startup_account_data {
    // @@protoc_insertion_point(message:CMsgAdditionalLobbyStartupAccountData.ChatWheelMessageRange)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChatWheelMessageRange {
        // message fields
        // @@protoc_insertion_point(field:CMsgAdditionalLobbyStartupAccountData.ChatWheelMessageRange.message_id_start)
        pub message_id_start: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgAdditionalLobbyStartupAccountData.ChatWheelMessageRange.message_id_end)
        pub message_id_end: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgAdditionalLobbyStartupAccountData.ChatWheelMessageRange.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChatWheelMessageRange {
        fn default() -> &'a ChatWheelMessageRange {
            <ChatWheelMessageRange as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ChatWheelMessageRange {
        pub fn new() -> ChatWheelMessageRange {
            ::std::default::Default::default()
        }

        // optional uint32 message_id_start = 1;

        pub fn message_id_start(&self) -> u32 {
            self.message_id_start.unwrap_or(4294967295u32)
        }

        pub fn clear_message_id_start(&mut self) {
            self.message_id_start = ::std::option::Option::None;
        }

        pub fn has_message_id_start(&self) -> bool {
            self.message_id_start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message_id_start(&mut self, v: u32) {
            self.message_id_start = ::std::option::Option::Some(v);
        }

        // optional uint32 message_id_end = 2;

        pub fn message_id_end(&self) -> u32 {
            self.message_id_end.unwrap_or(4294967295u32)
        }

        pub fn clear_message_id_end(&mut self) {
            self.message_id_end = ::std::option::Option::None;
        }

        pub fn has_message_id_end(&self) -> bool {
            self.message_id_end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message_id_end(&mut self, v: u32) {
            self.message_id_end = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ChatWheelMessageRange {
        const NAME: &'static str = "ChatWheelMessageRange";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.message_id_start = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.message_id_end = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.message_id_start {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.message_id_end {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.message_id_start {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.message_id_end {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChatWheelMessageRange {
            ChatWheelMessageRange::new()
        }

        fn clear(&mut self) {
            self.message_id_start = ::std::option::Option::None;
            self.message_id_end = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChatWheelMessageRange {
            static instance: ChatWheelMessageRange = ChatWheelMessageRange {
                message_id_start: ::std::option::Option::None,
                message_id_end: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgAdditionalLobbyStartupAccountData.PingWheelMessageRange)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PingWheelMessageRange {
        // message fields
        // @@protoc_insertion_point(field:CMsgAdditionalLobbyStartupAccountData.PingWheelMessageRange.message_id_start)
        pub message_id_start: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgAdditionalLobbyStartupAccountData.PingWheelMessageRange.message_id_end)
        pub message_id_end: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgAdditionalLobbyStartupAccountData.PingWheelMessageRange.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PingWheelMessageRange {
        fn default() -> &'a PingWheelMessageRange {
            <PingWheelMessageRange as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PingWheelMessageRange {
        pub fn new() -> PingWheelMessageRange {
            ::std::default::Default::default()
        }

        // optional uint32 message_id_start = 1;

        pub fn message_id_start(&self) -> u32 {
            self.message_id_start.unwrap_or(4294967295u32)
        }

        pub fn clear_message_id_start(&mut self) {
            self.message_id_start = ::std::option::Option::None;
        }

        pub fn has_message_id_start(&self) -> bool {
            self.message_id_start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message_id_start(&mut self, v: u32) {
            self.message_id_start = ::std::option::Option::Some(v);
        }

        // optional uint32 message_id_end = 2;

        pub fn message_id_end(&self) -> u32 {
            self.message_id_end.unwrap_or(4294967295u32)
        }

        pub fn clear_message_id_end(&mut self) {
            self.message_id_end = ::std::option::Option::None;
        }

        pub fn has_message_id_end(&self) -> bool {
            self.message_id_end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message_id_end(&mut self, v: u32) {
            self.message_id_end = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PingWheelMessageRange {
        const NAME: &'static str = "PingWheelMessageRange";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.message_id_start = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.message_id_end = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.message_id_start {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.message_id_end {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.message_id_start {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.message_id_end {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PingWheelMessageRange {
            PingWheelMessageRange::new()
        }

        fn clear(&mut self) {
            self.message_id_start = ::std::option::Option::None;
            self.message_id_end = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PingWheelMessageRange {
            static instance: PingWheelMessageRange = PingWheelMessageRange {
                message_id_start: ::std::option::Option::None,
                message_id_end: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgLobbyInitializationComplete)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyInitializationComplete {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLobbyInitializationComplete.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyInitializationComplete {
    fn default() -> &'a CMsgLobbyInitializationComplete {
        <CMsgLobbyInitializationComplete as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyInitializationComplete {
    pub fn new() -> CMsgLobbyInitializationComplete {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLobbyInitializationComplete {
    const NAME: &'static str = "CMsgLobbyInitializationComplete";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyInitializationComplete {
        CMsgLobbyInitializationComplete::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyInitializationComplete {
        static instance: CMsgLobbyInitializationComplete = CMsgLobbyInitializationComplete {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLobbyPlaytestDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyPlaytestDetails {
    // message fields
    // @@protoc_insertion_point(field:CMsgLobbyPlaytestDetails.json)
    pub json: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLobbyPlaytestDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyPlaytestDetails {
    fn default() -> &'a CMsgLobbyPlaytestDetails {
        <CMsgLobbyPlaytestDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyPlaytestDetails {
    pub fn new() -> CMsgLobbyPlaytestDetails {
        ::std::default::Default::default()
    }

    // optional string json = 1;

    pub fn json(&self) -> &str {
        match self.json.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_json(&mut self) {
        self.json = ::std::option::Option::None;
    }

    pub fn has_json(&self) -> bool {
        self.json.is_some()
    }

    // Param is passed by value, moved
    pub fn set_json(&mut self, v: ::std::string::String) {
        self.json = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_json(&mut self) -> &mut ::std::string::String {
        if self.json.is_none() {
            self.json = ::std::option::Option::Some(::std::string::String::new());
        }
        self.json.as_mut().unwrap()
    }

    // Take field
    pub fn take_json(&mut self) -> ::std::string::String {
        self.json.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLobbyPlaytestDetails {
    const NAME: &'static str = "CMsgLobbyPlaytestDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.json = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.json.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.json.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyPlaytestDetails {
        CMsgLobbyPlaytestDetails::new()
    }

    fn clear(&mut self) {
        self.json = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyPlaytestDetails {
        static instance: CMsgLobbyPlaytestDetails = CMsgLobbyPlaytestDetails {
            json: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLocalServerGuildData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLocalServerGuildData {
    // message fields
    // @@protoc_insertion_point(field:CMsgLocalServerGuildData.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLocalServerGuildData.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgLocalServerGuildData.guild_points)
    pub guild_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLocalServerGuildData.guild_logo)
    pub guild_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgLocalServerGuildData.guild_primary_color)
    pub guild_primary_color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLocalServerGuildData.guild_secondary_color)
    pub guild_secondary_color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLocalServerGuildData.guild_pattern)
    pub guild_pattern: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLocalServerGuildData.guild_flags)
    pub guild_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLocalServerGuildData.guild_weekly_percentile)
    pub guild_weekly_percentile: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLocalServerGuildData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLocalServerGuildData {
    fn default() -> &'a CMsgLocalServerGuildData {
        <CMsgLocalServerGuildData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLocalServerGuildData {
    pub fn new() -> CMsgLocalServerGuildData {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 guild_points = 3;

    pub fn guild_points(&self) -> u32 {
        self.guild_points.unwrap_or(0)
    }

    pub fn clear_guild_points(&mut self) {
        self.guild_points = ::std::option::Option::None;
    }

    pub fn has_guild_points(&self) -> bool {
        self.guild_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_points(&mut self, v: u32) {
        self.guild_points = ::std::option::Option::Some(v);
    }

    // optional uint64 guild_logo = 4;

    pub fn guild_logo(&self) -> u64 {
        self.guild_logo.unwrap_or(0)
    }

    pub fn clear_guild_logo(&mut self) {
        self.guild_logo = ::std::option::Option::None;
    }

    pub fn has_guild_logo(&self) -> bool {
        self.guild_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_logo(&mut self, v: u64) {
        self.guild_logo = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_primary_color = 5;

    pub fn guild_primary_color(&self) -> u32 {
        self.guild_primary_color.unwrap_or(0)
    }

    pub fn clear_guild_primary_color(&mut self) {
        self.guild_primary_color = ::std::option::Option::None;
    }

    pub fn has_guild_primary_color(&self) -> bool {
        self.guild_primary_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_primary_color(&mut self, v: u32) {
        self.guild_primary_color = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_secondary_color = 6;

    pub fn guild_secondary_color(&self) -> u32 {
        self.guild_secondary_color.unwrap_or(0)
    }

    pub fn clear_guild_secondary_color(&mut self) {
        self.guild_secondary_color = ::std::option::Option::None;
    }

    pub fn has_guild_secondary_color(&self) -> bool {
        self.guild_secondary_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_secondary_color(&mut self, v: u32) {
        self.guild_secondary_color = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_pattern = 7;

    pub fn guild_pattern(&self) -> u32 {
        self.guild_pattern.unwrap_or(0)
    }

    pub fn clear_guild_pattern(&mut self) {
        self.guild_pattern = ::std::option::Option::None;
    }

    pub fn has_guild_pattern(&self) -> bool {
        self.guild_pattern.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_pattern(&mut self, v: u32) {
        self.guild_pattern = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_flags = 8;

    pub fn guild_flags(&self) -> u32 {
        self.guild_flags.unwrap_or(0)
    }

    pub fn clear_guild_flags(&mut self) {
        self.guild_flags = ::std::option::Option::None;
    }

    pub fn has_guild_flags(&self) -> bool {
        self.guild_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_flags(&mut self, v: u32) {
        self.guild_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_weekly_percentile = 9;

    pub fn guild_weekly_percentile(&self) -> u32 {
        self.guild_weekly_percentile.unwrap_or(0)
    }

    pub fn clear_guild_weekly_percentile(&mut self) {
        self.guild_weekly_percentile = ::std::option::Option::None;
    }

    pub fn has_guild_weekly_percentile(&self) -> bool {
        self.guild_weekly_percentile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_weekly_percentile(&mut self, v: u32) {
        self.guild_weekly_percentile = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLocalServerGuildData {
    const NAME: &'static str = "CMsgLocalServerGuildData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.guild_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.guild_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.guild_primary_color = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.guild_secondary_color = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.guild_pattern = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.guild_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.guild_weekly_percentile = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.guild_points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.guild_logo {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.guild_primary_color {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.guild_secondary_color {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.guild_pattern {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.guild_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.guild_weekly_percentile {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.guild_points {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.guild_logo {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.guild_primary_color {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.guild_secondary_color {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.guild_pattern {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.guild_flags {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.guild_weekly_percentile {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLocalServerGuildData {
        CMsgLocalServerGuildData::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.guild_points = ::std::option::Option::None;
        self.guild_logo = ::std::option::Option::None;
        self.guild_primary_color = ::std::option::Option::None;
        self.guild_secondary_color = ::std::option::Option::None;
        self.guild_pattern = ::std::option::Option::None;
        self.guild_flags = ::std::option::Option::None;
        self.guild_weekly_percentile = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLocalServerGuildData {
        static instance: CMsgLocalServerGuildData = CMsgLocalServerGuildData {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            guild_points: ::std::option::Option::None,
            guild_logo: ::std::option::Option::None,
            guild_primary_color: ::std::option::Option::None,
            guild_secondary_color: ::std::option::Option::None,
            guild_pattern: ::std::option::Option::None,
            guild_flags: ::std::option::Option::None,
            guild_weekly_percentile: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLocalServerFakeLobbyData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLocalServerFakeLobbyData {
    // message fields
    // @@protoc_insertion_point(field:CMsgLocalServerFakeLobbyData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLocalServerFakeLobbyData.event_points)
    pub event_points: ::std::vec::Vec<CMsgLobbyEventPoints>,
    // @@protoc_insertion_point(field:CMsgLocalServerFakeLobbyData.is_plus_subscriber)
    pub is_plus_subscriber: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgLocalServerFakeLobbyData.primary_event_id)
    pub primary_event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLocalServerFakeLobbyData.favorite_team)
    pub favorite_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLocalServerFakeLobbyData.favorite_team_quality)
    pub favorite_team_quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLocalServerFakeLobbyData.guild_info)
    pub guild_info: ::steam_vent_proto_common::protobuf::MessageField<CMsgLocalServerGuildData>,
    // @@protoc_insertion_point(field:CMsgLocalServerFakeLobbyData.teleport_fx_level)
    pub teleport_fx_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLocalServerFakeLobbyData.additional_data)
    pub additional_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgAdditionalLobbyStartupAccountData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLocalServerFakeLobbyData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLocalServerFakeLobbyData {
    fn default() -> &'a CMsgLocalServerFakeLobbyData {
        <CMsgLocalServerFakeLobbyData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLocalServerFakeLobbyData {
    pub fn new() -> CMsgLocalServerFakeLobbyData {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional bool is_plus_subscriber = 3;

    pub fn is_plus_subscriber(&self) -> bool {
        self.is_plus_subscriber.unwrap_or(false)
    }

    pub fn clear_is_plus_subscriber(&mut self) {
        self.is_plus_subscriber = ::std::option::Option::None;
    }

    pub fn has_is_plus_subscriber(&self) -> bool {
        self.is_plus_subscriber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_plus_subscriber(&mut self, v: bool) {
        self.is_plus_subscriber = ::std::option::Option::Some(v);
    }

    // optional uint32 primary_event_id = 4;

    pub fn primary_event_id(&self) -> u32 {
        self.primary_event_id.unwrap_or(0)
    }

    pub fn clear_primary_event_id(&mut self) {
        self.primary_event_id = ::std::option::Option::None;
    }

    pub fn has_primary_event_id(&self) -> bool {
        self.primary_event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_event_id(&mut self, v: u32) {
        self.primary_event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 favorite_team = 5;

    pub fn favorite_team(&self) -> u32 {
        self.favorite_team.unwrap_or(0)
    }

    pub fn clear_favorite_team(&mut self) {
        self.favorite_team = ::std::option::Option::None;
    }

    pub fn has_favorite_team(&self) -> bool {
        self.favorite_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_team(&mut self, v: u32) {
        self.favorite_team = ::std::option::Option::Some(v);
    }

    // optional uint32 favorite_team_quality = 6;

    pub fn favorite_team_quality(&self) -> u32 {
        self.favorite_team_quality.unwrap_or(0)
    }

    pub fn clear_favorite_team_quality(&mut self) {
        self.favorite_team_quality = ::std::option::Option::None;
    }

    pub fn has_favorite_team_quality(&self) -> bool {
        self.favorite_team_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_team_quality(&mut self, v: u32) {
        self.favorite_team_quality = ::std::option::Option::Some(v);
    }

    // optional uint32 teleport_fx_level = 8;

    pub fn teleport_fx_level(&self) -> u32 {
        self.teleport_fx_level.unwrap_or(0)
    }

    pub fn clear_teleport_fx_level(&mut self) {
        self.teleport_fx_level = ::std::option::Option::None;
    }

    pub fn has_teleport_fx_level(&self) -> bool {
        self.teleport_fx_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teleport_fx_level(&mut self, v: u32) {
        self.teleport_fx_level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLocalServerFakeLobbyData {
    const NAME: &'static str = "CMsgLocalServerFakeLobbyData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.event_points.push(is.read_message()?);
                },
                24 => {
                    self.is_plus_subscriber = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.primary_event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.favorite_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.favorite_team_quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_info)?;
                },
                64 => {
                    self.teleport_fx_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.additional_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.event_points {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_plus_subscriber {
            my_size += 1 + 1;
        }
        if let Some(v) = self.primary_event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.favorite_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.favorite_team_quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.guild_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.teleport_fx_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.additional_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.event_points {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.is_plus_subscriber {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.primary_event_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.favorite_team {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.favorite_team_quality {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.guild_info.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.teleport_fx_level {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.additional_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLocalServerFakeLobbyData {
        CMsgLocalServerFakeLobbyData::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.event_points.clear();
        self.is_plus_subscriber = ::std::option::Option::None;
        self.primary_event_id = ::std::option::Option::None;
        self.favorite_team = ::std::option::Option::None;
        self.favorite_team_quality = ::std::option::Option::None;
        self.guild_info.clear();
        self.teleport_fx_level = ::std::option::Option::None;
        self.additional_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLocalServerFakeLobbyData {
        static instance: CMsgLocalServerFakeLobbyData = CMsgLocalServerFakeLobbyData {
            account_id: ::std::option::Option::None,
            event_points: ::std::vec::Vec::new(),
            is_plus_subscriber: ::std::option::Option::None,
            primary_event_id: ::std::option::Option::None,
            favorite_team: ::std::option::Option::None,
            favorite_team_quality: ::std::option::Option::None,
            guild_info: ::steam_vent_proto_common::protobuf::MessageField::none(),
            teleport_fx_level: ::std::option::Option::None,
            additional_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ELobbyMemberCoachRequestState)
pub enum ELobbyMemberCoachRequestState {
    // @@protoc_insertion_point(enum_value:ELobbyMemberCoachRequestState.k_eLobbyMemberCoachRequestState_None)
    k_eLobbyMemberCoachRequestState_None = 0,
    // @@protoc_insertion_point(enum_value:ELobbyMemberCoachRequestState.k_eLobbyMemberCoachRequestState_Accepted)
    k_eLobbyMemberCoachRequestState_Accepted = 1,
    // @@protoc_insertion_point(enum_value:ELobbyMemberCoachRequestState.k_eLobbyMemberCoachRequestState_Rejected)
    k_eLobbyMemberCoachRequestState_Rejected = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for ELobbyMemberCoachRequestState {
    const NAME: &'static str = "ELobbyMemberCoachRequestState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELobbyMemberCoachRequestState> {
        match value {
            0 => ::std::option::Option::Some(ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_None),
            1 => ::std::option::Option::Some(ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_Accepted),
            2 => ::std::option::Option::Some(ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_Rejected),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELobbyMemberCoachRequestState> {
        match str {
            "k_eLobbyMemberCoachRequestState_None" => ::std::option::Option::Some(ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_None),
            "k_eLobbyMemberCoachRequestState_Accepted" => ::std::option::Option::Some(ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_Accepted),
            "k_eLobbyMemberCoachRequestState_Rejected" => ::std::option::Option::Some(ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_Rejected),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELobbyMemberCoachRequestState] = &[
        ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_None,
        ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_Accepted,
        ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_Rejected,
    ];
}

impl ::std::default::Default for ELobbyMemberCoachRequestState {
    fn default() -> Self {
        ELobbyMemberCoachRequestState::k_eLobbyMemberCoachRequestState_None
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:LobbyDotaTVDelay)
pub enum LobbyDotaTVDelay {
    // @@protoc_insertion_point(enum_value:LobbyDotaTVDelay.LobbyDotaTV_10)
    LobbyDotaTV_10 = 0,
    // @@protoc_insertion_point(enum_value:LobbyDotaTVDelay.LobbyDotaTV_120)
    LobbyDotaTV_120 = 1,
    // @@protoc_insertion_point(enum_value:LobbyDotaTVDelay.LobbyDotaTV_300)
    LobbyDotaTV_300 = 2,
    // @@protoc_insertion_point(enum_value:LobbyDotaTVDelay.LobbyDotaTV_900)
    LobbyDotaTV_900 = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for LobbyDotaTVDelay {
    const NAME: &'static str = "LobbyDotaTVDelay";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LobbyDotaTVDelay> {
        match value {
            0 => ::std::option::Option::Some(LobbyDotaTVDelay::LobbyDotaTV_10),
            1 => ::std::option::Option::Some(LobbyDotaTVDelay::LobbyDotaTV_120),
            2 => ::std::option::Option::Some(LobbyDotaTVDelay::LobbyDotaTV_300),
            3 => ::std::option::Option::Some(LobbyDotaTVDelay::LobbyDotaTV_900),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LobbyDotaTVDelay> {
        match str {
            "LobbyDotaTV_10" => ::std::option::Option::Some(LobbyDotaTVDelay::LobbyDotaTV_10),
            "LobbyDotaTV_120" => ::std::option::Option::Some(LobbyDotaTVDelay::LobbyDotaTV_120),
            "LobbyDotaTV_300" => ::std::option::Option::Some(LobbyDotaTVDelay::LobbyDotaTV_300),
            "LobbyDotaTV_900" => ::std::option::Option::Some(LobbyDotaTVDelay::LobbyDotaTV_900),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LobbyDotaTVDelay] = &[
        LobbyDotaTVDelay::LobbyDotaTV_10,
        LobbyDotaTVDelay::LobbyDotaTV_120,
        LobbyDotaTVDelay::LobbyDotaTV_300,
        LobbyDotaTVDelay::LobbyDotaTV_900,
    ];
}

impl ::std::default::Default for LobbyDotaTVDelay {
    fn default() -> Self {
        LobbyDotaTVDelay::LobbyDotaTV_10
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:LobbyDotaPauseSetting)
pub enum LobbyDotaPauseSetting {
    // @@protoc_insertion_point(enum_value:LobbyDotaPauseSetting.LobbyDotaPauseSetting_Unlimited)
    LobbyDotaPauseSetting_Unlimited = 0,
    // @@protoc_insertion_point(enum_value:LobbyDotaPauseSetting.LobbyDotaPauseSetting_Limited)
    LobbyDotaPauseSetting_Limited = 1,
    // @@protoc_insertion_point(enum_value:LobbyDotaPauseSetting.LobbyDotaPauseSetting_Disabled)
    LobbyDotaPauseSetting_Disabled = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for LobbyDotaPauseSetting {
    const NAME: &'static str = "LobbyDotaPauseSetting";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LobbyDotaPauseSetting> {
        match value {
            0 => ::std::option::Option::Some(LobbyDotaPauseSetting::LobbyDotaPauseSetting_Unlimited),
            1 => ::std::option::Option::Some(LobbyDotaPauseSetting::LobbyDotaPauseSetting_Limited),
            2 => ::std::option::Option::Some(LobbyDotaPauseSetting::LobbyDotaPauseSetting_Disabled),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LobbyDotaPauseSetting> {
        match str {
            "LobbyDotaPauseSetting_Unlimited" => ::std::option::Option::Some(LobbyDotaPauseSetting::LobbyDotaPauseSetting_Unlimited),
            "LobbyDotaPauseSetting_Limited" => ::std::option::Option::Some(LobbyDotaPauseSetting::LobbyDotaPauseSetting_Limited),
            "LobbyDotaPauseSetting_Disabled" => ::std::option::Option::Some(LobbyDotaPauseSetting::LobbyDotaPauseSetting_Disabled),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LobbyDotaPauseSetting] = &[
        LobbyDotaPauseSetting::LobbyDotaPauseSetting_Unlimited,
        LobbyDotaPauseSetting::LobbyDotaPauseSetting_Limited,
        LobbyDotaPauseSetting::LobbyDotaPauseSetting_Disabled,
    ];
}

impl ::std::default::Default for LobbyDotaPauseSetting {
    fn default() -> Self {
        LobbyDotaPauseSetting::LobbyDotaPauseSetting_Unlimited
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages::*;
#[allow(unused_imports)]
use crate::dota_shared_enums::*;
#[allow(unused_imports)]
use crate::gcsdk_gcmessages::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgLobbyCoachFriendRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLobbyPlayerPlusSubscriptionData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgEventActionData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPeriodicResourceData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLobbyEventPoints {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLobbyEventGameData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSODOTALobbyInvite {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSODOTALobbyMember {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSODOTAServerLobbyMember {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSODOTAStaticLobbyMember {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSODOTAServerStaticLobbyMember {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CLobbyTeamDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CLobbyGuildDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CLobbyTimedRewardDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CLobbyBroadcastChannelInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CLobbyGuildChallenge {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTALobbyMatchQualityData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSODOTALobby {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSODOTAServerLobby {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSODOTAStaticLobby {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSODOTAServerStaticLobby {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAdditionalLobbyStartupAccountData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLobbyInitializationComplete {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLobbyPlaytestDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLocalServerGuildData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLocalServerFakeLobbyData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
