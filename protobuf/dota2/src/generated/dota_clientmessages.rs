// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_clientmessages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CDOTAClientMsg_MapPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_MapPing {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_MapPing.location_ping)
    pub location_ping: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_LocationPing>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_MapPing.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_MapPing {
    fn default() -> &'a CDOTAClientMsg_MapPing {
        <CDOTAClientMsg_MapPing as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_MapPing {
    pub fn new() -> CDOTAClientMsg_MapPing {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_MapPing {
    const NAME: &'static str = "CDOTAClientMsg_MapPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.location_ping)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.location_ping.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.location_ping.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_MapPing {
        CDOTAClientMsg_MapPing::new()
    }

    fn clear(&mut self) {
        self.location_ping.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_MapPing {
        static instance: CDOTAClientMsg_MapPing = CDOTAClientMsg_MapPing {
            location_ping: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_ItemAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ItemAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_ItemAlert.item_alert)
    pub item_alert: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_ItemAlert>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_ItemAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ItemAlert {
    fn default() -> &'a CDOTAClientMsg_ItemAlert {
        <CDOTAClientMsg_ItemAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ItemAlert {
    pub fn new() -> CDOTAClientMsg_ItemAlert {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_ItemAlert {
    const NAME: &'static str = "CDOTAClientMsg_ItemAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.item_alert)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_alert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_alert.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ItemAlert {
        CDOTAClientMsg_ItemAlert::new()
    }

    fn clear(&mut self) {
        self.item_alert.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ItemAlert {
        static instance: CDOTAClientMsg_ItemAlert = CDOTAClientMsg_ItemAlert {
            item_alert: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_EnemyItemAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_EnemyItemAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_EnemyItemAlert.item_entindex)
    pub item_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_EnemyItemAlert.rune_type)
    pub rune_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_EnemyItemAlert.item_level)
    pub item_level: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_EnemyItemAlert.primary_charges)
    pub primary_charges: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_EnemyItemAlert.secondary_charges)
    pub secondary_charges: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_EnemyItemAlert.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_EnemyItemAlert.owner_entindex)
    pub owner_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_EnemyItemAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_EnemyItemAlert {
    fn default() -> &'a CDOTAClientMsg_EnemyItemAlert {
        <CDOTAClientMsg_EnemyItemAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_EnemyItemAlert {
    pub fn new() -> CDOTAClientMsg_EnemyItemAlert {
        ::std::default::Default::default()
    }

    // optional int32 item_entindex = 1;

    pub fn item_entindex(&self) -> i32 {
        self.item_entindex.unwrap_or(-1i32)
    }

    pub fn clear_item_entindex(&mut self) {
        self.item_entindex = ::std::option::Option::None;
    }

    pub fn has_item_entindex(&self) -> bool {
        self.item_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_entindex(&mut self, v: i32) {
        self.item_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 rune_type = 2;

    pub fn rune_type(&self) -> i32 {
        self.rune_type.unwrap_or(-1i32)
    }

    pub fn clear_rune_type(&mut self) {
        self.rune_type = ::std::option::Option::None;
    }

    pub fn has_rune_type(&self) -> bool {
        self.rune_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rune_type(&mut self, v: i32) {
        self.rune_type = ::std::option::Option::Some(v);
    }

    // optional int32 item_level = 3;

    pub fn item_level(&self) -> i32 {
        self.item_level.unwrap_or(-1i32)
    }

    pub fn clear_item_level(&mut self) {
        self.item_level = ::std::option::Option::None;
    }

    pub fn has_item_level(&self) -> bool {
        self.item_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_level(&mut self, v: i32) {
        self.item_level = ::std::option::Option::Some(v);
    }

    // optional int32 primary_charges = 4;

    pub fn primary_charges(&self) -> i32 {
        self.primary_charges.unwrap_or(-1i32)
    }

    pub fn clear_primary_charges(&mut self) {
        self.primary_charges = ::std::option::Option::None;
    }

    pub fn has_primary_charges(&self) -> bool {
        self.primary_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_charges(&mut self, v: i32) {
        self.primary_charges = ::std::option::Option::Some(v);
    }

    // optional int32 secondary_charges = 5;

    pub fn secondary_charges(&self) -> i32 {
        self.secondary_charges.unwrap_or(-1i32)
    }

    pub fn clear_secondary_charges(&mut self) {
        self.secondary_charges = ::std::option::Option::None;
    }

    pub fn has_secondary_charges(&self) -> bool {
        self.secondary_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary_charges(&mut self, v: i32) {
        self.secondary_charges = ::std::option::Option::Some(v);
    }

    // optional int32 ability_id = 6;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(-1i32)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional int32 owner_entindex = 7;

    pub fn owner_entindex(&self) -> i32 {
        self.owner_entindex.unwrap_or(-1i32)
    }

    pub fn clear_owner_entindex(&mut self) {
        self.owner_entindex = ::std::option::Option::None;
    }

    pub fn has_owner_entindex(&self) -> bool {
        self.owner_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_entindex(&mut self, v: i32) {
        self.owner_entindex = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_EnemyItemAlert {
    const NAME: &'static str = "CDOTAClientMsg_EnemyItemAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.rune_type = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.item_level = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.primary_charges = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.secondary_charges = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.owner_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.rune_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.item_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.primary_charges {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.secondary_charges {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.owner_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.rune_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.item_level {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.primary_charges {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.secondary_charges {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.owner_entindex {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_EnemyItemAlert {
        CDOTAClientMsg_EnemyItemAlert::new()
    }

    fn clear(&mut self) {
        self.item_entindex = ::std::option::Option::None;
        self.rune_type = ::std::option::Option::None;
        self.item_level = ::std::option::Option::None;
        self.primary_charges = ::std::option::Option::None;
        self.secondary_charges = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.owner_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_EnemyItemAlert {
        static instance: CDOTAClientMsg_EnemyItemAlert = CDOTAClientMsg_EnemyItemAlert {
            item_entindex: ::std::option::Option::None,
            rune_type: ::std::option::Option::None,
            item_level: ::std::option::Option::None,
            primary_charges: ::std::option::Option::None,
            secondary_charges: ::std::option::Option::None,
            ability_id: ::std::option::Option::None,
            owner_entindex: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_ModifierAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ModifierAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_ModifierAlert.buff_internal_index)
    pub buff_internal_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_ModifierAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_ModifierAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ModifierAlert {
    fn default() -> &'a CDOTAClientMsg_ModifierAlert {
        <CDOTAClientMsg_ModifierAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ModifierAlert {
    pub fn new() -> CDOTAClientMsg_ModifierAlert {
        ::std::default::Default::default()
    }

    // optional int32 buff_internal_index = 1;

    pub fn buff_internal_index(&self) -> i32 {
        self.buff_internal_index.unwrap_or(0)
    }

    pub fn clear_buff_internal_index(&mut self) {
        self.buff_internal_index = ::std::option::Option::None;
    }

    pub fn has_buff_internal_index(&self) -> bool {
        self.buff_internal_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buff_internal_index(&mut self, v: i32) {
        self.buff_internal_index = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 2;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_ModifierAlert {
    const NAME: &'static str = "CDOTAClientMsg_ModifierAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.buff_internal_index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.buff_internal_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.buff_internal_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ModifierAlert {
        CDOTAClientMsg_ModifierAlert::new()
    }

    fn clear(&mut self) {
        self.buff_internal_index = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ModifierAlert {
        static instance: CDOTAClientMsg_ModifierAlert = CDOTAClientMsg_ModifierAlert {
            buff_internal_index: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_ClickedBuff)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ClickedBuff {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_ClickedBuff.buff_internal_index)
    pub buff_internal_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_ClickedBuff.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_ClickedBuff.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ClickedBuff {
    fn default() -> &'a CDOTAClientMsg_ClickedBuff {
        <CDOTAClientMsg_ClickedBuff as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ClickedBuff {
    pub fn new() -> CDOTAClientMsg_ClickedBuff {
        ::std::default::Default::default()
    }

    // optional int32 buff_internal_index = 1;

    pub fn buff_internal_index(&self) -> i32 {
        self.buff_internal_index.unwrap_or(0)
    }

    pub fn clear_buff_internal_index(&mut self) {
        self.buff_internal_index = ::std::option::Option::None;
    }

    pub fn has_buff_internal_index(&self) -> bool {
        self.buff_internal_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buff_internal_index(&mut self, v: i32) {
        self.buff_internal_index = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 2;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_ClickedBuff {
    const NAME: &'static str = "CDOTAClientMsg_ClickedBuff";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.buff_internal_index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.buff_internal_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.buff_internal_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ClickedBuff {
        CDOTAClientMsg_ClickedBuff::new()
    }

    fn clear(&mut self) {
        self.buff_internal_index = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ClickedBuff {
        static instance: CDOTAClientMsg_ClickedBuff = CDOTAClientMsg_ClickedBuff {
            buff_internal_index: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_HPManaAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_HPManaAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_HPManaAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_HPManaAlert.show_raw_values)
    pub show_raw_values: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_HPManaAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_HPManaAlert {
    fn default() -> &'a CDOTAClientMsg_HPManaAlert {
        <CDOTAClientMsg_HPManaAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_HPManaAlert {
    pub fn new() -> CDOTAClientMsg_HPManaAlert {
        ::std::default::Default::default()
    }

    // optional int32 target_entindex = 1;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional bool show_raw_values = 2;

    pub fn show_raw_values(&self) -> bool {
        self.show_raw_values.unwrap_or(false)
    }

    pub fn clear_show_raw_values(&mut self) {
        self.show_raw_values = ::std::option::Option::None;
    }

    pub fn has_show_raw_values(&self) -> bool {
        self.show_raw_values.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_raw_values(&mut self, v: bool) {
        self.show_raw_values = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_HPManaAlert {
    const NAME: &'static str = "CDOTAClientMsg_HPManaAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.show_raw_values = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.show_raw_values {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.show_raw_values {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_HPManaAlert {
        CDOTAClientMsg_HPManaAlert::new()
    }

    fn clear(&mut self) {
        self.target_entindex = ::std::option::Option::None;
        self.show_raw_values = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_HPManaAlert {
        static instance: CDOTAClientMsg_HPManaAlert = CDOTAClientMsg_HPManaAlert {
            target_entindex: ::std::option::Option::None,
            show_raw_values: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_NeutralCampAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_NeutralCampAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_NeutralCampAlert.spawner_entindex)
    pub spawner_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_NeutralCampAlert.unit_entindex)
    pub unit_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_NeutralCampAlert.stack_request)
    pub stack_request: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_NeutralCampAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_NeutralCampAlert {
    fn default() -> &'a CDOTAClientMsg_NeutralCampAlert {
        <CDOTAClientMsg_NeutralCampAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_NeutralCampAlert {
    pub fn new() -> CDOTAClientMsg_NeutralCampAlert {
        ::std::default::Default::default()
    }

    // optional int32 spawner_entindex = 1;

    pub fn spawner_entindex(&self) -> i32 {
        self.spawner_entindex.unwrap_or(-1i32)
    }

    pub fn clear_spawner_entindex(&mut self) {
        self.spawner_entindex = ::std::option::Option::None;
    }

    pub fn has_spawner_entindex(&self) -> bool {
        self.spawner_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawner_entindex(&mut self, v: i32) {
        self.spawner_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 unit_entindex = 2;

    pub fn unit_entindex(&self) -> i32 {
        self.unit_entindex.unwrap_or(-1i32)
    }

    pub fn clear_unit_entindex(&mut self) {
        self.unit_entindex = ::std::option::Option::None;
    }

    pub fn has_unit_entindex(&self) -> bool {
        self.unit_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_entindex(&mut self, v: i32) {
        self.unit_entindex = ::std::option::Option::Some(v);
    }

    // optional bool stack_request = 3;

    pub fn stack_request(&self) -> bool {
        self.stack_request.unwrap_or(false)
    }

    pub fn clear_stack_request(&mut self) {
        self.stack_request = ::std::option::Option::None;
    }

    pub fn has_stack_request(&self) -> bool {
        self.stack_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_request(&mut self, v: bool) {
        self.stack_request = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_NeutralCampAlert {
    const NAME: &'static str = "CDOTAClientMsg_NeutralCampAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.spawner_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.unit_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.stack_request = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spawner_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.unit_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.stack_request {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.spawner_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.unit_entindex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.stack_request {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_NeutralCampAlert {
        CDOTAClientMsg_NeutralCampAlert::new()
    }

    fn clear(&mut self) {
        self.spawner_entindex = ::std::option::Option::None;
        self.unit_entindex = ::std::option::Option::None;
        self.stack_request = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_NeutralCampAlert {
        static instance: CDOTAClientMsg_NeutralCampAlert = CDOTAClientMsg_NeutralCampAlert {
            spawner_entindex: ::std::option::Option::None,
            unit_entindex: ::std::option::Option::None,
            stack_request: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_GlyphAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_GlyphAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_GlyphAlert.negative)
    pub negative: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_GlyphAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_GlyphAlert {
    fn default() -> &'a CDOTAClientMsg_GlyphAlert {
        <CDOTAClientMsg_GlyphAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_GlyphAlert {
    pub fn new() -> CDOTAClientMsg_GlyphAlert {
        ::std::default::Default::default()
    }

    // optional bool negative = 1;

    pub fn negative(&self) -> bool {
        self.negative.unwrap_or(false)
    }

    pub fn clear_negative(&mut self) {
        self.negative = ::std::option::Option::None;
    }

    pub fn has_negative(&self) -> bool {
        self.negative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative(&mut self, v: bool) {
        self.negative = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_GlyphAlert {
    const NAME: &'static str = "CDOTAClientMsg_GlyphAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.negative = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.negative {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.negative {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_GlyphAlert {
        CDOTAClientMsg_GlyphAlert::new()
    }

    fn clear(&mut self) {
        self.negative = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_GlyphAlert {
        static instance: CDOTAClientMsg_GlyphAlert = CDOTAClientMsg_GlyphAlert {
            negative: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_RadarAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_RadarAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_RadarAlert.negative)
    pub negative: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_RadarAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_RadarAlert {
    fn default() -> &'a CDOTAClientMsg_RadarAlert {
        <CDOTAClientMsg_RadarAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_RadarAlert {
    pub fn new() -> CDOTAClientMsg_RadarAlert {
        ::std::default::Default::default()
    }

    // optional bool negative = 1;

    pub fn negative(&self) -> bool {
        self.negative.unwrap_or(false)
    }

    pub fn clear_negative(&mut self) {
        self.negative = ::std::option::Option::None;
    }

    pub fn has_negative(&self) -> bool {
        self.negative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative(&mut self, v: bool) {
        self.negative = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_RadarAlert {
    const NAME: &'static str = "CDOTAClientMsg_RadarAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.negative = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.negative {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.negative {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_RadarAlert {
        CDOTAClientMsg_RadarAlert::new()
    }

    fn clear(&mut self) {
        self.negative = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_RadarAlert {
        static instance: CDOTAClientMsg_RadarAlert = CDOTAClientMsg_RadarAlert {
            negative: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_MapLine)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_MapLine {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_MapLine.mapline)
    pub mapline: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_MapLine>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_MapLine.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_MapLine {
    fn default() -> &'a CDOTAClientMsg_MapLine {
        <CDOTAClientMsg_MapLine as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_MapLine {
    pub fn new() -> CDOTAClientMsg_MapLine {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_MapLine {
    const NAME: &'static str = "CDOTAClientMsg_MapLine";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.mapline)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mapline.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.mapline.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_MapLine {
        CDOTAClientMsg_MapLine::new()
    }

    fn clear(&mut self) {
        self.mapline.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_MapLine {
        static instance: CDOTAClientMsg_MapLine = CDOTAClientMsg_MapLine {
            mapline: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_AspectRatio)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_AspectRatio {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_AspectRatio.ratio)
    pub ratio: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_AspectRatio.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_AspectRatio {
    fn default() -> &'a CDOTAClientMsg_AspectRatio {
        <CDOTAClientMsg_AspectRatio as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_AspectRatio {
    pub fn new() -> CDOTAClientMsg_AspectRatio {
        ::std::default::Default::default()
    }

    // optional float ratio = 1;

    pub fn ratio(&self) -> f32 {
        self.ratio.unwrap_or(0.)
    }

    pub fn clear_ratio(&mut self) {
        self.ratio = ::std::option::Option::None;
    }

    pub fn has_ratio(&self) -> bool {
        self.ratio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ratio(&mut self, v: f32) {
        self.ratio = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_AspectRatio {
    const NAME: &'static str = "CDOTAClientMsg_AspectRatio";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.ratio = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ratio {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ratio {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_AspectRatio {
        CDOTAClientMsg_AspectRatio::new()
    }

    fn clear(&mut self) {
        self.ratio = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_AspectRatio {
        static instance: CDOTAClientMsg_AspectRatio = CDOTAClientMsg_AspectRatio {
            ratio: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_UnitsAutoAttackMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_UnitsAutoAttackMode {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_UnitsAutoAttackMode.mode)
    pub mode: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cdotaclient_msg_units_auto_attack_mode::EMode>>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_UnitsAutoAttackMode.unit_type)
    pub unit_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cdotaclient_msg_units_auto_attack_mode::EUnitType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_UnitsAutoAttackMode.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_UnitsAutoAttackMode {
    fn default() -> &'a CDOTAClientMsg_UnitsAutoAttackMode {
        <CDOTAClientMsg_UnitsAutoAttackMode as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_UnitsAutoAttackMode {
    pub fn new() -> CDOTAClientMsg_UnitsAutoAttackMode {
        ::std::default::Default::default()
    }

    // optional .CDOTAClientMsg_UnitsAutoAttackMode.EMode mode = 1;

    pub fn mode(&self) -> cdotaclient_msg_units_auto_attack_mode::EMode {
        match self.mode {
            Some(e) => e.enum_value_or(cdotaclient_msg_units_auto_attack_mode::EMode::INVALID),
            None => cdotaclient_msg_units_auto_attack_mode::EMode::INVALID,
        }
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: cdotaclient_msg_units_auto_attack_mode::EMode) {
        self.mode = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .CDOTAClientMsg_UnitsAutoAttackMode.EUnitType unit_type = 2;

    pub fn unit_type(&self) -> cdotaclient_msg_units_auto_attack_mode::EUnitType {
        match self.unit_type {
            Some(e) => e.enum_value_or(cdotaclient_msg_units_auto_attack_mode::EUnitType::NORMAL),
            None => cdotaclient_msg_units_auto_attack_mode::EUnitType::NORMAL,
        }
    }

    pub fn clear_unit_type(&mut self) {
        self.unit_type = ::std::option::Option::None;
    }

    pub fn has_unit_type(&self) -> bool {
        self.unit_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_type(&mut self, v: cdotaclient_msg_units_auto_attack_mode::EUnitType) {
        self.unit_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_UnitsAutoAttackMode {
    const NAME: &'static str = "CDOTAClientMsg_UnitsAutoAttackMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.unit_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.unit_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.mode {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.unit_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_UnitsAutoAttackMode {
        CDOTAClientMsg_UnitsAutoAttackMode::new()
    }

    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.unit_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_UnitsAutoAttackMode {
        static instance: CDOTAClientMsg_UnitsAutoAttackMode = CDOTAClientMsg_UnitsAutoAttackMode {
            mode: ::std::option::Option::None,
            unit_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CDOTAClientMsg_UnitsAutoAttackMode`
pub mod cdotaclient_msg_units_auto_attack_mode {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CDOTAClientMsg_UnitsAutoAttackMode.EMode)
    pub enum EMode {
        // @@protoc_insertion_point(enum_value:CDOTAClientMsg_UnitsAutoAttackMode.EMode.INVALID)
        INVALID = -1,
        // @@protoc_insertion_point(enum_value:CDOTAClientMsg_UnitsAutoAttackMode.EMode.NEVER)
        NEVER = 0,
        // @@protoc_insertion_point(enum_value:CDOTAClientMsg_UnitsAutoAttackMode.EMode.AFTER_SPELLCAST)
        AFTER_SPELLCAST = 1,
        // @@protoc_insertion_point(enum_value:CDOTAClientMsg_UnitsAutoAttackMode.EMode.ALWAYS)
        ALWAYS = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EMode {
        const NAME: &'static str = "EMode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EMode> {
            match value {
                -1 => ::std::option::Option::Some(EMode::INVALID),
                0 => ::std::option::Option::Some(EMode::NEVER),
                1 => ::std::option::Option::Some(EMode::AFTER_SPELLCAST),
                2 => ::std::option::Option::Some(EMode::ALWAYS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EMode> {
            match str {
                "INVALID" => ::std::option::Option::Some(EMode::INVALID),
                "NEVER" => ::std::option::Option::Some(EMode::NEVER),
                "AFTER_SPELLCAST" => ::std::option::Option::Some(EMode::AFTER_SPELLCAST),
                "ALWAYS" => ::std::option::Option::Some(EMode::ALWAYS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EMode] = &[
            EMode::INVALID,
            EMode::NEVER,
            EMode::AFTER_SPELLCAST,
            EMode::ALWAYS,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for EMode {
        fn default() -> Self {
            EMode::INVALID
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CDOTAClientMsg_UnitsAutoAttackMode.EUnitType)
    pub enum EUnitType {
        // @@protoc_insertion_point(enum_value:CDOTAClientMsg_UnitsAutoAttackMode.EUnitType.NORMAL)
        NORMAL = 0,
        // @@protoc_insertion_point(enum_value:CDOTAClientMsg_UnitsAutoAttackMode.EUnitType.SUMMONED)
        SUMMONED = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EUnitType {
        const NAME: &'static str = "EUnitType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EUnitType> {
            match value {
                0 => ::std::option::Option::Some(EUnitType::NORMAL),
                1 => ::std::option::Option::Some(EUnitType::SUMMONED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EUnitType> {
            match str {
                "NORMAL" => ::std::option::Option::Some(EUnitType::NORMAL),
                "SUMMONED" => ::std::option::Option::Some(EUnitType::SUMMONED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EUnitType] = &[
            EUnitType::NORMAL,
            EUnitType::SUMMONED,
        ];
    }

    impl ::std::default::Default for EUnitType {
        fn default() -> Self {
            EUnitType::NORMAL
        }
    }

}

// @@protoc_insertion_point(message:CDOTAClientMsg_UnitsAutoAttackAfterSpell)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_UnitsAutoAttackAfterSpell {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_UnitsAutoAttackAfterSpell.enabled)
    pub enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_UnitsAutoAttackAfterSpell.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_UnitsAutoAttackAfterSpell {
    fn default() -> &'a CDOTAClientMsg_UnitsAutoAttackAfterSpell {
        <CDOTAClientMsg_UnitsAutoAttackAfterSpell as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_UnitsAutoAttackAfterSpell {
    pub fn new() -> CDOTAClientMsg_UnitsAutoAttackAfterSpell {
        ::std::default::Default::default()
    }

    // optional bool enabled = 1;

    pub fn enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_UnitsAutoAttackAfterSpell {
    const NAME: &'static str = "CDOTAClientMsg_UnitsAutoAttackAfterSpell";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_UnitsAutoAttackAfterSpell {
        CDOTAClientMsg_UnitsAutoAttackAfterSpell::new()
    }

    fn clear(&mut self) {
        self.enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_UnitsAutoAttackAfterSpell {
        static instance: CDOTAClientMsg_UnitsAutoAttackAfterSpell = CDOTAClientMsg_UnitsAutoAttackAfterSpell {
            enabled: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_TeleportRequiresHalt)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_TeleportRequiresHalt {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_TeleportRequiresHalt.enabled)
    pub enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_TeleportRequiresHalt.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_TeleportRequiresHalt {
    fn default() -> &'a CDOTAClientMsg_TeleportRequiresHalt {
        <CDOTAClientMsg_TeleportRequiresHalt as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_TeleportRequiresHalt {
    pub fn new() -> CDOTAClientMsg_TeleportRequiresHalt {
        ::std::default::Default::default()
    }

    // optional bool enabled = 1;

    pub fn enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_TeleportRequiresHalt {
    const NAME: &'static str = "CDOTAClientMsg_TeleportRequiresHalt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_TeleportRequiresHalt {
        CDOTAClientMsg_TeleportRequiresHalt::new()
    }

    fn clear(&mut self) {
        self.enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_TeleportRequiresHalt {
        static instance: CDOTAClientMsg_TeleportRequiresHalt = CDOTAClientMsg_TeleportRequiresHalt {
            enabled: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_ChannelRequiresHalt)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ChannelRequiresHalt {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_ChannelRequiresHalt.enabled)
    pub enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_ChannelRequiresHalt.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ChannelRequiresHalt {
    fn default() -> &'a CDOTAClientMsg_ChannelRequiresHalt {
        <CDOTAClientMsg_ChannelRequiresHalt as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ChannelRequiresHalt {
    pub fn new() -> CDOTAClientMsg_ChannelRequiresHalt {
        ::std::default::Default::default()
    }

    // optional bool enabled = 1;

    pub fn enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_ChannelRequiresHalt {
    const NAME: &'static str = "CDOTAClientMsg_ChannelRequiresHalt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ChannelRequiresHalt {
        CDOTAClientMsg_ChannelRequiresHalt::new()
    }

    fn clear(&mut self) {
        self.enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ChannelRequiresHalt {
        static instance: CDOTAClientMsg_ChannelRequiresHalt = CDOTAClientMsg_ChannelRequiresHalt {
            enabled: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_SearchString)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SearchString {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_SearchString.search)
    pub search: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_SearchString.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SearchString {
    fn default() -> &'a CDOTAClientMsg_SearchString {
        <CDOTAClientMsg_SearchString as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SearchString {
    pub fn new() -> CDOTAClientMsg_SearchString {
        ::std::default::Default::default()
    }

    // optional string search = 1;

    pub fn search(&self) -> &str {
        match self.search.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_search(&mut self) {
        self.search = ::std::option::Option::None;
    }

    pub fn has_search(&self) -> bool {
        self.search.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search(&mut self, v: ::std::string::String) {
        self.search = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search(&mut self) -> &mut ::std::string::String {
        if self.search.is_none() {
            self.search = ::std::option::Option::Some(::std::string::String::new());
        }
        self.search.as_mut().unwrap()
    }

    // Take field
    pub fn take_search(&mut self) -> ::std::string::String {
        self.search.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_SearchString {
    const NAME: &'static str = "CDOTAClientMsg_SearchString";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.search = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.search.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.search.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SearchString {
        CDOTAClientMsg_SearchString::new()
    }

    fn clear(&mut self) {
        self.search = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SearchString {
        static instance: CDOTAClientMsg_SearchString = CDOTAClientMsg_SearchString {
            search: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_Pause)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_Pause {
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_Pause.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_Pause {
    fn default() -> &'a CDOTAClientMsg_Pause {
        <CDOTAClientMsg_Pause as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_Pause {
    pub fn new() -> CDOTAClientMsg_Pause {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_Pause {
    const NAME: &'static str = "CDOTAClientMsg_Pause";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_Pause {
        CDOTAClientMsg_Pause::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_Pause {
        static instance: CDOTAClientMsg_Pause = CDOTAClientMsg_Pause {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_ShopViewMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ShopViewMode {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_ShopViewMode.mode)
    pub mode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_ShopViewMode.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ShopViewMode {
    fn default() -> &'a CDOTAClientMsg_ShopViewMode {
        <CDOTAClientMsg_ShopViewMode as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ShopViewMode {
    pub fn new() -> CDOTAClientMsg_ShopViewMode {
        ::std::default::Default::default()
    }

    // optional uint32 mode = 1;

    pub fn mode(&self) -> u32 {
        self.mode.unwrap_or(0)
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: u32) {
        self.mode = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_ShopViewMode {
    const NAME: &'static str = "CDOTAClientMsg_ShopViewMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.mode {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ShopViewMode {
        CDOTAClientMsg_ShopViewMode::new()
    }

    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ShopViewMode {
        static instance: CDOTAClientMsg_ShopViewMode = CDOTAClientMsg_ShopViewMode {
            mode: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_SetUnitShareFlag)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SetUnitShareFlag {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_SetUnitShareFlag.player_id)
    pub player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_SetUnitShareFlag.flag)
    pub flag: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_SetUnitShareFlag.state)
    pub state: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_SetUnitShareFlag.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SetUnitShareFlag {
    fn default() -> &'a CDOTAClientMsg_SetUnitShareFlag {
        <CDOTAClientMsg_SetUnitShareFlag as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SetUnitShareFlag {
    pub fn new() -> CDOTAClientMsg_SetUnitShareFlag {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 flag = 2;

    pub fn flag(&self) -> u32 {
        self.flag.unwrap_or(0)
    }

    pub fn clear_flag(&mut self) {
        self.flag = ::std::option::Option::None;
    }

    pub fn has_flag(&self) -> bool {
        self.flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flag(&mut self, v: u32) {
        self.flag = ::std::option::Option::Some(v);
    }

    // optional bool state = 3;

    pub fn state(&self) -> bool {
        self.state.unwrap_or(false)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_SetUnitShareFlag {
    const NAME: &'static str = "CDOTAClientMsg_SetUnitShareFlag";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.flag = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.state = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.flag {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.state {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.flag {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.state {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SetUnitShareFlag {
        CDOTAClientMsg_SetUnitShareFlag::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.flag = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SetUnitShareFlag {
        static instance: CDOTAClientMsg_SetUnitShareFlag = CDOTAClientMsg_SetUnitShareFlag {
            player_id: ::std::option::Option::None,
            flag: ::std::option::Option::None,
            state: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_SwapRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SwapRequest {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_SwapRequest.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_SwapRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SwapRequest {
    fn default() -> &'a CDOTAClientMsg_SwapRequest {
        <CDOTAClientMsg_SwapRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SwapRequest {
    pub fn new() -> CDOTAClientMsg_SwapRequest {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_SwapRequest {
    const NAME: &'static str = "CDOTAClientMsg_SwapRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SwapRequest {
        CDOTAClientMsg_SwapRequest::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SwapRequest {
        static instance: CDOTAClientMsg_SwapRequest = CDOTAClientMsg_SwapRequest {
            player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_SwapAccept)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SwapAccept {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_SwapAccept.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_SwapAccept.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SwapAccept {
    fn default() -> &'a CDOTAClientMsg_SwapAccept {
        <CDOTAClientMsg_SwapAccept as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SwapAccept {
    pub fn new() -> CDOTAClientMsg_SwapAccept {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_SwapAccept {
    const NAME: &'static str = "CDOTAClientMsg_SwapAccept";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SwapAccept {
        CDOTAClientMsg_SwapAccept::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SwapAccept {
        static instance: CDOTAClientMsg_SwapAccept = CDOTAClientMsg_SwapAccept {
            player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_WorldLine)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_WorldLine {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_WorldLine.worldline)
    pub worldline: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_WorldLine>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_WorldLine.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_WorldLine {
    fn default() -> &'a CDOTAClientMsg_WorldLine {
        <CDOTAClientMsg_WorldLine as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_WorldLine {
    pub fn new() -> CDOTAClientMsg_WorldLine {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_WorldLine {
    const NAME: &'static str = "CDOTAClientMsg_WorldLine";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.worldline)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.worldline.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.worldline.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_WorldLine {
        CDOTAClientMsg_WorldLine::new()
    }

    fn clear(&mut self) {
        self.worldline.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_WorldLine {
        static instance: CDOTAClientMsg_WorldLine = CDOTAClientMsg_WorldLine {
            worldline: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_RequestGraphUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_RequestGraphUpdate {
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_RequestGraphUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_RequestGraphUpdate {
    fn default() -> &'a CDOTAClientMsg_RequestGraphUpdate {
        <CDOTAClientMsg_RequestGraphUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_RequestGraphUpdate {
    pub fn new() -> CDOTAClientMsg_RequestGraphUpdate {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_RequestGraphUpdate {
    const NAME: &'static str = "CDOTAClientMsg_RequestGraphUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_RequestGraphUpdate {
        CDOTAClientMsg_RequestGraphUpdate::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_RequestGraphUpdate {
        static instance: CDOTAClientMsg_RequestGraphUpdate = CDOTAClientMsg_RequestGraphUpdate {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_ChatWheel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ChatWheel {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_ChatWheel.chat_message_id)
    pub chat_message_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_ChatWheel.param_hero_id)
    pub param_hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_ChatWheel.emoticon_id)
    pub emoticon_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_ChatWheel.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ChatWheel {
    fn default() -> &'a CDOTAClientMsg_ChatWheel {
        <CDOTAClientMsg_ChatWheel as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ChatWheel {
    pub fn new() -> CDOTAClientMsg_ChatWheel {
        ::std::default::Default::default()
    }

    // optional uint32 chat_message_id = 1;

    pub fn chat_message_id(&self) -> u32 {
        self.chat_message_id.unwrap_or(4294967295u32)
    }

    pub fn clear_chat_message_id(&mut self) {
        self.chat_message_id = ::std::option::Option::None;
    }

    pub fn has_chat_message_id(&self) -> bool {
        self.chat_message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_message_id(&mut self, v: u32) {
        self.chat_message_id = ::std::option::Option::Some(v);
    }

    // optional int32 param_hero_id = 2;

    pub fn param_hero_id(&self) -> i32 {
        self.param_hero_id.unwrap_or(0)
    }

    pub fn clear_param_hero_id(&mut self) {
        self.param_hero_id = ::std::option::Option::None;
    }

    pub fn has_param_hero_id(&self) -> bool {
        self.param_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_hero_id(&mut self, v: i32) {
        self.param_hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 emoticon_id = 3;

    pub fn emoticon_id(&self) -> u32 {
        self.emoticon_id.unwrap_or(0)
    }

    pub fn clear_emoticon_id(&mut self) {
        self.emoticon_id = ::std::option::Option::None;
    }

    pub fn has_emoticon_id(&self) -> bool {
        self.emoticon_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emoticon_id(&mut self, v: u32) {
        self.emoticon_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_ChatWheel {
    const NAME: &'static str = "CDOTAClientMsg_ChatWheel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_message_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.param_hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.emoticon_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_message_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.param_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.emoticon_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.chat_message_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.param_hero_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.emoticon_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ChatWheel {
        CDOTAClientMsg_ChatWheel::new()
    }

    fn clear(&mut self) {
        self.chat_message_id = ::std::option::Option::None;
        self.param_hero_id = ::std::option::Option::None;
        self.emoticon_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ChatWheel {
        static instance: CDOTAClientMsg_ChatWheel = CDOTAClientMsg_ChatWheel {
            chat_message_id: ::std::option::Option::None,
            param_hero_id: ::std::option::Option::None,
            emoticon_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_SendStatPopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SendStatPopup {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_SendStatPopup.statpopup)
    pub statpopup: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_SendStatPopup>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_SendStatPopup.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SendStatPopup {
    fn default() -> &'a CDOTAClientMsg_SendStatPopup {
        <CDOTAClientMsg_SendStatPopup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SendStatPopup {
    pub fn new() -> CDOTAClientMsg_SendStatPopup {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_SendStatPopup {
    const NAME: &'static str = "CDOTAClientMsg_SendStatPopup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.statpopup)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.statpopup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.statpopup.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SendStatPopup {
        CDOTAClientMsg_SendStatPopup::new()
    }

    fn clear(&mut self) {
        self.statpopup.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SendStatPopup {
        static instance: CDOTAClientMsg_SendStatPopup = CDOTAClientMsg_SendStatPopup {
            statpopup: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_DismissAllStatPopups)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_DismissAllStatPopups {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_DismissAllStatPopups.dismissallmsg)
    pub dismissallmsg: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::CDOTAMsg_DismissAllStatPopups>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_DismissAllStatPopups.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_DismissAllStatPopups {
    fn default() -> &'a CDOTAClientMsg_DismissAllStatPopups {
        <CDOTAClientMsg_DismissAllStatPopups as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_DismissAllStatPopups {
    pub fn new() -> CDOTAClientMsg_DismissAllStatPopups {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_DismissAllStatPopups {
    const NAME: &'static str = "CDOTAClientMsg_DismissAllStatPopups";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.dismissallmsg)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dismissallmsg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.dismissallmsg.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_DismissAllStatPopups {
        CDOTAClientMsg_DismissAllStatPopups::new()
    }

    fn clear(&mut self) {
        self.dismissallmsg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_DismissAllStatPopups {
        static instance: CDOTAClientMsg_DismissAllStatPopups = CDOTAClientMsg_DismissAllStatPopups {
            dismissallmsg: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_BeginLastHitChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_BeginLastHitChallenge {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_BeginLastHitChallenge.chosen_lane)
    pub chosen_lane: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_BeginLastHitChallenge.helper_enabled)
    pub helper_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_BeginLastHitChallenge.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_BeginLastHitChallenge {
    fn default() -> &'a CDOTAClientMsg_BeginLastHitChallenge {
        <CDOTAClientMsg_BeginLastHitChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_BeginLastHitChallenge {
    pub fn new() -> CDOTAClientMsg_BeginLastHitChallenge {
        ::std::default::Default::default()
    }

    // optional uint32 chosen_lane = 1;

    pub fn chosen_lane(&self) -> u32 {
        self.chosen_lane.unwrap_or(0)
    }

    pub fn clear_chosen_lane(&mut self) {
        self.chosen_lane = ::std::option::Option::None;
    }

    pub fn has_chosen_lane(&self) -> bool {
        self.chosen_lane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chosen_lane(&mut self, v: u32) {
        self.chosen_lane = ::std::option::Option::Some(v);
    }

    // optional bool helper_enabled = 2;

    pub fn helper_enabled(&self) -> bool {
        self.helper_enabled.unwrap_or(false)
    }

    pub fn clear_helper_enabled(&mut self) {
        self.helper_enabled = ::std::option::Option::None;
    }

    pub fn has_helper_enabled(&self) -> bool {
        self.helper_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_helper_enabled(&mut self, v: bool) {
        self.helper_enabled = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_BeginLastHitChallenge {
    const NAME: &'static str = "CDOTAClientMsg_BeginLastHitChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chosen_lane = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.helper_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chosen_lane {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.helper_enabled {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.chosen_lane {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.helper_enabled {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_BeginLastHitChallenge {
        CDOTAClientMsg_BeginLastHitChallenge::new()
    }

    fn clear(&mut self) {
        self.chosen_lane = ::std::option::Option::None;
        self.helper_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_BeginLastHitChallenge {
        static instance: CDOTAClientMsg_BeginLastHitChallenge = CDOTAClientMsg_BeginLastHitChallenge {
            chosen_lane: ::std::option::Option::None,
            helper_enabled: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_UpdateQuickBuyItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_UpdateQuickBuyItem {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_UpdateQuickBuyItem.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_UpdateQuickBuyItem.purchasable)
    pub purchasable: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_UpdateQuickBuyItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_UpdateQuickBuyItem {
    fn default() -> &'a CDOTAClientMsg_UpdateQuickBuyItem {
        <CDOTAClientMsg_UpdateQuickBuyItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_UpdateQuickBuyItem {
    pub fn new() -> CDOTAClientMsg_UpdateQuickBuyItem {
        ::std::default::Default::default()
    }

    // optional int32 item_ability_id = 1;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(-1i32)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional bool purchasable = 2;

    pub fn purchasable(&self) -> bool {
        self.purchasable.unwrap_or(false)
    }

    pub fn clear_purchasable(&mut self) {
        self.purchasable = ::std::option::Option::None;
    }

    pub fn has_purchasable(&self) -> bool {
        self.purchasable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchasable(&mut self, v: bool) {
        self.purchasable = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_UpdateQuickBuyItem {
    const NAME: &'static str = "CDOTAClientMsg_UpdateQuickBuyItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.purchasable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.purchasable {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_ability_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.purchasable {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_UpdateQuickBuyItem {
        CDOTAClientMsg_UpdateQuickBuyItem::new()
    }

    fn clear(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
        self.purchasable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_UpdateQuickBuyItem {
        static instance: CDOTAClientMsg_UpdateQuickBuyItem = CDOTAClientMsg_UpdateQuickBuyItem {
            item_ability_id: ::std::option::Option::None,
            purchasable: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_UpdateQuickBuy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_UpdateQuickBuy {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_UpdateQuickBuy.items)
    pub items: ::std::vec::Vec<CDOTAClientMsg_UpdateQuickBuyItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_UpdateQuickBuy.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_UpdateQuickBuy {
    fn default() -> &'a CDOTAClientMsg_UpdateQuickBuy {
        <CDOTAClientMsg_UpdateQuickBuy as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_UpdateQuickBuy {
    pub fn new() -> CDOTAClientMsg_UpdateQuickBuy {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_UpdateQuickBuy {
    const NAME: &'static str = "CDOTAClientMsg_UpdateQuickBuy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_UpdateQuickBuy {
        CDOTAClientMsg_UpdateQuickBuy::new()
    }

    fn clear(&mut self) {
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_UpdateQuickBuy {
        static instance: CDOTAClientMsg_UpdateQuickBuy = CDOTAClientMsg_UpdateQuickBuy {
            items: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_RecordVote)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_RecordVote {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_RecordVote.choice_index)
    pub choice_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_RecordVote.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_RecordVote {
    fn default() -> &'a CDOTAClientMsg_RecordVote {
        <CDOTAClientMsg_RecordVote as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_RecordVote {
    pub fn new() -> CDOTAClientMsg_RecordVote {
        ::std::default::Default::default()
    }

    // optional int32 choice_index = 1;

    pub fn choice_index(&self) -> i32 {
        self.choice_index.unwrap_or(0)
    }

    pub fn clear_choice_index(&mut self) {
        self.choice_index = ::std::option::Option::None;
    }

    pub fn has_choice_index(&self) -> bool {
        self.choice_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_choice_index(&mut self, v: i32) {
        self.choice_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_RecordVote {
    const NAME: &'static str = "CDOTAClientMsg_RecordVote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.choice_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.choice_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.choice_index {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_RecordVote {
        CDOTAClientMsg_RecordVote::new()
    }

    fn clear(&mut self) {
        self.choice_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_RecordVote {
        static instance: CDOTAClientMsg_RecordVote = CDOTAClientMsg_RecordVote {
            choice_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_WillPurchaseAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_WillPurchaseAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_WillPurchaseAlert.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_WillPurchaseAlert.gold_remaining)
    pub gold_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_WillPurchaseAlert.suggestion_player_id)
    pub suggestion_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_WillPurchaseAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_WillPurchaseAlert {
    fn default() -> &'a CDOTAClientMsg_WillPurchaseAlert {
        <CDOTAClientMsg_WillPurchaseAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_WillPurchaseAlert {
    pub fn new() -> CDOTAClientMsg_WillPurchaseAlert {
        ::std::default::Default::default()
    }

    // optional int32 item_ability_id = 1;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(-1i32)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional uint32 gold_remaining = 2;

    pub fn gold_remaining(&self) -> u32 {
        self.gold_remaining.unwrap_or(0)
    }

    pub fn clear_gold_remaining(&mut self) {
        self.gold_remaining = ::std::option::Option::None;
    }

    pub fn has_gold_remaining(&self) -> bool {
        self.gold_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_remaining(&mut self, v: u32) {
        self.gold_remaining = ::std::option::Option::Some(v);
    }

    // optional int32 suggestion_player_id = 3;

    pub fn suggestion_player_id(&self) -> i32 {
        self.suggestion_player_id.unwrap_or(-1i32)
    }

    pub fn clear_suggestion_player_id(&mut self) {
        self.suggestion_player_id = ::std::option::Option::None;
    }

    pub fn has_suggestion_player_id(&self) -> bool {
        self.suggestion_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suggestion_player_id(&mut self, v: i32) {
        self.suggestion_player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_WillPurchaseAlert {
    const NAME: &'static str = "CDOTAClientMsg_WillPurchaseAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.gold_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.suggestion_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.gold_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.suggestion_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_ability_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.gold_remaining {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.suggestion_player_id {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_WillPurchaseAlert {
        CDOTAClientMsg_WillPurchaseAlert::new()
    }

    fn clear(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
        self.gold_remaining = ::std::option::Option::None;
        self.suggestion_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_WillPurchaseAlert {
        static instance: CDOTAClientMsg_WillPurchaseAlert = CDOTAClientMsg_WillPurchaseAlert {
            item_ability_id: ::std::option::Option::None,
            gold_remaining: ::std::option::Option::None,
            suggestion_player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_BuyBackStateAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_BuyBackStateAlert {
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_BuyBackStateAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_BuyBackStateAlert {
    fn default() -> &'a CDOTAClientMsg_BuyBackStateAlert {
        <CDOTAClientMsg_BuyBackStateAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_BuyBackStateAlert {
    pub fn new() -> CDOTAClientMsg_BuyBackStateAlert {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_BuyBackStateAlert {
    const NAME: &'static str = "CDOTAClientMsg_BuyBackStateAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_BuyBackStateAlert {
        CDOTAClientMsg_BuyBackStateAlert::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_BuyBackStateAlert {
        static instance: CDOTAClientMsg_BuyBackStateAlert = CDOTAClientMsg_BuyBackStateAlert {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_QuickBuyAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_QuickBuyAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_QuickBuyAlert.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_QuickBuyAlert.gold_cost)
    pub gold_cost: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_QuickBuyAlert.item_cooldown_seconds)
    pub item_cooldown_seconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_QuickBuyAlert.show_buyback)
    pub show_buyback: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_QuickBuyAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_QuickBuyAlert {
    fn default() -> &'a CDOTAClientMsg_QuickBuyAlert {
        <CDOTAClientMsg_QuickBuyAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_QuickBuyAlert {
    pub fn new() -> CDOTAClientMsg_QuickBuyAlert {
        ::std::default::Default::default()
    }

    // optional int32 item_ability_id = 1;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(-1i32)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional int32 gold_cost = 2;

    pub fn gold_cost(&self) -> i32 {
        self.gold_cost.unwrap_or(0)
    }

    pub fn clear_gold_cost(&mut self) {
        self.gold_cost = ::std::option::Option::None;
    }

    pub fn has_gold_cost(&self) -> bool {
        self.gold_cost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_cost(&mut self, v: i32) {
        self.gold_cost = ::std::option::Option::Some(v);
    }

    // optional int32 item_cooldown_seconds = 3;

    pub fn item_cooldown_seconds(&self) -> i32 {
        self.item_cooldown_seconds.unwrap_or(0)
    }

    pub fn clear_item_cooldown_seconds(&mut self) {
        self.item_cooldown_seconds = ::std::option::Option::None;
    }

    pub fn has_item_cooldown_seconds(&self) -> bool {
        self.item_cooldown_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_cooldown_seconds(&mut self, v: i32) {
        self.item_cooldown_seconds = ::std::option::Option::Some(v);
    }

    // optional bool show_buyback = 4;

    pub fn show_buyback(&self) -> bool {
        self.show_buyback.unwrap_or(false)
    }

    pub fn clear_show_buyback(&mut self) {
        self.show_buyback = ::std::option::Option::None;
    }

    pub fn has_show_buyback(&self) -> bool {
        self.show_buyback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_buyback(&mut self, v: bool) {
        self.show_buyback = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_QuickBuyAlert {
    const NAME: &'static str = "CDOTAClientMsg_QuickBuyAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.gold_cost = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.item_cooldown_seconds = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.show_buyback = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.gold_cost {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.item_cooldown_seconds {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.show_buyback {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_ability_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.gold_cost {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.item_cooldown_seconds {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.show_buyback {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_QuickBuyAlert {
        CDOTAClientMsg_QuickBuyAlert::new()
    }

    fn clear(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
        self.gold_cost = ::std::option::Option::None;
        self.item_cooldown_seconds = ::std::option::Option::None;
        self.show_buyback = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_QuickBuyAlert {
        static instance: CDOTAClientMsg_QuickBuyAlert = CDOTAClientMsg_QuickBuyAlert {
            item_ability_id: ::std::option::Option::None,
            gold_cost: ::std::option::Option::None,
            item_cooldown_seconds: ::std::option::Option::None,
            show_buyback: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_PlayerShowCase)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_PlayerShowCase {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_PlayerShowCase.showcase)
    pub showcase: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_PlayerShowCase.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_PlayerShowCase {
    fn default() -> &'a CDOTAClientMsg_PlayerShowCase {
        <CDOTAClientMsg_PlayerShowCase as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_PlayerShowCase {
    pub fn new() -> CDOTAClientMsg_PlayerShowCase {
        ::std::default::Default::default()
    }

    // optional bool showcase = 1;

    pub fn showcase(&self) -> bool {
        self.showcase.unwrap_or(false)
    }

    pub fn clear_showcase(&mut self) {
        self.showcase = ::std::option::Option::None;
    }

    pub fn has_showcase(&self) -> bool {
        self.showcase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase(&mut self, v: bool) {
        self.showcase = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_PlayerShowCase {
    const NAME: &'static str = "CDOTAClientMsg_PlayerShowCase";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.showcase = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.showcase {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.showcase {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_PlayerShowCase {
        CDOTAClientMsg_PlayerShowCase::new()
    }

    fn clear(&mut self) {
        self.showcase = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_PlayerShowCase {
        static instance: CDOTAClientMsg_PlayerShowCase = CDOTAClientMsg_PlayerShowCase {
            showcase: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_CameraZoomAmount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_CameraZoomAmount {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_CameraZoomAmount.zoom_amount)
    pub zoom_amount: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_CameraZoomAmount.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_CameraZoomAmount {
    fn default() -> &'a CDOTAClientMsg_CameraZoomAmount {
        <CDOTAClientMsg_CameraZoomAmount as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_CameraZoomAmount {
    pub fn new() -> CDOTAClientMsg_CameraZoomAmount {
        ::std::default::Default::default()
    }

    // optional float zoom_amount = 1;

    pub fn zoom_amount(&self) -> f32 {
        self.zoom_amount.unwrap_or(0.)
    }

    pub fn clear_zoom_amount(&mut self) {
        self.zoom_amount = ::std::option::Option::None;
    }

    pub fn has_zoom_amount(&self) -> bool {
        self.zoom_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom_amount(&mut self, v: f32) {
        self.zoom_amount = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_CameraZoomAmount {
    const NAME: &'static str = "CDOTAClientMsg_CameraZoomAmount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.zoom_amount = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.zoom_amount {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.zoom_amount {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_CameraZoomAmount {
        CDOTAClientMsg_CameraZoomAmount::new()
    }

    fn clear(&mut self) {
        self.zoom_amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_CameraZoomAmount {
        static instance: CDOTAClientMsg_CameraZoomAmount = CDOTAClientMsg_CameraZoomAmount {
            zoom_amount: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_BroadcasterUsingCameraman)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_BroadcasterUsingCameraman {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_BroadcasterUsingCameraman.cameraman)
    pub cameraman: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_BroadcasterUsingCameraman.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_BroadcasterUsingCameraman {
    fn default() -> &'a CDOTAClientMsg_BroadcasterUsingCameraman {
        <CDOTAClientMsg_BroadcasterUsingCameraman as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_BroadcasterUsingCameraman {
    pub fn new() -> CDOTAClientMsg_BroadcasterUsingCameraman {
        ::std::default::Default::default()
    }

    // optional bool cameraman = 1;

    pub fn cameraman(&self) -> bool {
        self.cameraman.unwrap_or(false)
    }

    pub fn clear_cameraman(&mut self) {
        self.cameraman = ::std::option::Option::None;
    }

    pub fn has_cameraman(&self) -> bool {
        self.cameraman.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cameraman(&mut self, v: bool) {
        self.cameraman = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_BroadcasterUsingCameraman {
    const NAME: &'static str = "CDOTAClientMsg_BroadcasterUsingCameraman";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cameraman = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cameraman {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.cameraman {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_BroadcasterUsingCameraman {
        CDOTAClientMsg_BroadcasterUsingCameraman::new()
    }

    fn clear(&mut self) {
        self.cameraman = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_BroadcasterUsingCameraman {
        static instance: CDOTAClientMsg_BroadcasterUsingCameraman = CDOTAClientMsg_BroadcasterUsingCameraman {
            cameraman: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.enabled)
    pub enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
    fn default() -> &'a CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
        <CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
    pub fn new() -> CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
        ::std::default::Default::default()
    }

    // optional bool enabled = 1;

    pub fn enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
    const NAME: &'static str = "CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
        CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator::new()
    }

    fn clear(&mut self) {
        self.enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
        static instance: CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator = CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
            enabled: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_FillEmptySlotsWithBots)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_FillEmptySlotsWithBots {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_FillEmptySlotsWithBots.fillwithbots)
    pub fillwithbots: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_FillEmptySlotsWithBots.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_FillEmptySlotsWithBots {
    fn default() -> &'a CDOTAClientMsg_FillEmptySlotsWithBots {
        <CDOTAClientMsg_FillEmptySlotsWithBots as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_FillEmptySlotsWithBots {
    pub fn new() -> CDOTAClientMsg_FillEmptySlotsWithBots {
        ::std::default::Default::default()
    }

    // optional bool fillwithbots = 1;

    pub fn fillwithbots(&self) -> bool {
        self.fillwithbots.unwrap_or(false)
    }

    pub fn clear_fillwithbots(&mut self) {
        self.fillwithbots = ::std::option::Option::None;
    }

    pub fn has_fillwithbots(&self) -> bool {
        self.fillwithbots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fillwithbots(&mut self, v: bool) {
        self.fillwithbots = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_FillEmptySlotsWithBots {
    const NAME: &'static str = "CDOTAClientMsg_FillEmptySlotsWithBots";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fillwithbots = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fillwithbots {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.fillwithbots {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_FillEmptySlotsWithBots {
        CDOTAClientMsg_FillEmptySlotsWithBots::new()
    }

    fn clear(&mut self) {
        self.fillwithbots = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_FillEmptySlotsWithBots {
        static instance: CDOTAClientMsg_FillEmptySlotsWithBots = CDOTAClientMsg_FillEmptySlotsWithBots {
            fillwithbots: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_HeroStatueLike)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_HeroStatueLike {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_HeroStatueLike.owner_player_id)
    pub owner_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_HeroStatueLike.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_HeroStatueLike {
    fn default() -> &'a CDOTAClientMsg_HeroStatueLike {
        <CDOTAClientMsg_HeroStatueLike as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_HeroStatueLike {
    pub fn new() -> CDOTAClientMsg_HeroStatueLike {
        ::std::default::Default::default()
    }

    // optional int32 owner_player_id = 1;

    pub fn owner_player_id(&self) -> i32 {
        self.owner_player_id.unwrap_or(-1i32)
    }

    pub fn clear_owner_player_id(&mut self) {
        self.owner_player_id = ::std::option::Option::None;
    }

    pub fn has_owner_player_id(&self) -> bool {
        self.owner_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_player_id(&mut self, v: i32) {
        self.owner_player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_HeroStatueLike {
    const NAME: &'static str = "CDOTAClientMsg_HeroStatueLike";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.owner_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.owner_player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_HeroStatueLike {
        CDOTAClientMsg_HeroStatueLike::new()
    }

    fn clear(&mut self) {
        self.owner_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_HeroStatueLike {
        static instance: CDOTAClientMsg_HeroStatueLike = CDOTAClientMsg_HeroStatueLike {
            owner_player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_EventCNY2015Cmd)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_EventCNY2015Cmd {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_EventCNY2015Cmd.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_EventCNY2015Cmd.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_EventCNY2015Cmd {
    fn default() -> &'a CDOTAClientMsg_EventCNY2015Cmd {
        <CDOTAClientMsg_EventCNY2015Cmd as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_EventCNY2015Cmd {
    pub fn new() -> CDOTAClientMsg_EventCNY2015Cmd {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_EventCNY2015Cmd {
    const NAME: &'static str = "CDOTAClientMsg_EventCNY2015Cmd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_EventCNY2015Cmd {
        CDOTAClientMsg_EventCNY2015Cmd::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_EventCNY2015Cmd {
        static instance: CDOTAClientMsg_EventCNY2015Cmd = CDOTAClientMsg_EventCNY2015Cmd {
            data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_DemoHero)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_DemoHero {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_DemoHero.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_DemoHero.hero_id_to_spawn)
    pub hero_id_to_spawn: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_DemoHero.item_defs)
    pub item_defs: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_DemoHero.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_DemoHero.style_index)
    pub style_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_DemoHero.keep_existing_demohero)
    pub keep_existing_demohero: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_DemoHero.item_data)
    pub item_data: ::std::vec::Vec<super::base_gcmessages::CSOEconItem>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_DemoHero.hero_variant)
    pub hero_variant: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_DemoHero.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_DemoHero {
    fn default() -> &'a CDOTAClientMsg_DemoHero {
        <CDOTAClientMsg_DemoHero as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_DemoHero {
    pub fn new() -> CDOTAClientMsg_DemoHero {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 1;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id_to_spawn = 2;

    pub fn hero_id_to_spawn(&self) -> i32 {
        self.hero_id_to_spawn.unwrap_or(0)
    }

    pub fn clear_hero_id_to_spawn(&mut self) {
        self.hero_id_to_spawn = ::std::option::Option::None;
    }

    pub fn has_hero_id_to_spawn(&self) -> bool {
        self.hero_id_to_spawn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id_to_spawn(&mut self, v: i32) {
        self.hero_id_to_spawn = ::std::option::Option::Some(v);
    }

    // optional uint32 style_index = 5;

    pub fn style_index(&self) -> u32 {
        self.style_index.unwrap_or(255u32)
    }

    pub fn clear_style_index(&mut self) {
        self.style_index = ::std::option::Option::None;
    }

    pub fn has_style_index(&self) -> bool {
        self.style_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_index(&mut self, v: u32) {
        self.style_index = ::std::option::Option::Some(v);
    }

    // optional bool keep_existing_demohero = 6;

    pub fn keep_existing_demohero(&self) -> bool {
        self.keep_existing_demohero.unwrap_or(false)
    }

    pub fn clear_keep_existing_demohero(&mut self) {
        self.keep_existing_demohero = ::std::option::Option::None;
    }

    pub fn has_keep_existing_demohero(&self) -> bool {
        self.keep_existing_demohero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keep_existing_demohero(&mut self, v: bool) {
        self.keep_existing_demohero = ::std::option::Option::Some(v);
    }

    // optional int32 hero_variant = 8;

    pub fn hero_variant(&self) -> i32 {
        self.hero_variant.unwrap_or(0)
    }

    pub fn clear_hero_variant(&mut self) {
        self.hero_variant = ::std::option::Option::None;
    }

    pub fn has_hero_variant(&self) -> bool {
        self.hero_variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_variant(&mut self, v: i32) {
        self.hero_variant = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_DemoHero {
    const NAME: &'static str = "CDOTAClientMsg_DemoHero";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.hero_id_to_spawn = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.item_defs)?;
                },
                24 => {
                    self.item_defs.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                32 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                40 => {
                    self.style_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.keep_existing_demohero = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.item_data.push(is.read_message()?);
                },
                64 => {
                    self.hero_variant = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.hero_id_to_spawn {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        for value in &self.item_defs {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        for value in &self.item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, *value);
        };
        if let Some(v) = self.style_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.keep_existing_demohero {
            my_size += 1 + 1;
        }
        for value in &self.item_data {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.hero_variant {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hero_id_to_spawn {
            os.write_int32(2, v)?;
        }
        for v in &self.item_defs {
            os.write_uint32(3, *v)?;
        };
        for v in &self.item_ids {
            os.write_uint64(4, *v)?;
        };
        if let Some(v) = self.style_index {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.keep_existing_demohero {
            os.write_bool(6, v)?;
        }
        for v in &self.item_data {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.hero_variant {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_DemoHero {
        CDOTAClientMsg_DemoHero::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.hero_id_to_spawn = ::std::option::Option::None;
        self.item_defs.clear();
        self.item_ids.clear();
        self.style_index = ::std::option::Option::None;
        self.keep_existing_demohero = ::std::option::Option::None;
        self.item_data.clear();
        self.hero_variant = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_DemoHero {
        static instance: CDOTAClientMsg_DemoHero = CDOTAClientMsg_DemoHero {
            hero_id: ::std::option::Option::None,
            hero_id_to_spawn: ::std::option::Option::None,
            item_defs: ::std::vec::Vec::new(),
            item_ids: ::std::vec::Vec::new(),
            style_index: ::std::option::Option::None,
            keep_existing_demohero: ::std::option::Option::None,
            item_data: ::std::vec::Vec::new(),
            hero_variant: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_ChallengeSelect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ChallengeSelect {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_ChallengeSelect.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_ChallengeSelect.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_ChallengeSelect.sequence_id)
    pub sequence_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_ChallengeSelect.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ChallengeSelect {
    fn default() -> &'a CDOTAClientMsg_ChallengeSelect {
        <CDOTAClientMsg_ChallengeSelect as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ChallengeSelect {
    pub fn new() -> CDOTAClientMsg_ChallengeSelect {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 2;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    // optional uint32 sequence_id = 3;

    pub fn sequence_id(&self) -> u32 {
        self.sequence_id.unwrap_or(0)
    }

    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u32) {
        self.sequence_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_ChallengeSelect {
    const NAME: &'static str = "CDOTAClientMsg_ChallengeSelect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.sequence_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.slot_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ChallengeSelect {
        CDOTAClientMsg_ChallengeSelect::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.sequence_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ChallengeSelect {
        static instance: CDOTAClientMsg_ChallengeSelect = CDOTAClientMsg_ChallengeSelect {
            event_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            sequence_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_ChallengeReroll)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ChallengeReroll {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_ChallengeReroll.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_ChallengeReroll.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_ChallengeReroll.sequence_id)
    pub sequence_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_ChallengeReroll.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_ChallengeReroll.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ChallengeReroll {
    fn default() -> &'a CDOTAClientMsg_ChallengeReroll {
        <CDOTAClientMsg_ChallengeReroll as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ChallengeReroll {
    pub fn new() -> CDOTAClientMsg_ChallengeReroll {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 slot_id = 2;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    // optional uint32 sequence_id = 3;

    pub fn sequence_id(&self) -> u32 {
        self.sequence_id.unwrap_or(0)
    }

    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u32) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 4;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_ChallengeReroll {
    const NAME: &'static str = "CDOTAClientMsg_ChallengeReroll";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.sequence_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.slot_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ChallengeReroll {
        CDOTAClientMsg_ChallengeReroll::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.sequence_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ChallengeReroll {
        static instance: CDOTAClientMsg_ChallengeReroll = CDOTAClientMsg_ChallengeReroll {
            event_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            sequence_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_CoinWager)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_CoinWager {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_CoinWager.wager_amount)
    pub wager_amount: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_CoinWager.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_CoinWager {
    fn default() -> &'a CDOTAClientMsg_CoinWager {
        <CDOTAClientMsg_CoinWager as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_CoinWager {
    pub fn new() -> CDOTAClientMsg_CoinWager {
        ::std::default::Default::default()
    }

    // optional uint32 wager_amount = 1;

    pub fn wager_amount(&self) -> u32 {
        self.wager_amount.unwrap_or(0)
    }

    pub fn clear_wager_amount(&mut self) {
        self.wager_amount = ::std::option::Option::None;
    }

    pub fn has_wager_amount(&self) -> bool {
        self.wager_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wager_amount(&mut self, v: u32) {
        self.wager_amount = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_CoinWager {
    const NAME: &'static str = "CDOTAClientMsg_CoinWager";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.wager_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.wager_amount {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.wager_amount {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_CoinWager {
        CDOTAClientMsg_CoinWager::new()
    }

    fn clear(&mut self) {
        self.wager_amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_CoinWager {
        static instance: CDOTAClientMsg_CoinWager = CDOTAClientMsg_CoinWager {
            wager_amount: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_CoinWagerToken)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_CoinWagerToken {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_CoinWagerToken.wager_token_item_id)
    pub wager_token_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_CoinWagerToken.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_CoinWagerToken {
    fn default() -> &'a CDOTAClientMsg_CoinWagerToken {
        <CDOTAClientMsg_CoinWagerToken as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_CoinWagerToken {
    pub fn new() -> CDOTAClientMsg_CoinWagerToken {
        ::std::default::Default::default()
    }

    // optional uint64 wager_token_item_id = 1;

    pub fn wager_token_item_id(&self) -> u64 {
        self.wager_token_item_id.unwrap_or(0)
    }

    pub fn clear_wager_token_item_id(&mut self) {
        self.wager_token_item_id = ::std::option::Option::None;
    }

    pub fn has_wager_token_item_id(&self) -> bool {
        self.wager_token_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wager_token_item_id(&mut self, v: u64) {
        self.wager_token_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_CoinWagerToken {
    const NAME: &'static str = "CDOTAClientMsg_CoinWagerToken";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.wager_token_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.wager_token_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.wager_token_item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_CoinWagerToken {
        CDOTAClientMsg_CoinWagerToken::new()
    }

    fn clear(&mut self) {
        self.wager_token_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_CoinWagerToken {
        static instance: CDOTAClientMsg_CoinWagerToken = CDOTAClientMsg_CoinWagerToken {
            wager_token_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_RankWager)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_RankWager {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_RankWager.announce_wager)
    pub announce_wager: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_RankWager.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_RankWager {
    fn default() -> &'a CDOTAClientMsg_RankWager {
        <CDOTAClientMsg_RankWager as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_RankWager {
    pub fn new() -> CDOTAClientMsg_RankWager {
        ::std::default::Default::default()
    }

    // optional bool announce_wager = 1;

    pub fn announce_wager(&self) -> bool {
        self.announce_wager.unwrap_or(false)
    }

    pub fn clear_announce_wager(&mut self) {
        self.announce_wager = ::std::option::Option::None;
    }

    pub fn has_announce_wager(&self) -> bool {
        self.announce_wager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announce_wager(&mut self, v: bool) {
        self.announce_wager = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_RankWager {
    const NAME: &'static str = "CDOTAClientMsg_RankWager";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.announce_wager = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.announce_wager {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.announce_wager {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_RankWager {
        CDOTAClientMsg_RankWager::new()
    }

    fn clear(&mut self) {
        self.announce_wager = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_RankWager {
        static instance: CDOTAClientMsg_RankWager = CDOTAClientMsg_RankWager {
            announce_wager: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_PlayerBounty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_PlayerBounty {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_PlayerBounty.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_PlayerBounty.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_PlayerBounty {
    fn default() -> &'a CDOTAClientMsg_PlayerBounty {
        <CDOTAClientMsg_PlayerBounty as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_PlayerBounty {
    pub fn new() -> CDOTAClientMsg_PlayerBounty {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_PlayerBounty {
    const NAME: &'static str = "CDOTAClientMsg_PlayerBounty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_PlayerBounty {
        CDOTAClientMsg_PlayerBounty::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_PlayerBounty {
        static instance: CDOTAClientMsg_PlayerBounty = CDOTAClientMsg_PlayerBounty {
            player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_EventPointsTip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_EventPointsTip {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_EventPointsTip.recipient_player_id)
    pub recipient_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_EventPointsTip.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_EventPointsTip {
    fn default() -> &'a CDOTAClientMsg_EventPointsTip {
        <CDOTAClientMsg_EventPointsTip as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_EventPointsTip {
    pub fn new() -> CDOTAClientMsg_EventPointsTip {
        ::std::default::Default::default()
    }

    // optional int32 recipient_player_id = 1;

    pub fn recipient_player_id(&self) -> i32 {
        self.recipient_player_id.unwrap_or(-1i32)
    }

    pub fn clear_recipient_player_id(&mut self) {
        self.recipient_player_id = ::std::option::Option::None;
    }

    pub fn has_recipient_player_id(&self) -> bool {
        self.recipient_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_player_id(&mut self, v: i32) {
        self.recipient_player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_EventPointsTip {
    const NAME: &'static str = "CDOTAClientMsg_EventPointsTip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.recipient_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.recipient_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.recipient_player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_EventPointsTip {
        CDOTAClientMsg_EventPointsTip::new()
    }

    fn clear(&mut self) {
        self.recipient_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_EventPointsTip {
        static instance: CDOTAClientMsg_EventPointsTip = CDOTAClientMsg_EventPointsTip {
            recipient_player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_ExecuteOrders)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ExecuteOrders {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_ExecuteOrders.orders)
    pub orders: ::std::vec::Vec<super::dota_commonmessages::CDOTAMsg_UnitOrder>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_ExecuteOrders.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ExecuteOrders {
    fn default() -> &'a CDOTAClientMsg_ExecuteOrders {
        <CDOTAClientMsg_ExecuteOrders as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ExecuteOrders {
    pub fn new() -> CDOTAClientMsg_ExecuteOrders {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_ExecuteOrders {
    const NAME: &'static str = "CDOTAClientMsg_ExecuteOrders";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.orders.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.orders {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ExecuteOrders {
        CDOTAClientMsg_ExecuteOrders::new()
    }

    fn clear(&mut self) {
        self.orders.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ExecuteOrders {
        static instance: CDOTAClientMsg_ExecuteOrders = CDOTAClientMsg_ExecuteOrders {
            orders: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_XPAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_XPAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_XPAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_XPAlert.damage_taken)
    pub damage_taken: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_XPAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_XPAlert {
    fn default() -> &'a CDOTAClientMsg_XPAlert {
        <CDOTAClientMsg_XPAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_XPAlert {
    pub fn new() -> CDOTAClientMsg_XPAlert {
        ::std::default::Default::default()
    }

    // optional int32 target_entindex = 1;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_taken = 2;

    pub fn damage_taken(&self) -> u32 {
        self.damage_taken.unwrap_or(0)
    }

    pub fn clear_damage_taken(&mut self) {
        self.damage_taken = ::std::option::Option::None;
    }

    pub fn has_damage_taken(&self) -> bool {
        self.damage_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_taken(&mut self, v: u32) {
        self.damage_taken = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_XPAlert {
    const NAME: &'static str = "CDOTAClientMsg_XPAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.damage_taken = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.damage_taken {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.damage_taken {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_XPAlert {
        CDOTAClientMsg_XPAlert::new()
    }

    fn clear(&mut self) {
        self.target_entindex = ::std::option::Option::None;
        self.damage_taken = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_XPAlert {
        static instance: CDOTAClientMsg_XPAlert = CDOTAClientMsg_XPAlert {
            target_entindex: ::std::option::Option::None,
            damage_taken: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_TalentTreeAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_TalentTreeAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_TalentTreeAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_TalentTreeAlert.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_TalentTreeAlert.slot)
    pub slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_TalentTreeAlert.learned)
    pub learned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_TalentTreeAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_TalentTreeAlert {
    fn default() -> &'a CDOTAClientMsg_TalentTreeAlert {
        <CDOTAClientMsg_TalentTreeAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_TalentTreeAlert {
    pub fn new() -> CDOTAClientMsg_TalentTreeAlert {
        ::std::default::Default::default()
    }

    // optional int32 target_entindex = 1;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 ability_id = 2;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(-1i32)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional int32 slot = 3;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }

    // optional bool learned = 4;

    pub fn learned(&self) -> bool {
        self.learned.unwrap_or(false)
    }

    pub fn clear_learned(&mut self) {
        self.learned = ::std::option::Option::None;
    }

    pub fn has_learned(&self) -> bool {
        self.learned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_learned(&mut self, v: bool) {
        self.learned = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_TalentTreeAlert {
    const NAME: &'static str = "CDOTAClientMsg_TalentTreeAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.learned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.learned {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.slot {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.learned {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_TalentTreeAlert {
        CDOTAClientMsg_TalentTreeAlert::new()
    }

    fn clear(&mut self) {
        self.target_entindex = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.slot = ::std::option::Option::None;
        self.learned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_TalentTreeAlert {
        static instance: CDOTAClientMsg_TalentTreeAlert = CDOTAClientMsg_TalentTreeAlert {
            target_entindex: ::std::option::Option::None,
            ability_id: ::std::option::Option::None,
            slot: ::std::option::Option::None,
            learned: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_KillcamDamageTaken)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_KillcamDamageTaken {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_KillcamDamageTaken.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_KillcamDamageTaken.damage_taken)
    pub damage_taken: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_KillcamDamageTaken.item_type)
    pub item_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_KillcamDamageTaken.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_KillcamDamageTaken.hero_name)
    pub hero_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_KillcamDamageTaken.damage_color)
    pub damage_color: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_KillcamDamageTaken.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_KillcamDamageTaken {
    fn default() -> &'a CDOTAClientMsg_KillcamDamageTaken {
        <CDOTAClientMsg_KillcamDamageTaken as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_KillcamDamageTaken {
    pub fn new() -> CDOTAClientMsg_KillcamDamageTaken {
        ::std::default::Default::default()
    }

    // optional int32 target_entindex = 1;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_taken = 2;

    pub fn damage_taken(&self) -> u32 {
        self.damage_taken.unwrap_or(0)
    }

    pub fn clear_damage_taken(&mut self) {
        self.damage_taken = ::std::option::Option::None;
    }

    pub fn has_damage_taken(&self) -> bool {
        self.damage_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_taken(&mut self, v: u32) {
        self.damage_taken = ::std::option::Option::Some(v);
    }

    // optional uint32 item_type = 3;

    pub fn item_type(&self) -> u32 {
        self.item_type.unwrap_or(0)
    }

    pub fn clear_item_type(&mut self) {
        self.item_type = ::std::option::Option::None;
    }

    pub fn has_item_type(&self) -> bool {
        self.item_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_type(&mut self, v: u32) {
        self.item_type = ::std::option::Option::Some(v);
    }

    // optional int32 item_ability_id = 4;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(-1i32)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }

    // optional string hero_name = 5;

    pub fn hero_name(&self) -> &str {
        match self.hero_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hero_name(&mut self) {
        self.hero_name = ::std::option::Option::None;
    }

    pub fn has_hero_name(&self) -> bool {
        self.hero_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_name(&mut self, v: ::std::string::String) {
        self.hero_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hero_name(&mut self) -> &mut ::std::string::String {
        if self.hero_name.is_none() {
            self.hero_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hero_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_hero_name(&mut self) -> ::std::string::String {
        self.hero_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string damage_color = 6;

    pub fn damage_color(&self) -> &str {
        match self.damage_color.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_damage_color(&mut self) {
        self.damage_color = ::std::option::Option::None;
    }

    pub fn has_damage_color(&self) -> bool {
        self.damage_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_color(&mut self, v: ::std::string::String) {
        self.damage_color = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_damage_color(&mut self) -> &mut ::std::string::String {
        if self.damage_color.is_none() {
            self.damage_color = ::std::option::Option::Some(::std::string::String::new());
        }
        self.damage_color.as_mut().unwrap()
    }

    // Take field
    pub fn take_damage_color(&mut self) -> ::std::string::String {
        self.damage_color.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_KillcamDamageTaken {
    const NAME: &'static str = "CDOTAClientMsg_KillcamDamageTaken";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.damage_taken = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.hero_name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.damage_color = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.damage_taken {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.item_ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.hero_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.damage_color.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.damage_taken {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.item_ability_id {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.hero_name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.damage_color.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_KillcamDamageTaken {
        CDOTAClientMsg_KillcamDamageTaken::new()
    }

    fn clear(&mut self) {
        self.target_entindex = ::std::option::Option::None;
        self.damage_taken = ::std::option::Option::None;
        self.item_type = ::std::option::Option::None;
        self.item_ability_id = ::std::option::Option::None;
        self.hero_name = ::std::option::Option::None;
        self.damage_color = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_KillcamDamageTaken {
        static instance: CDOTAClientMsg_KillcamDamageTaken = CDOTAClientMsg_KillcamDamageTaken {
            target_entindex: ::std::option::Option::None,
            damage_taken: ::std::option::Option::None,
            item_type: ::std::option::Option::None,
            item_ability_id: ::std::option::Option::None,
            hero_name: ::std::option::Option::None,
            damage_color: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_KillMyHero)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_KillMyHero {
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_KillMyHero.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_KillMyHero {
    fn default() -> &'a CDOTAClientMsg_KillMyHero {
        <CDOTAClientMsg_KillMyHero as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_KillMyHero {
    pub fn new() -> CDOTAClientMsg_KillMyHero {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_KillMyHero {
    const NAME: &'static str = "CDOTAClientMsg_KillMyHero";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_KillMyHero {
        CDOTAClientMsg_KillMyHero::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_KillMyHero {
        static instance: CDOTAClientMsg_KillMyHero = CDOTAClientMsg_KillMyHero {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_QuestStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_QuestStatus {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_QuestStatus.quest_id)
    pub quest_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_QuestStatus.challenge_id)
    pub challenge_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_QuestStatus.progress)
    pub progress: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_QuestStatus.goal)
    pub goal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_QuestStatus.query)
    pub query: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_QuestStatus.fail_gametime)
    pub fail_gametime: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_QuestStatus.item_ability_id)
    pub item_ability_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_QuestStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_QuestStatus {
    fn default() -> &'a CDOTAClientMsg_QuestStatus {
        <CDOTAClientMsg_QuestStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_QuestStatus {
    pub fn new() -> CDOTAClientMsg_QuestStatus {
        ::std::default::Default::default()
    }

    // optional uint32 quest_id = 1;

    pub fn quest_id(&self) -> u32 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u32) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_id = 2;

    pub fn challenge_id(&self) -> u32 {
        self.challenge_id.unwrap_or(0)
    }

    pub fn clear_challenge_id(&mut self) {
        self.challenge_id = ::std::option::Option::None;
    }

    pub fn has_challenge_id(&self) -> bool {
        self.challenge_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_id(&mut self, v: u32) {
        self.challenge_id = ::std::option::Option::Some(v);
    }

    // optional uint32 progress = 3;

    pub fn progress(&self) -> u32 {
        self.progress.unwrap_or(0)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: u32) {
        self.progress = ::std::option::Option::Some(v);
    }

    // optional uint32 goal = 4;

    pub fn goal(&self) -> u32 {
        self.goal.unwrap_or(0)
    }

    pub fn clear_goal(&mut self) {
        self.goal = ::std::option::Option::None;
    }

    pub fn has_goal(&self) -> bool {
        self.goal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_goal(&mut self, v: u32) {
        self.goal = ::std::option::Option::Some(v);
    }

    // optional uint32 query = 5;

    pub fn query(&self) -> u32 {
        self.query.unwrap_or(0)
    }

    pub fn clear_query(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: u32) {
        self.query = ::std::option::Option::Some(v);
    }

    // optional float fail_gametime = 6;

    pub fn fail_gametime(&self) -> f32 {
        self.fail_gametime.unwrap_or(0.)
    }

    pub fn clear_fail_gametime(&mut self) {
        self.fail_gametime = ::std::option::Option::None;
    }

    pub fn has_fail_gametime(&self) -> bool {
        self.fail_gametime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fail_gametime(&mut self, v: f32) {
        self.fail_gametime = ::std::option::Option::Some(v);
    }

    // optional int32 item_ability_id = 7;

    pub fn item_ability_id(&self) -> i32 {
        self.item_ability_id.unwrap_or(-1i32)
    }

    pub fn clear_item_ability_id(&mut self) {
        self.item_ability_id = ::std::option::Option::None;
    }

    pub fn has_item_ability_id(&self) -> bool {
        self.item_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_ability_id(&mut self, v: i32) {
        self.item_ability_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_QuestStatus {
    const NAME: &'static str = "CDOTAClientMsg_QuestStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.challenge_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.progress = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.goal = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.query = ::std::option::Option::Some(is.read_uint32()?);
                },
                53 => {
                    self.fail_gametime = ::std::option::Option::Some(is.read_float()?);
                },
                56 => {
                    self.item_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.challenge_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.progress {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.goal {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.query {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.fail_gametime {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.challenge_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.progress {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.goal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.query {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.fail_gametime {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.item_ability_id {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_QuestStatus {
        CDOTAClientMsg_QuestStatus::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.challenge_id = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.goal = ::std::option::Option::None;
        self.query = ::std::option::Option::None;
        self.fail_gametime = ::std::option::Option::None;
        self.item_ability_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_QuestStatus {
        static instance: CDOTAClientMsg_QuestStatus = CDOTAClientMsg_QuestStatus {
            quest_id: ::std::option::Option::None,
            challenge_id: ::std::option::Option::None,
            progress: ::std::option::Option::None,
            goal: ::std::option::Option::None,
            query: ::std::option::Option::None,
            fail_gametime: ::std::option::Option::None,
            item_ability_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_ToggleAutoattack)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ToggleAutoattack {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_ToggleAutoattack.mode)
    pub mode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_ToggleAutoattack.show_message)
    pub show_message: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_ToggleAutoattack.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ToggleAutoattack {
    fn default() -> &'a CDOTAClientMsg_ToggleAutoattack {
        <CDOTAClientMsg_ToggleAutoattack as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ToggleAutoattack {
    pub fn new() -> CDOTAClientMsg_ToggleAutoattack {
        ::std::default::Default::default()
    }

    // optional int32 mode = 1;

    pub fn mode(&self) -> i32 {
        self.mode.unwrap_or(0)
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: i32) {
        self.mode = ::std::option::Option::Some(v);
    }

    // optional bool show_message = 2;

    pub fn show_message(&self) -> bool {
        self.show_message.unwrap_or(false)
    }

    pub fn clear_show_message(&mut self) {
        self.show_message = ::std::option::Option::None;
    }

    pub fn has_show_message(&self) -> bool {
        self.show_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_message(&mut self, v: bool) {
        self.show_message = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_ToggleAutoattack {
    const NAME: &'static str = "CDOTAClientMsg_ToggleAutoattack";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.show_message = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.show_message {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.mode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.show_message {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ToggleAutoattack {
        CDOTAClientMsg_ToggleAutoattack::new()
    }

    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.show_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ToggleAutoattack {
        static instance: CDOTAClientMsg_ToggleAutoattack = CDOTAClientMsg_ToggleAutoattack {
            mode: ::std::option::Option::None,
            show_message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_SpecialAbility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SpecialAbility {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_SpecialAbility.ability_index)
    pub ability_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_SpecialAbility.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_SpecialAbility.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SpecialAbility {
    fn default() -> &'a CDOTAClientMsg_SpecialAbility {
        <CDOTAClientMsg_SpecialAbility as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SpecialAbility {
    pub fn new() -> CDOTAClientMsg_SpecialAbility {
        ::std::default::Default::default()
    }

    // optional uint32 ability_index = 1;

    pub fn ability_index(&self) -> u32 {
        self.ability_index.unwrap_or(0)
    }

    pub fn clear_ability_index(&mut self) {
        self.ability_index = ::std::option::Option::None;
    }

    pub fn has_ability_index(&self) -> bool {
        self.ability_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_index(&mut self, v: u32) {
        self.ability_index = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 2;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_SpecialAbility {
    const NAME: &'static str = "CDOTAClientMsg_SpecialAbility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ability_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SpecialAbility {
        CDOTAClientMsg_SpecialAbility::new()
    }

    fn clear(&mut self) {
        self.ability_index = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SpecialAbility {
        static instance: CDOTAClientMsg_SpecialAbility = CDOTAClientMsg_SpecialAbility {
            ability_index: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_SetEnemyStartingPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SetEnemyStartingPosition {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_SetEnemyStartingPosition.enemy_player_id)
    pub enemy_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_SetEnemyStartingPosition.enemy_starting_position)
    pub enemy_starting_position: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_SetEnemyStartingPosition.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SetEnemyStartingPosition {
    fn default() -> &'a CDOTAClientMsg_SetEnemyStartingPosition {
        <CDOTAClientMsg_SetEnemyStartingPosition as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SetEnemyStartingPosition {
    pub fn new() -> CDOTAClientMsg_SetEnemyStartingPosition {
        ::std::default::Default::default()
    }

    // optional int32 enemy_player_id = 1;

    pub fn enemy_player_id(&self) -> i32 {
        self.enemy_player_id.unwrap_or(-1i32)
    }

    pub fn clear_enemy_player_id(&mut self) {
        self.enemy_player_id = ::std::option::Option::None;
    }

    pub fn has_enemy_player_id(&self) -> bool {
        self.enemy_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_player_id(&mut self, v: i32) {
        self.enemy_player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_starting_position = 2;

    pub fn enemy_starting_position(&self) -> u32 {
        self.enemy_starting_position.unwrap_or(0)
    }

    pub fn clear_enemy_starting_position(&mut self) {
        self.enemy_starting_position = ::std::option::Option::None;
    }

    pub fn has_enemy_starting_position(&self) -> bool {
        self.enemy_starting_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_starting_position(&mut self, v: u32) {
        self.enemy_starting_position = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_SetEnemyStartingPosition {
    const NAME: &'static str = "CDOTAClientMsg_SetEnemyStartingPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enemy_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.enemy_starting_position = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enemy_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.enemy_starting_position {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.enemy_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.enemy_starting_position {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SetEnemyStartingPosition {
        CDOTAClientMsg_SetEnemyStartingPosition::new()
    }

    fn clear(&mut self) {
        self.enemy_player_id = ::std::option::Option::None;
        self.enemy_starting_position = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SetEnemyStartingPosition {
        static instance: CDOTAClientMsg_SetEnemyStartingPosition = CDOTAClientMsg_SetEnemyStartingPosition {
            enemy_player_id: ::std::option::Option::None,
            enemy_starting_position: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_SetDesiredWardPlacement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SetDesiredWardPlacement {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_SetDesiredWardPlacement.ward_index)
    pub ward_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_SetDesiredWardPlacement.ward_x)
    pub ward_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_SetDesiredWardPlacement.ward_y)
    pub ward_y: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_SetDesiredWardPlacement.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SetDesiredWardPlacement {
    fn default() -> &'a CDOTAClientMsg_SetDesiredWardPlacement {
        <CDOTAClientMsg_SetDesiredWardPlacement as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SetDesiredWardPlacement {
    pub fn new() -> CDOTAClientMsg_SetDesiredWardPlacement {
        ::std::default::Default::default()
    }

    // optional uint32 ward_index = 1;

    pub fn ward_index(&self) -> u32 {
        self.ward_index.unwrap_or(0)
    }

    pub fn clear_ward_index(&mut self) {
        self.ward_index = ::std::option::Option::None;
    }

    pub fn has_ward_index(&self) -> bool {
        self.ward_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ward_index(&mut self, v: u32) {
        self.ward_index = ::std::option::Option::Some(v);
    }

    // optional float ward_x = 2;

    pub fn ward_x(&self) -> f32 {
        self.ward_x.unwrap_or(0.)
    }

    pub fn clear_ward_x(&mut self) {
        self.ward_x = ::std::option::Option::None;
    }

    pub fn has_ward_x(&self) -> bool {
        self.ward_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ward_x(&mut self, v: f32) {
        self.ward_x = ::std::option::Option::Some(v);
    }

    // optional float ward_y = 3;

    pub fn ward_y(&self) -> f32 {
        self.ward_y.unwrap_or(0.)
    }

    pub fn clear_ward_y(&mut self) {
        self.ward_y = ::std::option::Option::None;
    }

    pub fn has_ward_y(&self) -> bool {
        self.ward_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ward_y(&mut self, v: f32) {
        self.ward_y = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_SetDesiredWardPlacement {
    const NAME: &'static str = "CDOTAClientMsg_SetDesiredWardPlacement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ward_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.ward_x = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.ward_y = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ward_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.ward_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ward_y {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ward_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ward_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.ward_y {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SetDesiredWardPlacement {
        CDOTAClientMsg_SetDesiredWardPlacement::new()
    }

    fn clear(&mut self) {
        self.ward_index = ::std::option::Option::None;
        self.ward_x = ::std::option::Option::None;
        self.ward_y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SetDesiredWardPlacement {
        static instance: CDOTAClientMsg_SetDesiredWardPlacement = CDOTAClientMsg_SetDesiredWardPlacement {
            ward_index: ::std::option::Option::None,
            ward_x: ::std::option::Option::None,
            ward_y: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_RollDice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_RollDice {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_RollDice.channel_type)
    pub channel_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_RollDice.roll_min)
    pub roll_min: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_RollDice.roll_max)
    pub roll_max: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_RollDice.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_RollDice {
    fn default() -> &'a CDOTAClientMsg_RollDice {
        <CDOTAClientMsg_RollDice as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_RollDice {
    pub fn new() -> CDOTAClientMsg_RollDice {
        ::std::default::Default::default()
    }

    // optional uint32 channel_type = 1;

    pub fn channel_type(&self) -> u32 {
        self.channel_type.unwrap_or(0)
    }

    pub fn clear_channel_type(&mut self) {
        self.channel_type = ::std::option::Option::None;
    }

    pub fn has_channel_type(&self) -> bool {
        self.channel_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_type(&mut self, v: u32) {
        self.channel_type = ::std::option::Option::Some(v);
    }

    // optional uint32 roll_min = 2;

    pub fn roll_min(&self) -> u32 {
        self.roll_min.unwrap_or(0)
    }

    pub fn clear_roll_min(&mut self) {
        self.roll_min = ::std::option::Option::None;
    }

    pub fn has_roll_min(&self) -> bool {
        self.roll_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roll_min(&mut self, v: u32) {
        self.roll_min = ::std::option::Option::Some(v);
    }

    // optional uint32 roll_max = 3;

    pub fn roll_max(&self) -> u32 {
        self.roll_max.unwrap_or(0)
    }

    pub fn clear_roll_max(&mut self) {
        self.roll_max = ::std::option::Option::None;
    }

    pub fn has_roll_max(&self) -> bool {
        self.roll_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roll_max(&mut self, v: u32) {
        self.roll_max = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_RollDice {
    const NAME: &'static str = "CDOTAClientMsg_RollDice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.roll_min = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.roll_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.roll_min {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.roll_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.channel_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.roll_min {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.roll_max {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_RollDice {
        CDOTAClientMsg_RollDice::new()
    }

    fn clear(&mut self) {
        self.channel_type = ::std::option::Option::None;
        self.roll_min = ::std::option::Option::None;
        self.roll_max = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_RollDice {
        static instance: CDOTAClientMsg_RollDice = CDOTAClientMsg_RollDice {
            channel_type: ::std::option::Option::None,
            roll_min: ::std::option::Option::None,
            roll_max: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_FlipCoin)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_FlipCoin {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_FlipCoin.channel_type)
    pub channel_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_FlipCoin.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_FlipCoin {
    fn default() -> &'a CDOTAClientMsg_FlipCoin {
        <CDOTAClientMsg_FlipCoin as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_FlipCoin {
    pub fn new() -> CDOTAClientMsg_FlipCoin {
        ::std::default::Default::default()
    }

    // optional uint32 channel_type = 1;

    pub fn channel_type(&self) -> u32 {
        self.channel_type.unwrap_or(0)
    }

    pub fn clear_channel_type(&mut self) {
        self.channel_type = ::std::option::Option::None;
    }

    pub fn has_channel_type(&self) -> bool {
        self.channel_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_type(&mut self, v: u32) {
        self.channel_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_FlipCoin {
    const NAME: &'static str = "CDOTAClientMsg_FlipCoin";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.channel_type {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_FlipCoin {
        CDOTAClientMsg_FlipCoin::new()
    }

    fn clear(&mut self) {
        self.channel_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_FlipCoin {
        static instance: CDOTAClientMsg_FlipCoin = CDOTAClientMsg_FlipCoin {
            channel_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_RequestItemSuggestions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_RequestItemSuggestions {
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_RequestItemSuggestions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_RequestItemSuggestions {
    fn default() -> &'a CDOTAClientMsg_RequestItemSuggestions {
        <CDOTAClientMsg_RequestItemSuggestions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_RequestItemSuggestions {
    pub fn new() -> CDOTAClientMsg_RequestItemSuggestions {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_RequestItemSuggestions {
    const NAME: &'static str = "CDOTAClientMsg_RequestItemSuggestions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_RequestItemSuggestions {
        CDOTAClientMsg_RequestItemSuggestions::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_RequestItemSuggestions {
        static instance: CDOTAClientMsg_RequestItemSuggestions = CDOTAClientMsg_RequestItemSuggestions {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_MakeTeamCaptain)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_MakeTeamCaptain {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_MakeTeamCaptain.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_MakeTeamCaptain.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_MakeTeamCaptain {
    fn default() -> &'a CDOTAClientMsg_MakeTeamCaptain {
        <CDOTAClientMsg_MakeTeamCaptain as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_MakeTeamCaptain {
    pub fn new() -> CDOTAClientMsg_MakeTeamCaptain {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_MakeTeamCaptain {
    const NAME: &'static str = "CDOTAClientMsg_MakeTeamCaptain";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_MakeTeamCaptain {
        CDOTAClientMsg_MakeTeamCaptain::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_MakeTeamCaptain {
        static instance: CDOTAClientMsg_MakeTeamCaptain = CDOTAClientMsg_MakeTeamCaptain {
            player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_HelpTipSystemStateChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_HelpTipSystemStateChanged {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_HelpTipSystemStateChanged.tip_displayed)
    pub tip_displayed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_HelpTipSystemStateChanged.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_HelpTipSystemStateChanged {
    fn default() -> &'a CDOTAClientMsg_HelpTipSystemStateChanged {
        <CDOTAClientMsg_HelpTipSystemStateChanged as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_HelpTipSystemStateChanged {
    pub fn new() -> CDOTAClientMsg_HelpTipSystemStateChanged {
        ::std::default::Default::default()
    }

    // optional bool tip_displayed = 1;

    pub fn tip_displayed(&self) -> bool {
        self.tip_displayed.unwrap_or(false)
    }

    pub fn clear_tip_displayed(&mut self) {
        self.tip_displayed = ::std::option::Option::None;
    }

    pub fn has_tip_displayed(&self) -> bool {
        self.tip_displayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_displayed(&mut self, v: bool) {
        self.tip_displayed = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_HelpTipSystemStateChanged {
    const NAME: &'static str = "CDOTAClientMsg_HelpTipSystemStateChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tip_displayed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tip_displayed {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tip_displayed {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_HelpTipSystemStateChanged {
        CDOTAClientMsg_HelpTipSystemStateChanged::new()
    }

    fn clear(&mut self) {
        self.tip_displayed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_HelpTipSystemStateChanged {
        static instance: CDOTAClientMsg_HelpTipSystemStateChanged = CDOTAClientMsg_HelpTipSystemStateChanged {
            tip_displayed: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_RequestBulkCombatLog)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_RequestBulkCombatLog {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_RequestBulkCombatLog.game_time)
    pub game_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_RequestBulkCombatLog.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_RequestBulkCombatLog.recent_player_death)
    pub recent_player_death: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_RequestBulkCombatLog.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_RequestBulkCombatLog.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_RequestBulkCombatLog {
    fn default() -> &'a CDOTAClientMsg_RequestBulkCombatLog {
        <CDOTAClientMsg_RequestBulkCombatLog as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_RequestBulkCombatLog {
    pub fn new() -> CDOTAClientMsg_RequestBulkCombatLog {
        ::std::default::Default::default()
    }

    // optional float game_time = 1;

    pub fn game_time(&self) -> f32 {
        self.game_time.unwrap_or(0.)
    }

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: f32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool recent_player_death = 3;

    pub fn recent_player_death(&self) -> bool {
        self.recent_player_death.unwrap_or(false)
    }

    pub fn clear_recent_player_death(&mut self) {
        self.recent_player_death = ::std::option::Option::None;
    }

    pub fn has_recent_player_death(&self) -> bool {
        self.recent_player_death.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_player_death(&mut self, v: bool) {
        self.recent_player_death = ::std::option::Option::Some(v);
    }

    // optional int32 player_id = 4;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_RequestBulkCombatLog {
    const NAME: &'static str = "CDOTAClientMsg_RequestBulkCombatLog";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.game_time = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.recent_player_death = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.recent_player_death {
            my_size += 1 + 1;
        }
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_time {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.recent_player_death {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_RequestBulkCombatLog {
        CDOTAClientMsg_RequestBulkCombatLog::new()
    }

    fn clear(&mut self) {
        self.game_time = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.recent_player_death = ::std::option::Option::None;
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_RequestBulkCombatLog {
        static instance: CDOTAClientMsg_RequestBulkCombatLog = CDOTAClientMsg_RequestBulkCombatLog {
            game_time: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            recent_player_death: ::std::option::Option::None,
            player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_AbilityDraftRequestAbility)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_AbilityDraftRequestAbility {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_AbilityDraftRequestAbility.requested_ability_id)
    pub requested_ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_AbilityDraftRequestAbility.ctrl_is_down)
    pub ctrl_is_down: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_AbilityDraftRequestAbility.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_AbilityDraftRequestAbility {
    fn default() -> &'a CDOTAClientMsg_AbilityDraftRequestAbility {
        <CDOTAClientMsg_AbilityDraftRequestAbility as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_AbilityDraftRequestAbility {
    pub fn new() -> CDOTAClientMsg_AbilityDraftRequestAbility {
        ::std::default::Default::default()
    }

    // optional int32 requested_ability_id = 1;

    pub fn requested_ability_id(&self) -> i32 {
        self.requested_ability_id.unwrap_or(-1i32)
    }

    pub fn clear_requested_ability_id(&mut self) {
        self.requested_ability_id = ::std::option::Option::None;
    }

    pub fn has_requested_ability_id(&self) -> bool {
        self.requested_ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requested_ability_id(&mut self, v: i32) {
        self.requested_ability_id = ::std::option::Option::Some(v);
    }

    // optional bool ctrl_is_down = 2;

    pub fn ctrl_is_down(&self) -> bool {
        self.ctrl_is_down.unwrap_or(false)
    }

    pub fn clear_ctrl_is_down(&mut self) {
        self.ctrl_is_down = ::std::option::Option::None;
    }

    pub fn has_ctrl_is_down(&self) -> bool {
        self.ctrl_is_down.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctrl_is_down(&mut self, v: bool) {
        self.ctrl_is_down = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_AbilityDraftRequestAbility {
    const NAME: &'static str = "CDOTAClientMsg_AbilityDraftRequestAbility";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.requested_ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.ctrl_is_down = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.requested_ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.ctrl_is_down {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.requested_ability_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ctrl_is_down {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_AbilityDraftRequestAbility {
        CDOTAClientMsg_AbilityDraftRequestAbility::new()
    }

    fn clear(&mut self) {
        self.requested_ability_id = ::std::option::Option::None;
        self.ctrl_is_down = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_AbilityDraftRequestAbility {
        static instance: CDOTAClientMsg_AbilityDraftRequestAbility = CDOTAClientMsg_AbilityDraftRequestAbility {
            requested_ability_id: ::std::option::Option::None,
            ctrl_is_down: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_GuideSelectOption)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_GuideSelectOption {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_GuideSelectOption.option)
    pub option: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_GuideSelectOption.force_recalculate)
    pub force_recalculate: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_GuideSelectOption.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_GuideSelectOption {
    fn default() -> &'a CDOTAClientMsg_GuideSelectOption {
        <CDOTAClientMsg_GuideSelectOption as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_GuideSelectOption {
    pub fn new() -> CDOTAClientMsg_GuideSelectOption {
        ::std::default::Default::default()
    }

    // optional uint32 option = 1;

    pub fn option(&self) -> u32 {
        self.option.unwrap_or(0)
    }

    pub fn clear_option(&mut self) {
        self.option = ::std::option::Option::None;
    }

    pub fn has_option(&self) -> bool {
        self.option.is_some()
    }

    // Param is passed by value, moved
    pub fn set_option(&mut self, v: u32) {
        self.option = ::std::option::Option::Some(v);
    }

    // optional bool force_recalculate = 2;

    pub fn force_recalculate(&self) -> bool {
        self.force_recalculate.unwrap_or(false)
    }

    pub fn clear_force_recalculate(&mut self) {
        self.force_recalculate = ::std::option::Option::None;
    }

    pub fn has_force_recalculate(&self) -> bool {
        self.force_recalculate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_recalculate(&mut self, v: bool) {
        self.force_recalculate = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_GuideSelectOption {
    const NAME: &'static str = "CDOTAClientMsg_GuideSelectOption";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.option = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.force_recalculate = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.option {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.force_recalculate {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.option {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.force_recalculate {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_GuideSelectOption {
        CDOTAClientMsg_GuideSelectOption::new()
    }

    fn clear(&mut self) {
        self.option = ::std::option::Option::None;
        self.force_recalculate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_GuideSelectOption {
        static instance: CDOTAClientMsg_GuideSelectOption = CDOTAClientMsg_GuideSelectOption {
            option: ::std::option::Option::None,
            force_recalculate: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_GuideSelected)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_GuideSelected {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_GuideSelected.guide_workshop_id)
    pub guide_workshop_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_GuideSelected.is_plus_guide)
    pub is_plus_guide: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_GuideSelected.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_GuideSelected {
    fn default() -> &'a CDOTAClientMsg_GuideSelected {
        <CDOTAClientMsg_GuideSelected as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_GuideSelected {
    pub fn new() -> CDOTAClientMsg_GuideSelected {
        ::std::default::Default::default()
    }

    // optional uint64 guide_workshop_id = 1;

    pub fn guide_workshop_id(&self) -> u64 {
        self.guide_workshop_id.unwrap_or(0)
    }

    pub fn clear_guide_workshop_id(&mut self) {
        self.guide_workshop_id = ::std::option::Option::None;
    }

    pub fn has_guide_workshop_id(&self) -> bool {
        self.guide_workshop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guide_workshop_id(&mut self, v: u64) {
        self.guide_workshop_id = ::std::option::Option::Some(v);
    }

    // optional bool is_plus_guide = 2;

    pub fn is_plus_guide(&self) -> bool {
        self.is_plus_guide.unwrap_or(false)
    }

    pub fn clear_is_plus_guide(&mut self) {
        self.is_plus_guide = ::std::option::Option::None;
    }

    pub fn has_is_plus_guide(&self) -> bool {
        self.is_plus_guide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_plus_guide(&mut self, v: bool) {
        self.is_plus_guide = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_GuideSelected {
    const NAME: &'static str = "CDOTAClientMsg_GuideSelected";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guide_workshop_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.is_plus_guide = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guide_workshop_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.is_plus_guide {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guide_workshop_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.is_plus_guide {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_GuideSelected {
        CDOTAClientMsg_GuideSelected::new()
    }

    fn clear(&mut self) {
        self.guide_workshop_id = ::std::option::Option::None;
        self.is_plus_guide = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_GuideSelected {
        static instance: CDOTAClientMsg_GuideSelected = CDOTAClientMsg_GuideSelected {
            guide_workshop_id: ::std::option::Option::None,
            is_plus_guide: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_DamageReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_DamageReport {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_DamageReport.target_hero_id)
    pub target_hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_DamageReport.source_hero_id)
    pub source_hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_DamageReport.damage_amount)
    pub damage_amount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_DamageReport.broadcast)
    pub broadcast: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_DamageReport.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_DamageReport {
    fn default() -> &'a CDOTAClientMsg_DamageReport {
        <CDOTAClientMsg_DamageReport as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_DamageReport {
    pub fn new() -> CDOTAClientMsg_DamageReport {
        ::std::default::Default::default()
    }

    // optional int32 target_hero_id = 1;

    pub fn target_hero_id(&self) -> i32 {
        self.target_hero_id.unwrap_or(0)
    }

    pub fn clear_target_hero_id(&mut self) {
        self.target_hero_id = ::std::option::Option::None;
    }

    pub fn has_target_hero_id(&self) -> bool {
        self.target_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_hero_id(&mut self, v: i32) {
        self.target_hero_id = ::std::option::Option::Some(v);
    }

    // optional int32 source_hero_id = 2;

    pub fn source_hero_id(&self) -> i32 {
        self.source_hero_id.unwrap_or(0)
    }

    pub fn clear_source_hero_id(&mut self) {
        self.source_hero_id = ::std::option::Option::None;
    }

    pub fn has_source_hero_id(&self) -> bool {
        self.source_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_hero_id(&mut self, v: i32) {
        self.source_hero_id = ::std::option::Option::Some(v);
    }

    // optional int32 damage_amount = 3;

    pub fn damage_amount(&self) -> i32 {
        self.damage_amount.unwrap_or(0)
    }

    pub fn clear_damage_amount(&mut self) {
        self.damage_amount = ::std::option::Option::None;
    }

    pub fn has_damage_amount(&self) -> bool {
        self.damage_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_amount(&mut self, v: i32) {
        self.damage_amount = ::std::option::Option::Some(v);
    }

    // optional bool broadcast = 4;

    pub fn broadcast(&self) -> bool {
        self.broadcast.unwrap_or(false)
    }

    pub fn clear_broadcast(&mut self) {
        self.broadcast = ::std::option::Option::None;
    }

    pub fn has_broadcast(&self) -> bool {
        self.broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast(&mut self, v: bool) {
        self.broadcast = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_DamageReport {
    const NAME: &'static str = "CDOTAClientMsg_DamageReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.source_hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.damage_amount = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.source_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.damage_amount {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.broadcast {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_hero_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.source_hero_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.damage_amount {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.broadcast {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_DamageReport {
        CDOTAClientMsg_DamageReport::new()
    }

    fn clear(&mut self) {
        self.target_hero_id = ::std::option::Option::None;
        self.source_hero_id = ::std::option::Option::None;
        self.damage_amount = ::std::option::Option::None;
        self.broadcast = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_DamageReport {
        static instance: CDOTAClientMsg_DamageReport = CDOTAClientMsg_DamageReport {
            target_hero_id: ::std::option::Option::None,
            source_hero_id: ::std::option::Option::None,
            damage_amount: ::std::option::Option::None,
            broadcast: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_SalutePlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SalutePlayer {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_SalutePlayer.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_SalutePlayer.event_id)
    pub event_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_SalutePlayer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SalutePlayer {
    fn default() -> &'a CDOTAClientMsg_SalutePlayer {
        <CDOTAClientMsg_SalutePlayer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SalutePlayer {
    pub fn new() -> CDOTAClientMsg_SalutePlayer {
        ::std::default::Default::default()
    }

    // optional int32 target_player_id = 1;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(-1i32)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 event_id = 2;

    pub fn event_id(&self) -> i32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: i32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_SalutePlayer {
    const NAME: &'static str = "CDOTAClientMsg_SalutePlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SalutePlayer {
        CDOTAClientMsg_SalutePlayer::new()
    }

    fn clear(&mut self) {
        self.target_player_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SalutePlayer {
        static instance: CDOTAClientMsg_SalutePlayer = CDOTAClientMsg_SalutePlayer {
            target_player_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_GiftPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_GiftPlayer {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_GiftPlayer.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_GiftPlayer.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_GiftPlayer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_GiftPlayer {
    fn default() -> &'a CDOTAClientMsg_GiftPlayer {
        <CDOTAClientMsg_GiftPlayer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_GiftPlayer {
    pub fn new() -> CDOTAClientMsg_GiftPlayer {
        ::std::default::Default::default()
    }

    // optional int32 target_player_id = 1;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(-1i32)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def_index = 2;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_GiftPlayer {
    const NAME: &'static str = "CDOTAClientMsg_GiftPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.item_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.item_def_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_GiftPlayer {
        CDOTAClientMsg_GiftPlayer::new()
    }

    fn clear(&mut self) {
        self.target_player_id = ::std::option::Option::None;
        self.item_def_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_GiftPlayer {
        static instance: CDOTAClientMsg_GiftPlayer = CDOTAClientMsg_GiftPlayer {
            target_player_id: ::std::option::Option::None,
            item_def_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_GiftEveryone)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_GiftEveryone {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_GiftEveryone.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_GiftEveryone.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_GiftEveryone {
    fn default() -> &'a CDOTAClientMsg_GiftEveryone {
        <CDOTAClientMsg_GiftEveryone as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_GiftEveryone {
    pub fn new() -> CDOTAClientMsg_GiftEveryone {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_GiftEveryone {
    const NAME: &'static str = "CDOTAClientMsg_GiftEveryone";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_GiftEveryone {
        CDOTAClientMsg_GiftEveryone::new()
    }

    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_GiftEveryone {
        static instance: CDOTAClientMsg_GiftEveryone = CDOTAClientMsg_GiftEveryone {
            item_def_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_TipAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_TipAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_TipAlert.tip_text)
    pub tip_text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_TipAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_TipAlert {
    fn default() -> &'a CDOTAClientMsg_TipAlert {
        <CDOTAClientMsg_TipAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_TipAlert {
    pub fn new() -> CDOTAClientMsg_TipAlert {
        ::std::default::Default::default()
    }

    // optional string tip_text = 1;

    pub fn tip_text(&self) -> &str {
        match self.tip_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tip_text(&mut self) {
        self.tip_text = ::std::option::Option::None;
    }

    pub fn has_tip_text(&self) -> bool {
        self.tip_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_text(&mut self, v: ::std::string::String) {
        self.tip_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tip_text(&mut self) -> &mut ::std::string::String {
        if self.tip_text.is_none() {
            self.tip_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tip_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_tip_text(&mut self) -> ::std::string::String {
        self.tip_text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_TipAlert {
    const NAME: &'static str = "CDOTAClientMsg_TipAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tip_text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tip_text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tip_text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_TipAlert {
        CDOTAClientMsg_TipAlert::new()
    }

    fn clear(&mut self) {
        self.tip_text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_TipAlert {
        static instance: CDOTAClientMsg_TipAlert = CDOTAClientMsg_TipAlert {
            tip_text: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_EmptyTeleportAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_EmptyTeleportAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_EmptyTeleportAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_EmptyTeleportAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_EmptyTeleportAlert {
    fn default() -> &'a CDOTAClientMsg_EmptyTeleportAlert {
        <CDOTAClientMsg_EmptyTeleportAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_EmptyTeleportAlert {
    pub fn new() -> CDOTAClientMsg_EmptyTeleportAlert {
        ::std::default::Default::default()
    }

    // optional int32 target_entindex = 1;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_EmptyTeleportAlert {
    const NAME: &'static str = "CDOTAClientMsg_EmptyTeleportAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_entindex {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_EmptyTeleportAlert {
        CDOTAClientMsg_EmptyTeleportAlert::new()
    }

    fn clear(&mut self) {
        self.target_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_EmptyTeleportAlert {
        static instance: CDOTAClientMsg_EmptyTeleportAlert = CDOTAClientMsg_EmptyTeleportAlert {
            target_entindex: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_SetCavernMapVariant)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SetCavernMapVariant {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_SetCavernMapVariant.map_variant)
    pub map_variant: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_SetCavernMapVariant.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SetCavernMapVariant {
    fn default() -> &'a CDOTAClientMsg_SetCavernMapVariant {
        <CDOTAClientMsg_SetCavernMapVariant as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SetCavernMapVariant {
    pub fn new() -> CDOTAClientMsg_SetCavernMapVariant {
        ::std::default::Default::default()
    }

    // optional uint32 map_variant = 1;

    pub fn map_variant(&self) -> u32 {
        self.map_variant.unwrap_or(255u32)
    }

    pub fn clear_map_variant(&mut self) {
        self.map_variant = ::std::option::Option::None;
    }

    pub fn has_map_variant(&self) -> bool {
        self.map_variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_variant(&mut self, v: u32) {
        self.map_variant = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_SetCavernMapVariant {
    const NAME: &'static str = "CDOTAClientMsg_SetCavernMapVariant";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.map_variant = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.map_variant {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.map_variant {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SetCavernMapVariant {
        CDOTAClientMsg_SetCavernMapVariant::new()
    }

    fn clear(&mut self) {
        self.map_variant = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SetCavernMapVariant {
        static instance: CDOTAClientMsg_SetCavernMapVariant = CDOTAClientMsg_SetCavernMapVariant {
            map_variant: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_PauseGameOrder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_PauseGameOrder {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_PauseGameOrder.order_id)
    pub order_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PauseGameOrder.data)
    pub data: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_PauseGameOrder.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_PauseGameOrder {
    fn default() -> &'a CDOTAClientMsg_PauseGameOrder {
        <CDOTAClientMsg_PauseGameOrder as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_PauseGameOrder {
    pub fn new() -> CDOTAClientMsg_PauseGameOrder {
        ::std::default::Default::default()
    }

    // optional int32 order_id = 1;

    pub fn order_id(&self) -> i32 {
        self.order_id.unwrap_or(0)
    }

    pub fn clear_order_id(&mut self) {
        self.order_id = ::std::option::Option::None;
    }

    pub fn has_order_id(&self) -> bool {
        self.order_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_id(&mut self, v: i32) {
        self.order_id = ::std::option::Option::Some(v);
    }

    // optional int32 data = 2;

    pub fn data(&self) -> i32 {
        self.data.unwrap_or(0)
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: i32) {
        self.data = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_PauseGameOrder {
    const NAME: &'static str = "CDOTAClientMsg_PauseGameOrder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.order_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.data = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.order_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.data {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.order_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_PauseGameOrder {
        CDOTAClientMsg_PauseGameOrder::new()
    }

    fn clear(&mut self) {
        self.order_id = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_PauseGameOrder {
        static instance: CDOTAClientMsg_PauseGameOrder = CDOTAClientMsg_PauseGameOrder {
            order_id: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_VersusScene_PlayerBehavior)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_VersusScene_PlayerBehavior {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_VersusScene_PlayerBehavior.behavior)
    pub behavior: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_commonmessages::EDOTAVersusScenePlayerBehavior>>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_VersusScene_PlayerBehavior.play_activity)
    pub play_activity: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::VersusScene_PlayActivity>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_VersusScene_PlayerBehavior.chat_wheel)
    pub chat_wheel: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::VersusScene_ChatWheel>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_VersusScene_PlayerBehavior.playback_rate)
    pub playback_rate: ::steam_vent_proto_common::protobuf::MessageField<super::dota_commonmessages::VersusScene_PlaybackRate>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_VersusScene_PlayerBehavior.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_VersusScene_PlayerBehavior {
    fn default() -> &'a CDOTAClientMsg_VersusScene_PlayerBehavior {
        <CDOTAClientMsg_VersusScene_PlayerBehavior as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_VersusScene_PlayerBehavior {
    pub fn new() -> CDOTAClientMsg_VersusScene_PlayerBehavior {
        ::std::default::Default::default()
    }

    // optional .EDOTAVersusScenePlayerBehavior behavior = 1;

    pub fn behavior(&self) -> super::dota_commonmessages::EDOTAVersusScenePlayerBehavior {
        match self.behavior {
            Some(e) => e.enum_value_or(super::dota_commonmessages::EDOTAVersusScenePlayerBehavior::VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY),
            None => super::dota_commonmessages::EDOTAVersusScenePlayerBehavior::VS_PLAYER_BEHAVIOR_PLAY_ACTIVITY,
        }
    }

    pub fn clear_behavior(&mut self) {
        self.behavior = ::std::option::Option::None;
    }

    pub fn has_behavior(&self) -> bool {
        self.behavior.is_some()
    }

    // Param is passed by value, moved
    pub fn set_behavior(&mut self, v: super::dota_commonmessages::EDOTAVersusScenePlayerBehavior) {
        self.behavior = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_VersusScene_PlayerBehavior {
    const NAME: &'static str = "CDOTAClientMsg_VersusScene_PlayerBehavior";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.behavior = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.play_activity)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.chat_wheel)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.playback_rate)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.behavior {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.play_activity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.chat_wheel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.playback_rate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.behavior {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.play_activity.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.chat_wheel.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.playback_rate.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_VersusScene_PlayerBehavior {
        CDOTAClientMsg_VersusScene_PlayerBehavior::new()
    }

    fn clear(&mut self) {
        self.behavior = ::std::option::Option::None;
        self.play_activity.clear();
        self.chat_wheel.clear();
        self.playback_rate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_VersusScene_PlayerBehavior {
        static instance: CDOTAClientMsg_VersusScene_PlayerBehavior = CDOTAClientMsg_VersusScene_PlayerBehavior {
            behavior: ::std::option::Option::None,
            play_activity: ::steam_vent_proto_common::protobuf::MessageField::none(),
            chat_wheel: ::steam_vent_proto_common::protobuf::MessageField::none(),
            playback_rate: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_EmptyItemSlotAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_EmptyItemSlotAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_EmptyItemSlotAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_EmptyItemSlotAlert.slot_index)
    pub slot_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_EmptyItemSlotAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_EmptyItemSlotAlert {
    fn default() -> &'a CDOTAClientMsg_EmptyItemSlotAlert {
        <CDOTAClientMsg_EmptyItemSlotAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_EmptyItemSlotAlert {
    pub fn new() -> CDOTAClientMsg_EmptyItemSlotAlert {
        ::std::default::Default::default()
    }

    // optional int32 target_entindex = 1;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 slot_index = 2;

    pub fn slot_index(&self) -> i32 {
        self.slot_index.unwrap_or(0)
    }

    pub fn clear_slot_index(&mut self) {
        self.slot_index = ::std::option::Option::None;
    }

    pub fn has_slot_index(&self) -> bool {
        self.slot_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_index(&mut self, v: i32) {
        self.slot_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_EmptyItemSlotAlert {
    const NAME: &'static str = "CDOTAClientMsg_EmptyItemSlotAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.slot_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.slot_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.slot_index {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_EmptyItemSlotAlert {
        CDOTAClientMsg_EmptyItemSlotAlert::new()
    }

    fn clear(&mut self) {
        self.target_entindex = ::std::option::Option::None;
        self.slot_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_EmptyItemSlotAlert {
        static instance: CDOTAClientMsg_EmptyItemSlotAlert = CDOTAClientMsg_EmptyItemSlotAlert {
            target_entindex: ::std::option::Option::None,
            slot_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_AddOverwatchReportMarker)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_AddOverwatchReportMarker {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_AddOverwatchReportMarker.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_AddOverwatchReportMarker.reason)
    pub reason: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EOverwatchReportReason>>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_AddOverwatchReportMarker.seconds_ago)
    pub seconds_ago: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_AddOverwatchReportMarker.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_AddOverwatchReportMarker {
    fn default() -> &'a CDOTAClientMsg_AddOverwatchReportMarker {
        <CDOTAClientMsg_AddOverwatchReportMarker as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_AddOverwatchReportMarker {
    pub fn new() -> CDOTAClientMsg_AddOverwatchReportMarker {
        ::std::default::Default::default()
    }

    // optional int32 target_player_id = 1;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(-1i32)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional .EOverwatchReportReason reason = 2;

    pub fn reason(&self) -> super::dota_shared_enums::EOverwatchReportReason {
        match self.reason {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EOverwatchReportReason::k_EOverwatchReportReason_Unknown),
            None => super::dota_shared_enums::EOverwatchReportReason::k_EOverwatchReportReason_Unknown,
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: super::dota_shared_enums::EOverwatchReportReason) {
        self.reason = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 seconds_ago = 4;

    pub fn seconds_ago(&self) -> u32 {
        self.seconds_ago.unwrap_or(0)
    }

    pub fn clear_seconds_ago(&mut self) {
        self.seconds_ago = ::std::option::Option::None;
    }

    pub fn has_seconds_ago(&self) -> bool {
        self.seconds_ago.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_ago(&mut self, v: u32) {
        self.seconds_ago = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_AddOverwatchReportMarker {
    const NAME: &'static str = "CDOTAClientMsg_AddOverwatchReportMarker";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.seconds_ago = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.seconds_ago {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.reason {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.seconds_ago {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_AddOverwatchReportMarker {
        CDOTAClientMsg_AddOverwatchReportMarker::new()
    }

    fn clear(&mut self) {
        self.target_player_id = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.seconds_ago = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_AddOverwatchReportMarker {
        static instance: CDOTAClientMsg_AddOverwatchReportMarker = CDOTAClientMsg_AddOverwatchReportMarker {
            target_player_id: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            seconds_ago: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_AddCommunicationsReportMarker)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_AddCommunicationsReportMarker {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_AddCommunicationsReportMarker.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_AddCommunicationsReportMarker.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_AddCommunicationsReportMarker {
    fn default() -> &'a CDOTAClientMsg_AddCommunicationsReportMarker {
        <CDOTAClientMsg_AddCommunicationsReportMarker as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_AddCommunicationsReportMarker {
    pub fn new() -> CDOTAClientMsg_AddCommunicationsReportMarker {
        ::std::default::Default::default()
    }

    // optional int32 target_player_id = 1;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(-1i32)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_AddCommunicationsReportMarker {
    const NAME: &'static str = "CDOTAClientMsg_AddCommunicationsReportMarker";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_AddCommunicationsReportMarker {
        CDOTAClientMsg_AddCommunicationsReportMarker::new()
    }

    fn clear(&mut self) {
        self.target_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_AddCommunicationsReportMarker {
        static instance: CDOTAClientMsg_AddCommunicationsReportMarker = CDOTAClientMsg_AddCommunicationsReportMarker {
            target_player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_AddCommunicationsBlockMarker)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_AddCommunicationsBlockMarker {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_AddCommunicationsBlockMarker.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_AddCommunicationsBlockMarker.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_AddCommunicationsBlockMarker {
    fn default() -> &'a CDOTAClientMsg_AddCommunicationsBlockMarker {
        <CDOTAClientMsg_AddCommunicationsBlockMarker as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_AddCommunicationsBlockMarker {
    pub fn new() -> CDOTAClientMsg_AddCommunicationsBlockMarker {
        ::std::default::Default::default()
    }

    // optional int32 target_player_id = 1;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(-1i32)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_AddCommunicationsBlockMarker {
    const NAME: &'static str = "CDOTAClientMsg_AddCommunicationsBlockMarker";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_AddCommunicationsBlockMarker {
        CDOTAClientMsg_AddCommunicationsBlockMarker::new()
    }

    fn clear(&mut self) {
        self.target_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_AddCommunicationsBlockMarker {
        static instance: CDOTAClientMsg_AddCommunicationsBlockMarker = CDOTAClientMsg_AddCommunicationsBlockMarker {
            target_player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_AghsStatusAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_AghsStatusAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_AghsStatusAlert.source_player_id)
    pub source_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_AghsStatusAlert.target_player_id)
    pub target_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_AghsStatusAlert.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_AghsStatusAlert.alert_type)
    pub alert_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_AghsStatusAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_AghsStatusAlert {
    fn default() -> &'a CDOTAClientMsg_AghsStatusAlert {
        <CDOTAClientMsg_AghsStatusAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_AghsStatusAlert {
    pub fn new() -> CDOTAClientMsg_AghsStatusAlert {
        ::std::default::Default::default()
    }

    // optional int32 source_player_id = 1;

    pub fn source_player_id(&self) -> i32 {
        self.source_player_id.unwrap_or(-1i32)
    }

    pub fn clear_source_player_id(&mut self) {
        self.source_player_id = ::std::option::Option::None;
    }

    pub fn has_source_player_id(&self) -> bool {
        self.source_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_id(&mut self, v: i32) {
        self.source_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_player_id = 2;

    pub fn target_player_id(&self) -> i32 {
        self.target_player_id.unwrap_or(-1i32)
    }

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: i32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 3;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional uint32 alert_type = 4;

    pub fn alert_type(&self) -> u32 {
        self.alert_type.unwrap_or(0)
    }

    pub fn clear_alert_type(&mut self) {
        self.alert_type = ::std::option::Option::None;
    }

    pub fn has_alert_type(&self) -> bool {
        self.alert_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alert_type(&mut self, v: u32) {
        self.alert_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_AghsStatusAlert {
    const NAME: &'static str = "CDOTAClientMsg_AghsStatusAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.alert_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.alert_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.source_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.alert_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_AghsStatusAlert {
        CDOTAClientMsg_AghsStatusAlert::new()
    }

    fn clear(&mut self) {
        self.source_player_id = ::std::option::Option::None;
        self.target_player_id = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.alert_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_AghsStatusAlert {
        static instance: CDOTAClientMsg_AghsStatusAlert = CDOTAClientMsg_AghsStatusAlert {
            source_player_id: ::std::option::Option::None,
            target_player_id: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            alert_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_PerfReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_PerfReport {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.average_frame_time)
    pub average_frame_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.max_frame_time)
    pub max_frame_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.average_compute_time)
    pub average_compute_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.max_compute_time)
    pub max_compute_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.average_client_tick_time)
    pub average_client_tick_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.max_client_tick_time)
    pub max_client_tick_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.average_client_simulate_time)
    pub average_client_simulate_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.max_client_simulate_time)
    pub max_client_simulate_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.average_output_time)
    pub average_output_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.max_output_time)
    pub max_output_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.average_wait_for_rendering_to_complete_time)
    pub average_wait_for_rendering_to_complete_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.max_wait_for_rendering_to_complete_time)
    pub max_wait_for_rendering_to_complete_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.average_swap_time)
    pub average_swap_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.max_swap_time)
    pub max_swap_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.average_frame_update_time)
    pub average_frame_update_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.max_frame_update_time)
    pub max_frame_update_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.average_idle_time)
    pub average_idle_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.max_idle_time)
    pub max_idle_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.average_input_processing_time)
    pub average_input_processing_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PerfReport.max_input_processing_time)
    pub max_input_processing_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_PerfReport.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_PerfReport {
    fn default() -> &'a CDOTAClientMsg_PerfReport {
        <CDOTAClientMsg_PerfReport as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_PerfReport {
    pub fn new() -> CDOTAClientMsg_PerfReport {
        ::std::default::Default::default()
    }

    // optional float average_frame_time = 1;

    pub fn average_frame_time(&self) -> f32 {
        self.average_frame_time.unwrap_or(0.)
    }

    pub fn clear_average_frame_time(&mut self) {
        self.average_frame_time = ::std::option::Option::None;
    }

    pub fn has_average_frame_time(&self) -> bool {
        self.average_frame_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_frame_time(&mut self, v: f32) {
        self.average_frame_time = ::std::option::Option::Some(v);
    }

    // optional float max_frame_time = 2;

    pub fn max_frame_time(&self) -> f32 {
        self.max_frame_time.unwrap_or(0.)
    }

    pub fn clear_max_frame_time(&mut self) {
        self.max_frame_time = ::std::option::Option::None;
    }

    pub fn has_max_frame_time(&self) -> bool {
        self.max_frame_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_frame_time(&mut self, v: f32) {
        self.max_frame_time = ::std::option::Option::Some(v);
    }

    // optional float average_compute_time = 3;

    pub fn average_compute_time(&self) -> f32 {
        self.average_compute_time.unwrap_or(0.)
    }

    pub fn clear_average_compute_time(&mut self) {
        self.average_compute_time = ::std::option::Option::None;
    }

    pub fn has_average_compute_time(&self) -> bool {
        self.average_compute_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_compute_time(&mut self, v: f32) {
        self.average_compute_time = ::std::option::Option::Some(v);
    }

    // optional float max_compute_time = 4;

    pub fn max_compute_time(&self) -> f32 {
        self.max_compute_time.unwrap_or(0.)
    }

    pub fn clear_max_compute_time(&mut self) {
        self.max_compute_time = ::std::option::Option::None;
    }

    pub fn has_max_compute_time(&self) -> bool {
        self.max_compute_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_compute_time(&mut self, v: f32) {
        self.max_compute_time = ::std::option::Option::Some(v);
    }

    // optional float average_client_tick_time = 5;

    pub fn average_client_tick_time(&self) -> f32 {
        self.average_client_tick_time.unwrap_or(0.)
    }

    pub fn clear_average_client_tick_time(&mut self) {
        self.average_client_tick_time = ::std::option::Option::None;
    }

    pub fn has_average_client_tick_time(&self) -> bool {
        self.average_client_tick_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_client_tick_time(&mut self, v: f32) {
        self.average_client_tick_time = ::std::option::Option::Some(v);
    }

    // optional float max_client_tick_time = 6;

    pub fn max_client_tick_time(&self) -> f32 {
        self.max_client_tick_time.unwrap_or(0.)
    }

    pub fn clear_max_client_tick_time(&mut self) {
        self.max_client_tick_time = ::std::option::Option::None;
    }

    pub fn has_max_client_tick_time(&self) -> bool {
        self.max_client_tick_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_client_tick_time(&mut self, v: f32) {
        self.max_client_tick_time = ::std::option::Option::Some(v);
    }

    // optional float average_client_simulate_time = 7;

    pub fn average_client_simulate_time(&self) -> f32 {
        self.average_client_simulate_time.unwrap_or(0.)
    }

    pub fn clear_average_client_simulate_time(&mut self) {
        self.average_client_simulate_time = ::std::option::Option::None;
    }

    pub fn has_average_client_simulate_time(&self) -> bool {
        self.average_client_simulate_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_client_simulate_time(&mut self, v: f32) {
        self.average_client_simulate_time = ::std::option::Option::Some(v);
    }

    // optional float max_client_simulate_time = 8;

    pub fn max_client_simulate_time(&self) -> f32 {
        self.max_client_simulate_time.unwrap_or(0.)
    }

    pub fn clear_max_client_simulate_time(&mut self) {
        self.max_client_simulate_time = ::std::option::Option::None;
    }

    pub fn has_max_client_simulate_time(&self) -> bool {
        self.max_client_simulate_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_client_simulate_time(&mut self, v: f32) {
        self.max_client_simulate_time = ::std::option::Option::Some(v);
    }

    // optional float average_output_time = 9;

    pub fn average_output_time(&self) -> f32 {
        self.average_output_time.unwrap_or(0.)
    }

    pub fn clear_average_output_time(&mut self) {
        self.average_output_time = ::std::option::Option::None;
    }

    pub fn has_average_output_time(&self) -> bool {
        self.average_output_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_output_time(&mut self, v: f32) {
        self.average_output_time = ::std::option::Option::Some(v);
    }

    // optional float max_output_time = 10;

    pub fn max_output_time(&self) -> f32 {
        self.max_output_time.unwrap_or(0.)
    }

    pub fn clear_max_output_time(&mut self) {
        self.max_output_time = ::std::option::Option::None;
    }

    pub fn has_max_output_time(&self) -> bool {
        self.max_output_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_output_time(&mut self, v: f32) {
        self.max_output_time = ::std::option::Option::Some(v);
    }

    // optional float average_wait_for_rendering_to_complete_time = 11;

    pub fn average_wait_for_rendering_to_complete_time(&self) -> f32 {
        self.average_wait_for_rendering_to_complete_time.unwrap_or(0.)
    }

    pub fn clear_average_wait_for_rendering_to_complete_time(&mut self) {
        self.average_wait_for_rendering_to_complete_time = ::std::option::Option::None;
    }

    pub fn has_average_wait_for_rendering_to_complete_time(&self) -> bool {
        self.average_wait_for_rendering_to_complete_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_wait_for_rendering_to_complete_time(&mut self, v: f32) {
        self.average_wait_for_rendering_to_complete_time = ::std::option::Option::Some(v);
    }

    // optional float max_wait_for_rendering_to_complete_time = 12;

    pub fn max_wait_for_rendering_to_complete_time(&self) -> f32 {
        self.max_wait_for_rendering_to_complete_time.unwrap_or(0.)
    }

    pub fn clear_max_wait_for_rendering_to_complete_time(&mut self) {
        self.max_wait_for_rendering_to_complete_time = ::std::option::Option::None;
    }

    pub fn has_max_wait_for_rendering_to_complete_time(&self) -> bool {
        self.max_wait_for_rendering_to_complete_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_wait_for_rendering_to_complete_time(&mut self, v: f32) {
        self.max_wait_for_rendering_to_complete_time = ::std::option::Option::Some(v);
    }

    // optional float average_swap_time = 13;

    pub fn average_swap_time(&self) -> f32 {
        self.average_swap_time.unwrap_or(0.)
    }

    pub fn clear_average_swap_time(&mut self) {
        self.average_swap_time = ::std::option::Option::None;
    }

    pub fn has_average_swap_time(&self) -> bool {
        self.average_swap_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_swap_time(&mut self, v: f32) {
        self.average_swap_time = ::std::option::Option::Some(v);
    }

    // optional float max_swap_time = 14;

    pub fn max_swap_time(&self) -> f32 {
        self.max_swap_time.unwrap_or(0.)
    }

    pub fn clear_max_swap_time(&mut self) {
        self.max_swap_time = ::std::option::Option::None;
    }

    pub fn has_max_swap_time(&self) -> bool {
        self.max_swap_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_swap_time(&mut self, v: f32) {
        self.max_swap_time = ::std::option::Option::Some(v);
    }

    // optional float average_frame_update_time = 15;

    pub fn average_frame_update_time(&self) -> f32 {
        self.average_frame_update_time.unwrap_or(0.)
    }

    pub fn clear_average_frame_update_time(&mut self) {
        self.average_frame_update_time = ::std::option::Option::None;
    }

    pub fn has_average_frame_update_time(&self) -> bool {
        self.average_frame_update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_frame_update_time(&mut self, v: f32) {
        self.average_frame_update_time = ::std::option::Option::Some(v);
    }

    // optional float max_frame_update_time = 16;

    pub fn max_frame_update_time(&self) -> f32 {
        self.max_frame_update_time.unwrap_or(0.)
    }

    pub fn clear_max_frame_update_time(&mut self) {
        self.max_frame_update_time = ::std::option::Option::None;
    }

    pub fn has_max_frame_update_time(&self) -> bool {
        self.max_frame_update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_frame_update_time(&mut self, v: f32) {
        self.max_frame_update_time = ::std::option::Option::Some(v);
    }

    // optional float average_idle_time = 17;

    pub fn average_idle_time(&self) -> f32 {
        self.average_idle_time.unwrap_or(0.)
    }

    pub fn clear_average_idle_time(&mut self) {
        self.average_idle_time = ::std::option::Option::None;
    }

    pub fn has_average_idle_time(&self) -> bool {
        self.average_idle_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_idle_time(&mut self, v: f32) {
        self.average_idle_time = ::std::option::Option::Some(v);
    }

    // optional float max_idle_time = 18;

    pub fn max_idle_time(&self) -> f32 {
        self.max_idle_time.unwrap_or(0.)
    }

    pub fn clear_max_idle_time(&mut self) {
        self.max_idle_time = ::std::option::Option::None;
    }

    pub fn has_max_idle_time(&self) -> bool {
        self.max_idle_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_idle_time(&mut self, v: f32) {
        self.max_idle_time = ::std::option::Option::Some(v);
    }

    // optional float average_input_processing_time = 19;

    pub fn average_input_processing_time(&self) -> f32 {
        self.average_input_processing_time.unwrap_or(0.)
    }

    pub fn clear_average_input_processing_time(&mut self) {
        self.average_input_processing_time = ::std::option::Option::None;
    }

    pub fn has_average_input_processing_time(&self) -> bool {
        self.average_input_processing_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_input_processing_time(&mut self, v: f32) {
        self.average_input_processing_time = ::std::option::Option::Some(v);
    }

    // optional float max_input_processing_time = 20;

    pub fn max_input_processing_time(&self) -> f32 {
        self.max_input_processing_time.unwrap_or(0.)
    }

    pub fn clear_max_input_processing_time(&mut self) {
        self.max_input_processing_time = ::std::option::Option::None;
    }

    pub fn has_max_input_processing_time(&self) -> bool {
        self.max_input_processing_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_input_processing_time(&mut self, v: f32) {
        self.max_input_processing_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_PerfReport {
    const NAME: &'static str = "CDOTAClientMsg_PerfReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.average_frame_time = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.max_frame_time = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.average_compute_time = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.max_compute_time = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.average_client_tick_time = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.max_client_tick_time = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.average_client_simulate_time = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.max_client_simulate_time = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.average_output_time = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.max_output_time = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.average_wait_for_rendering_to_complete_time = ::std::option::Option::Some(is.read_float()?);
                },
                101 => {
                    self.max_wait_for_rendering_to_complete_time = ::std::option::Option::Some(is.read_float()?);
                },
                109 => {
                    self.average_swap_time = ::std::option::Option::Some(is.read_float()?);
                },
                117 => {
                    self.max_swap_time = ::std::option::Option::Some(is.read_float()?);
                },
                125 => {
                    self.average_frame_update_time = ::std::option::Option::Some(is.read_float()?);
                },
                133 => {
                    self.max_frame_update_time = ::std::option::Option::Some(is.read_float()?);
                },
                141 => {
                    self.average_idle_time = ::std::option::Option::Some(is.read_float()?);
                },
                149 => {
                    self.max_idle_time = ::std::option::Option::Some(is.read_float()?);
                },
                157 => {
                    self.average_input_processing_time = ::std::option::Option::Some(is.read_float()?);
                },
                165 => {
                    self.max_input_processing_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.average_frame_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_frame_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.average_compute_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_compute_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.average_client_tick_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_client_tick_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.average_client_simulate_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_client_simulate_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.average_output_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_output_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.average_wait_for_rendering_to_complete_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_wait_for_rendering_to_complete_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.average_swap_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_swap_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.average_frame_update_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_frame_update_time {
            my_size += 2 + 4;
        }
        if let Some(v) = self.average_idle_time {
            my_size += 2 + 4;
        }
        if let Some(v) = self.max_idle_time {
            my_size += 2 + 4;
        }
        if let Some(v) = self.average_input_processing_time {
            my_size += 2 + 4;
        }
        if let Some(v) = self.max_input_processing_time {
            my_size += 2 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.average_frame_time {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.max_frame_time {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.average_compute_time {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.max_compute_time {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.average_client_tick_time {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.max_client_tick_time {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.average_client_simulate_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.max_client_simulate_time {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.average_output_time {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.max_output_time {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.average_wait_for_rendering_to_complete_time {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.max_wait_for_rendering_to_complete_time {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.average_swap_time {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.max_swap_time {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.average_frame_update_time {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.max_frame_update_time {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.average_idle_time {
            os.write_float(17, v)?;
        }
        if let Some(v) = self.max_idle_time {
            os.write_float(18, v)?;
        }
        if let Some(v) = self.average_input_processing_time {
            os.write_float(19, v)?;
        }
        if let Some(v) = self.max_input_processing_time {
            os.write_float(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_PerfReport {
        CDOTAClientMsg_PerfReport::new()
    }

    fn clear(&mut self) {
        self.average_frame_time = ::std::option::Option::None;
        self.max_frame_time = ::std::option::Option::None;
        self.average_compute_time = ::std::option::Option::None;
        self.max_compute_time = ::std::option::Option::None;
        self.average_client_tick_time = ::std::option::Option::None;
        self.max_client_tick_time = ::std::option::Option::None;
        self.average_client_simulate_time = ::std::option::Option::None;
        self.max_client_simulate_time = ::std::option::Option::None;
        self.average_output_time = ::std::option::Option::None;
        self.max_output_time = ::std::option::Option::None;
        self.average_wait_for_rendering_to_complete_time = ::std::option::Option::None;
        self.max_wait_for_rendering_to_complete_time = ::std::option::Option::None;
        self.average_swap_time = ::std::option::Option::None;
        self.max_swap_time = ::std::option::Option::None;
        self.average_frame_update_time = ::std::option::Option::None;
        self.max_frame_update_time = ::std::option::Option::None;
        self.average_idle_time = ::std::option::Option::None;
        self.max_idle_time = ::std::option::Option::None;
        self.average_input_processing_time = ::std::option::Option::None;
        self.max_input_processing_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_PerfReport {
        static instance: CDOTAClientMsg_PerfReport = CDOTAClientMsg_PerfReport {
            average_frame_time: ::std::option::Option::None,
            max_frame_time: ::std::option::Option::None,
            average_compute_time: ::std::option::Option::None,
            max_compute_time: ::std::option::Option::None,
            average_client_tick_time: ::std::option::Option::None,
            max_client_tick_time: ::std::option::Option::None,
            average_client_simulate_time: ::std::option::Option::None,
            max_client_simulate_time: ::std::option::Option::None,
            average_output_time: ::std::option::Option::None,
            max_output_time: ::std::option::Option::None,
            average_wait_for_rendering_to_complete_time: ::std::option::Option::None,
            max_wait_for_rendering_to_complete_time: ::std::option::Option::None,
            average_swap_time: ::std::option::Option::None,
            max_swap_time: ::std::option::Option::None,
            average_frame_update_time: ::std::option::Option::None,
            max_frame_update_time: ::std::option::Option::None,
            average_idle_time: ::std::option::Option::None,
            max_idle_time: ::std::option::Option::None,
            average_input_processing_time: ::std::option::Option::None,
            max_input_processing_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_ContextualTips_Subscribe_Entry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ContextualTips_Subscribe_Entry {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_ContextualTips_Subscribe_Entry.unsubscribe)
    pub unsubscribe: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_ContextualTips_Subscribe_Entry.tip_id)
    pub tip_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_ContextualTips_Subscribe_Entry.prior_display_count)
    pub prior_display_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_ContextualTips_Subscribe_Entry.variants_seen)
    pub variants_seen: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_ContextualTips_Subscribe_Entry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ContextualTips_Subscribe_Entry {
    fn default() -> &'a CDOTAClientMsg_ContextualTips_Subscribe_Entry {
        <CDOTAClientMsg_ContextualTips_Subscribe_Entry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ContextualTips_Subscribe_Entry {
    pub fn new() -> CDOTAClientMsg_ContextualTips_Subscribe_Entry {
        ::std::default::Default::default()
    }

    // optional bool unsubscribe = 1;

    pub fn unsubscribe(&self) -> bool {
        self.unsubscribe.unwrap_or(false)
    }

    pub fn clear_unsubscribe(&mut self) {
        self.unsubscribe = ::std::option::Option::None;
    }

    pub fn has_unsubscribe(&self) -> bool {
        self.unsubscribe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsubscribe(&mut self, v: bool) {
        self.unsubscribe = ::std::option::Option::Some(v);
    }

    // optional int32 tip_id = 2;

    pub fn tip_id(&self) -> i32 {
        self.tip_id.unwrap_or(0)
    }

    pub fn clear_tip_id(&mut self) {
        self.tip_id = ::std::option::Option::None;
    }

    pub fn has_tip_id(&self) -> bool {
        self.tip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_id(&mut self, v: i32) {
        self.tip_id = ::std::option::Option::Some(v);
    }

    // optional int32 prior_display_count = 3;

    pub fn prior_display_count(&self) -> i32 {
        self.prior_display_count.unwrap_or(0)
    }

    pub fn clear_prior_display_count(&mut self) {
        self.prior_display_count = ::std::option::Option::None;
    }

    pub fn has_prior_display_count(&self) -> bool {
        self.prior_display_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prior_display_count(&mut self, v: i32) {
        self.prior_display_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_ContextualTips_Subscribe_Entry {
    const NAME: &'static str = "CDOTAClientMsg_ContextualTips_Subscribe_Entry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unsubscribe = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.tip_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.prior_display_count = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    is.read_repeated_packed_int32_into(&mut self.variants_seen)?;
                },
                32 => {
                    self.variants_seen.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unsubscribe {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tip_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.prior_display_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        for value in &self.variants_seen {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.unsubscribe {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.tip_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.prior_display_count {
            os.write_int32(3, v)?;
        }
        for v in &self.variants_seen {
            os.write_int32(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ContextualTips_Subscribe_Entry {
        CDOTAClientMsg_ContextualTips_Subscribe_Entry::new()
    }

    fn clear(&mut self) {
        self.unsubscribe = ::std::option::Option::None;
        self.tip_id = ::std::option::Option::None;
        self.prior_display_count = ::std::option::Option::None;
        self.variants_seen.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ContextualTips_Subscribe_Entry {
        static instance: CDOTAClientMsg_ContextualTips_Subscribe_Entry = CDOTAClientMsg_ContextualTips_Subscribe_Entry {
            unsubscribe: ::std::option::Option::None,
            tip_id: ::std::option::Option::None,
            prior_display_count: ::std::option::Option::None,
            variants_seen: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_ContextualTips_Subscribe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ContextualTips_Subscribe {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_ContextualTips_Subscribe.tips)
    pub tips: ::std::vec::Vec<CDOTAClientMsg_ContextualTips_Subscribe_Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_ContextualTips_Subscribe.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ContextualTips_Subscribe {
    fn default() -> &'a CDOTAClientMsg_ContextualTips_Subscribe {
        <CDOTAClientMsg_ContextualTips_Subscribe as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ContextualTips_Subscribe {
    pub fn new() -> CDOTAClientMsg_ContextualTips_Subscribe {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_ContextualTips_Subscribe {
    const NAME: &'static str = "CDOTAClientMsg_ContextualTips_Subscribe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tips.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tips {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.tips {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ContextualTips_Subscribe {
        CDOTAClientMsg_ContextualTips_Subscribe::new()
    }

    fn clear(&mut self) {
        self.tips.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ContextualTips_Subscribe {
        static instance: CDOTAClientMsg_ContextualTips_Subscribe = CDOTAClientMsg_ContextualTips_Subscribe {
            tips: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_ChatMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ChatMessage {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_ChatMessage.channel_type)
    pub channel_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_ChatMessage.message_text)
    pub message_text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_ChatMessage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ChatMessage {
    fn default() -> &'a CDOTAClientMsg_ChatMessage {
        <CDOTAClientMsg_ChatMessage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ChatMessage {
    pub fn new() -> CDOTAClientMsg_ChatMessage {
        ::std::default::Default::default()
    }

    // optional uint32 channel_type = 1;

    pub fn channel_type(&self) -> u32 {
        self.channel_type.unwrap_or(0)
    }

    pub fn clear_channel_type(&mut self) {
        self.channel_type = ::std::option::Option::None;
    }

    pub fn has_channel_type(&self) -> bool {
        self.channel_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_type(&mut self, v: u32) {
        self.channel_type = ::std::option::Option::Some(v);
    }

    // optional string message_text = 2;

    pub fn message_text(&self) -> &str {
        match self.message_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message_text(&mut self) {
        self.message_text = ::std::option::Option::None;
    }

    pub fn has_message_text(&self) -> bool {
        self.message_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_text(&mut self, v: ::std::string::String) {
        self.message_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_text(&mut self) -> &mut ::std::string::String {
        if self.message_text.is_none() {
            self.message_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_text(&mut self) -> ::std::string::String {
        self.message_text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_ChatMessage {
    const NAME: &'static str = "CDOTAClientMsg_ChatMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message_text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message_text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.channel_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message_text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ChatMessage {
        CDOTAClientMsg_ChatMessage::new()
    }

    fn clear(&mut self) {
        self.channel_type = ::std::option::Option::None;
        self.message_text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ChatMessage {
        static instance: CDOTAClientMsg_ChatMessage = CDOTAClientMsg_ChatMessage {
            channel_type: ::std::option::Option::None,
            message_text: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_DuelAccepted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_DuelAccepted {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_DuelAccepted.challenger_player_id)
    pub challenger_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_DuelAccepted.accepter_player_id)
    pub accepter_player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_DuelAccepted.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_DuelAccepted {
    fn default() -> &'a CDOTAClientMsg_DuelAccepted {
        <CDOTAClientMsg_DuelAccepted as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_DuelAccepted {
    pub fn new() -> CDOTAClientMsg_DuelAccepted {
        ::std::default::Default::default()
    }

    // optional int32 challenger_player_id = 1;

    pub fn challenger_player_id(&self) -> i32 {
        self.challenger_player_id.unwrap_or(-1i32)
    }

    pub fn clear_challenger_player_id(&mut self) {
        self.challenger_player_id = ::std::option::Option::None;
    }

    pub fn has_challenger_player_id(&self) -> bool {
        self.challenger_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenger_player_id(&mut self, v: i32) {
        self.challenger_player_id = ::std::option::Option::Some(v);
    }

    // optional int32 accepter_player_id = 2;

    pub fn accepter_player_id(&self) -> i32 {
        self.accepter_player_id.unwrap_or(-1i32)
    }

    pub fn clear_accepter_player_id(&mut self) {
        self.accepter_player_id = ::std::option::Option::None;
    }

    pub fn has_accepter_player_id(&self) -> bool {
        self.accepter_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accepter_player_id(&mut self, v: i32) {
        self.accepter_player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_DuelAccepted {
    const NAME: &'static str = "CDOTAClientMsg_DuelAccepted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.challenger_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.accepter_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenger_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.accepter_player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.challenger_player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.accepter_player_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_DuelAccepted {
        CDOTAClientMsg_DuelAccepted::new()
    }

    fn clear(&mut self) {
        self.challenger_player_id = ::std::option::Option::None;
        self.accepter_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_DuelAccepted {
        static instance: CDOTAClientMsg_DuelAccepted = CDOTAClientMsg_DuelAccepted {
            challenger_player_id: ::std::option::Option::None,
            accepter_player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_ChooseNeutralItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_ChooseNeutralItem {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_ChooseNeutralItem.neutral_item_index)
    pub neutral_item_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_ChooseNeutralItem.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_ChooseNeutralItem.slot_index)
    pub slot_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_ChooseNeutralItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_ChooseNeutralItem {
    fn default() -> &'a CDOTAClientMsg_ChooseNeutralItem {
        <CDOTAClientMsg_ChooseNeutralItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_ChooseNeutralItem {
    pub fn new() -> CDOTAClientMsg_ChooseNeutralItem {
        ::std::default::Default::default()
    }

    // optional int32 neutral_item_index = 1;

    pub fn neutral_item_index(&self) -> i32 {
        self.neutral_item_index.unwrap_or(0)
    }

    pub fn clear_neutral_item_index(&mut self) {
        self.neutral_item_index = ::std::option::Option::None;
    }

    pub fn has_neutral_item_index(&self) -> bool {
        self.neutral_item_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_neutral_item_index(&mut self, v: i32) {
        self.neutral_item_index = ::std::option::Option::Some(v);
    }

    // optional int32 target_entindex = 2;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 slot_index = 3;

    pub fn slot_index(&self) -> i32 {
        self.slot_index.unwrap_or(0)
    }

    pub fn clear_slot_index(&mut self) {
        self.slot_index = ::std::option::Option::None;
    }

    pub fn has_slot_index(&self) -> bool {
        self.slot_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_index(&mut self, v: i32) {
        self.slot_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_ChooseNeutralItem {
    const NAME: &'static str = "CDOTAClientMsg_ChooseNeutralItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.neutral_item_index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.slot_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.neutral_item_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.slot_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.neutral_item_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.slot_index {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_ChooseNeutralItem {
        CDOTAClientMsg_ChooseNeutralItem::new()
    }

    fn clear(&mut self) {
        self.neutral_item_index = ::std::option::Option::None;
        self.target_entindex = ::std::option::Option::None;
        self.slot_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_ChooseNeutralItem {
        static instance: CDOTAClientMsg_ChooseNeutralItem = CDOTAClientMsg_ChooseNeutralItem {
            neutral_item_index: ::std::option::Option::None,
            target_entindex: ::std::option::Option::None,
            slot_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_RerollNeutralItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_RerollNeutralItem {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_RerollNeutralItem.target_entindex)
    pub target_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_RerollNeutralItem.slot_index)
    pub slot_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_RerollNeutralItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_RerollNeutralItem {
    fn default() -> &'a CDOTAClientMsg_RerollNeutralItem {
        <CDOTAClientMsg_RerollNeutralItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_RerollNeutralItem {
    pub fn new() -> CDOTAClientMsg_RerollNeutralItem {
        ::std::default::Default::default()
    }

    // optional int32 target_entindex = 1;

    pub fn target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(-1i32)
    }

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 slot_index = 2;

    pub fn slot_index(&self) -> i32 {
        self.slot_index.unwrap_or(0)
    }

    pub fn clear_slot_index(&mut self) {
        self.slot_index = ::std::option::Option::None;
    }

    pub fn has_slot_index(&self) -> bool {
        self.slot_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_index(&mut self, v: i32) {
        self.slot_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_RerollNeutralItem {
    const NAME: &'static str = "CDOTAClientMsg_RerollNeutralItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.slot_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.slot_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.slot_index {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_RerollNeutralItem {
        CDOTAClientMsg_RerollNeutralItem::new()
    }

    fn clear(&mut self) {
        self.target_entindex = ::std::option::Option::None;
        self.slot_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_RerollNeutralItem {
        static instance: CDOTAClientMsg_RerollNeutralItem = CDOTAClientMsg_RerollNeutralItem {
            target_entindex: ::std::option::Option::None,
            slot_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_PlayerDraftPick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_PlayerDraftPick {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_PlayerDraftPick.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_PlayerDraftPick.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_PlayerDraftPick {
    fn default() -> &'a CDOTAClientMsg_PlayerDraftPick {
        <CDOTAClientMsg_PlayerDraftPick as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_PlayerDraftPick {
    pub fn new() -> CDOTAClientMsg_PlayerDraftPick {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_PlayerDraftPick {
    const NAME: &'static str = "CDOTAClientMsg_PlayerDraftPick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_PlayerDraftPick {
        CDOTAClientMsg_PlayerDraftPick::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_PlayerDraftPick {
        static instance: CDOTAClientMsg_PlayerDraftPick = CDOTAClientMsg_PlayerDraftPick {
            player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_PlayerDraftSuggest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_PlayerDraftSuggest {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_PlayerDraftSuggest.player_id)
    pub player_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_PlayerDraftSuggest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_PlayerDraftSuggest {
    fn default() -> &'a CDOTAClientMsg_PlayerDraftSuggest {
        <CDOTAClientMsg_PlayerDraftSuggest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_PlayerDraftSuggest {
    pub fn new() -> CDOTAClientMsg_PlayerDraftSuggest {
        ::std::default::Default::default()
    }

    // optional int32 player_id = 1;

    pub fn player_id(&self) -> i32 {
        self.player_id.unwrap_or(-1i32)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_PlayerDraftSuggest {
    const NAME: &'static str = "CDOTAClientMsg_PlayerDraftSuggest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_PlayerDraftSuggest {
        CDOTAClientMsg_PlayerDraftSuggest::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_PlayerDraftSuggest {
        static instance: CDOTAClientMsg_PlayerDraftSuggest = CDOTAClientMsg_PlayerDraftSuggest {
            player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_PlayerDraftPreferRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_PlayerDraftPreferRole {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_PlayerDraftPreferRole.role_idx)
    pub role_idx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_PlayerDraftPreferRole.desired)
    pub desired: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_PlayerDraftPreferRole.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_PlayerDraftPreferRole {
    fn default() -> &'a CDOTAClientMsg_PlayerDraftPreferRole {
        <CDOTAClientMsg_PlayerDraftPreferRole as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_PlayerDraftPreferRole {
    pub fn new() -> CDOTAClientMsg_PlayerDraftPreferRole {
        ::std::default::Default::default()
    }

    // optional int32 role_idx = 1;

    pub fn role_idx(&self) -> i32 {
        self.role_idx.unwrap_or(0)
    }

    pub fn clear_role_idx(&mut self) {
        self.role_idx = ::std::option::Option::None;
    }

    pub fn has_role_idx(&self) -> bool {
        self.role_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_idx(&mut self, v: i32) {
        self.role_idx = ::std::option::Option::Some(v);
    }

    // optional bool desired = 2;

    pub fn desired(&self) -> bool {
        self.desired.unwrap_or(false)
    }

    pub fn clear_desired(&mut self) {
        self.desired = ::std::option::Option::None;
    }

    pub fn has_desired(&self) -> bool {
        self.desired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired(&mut self, v: bool) {
        self.desired = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_PlayerDraftPreferRole {
    const NAME: &'static str = "CDOTAClientMsg_PlayerDraftPreferRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.role_idx = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.desired = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.role_idx {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.desired {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.role_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.desired {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_PlayerDraftPreferRole {
        CDOTAClientMsg_PlayerDraftPreferRole::new()
    }

    fn clear(&mut self) {
        self.role_idx = ::std::option::Option::None;
        self.desired = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_PlayerDraftPreferRole {
        static instance: CDOTAClientMsg_PlayerDraftPreferRole = CDOTAClientMsg_PlayerDraftPreferRole {
            role_idx: ::std::option::Option::None,
            desired: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_PlayerDraftPreferTeam)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_PlayerDraftPreferTeam {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_PlayerDraftPreferTeam.team)
    pub team: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_PlayerDraftPreferTeam.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_PlayerDraftPreferTeam {
    fn default() -> &'a CDOTAClientMsg_PlayerDraftPreferTeam {
        <CDOTAClientMsg_PlayerDraftPreferTeam as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_PlayerDraftPreferTeam {
    pub fn new() -> CDOTAClientMsg_PlayerDraftPreferTeam {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;

    pub fn team(&self) -> i32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_PlayerDraftPreferTeam {
    const NAME: &'static str = "CDOTAClientMsg_PlayerDraftPreferTeam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_PlayerDraftPreferTeam {
        CDOTAClientMsg_PlayerDraftPreferTeam::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_PlayerDraftPreferTeam {
        static instance: CDOTAClientMsg_PlayerDraftPreferTeam = CDOTAClientMsg_PlayerDraftPreferTeam {
            team: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_AbilityAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_AbilityAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_AbilityAlert.ability_entindex)
    pub ability_entindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_AbilityAlert.ctrl_held)
    pub ctrl_held: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_AbilityAlert.owner_entindex)
    pub owner_entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_AbilityAlert.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_AbilityAlert.primary_charges)
    pub primary_charges: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_AbilityAlert.secondary_charges)
    pub secondary_charges: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_AbilityAlert.reclaim_time)
    pub reclaim_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_AbilityAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_AbilityAlert {
    fn default() -> &'a CDOTAClientMsg_AbilityAlert {
        <CDOTAClientMsg_AbilityAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_AbilityAlert {
    pub fn new() -> CDOTAClientMsg_AbilityAlert {
        ::std::default::Default::default()
    }

    // optional uint32 ability_entindex = 1;

    pub fn ability_entindex(&self) -> u32 {
        self.ability_entindex.unwrap_or(16777215u32)
    }

    pub fn clear_ability_entindex(&mut self) {
        self.ability_entindex = ::std::option::Option::None;
    }

    pub fn has_ability_entindex(&self) -> bool {
        self.ability_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_entindex(&mut self, v: u32) {
        self.ability_entindex = ::std::option::Option::Some(v);
    }

    // optional bool ctrl_held = 2;

    pub fn ctrl_held(&self) -> bool {
        self.ctrl_held.unwrap_or(false)
    }

    pub fn clear_ctrl_held(&mut self) {
        self.ctrl_held = ::std::option::Option::None;
    }

    pub fn has_ctrl_held(&self) -> bool {
        self.ctrl_held.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctrl_held(&mut self, v: bool) {
        self.ctrl_held = ::std::option::Option::Some(v);
    }

    // optional int32 owner_entindex = 3;

    pub fn owner_entindex(&self) -> i32 {
        self.owner_entindex.unwrap_or(-1i32)
    }

    pub fn clear_owner_entindex(&mut self) {
        self.owner_entindex = ::std::option::Option::None;
    }

    pub fn has_owner_entindex(&self) -> bool {
        self.owner_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_entindex(&mut self, v: i32) {
        self.owner_entindex = ::std::option::Option::Some(v);
    }

    // optional int32 ability_id = 4;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(-1i32)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional uint32 primary_charges = 5;

    pub fn primary_charges(&self) -> u32 {
        self.primary_charges.unwrap_or(0)
    }

    pub fn clear_primary_charges(&mut self) {
        self.primary_charges = ::std::option::Option::None;
    }

    pub fn has_primary_charges(&self) -> bool {
        self.primary_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_charges(&mut self, v: u32) {
        self.primary_charges = ::std::option::Option::Some(v);
    }

    // optional uint32 secondary_charges = 6;

    pub fn secondary_charges(&self) -> u32 {
        self.secondary_charges.unwrap_or(0)
    }

    pub fn clear_secondary_charges(&mut self) {
        self.secondary_charges = ::std::option::Option::None;
    }

    pub fn has_secondary_charges(&self) -> bool {
        self.secondary_charges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary_charges(&mut self, v: u32) {
        self.secondary_charges = ::std::option::Option::Some(v);
    }

    // optional float reclaim_time = 7;

    pub fn reclaim_time(&self) -> f32 {
        self.reclaim_time.unwrap_or(0.)
    }

    pub fn clear_reclaim_time(&mut self) {
        self.reclaim_time = ::std::option::Option::None;
    }

    pub fn has_reclaim_time(&self) -> bool {
        self.reclaim_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reclaim_time(&mut self, v: f32) {
        self.reclaim_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_AbilityAlert {
    const NAME: &'static str = "CDOTAClientMsg_AbilityAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_entindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.ctrl_held = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.owner_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.primary_charges = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.secondary_charges = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.reclaim_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.ctrl_held {
            my_size += 1 + 1;
        }
        if let Some(v) = self.owner_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.primary_charges {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.secondary_charges {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.reclaim_time {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ability_entindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ctrl_held {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.owner_entindex {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.primary_charges {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.secondary_charges {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.reclaim_time {
            os.write_float(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_AbilityAlert {
        CDOTAClientMsg_AbilityAlert::new()
    }

    fn clear(&mut self) {
        self.ability_entindex = ::std::option::Option::None;
        self.ctrl_held = ::std::option::Option::None;
        self.owner_entindex = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.primary_charges = ::std::option::Option::None;
        self.secondary_charges = ::std::option::Option::None;
        self.reclaim_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_AbilityAlert {
        static instance: CDOTAClientMsg_AbilityAlert = CDOTAClientMsg_AbilityAlert {
            ability_entindex: ::std::option::Option::None,
            ctrl_held: ::std::option::Option::None,
            owner_entindex: ::std::option::Option::None,
            ability_id: ::std::option::Option::None,
            primary_charges: ::std::option::Option::None,
            secondary_charges: ::std::option::Option::None,
            reclaim_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_SelectOverworldTokenRewards)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SelectOverworldTokenRewards {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_SelectOverworldTokenRewards.token_ids)
    pub token_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_SelectOverworldTokenRewards.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SelectOverworldTokenRewards {
    fn default() -> &'a CDOTAClientMsg_SelectOverworldTokenRewards {
        <CDOTAClientMsg_SelectOverworldTokenRewards as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SelectOverworldTokenRewards {
    pub fn new() -> CDOTAClientMsg_SelectOverworldTokenRewards {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_SelectOverworldTokenRewards {
    const NAME: &'static str = "CDOTAClientMsg_SelectOverworldTokenRewards";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.token_ids)?;
                },
                8 => {
                    self.token_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.token_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.token_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SelectOverworldTokenRewards {
        CDOTAClientMsg_SelectOverworldTokenRewards::new()
    }

    fn clear(&mut self) {
        self.token_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SelectOverworldTokenRewards {
        static instance: CDOTAClientMsg_SelectOverworldTokenRewards = CDOTAClientMsg_SelectOverworldTokenRewards {
            token_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_FacetAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_FacetAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_FacetAlert.facet_strhash)
    pub facet_strhash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_FacetAlert.hero_entindex)
    pub hero_entindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_FacetAlert.ctrl_held)
    pub ctrl_held: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_FacetAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_FacetAlert {
    fn default() -> &'a CDOTAClientMsg_FacetAlert {
        <CDOTAClientMsg_FacetAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_FacetAlert {
    pub fn new() -> CDOTAClientMsg_FacetAlert {
        ::std::default::Default::default()
    }

    // optional uint32 facet_strhash = 1;

    pub fn facet_strhash(&self) -> u32 {
        self.facet_strhash.unwrap_or(0)
    }

    pub fn clear_facet_strhash(&mut self) {
        self.facet_strhash = ::std::option::Option::None;
    }

    pub fn has_facet_strhash(&self) -> bool {
        self.facet_strhash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_facet_strhash(&mut self, v: u32) {
        self.facet_strhash = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_entindex = 2;

    pub fn hero_entindex(&self) -> u32 {
        self.hero_entindex.unwrap_or(16777215u32)
    }

    pub fn clear_hero_entindex(&mut self) {
        self.hero_entindex = ::std::option::Option::None;
    }

    pub fn has_hero_entindex(&self) -> bool {
        self.hero_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_entindex(&mut self, v: u32) {
        self.hero_entindex = ::std::option::Option::Some(v);
    }

    // optional bool ctrl_held = 3;

    pub fn ctrl_held(&self) -> bool {
        self.ctrl_held.unwrap_or(false)
    }

    pub fn clear_ctrl_held(&mut self) {
        self.ctrl_held = ::std::option::Option::None;
    }

    pub fn has_ctrl_held(&self) -> bool {
        self.ctrl_held.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctrl_held(&mut self, v: bool) {
        self.ctrl_held = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_FacetAlert {
    const NAME: &'static str = "CDOTAClientMsg_FacetAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.facet_strhash = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hero_entindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.ctrl_held = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.facet_strhash {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hero_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.ctrl_held {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.facet_strhash {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_entindex {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ctrl_held {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_FacetAlert {
        CDOTAClientMsg_FacetAlert::new()
    }

    fn clear(&mut self) {
        self.facet_strhash = ::std::option::Option::None;
        self.hero_entindex = ::std::option::Option::None;
        self.ctrl_held = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_FacetAlert {
        static instance: CDOTAClientMsg_FacetAlert = CDOTAClientMsg_FacetAlert {
            facet_strhash: ::std::option::Option::None,
            hero_entindex: ::std::option::Option::None,
            ctrl_held: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_InnateAlert)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_InnateAlert {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_InnateAlert.ability_entindex)
    pub ability_entindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDOTAClientMsg_InnateAlert.ctrl_held)
    pub ctrl_held: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_InnateAlert.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_InnateAlert {
    fn default() -> &'a CDOTAClientMsg_InnateAlert {
        <CDOTAClientMsg_InnateAlert as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_InnateAlert {
    pub fn new() -> CDOTAClientMsg_InnateAlert {
        ::std::default::Default::default()
    }

    // optional uint32 ability_entindex = 1;

    pub fn ability_entindex(&self) -> u32 {
        self.ability_entindex.unwrap_or(16777215u32)
    }

    pub fn clear_ability_entindex(&mut self) {
        self.ability_entindex = ::std::option::Option::None;
    }

    pub fn has_ability_entindex(&self) -> bool {
        self.ability_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_entindex(&mut self, v: u32) {
        self.ability_entindex = ::std::option::Option::Some(v);
    }

    // optional bool ctrl_held = 2;

    pub fn ctrl_held(&self) -> bool {
        self.ctrl_held.unwrap_or(false)
    }

    pub fn clear_ctrl_held(&mut self) {
        self.ctrl_held = ::std::option::Option::None;
    }

    pub fn has_ctrl_held(&self) -> bool {
        self.ctrl_held.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctrl_held(&mut self, v: bool) {
        self.ctrl_held = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_InnateAlert {
    const NAME: &'static str = "CDOTAClientMsg_InnateAlert";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_entindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.ctrl_held = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.ctrl_held {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ability_entindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ctrl_held {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_InnateAlert {
        CDOTAClientMsg_InnateAlert::new()
    }

    fn clear(&mut self) {
        self.ability_entindex = ::std::option::Option::None;
        self.ctrl_held = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_InnateAlert {
        static instance: CDOTAClientMsg_InnateAlert = CDOTAClientMsg_InnateAlert {
            ability_entindex: ::std::option::Option::None,
            ctrl_held: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CDOTAClientMsg_SelectOverworldID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDOTAClientMsg_SelectOverworldID {
    // message fields
    // @@protoc_insertion_point(field:CDOTAClientMsg_SelectOverworldID.overworld_id)
    pub overworld_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDOTAClientMsg_SelectOverworldID.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDOTAClientMsg_SelectOverworldID {
    fn default() -> &'a CDOTAClientMsg_SelectOverworldID {
        <CDOTAClientMsg_SelectOverworldID as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CDOTAClientMsg_SelectOverworldID {
    pub fn new() -> CDOTAClientMsg_SelectOverworldID {
        ::std::default::Default::default()
    }

    // optional uint32 overworld_id = 1;

    pub fn overworld_id(&self) -> u32 {
        self.overworld_id.unwrap_or(0)
    }

    pub fn clear_overworld_id(&mut self) {
        self.overworld_id = ::std::option::Option::None;
    }

    pub fn has_overworld_id(&self) -> bool {
        self.overworld_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overworld_id(&mut self, v: u32) {
        self.overworld_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CDOTAClientMsg_SelectOverworldID {
    const NAME: &'static str = "CDOTAClientMsg_SelectOverworldID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overworld_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overworld_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDOTAClientMsg_SelectOverworldID {
        CDOTAClientMsg_SelectOverworldID::new()
    }

    fn clear(&mut self) {
        self.overworld_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDOTAClientMsg_SelectOverworldID {
        static instance: CDOTAClientMsg_SelectOverworldID = CDOTAClientMsg_SelectOverworldID {
            overworld_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EDotaClientMessages)
pub enum EDotaClientMessages {
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_MapLine)
    DOTA_CM_MapLine = 301,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_AspectRatio)
    DOTA_CM_AspectRatio = 302,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_MapPing)
    DOTA_CM_MapPing = 303,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_UnitsAutoAttack)
    DOTA_CM_UnitsAutoAttack = 304,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_SearchString)
    DOTA_CM_SearchString = 307,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_Pause)
    DOTA_CM_Pause = 308,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_ShopViewMode)
    DOTA_CM_ShopViewMode = 309,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_SetUnitShareFlag)
    DOTA_CM_SetUnitShareFlag = 310,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_SwapRequest)
    DOTA_CM_SwapRequest = 311,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_SwapAccept)
    DOTA_CM_SwapAccept = 312,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_WorldLine)
    DOTA_CM_WorldLine = 313,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_RequestGraphUpdate)
    DOTA_CM_RequestGraphUpdate = 314,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_ItemAlert)
    DOTA_CM_ItemAlert = 315,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_ChatWheel)
    DOTA_CM_ChatWheel = 316,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_SendStatPopup)
    DOTA_CM_SendStatPopup = 317,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_BeginLastHitChallenge)
    DOTA_CM_BeginLastHitChallenge = 318,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_UpdateQuickBuy)
    DOTA_CM_UpdateQuickBuy = 319,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_UpdateCoachListen)
    DOTA_CM_UpdateCoachListen = 320,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_CoachHUDPing)
    DOTA_CM_CoachHUDPing = 321,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_RecordVote)
    DOTA_CM_RecordVote = 322,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_UnitsAutoAttackAfterSpell)
    DOTA_CM_UnitsAutoAttackAfterSpell = 323,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_WillPurchaseAlert)
    DOTA_CM_WillPurchaseAlert = 324,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_PlayerShowCase)
    DOTA_CM_PlayerShowCase = 325,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_TeleportRequiresHalt)
    DOTA_CM_TeleportRequiresHalt = 326,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_CameraZoomAmount)
    DOTA_CM_CameraZoomAmount = 327,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_BroadcasterUsingCamerman)
    DOTA_CM_BroadcasterUsingCamerman = 328,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_BroadcasterUsingAssistedCameraOperator)
    DOTA_CM_BroadcasterUsingAssistedCameraOperator = 329,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_EnemyItemAlert)
    DOTA_CM_EnemyItemAlert = 330,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_FreeInventory)
    DOTA_CM_FreeInventory = 331,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_BuyBackStateAlert)
    DOTA_CM_BuyBackStateAlert = 332,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_QuickBuyAlert)
    DOTA_CM_QuickBuyAlert = 333,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_HeroStatueLike)
    DOTA_CM_HeroStatueLike = 334,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_ModifierAlert)
    DOTA_CM_ModifierAlert = 335,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_TeamShowcaseEditor)
    DOTA_CM_TeamShowcaseEditor = 336,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_HPManaAlert)
    DOTA_CM_HPManaAlert = 337,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_GlyphAlert)
    DOTA_CM_GlyphAlert = 338,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_TeamShowcaseClientData)
    DOTA_CM_TeamShowcaseClientData = 339,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_PlayTeamShowcase)
    DOTA_CM_PlayTeamShowcase = 340,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_EventCNY2015Cmd)
    DOTA_CM_EventCNY2015Cmd = 341,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_FillEmptySlotsWithBots)
    DOTA_CM_FillEmptySlotsWithBots = 342,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_DemoHero)
    DOTA_CM_DemoHero = 343,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_AbilityLearnModeToggled)
    DOTA_CM_AbilityLearnModeToggled = 344,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_AbilityStartUse)
    DOTA_CM_AbilityStartUse = 345,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_ChallengeSelect)
    DOTA_CM_ChallengeSelect = 346,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_ChallengeReroll)
    DOTA_CM_ChallengeReroll = 347,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_ClickedBuff)
    DOTA_CM_ClickedBuff = 348,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_CoinWager)
    DOTA_CM_CoinWager = 349,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_ExecuteOrders)
    DOTA_CM_ExecuteOrders = 350,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_XPAlert)
    DOTA_CM_XPAlert = 351,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_EventPointsTip)
    DOTA_CM_EventPointsTip = 353,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_KillMyHero)
    DOTA_CM_KillMyHero = 355,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_QuestStatus)
    DOTA_CM_QuestStatus = 356,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_ToggleAutoattack)
    DOTA_CM_ToggleAutoattack = 357,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_SpecialAbility)
    DOTA_CM_SpecialAbility = 358,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_KillcamDamageTaken)
    DOTA_CM_KillcamDamageTaken = 359,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_SetEnemyStartingPosition)
    DOTA_CM_SetEnemyStartingPosition = 360,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_SetDesiredWardPlacement)
    DOTA_CM_SetDesiredWardPlacement = 361,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_RollDice)
    DOTA_CM_RollDice = 362,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_FlipCoin)
    DOTA_CM_FlipCoin = 363,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_RequestItemSuggestions)
    DOTA_CM_RequestItemSuggestions = 364,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_MakeTeamCaptain)
    DOTA_CM_MakeTeamCaptain = 365,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_CoinWagerToken)
    DOTA_CM_CoinWagerToken = 366,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_RankWager)
    DOTA_CM_RankWager = 367,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_DismissAllStatPopups)
    DOTA_CM_DismissAllStatPopups = 368,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_HelpTipSystemStateChanged)
    DOTA_CM_HelpTipSystemStateChanged = 369,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_ChannelRequiresHalt)
    DOTA_CM_ChannelRequiresHalt = 370,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_RequestBulkCombatLog)
    DOTA_CM_RequestBulkCombatLog = 371,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_AbilityDraftRequestAbility)
    DOTA_CM_AbilityDraftRequestAbility = 372,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_GuideSelectOption)
    DOTA_CM_GuideSelectOption = 373,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_GuideSelected)
    DOTA_CM_GuideSelected = 374,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_DamageReport)
    DOTA_CM_DamageReport = 375,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_SalutePlayer)
    DOTA_CM_SalutePlayer = 376,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_SprayWheel)
    DOTA_CM_SprayWheel = 377,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_TipAlert)
    DOTA_CM_TipAlert = 378,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_EmptyTeleportAlert)
    DOTA_CM_EmptyTeleportAlert = 379,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_RadarAlert)
    DOTA_CM_RadarAlert = 380,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_TalentTreeAlert)
    DOTA_CM_TalentTreeAlert = 381,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_SetCavernMapVariant)
    DOTA_CM_SetCavernMapVariant = 382,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_PauseGameOrder)
    DOTA_CM_PauseGameOrder = 383,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_VersusScene_PlayerBehavior)
    DOTA_CM_VersusScene_PlayerBehavior = 384,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_PlayerBounty)
    DOTA_CM_PlayerBounty = 385,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_PlayerBountyCancel)
    DOTA_CM_PlayerBountyCancel = 386,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_EmptyItemSlotAlert)
    DOTA_CM_EmptyItemSlotAlert = 388,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_AddOverwatchReportMarker)
    DOTA_CM_AddOverwatchReportMarker = 389,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_AghsStatusAlert)
    DOTA_CM_AghsStatusAlert = 390,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_PerfReport)
    DOTA_CM_PerfReport = 391,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_ContextualTips_Subscribe)
    DOTA_CM_ContextualTips_Subscribe = 393,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_ChatMessage)
    DOTA_CM_ChatMessage = 394,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_AddCommunicationsReportMarker)
    DOTA_CM_AddCommunicationsReportMarker = 395,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_AddCommunicationsBlockMarker)
    DOTA_CM_AddCommunicationsBlockMarker = 396,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_NeutralCampAlert)
    DOTA_CM_NeutralCampAlert = 397,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_DuelAccepted)
    DOTA_CM_DuelAccepted = 398,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_ChooseNeutralItem)
    DOTA_CM_ChooseNeutralItem = 399,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_PlayerDraftPick)
    DOTA_CM_PlayerDraftPick = 800,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_PlayerDraftSuggest)
    DOTA_CM_PlayerDraftSuggest = 801,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_PlayerDraftPreferRole)
    DOTA_CM_PlayerDraftPreferRole = 802,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_PlayerDraftPreferTeam)
    DOTA_CM_PlayerDraftPreferTeam = 803,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_ChatWheelAlert)
    DOTA_CM_ChatWheelAlert = 804,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_AbilityAlert)
    DOTA_CM_AbilityAlert = 805,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_AllyAbilityAlert)
    DOTA_CM_AllyAbilityAlert = 806,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_GiftPlayer)
    DOTA_CM_GiftPlayer = 807,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_GiftEveryone)
    DOTA_CM_GiftEveryone = 808,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_SelectOverworldTokenRewards)
    DOTA_CM_SelectOverworldTokenRewards = 809,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_FacetAlert)
    DOTA_CM_FacetAlert = 810,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_InnateAlert)
    DOTA_CM_InnateAlert = 811,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_SelectOverworldID)
    DOTA_CM_SelectOverworldID = 812,
    // @@protoc_insertion_point(enum_value:EDotaClientMessages.DOTA_CM_RerollNeutralItem)
    DOTA_CM_RerollNeutralItem = 813,
}

impl ::steam_vent_proto_common::protobuf::Enum for EDotaClientMessages {
    const NAME: &'static str = "EDotaClientMessages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDotaClientMessages> {
        match value {
            301 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_MapLine),
            302 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AspectRatio),
            303 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_MapPing),
            304 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_UnitsAutoAttack),
            307 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SearchString),
            308 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_Pause),
            309 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ShopViewMode),
            310 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SetUnitShareFlag),
            311 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SwapRequest),
            312 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SwapAccept),
            313 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_WorldLine),
            314 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RequestGraphUpdate),
            315 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ItemAlert),
            316 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChatWheel),
            317 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SendStatPopup),
            318 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_BeginLastHitChallenge),
            319 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_UpdateQuickBuy),
            320 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_UpdateCoachListen),
            321 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_CoachHUDPing),
            322 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RecordVote),
            323 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_UnitsAutoAttackAfterSpell),
            324 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_WillPurchaseAlert),
            325 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerShowCase),
            326 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TeleportRequiresHalt),
            327 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_CameraZoomAmount),
            328 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_BroadcasterUsingCamerman),
            329 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_BroadcasterUsingAssistedCameraOperator),
            330 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EnemyItemAlert),
            331 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_FreeInventory),
            332 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_BuyBackStateAlert),
            333 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_QuickBuyAlert),
            334 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_HeroStatueLike),
            335 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ModifierAlert),
            336 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TeamShowcaseEditor),
            337 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_HPManaAlert),
            338 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_GlyphAlert),
            339 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TeamShowcaseClientData),
            340 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayTeamShowcase),
            341 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EventCNY2015Cmd),
            342 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_FillEmptySlotsWithBots),
            343 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_DemoHero),
            344 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AbilityLearnModeToggled),
            345 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AbilityStartUse),
            346 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChallengeSelect),
            347 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChallengeReroll),
            348 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ClickedBuff),
            349 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_CoinWager),
            350 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ExecuteOrders),
            351 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_XPAlert),
            353 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EventPointsTip),
            355 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_KillMyHero),
            356 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_QuestStatus),
            357 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ToggleAutoattack),
            358 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SpecialAbility),
            359 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_KillcamDamageTaken),
            360 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SetEnemyStartingPosition),
            361 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SetDesiredWardPlacement),
            362 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RollDice),
            363 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_FlipCoin),
            364 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RequestItemSuggestions),
            365 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_MakeTeamCaptain),
            366 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_CoinWagerToken),
            367 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RankWager),
            368 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_DismissAllStatPopups),
            369 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_HelpTipSystemStateChanged),
            370 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChannelRequiresHalt),
            371 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RequestBulkCombatLog),
            372 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AbilityDraftRequestAbility),
            373 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_GuideSelectOption),
            374 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_GuideSelected),
            375 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_DamageReport),
            376 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SalutePlayer),
            377 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SprayWheel),
            378 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TipAlert),
            379 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EmptyTeleportAlert),
            380 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RadarAlert),
            381 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TalentTreeAlert),
            382 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SetCavernMapVariant),
            383 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PauseGameOrder),
            384 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_VersusScene_PlayerBehavior),
            385 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerBounty),
            386 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerBountyCancel),
            388 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EmptyItemSlotAlert),
            389 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AddOverwatchReportMarker),
            390 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AghsStatusAlert),
            391 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PerfReport),
            393 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ContextualTips_Subscribe),
            394 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChatMessage),
            395 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AddCommunicationsReportMarker),
            396 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AddCommunicationsBlockMarker),
            397 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_NeutralCampAlert),
            398 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_DuelAccepted),
            399 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChooseNeutralItem),
            800 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerDraftPick),
            801 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerDraftSuggest),
            802 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerDraftPreferRole),
            803 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerDraftPreferTeam),
            804 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChatWheelAlert),
            805 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AbilityAlert),
            806 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AllyAbilityAlert),
            807 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_GiftPlayer),
            808 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_GiftEveryone),
            809 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SelectOverworldTokenRewards),
            810 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_FacetAlert),
            811 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_InnateAlert),
            812 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SelectOverworldID),
            813 => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RerollNeutralItem),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDotaClientMessages> {
        match str {
            "DOTA_CM_MapLine" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_MapLine),
            "DOTA_CM_AspectRatio" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AspectRatio),
            "DOTA_CM_MapPing" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_MapPing),
            "DOTA_CM_UnitsAutoAttack" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_UnitsAutoAttack),
            "DOTA_CM_SearchString" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SearchString),
            "DOTA_CM_Pause" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_Pause),
            "DOTA_CM_ShopViewMode" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ShopViewMode),
            "DOTA_CM_SetUnitShareFlag" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SetUnitShareFlag),
            "DOTA_CM_SwapRequest" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SwapRequest),
            "DOTA_CM_SwapAccept" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SwapAccept),
            "DOTA_CM_WorldLine" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_WorldLine),
            "DOTA_CM_RequestGraphUpdate" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RequestGraphUpdate),
            "DOTA_CM_ItemAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ItemAlert),
            "DOTA_CM_ChatWheel" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChatWheel),
            "DOTA_CM_SendStatPopup" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SendStatPopup),
            "DOTA_CM_BeginLastHitChallenge" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_BeginLastHitChallenge),
            "DOTA_CM_UpdateQuickBuy" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_UpdateQuickBuy),
            "DOTA_CM_UpdateCoachListen" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_UpdateCoachListen),
            "DOTA_CM_CoachHUDPing" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_CoachHUDPing),
            "DOTA_CM_RecordVote" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RecordVote),
            "DOTA_CM_UnitsAutoAttackAfterSpell" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_UnitsAutoAttackAfterSpell),
            "DOTA_CM_WillPurchaseAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_WillPurchaseAlert),
            "DOTA_CM_PlayerShowCase" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerShowCase),
            "DOTA_CM_TeleportRequiresHalt" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TeleportRequiresHalt),
            "DOTA_CM_CameraZoomAmount" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_CameraZoomAmount),
            "DOTA_CM_BroadcasterUsingCamerman" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_BroadcasterUsingCamerman),
            "DOTA_CM_BroadcasterUsingAssistedCameraOperator" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_BroadcasterUsingAssistedCameraOperator),
            "DOTA_CM_EnemyItemAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EnemyItemAlert),
            "DOTA_CM_FreeInventory" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_FreeInventory),
            "DOTA_CM_BuyBackStateAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_BuyBackStateAlert),
            "DOTA_CM_QuickBuyAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_QuickBuyAlert),
            "DOTA_CM_HeroStatueLike" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_HeroStatueLike),
            "DOTA_CM_ModifierAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ModifierAlert),
            "DOTA_CM_TeamShowcaseEditor" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TeamShowcaseEditor),
            "DOTA_CM_HPManaAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_HPManaAlert),
            "DOTA_CM_GlyphAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_GlyphAlert),
            "DOTA_CM_TeamShowcaseClientData" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TeamShowcaseClientData),
            "DOTA_CM_PlayTeamShowcase" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayTeamShowcase),
            "DOTA_CM_EventCNY2015Cmd" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EventCNY2015Cmd),
            "DOTA_CM_FillEmptySlotsWithBots" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_FillEmptySlotsWithBots),
            "DOTA_CM_DemoHero" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_DemoHero),
            "DOTA_CM_AbilityLearnModeToggled" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AbilityLearnModeToggled),
            "DOTA_CM_AbilityStartUse" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AbilityStartUse),
            "DOTA_CM_ChallengeSelect" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChallengeSelect),
            "DOTA_CM_ChallengeReroll" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChallengeReroll),
            "DOTA_CM_ClickedBuff" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ClickedBuff),
            "DOTA_CM_CoinWager" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_CoinWager),
            "DOTA_CM_ExecuteOrders" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ExecuteOrders),
            "DOTA_CM_XPAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_XPAlert),
            "DOTA_CM_EventPointsTip" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EventPointsTip),
            "DOTA_CM_KillMyHero" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_KillMyHero),
            "DOTA_CM_QuestStatus" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_QuestStatus),
            "DOTA_CM_ToggleAutoattack" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ToggleAutoattack),
            "DOTA_CM_SpecialAbility" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SpecialAbility),
            "DOTA_CM_KillcamDamageTaken" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_KillcamDamageTaken),
            "DOTA_CM_SetEnemyStartingPosition" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SetEnemyStartingPosition),
            "DOTA_CM_SetDesiredWardPlacement" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SetDesiredWardPlacement),
            "DOTA_CM_RollDice" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RollDice),
            "DOTA_CM_FlipCoin" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_FlipCoin),
            "DOTA_CM_RequestItemSuggestions" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RequestItemSuggestions),
            "DOTA_CM_MakeTeamCaptain" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_MakeTeamCaptain),
            "DOTA_CM_CoinWagerToken" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_CoinWagerToken),
            "DOTA_CM_RankWager" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RankWager),
            "DOTA_CM_DismissAllStatPopups" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_DismissAllStatPopups),
            "DOTA_CM_HelpTipSystemStateChanged" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_HelpTipSystemStateChanged),
            "DOTA_CM_ChannelRequiresHalt" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChannelRequiresHalt),
            "DOTA_CM_RequestBulkCombatLog" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RequestBulkCombatLog),
            "DOTA_CM_AbilityDraftRequestAbility" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AbilityDraftRequestAbility),
            "DOTA_CM_GuideSelectOption" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_GuideSelectOption),
            "DOTA_CM_GuideSelected" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_GuideSelected),
            "DOTA_CM_DamageReport" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_DamageReport),
            "DOTA_CM_SalutePlayer" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SalutePlayer),
            "DOTA_CM_SprayWheel" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SprayWheel),
            "DOTA_CM_TipAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TipAlert),
            "DOTA_CM_EmptyTeleportAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EmptyTeleportAlert),
            "DOTA_CM_RadarAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RadarAlert),
            "DOTA_CM_TalentTreeAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_TalentTreeAlert),
            "DOTA_CM_SetCavernMapVariant" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SetCavernMapVariant),
            "DOTA_CM_PauseGameOrder" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PauseGameOrder),
            "DOTA_CM_VersusScene_PlayerBehavior" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_VersusScene_PlayerBehavior),
            "DOTA_CM_PlayerBounty" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerBounty),
            "DOTA_CM_PlayerBountyCancel" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerBountyCancel),
            "DOTA_CM_EmptyItemSlotAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_EmptyItemSlotAlert),
            "DOTA_CM_AddOverwatchReportMarker" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AddOverwatchReportMarker),
            "DOTA_CM_AghsStatusAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AghsStatusAlert),
            "DOTA_CM_PerfReport" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PerfReport),
            "DOTA_CM_ContextualTips_Subscribe" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ContextualTips_Subscribe),
            "DOTA_CM_ChatMessage" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChatMessage),
            "DOTA_CM_AddCommunicationsReportMarker" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AddCommunicationsReportMarker),
            "DOTA_CM_AddCommunicationsBlockMarker" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AddCommunicationsBlockMarker),
            "DOTA_CM_NeutralCampAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_NeutralCampAlert),
            "DOTA_CM_DuelAccepted" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_DuelAccepted),
            "DOTA_CM_ChooseNeutralItem" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChooseNeutralItem),
            "DOTA_CM_PlayerDraftPick" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerDraftPick),
            "DOTA_CM_PlayerDraftSuggest" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerDraftSuggest),
            "DOTA_CM_PlayerDraftPreferRole" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerDraftPreferRole),
            "DOTA_CM_PlayerDraftPreferTeam" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_PlayerDraftPreferTeam),
            "DOTA_CM_ChatWheelAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_ChatWheelAlert),
            "DOTA_CM_AbilityAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AbilityAlert),
            "DOTA_CM_AllyAbilityAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_AllyAbilityAlert),
            "DOTA_CM_GiftPlayer" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_GiftPlayer),
            "DOTA_CM_GiftEveryone" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_GiftEveryone),
            "DOTA_CM_SelectOverworldTokenRewards" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SelectOverworldTokenRewards),
            "DOTA_CM_FacetAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_FacetAlert),
            "DOTA_CM_InnateAlert" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_InnateAlert),
            "DOTA_CM_SelectOverworldID" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_SelectOverworldID),
            "DOTA_CM_RerollNeutralItem" => ::std::option::Option::Some(EDotaClientMessages::DOTA_CM_RerollNeutralItem),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDotaClientMessages] = &[
        EDotaClientMessages::DOTA_CM_MapLine,
        EDotaClientMessages::DOTA_CM_AspectRatio,
        EDotaClientMessages::DOTA_CM_MapPing,
        EDotaClientMessages::DOTA_CM_UnitsAutoAttack,
        EDotaClientMessages::DOTA_CM_SearchString,
        EDotaClientMessages::DOTA_CM_Pause,
        EDotaClientMessages::DOTA_CM_ShopViewMode,
        EDotaClientMessages::DOTA_CM_SetUnitShareFlag,
        EDotaClientMessages::DOTA_CM_SwapRequest,
        EDotaClientMessages::DOTA_CM_SwapAccept,
        EDotaClientMessages::DOTA_CM_WorldLine,
        EDotaClientMessages::DOTA_CM_RequestGraphUpdate,
        EDotaClientMessages::DOTA_CM_ItemAlert,
        EDotaClientMessages::DOTA_CM_ChatWheel,
        EDotaClientMessages::DOTA_CM_SendStatPopup,
        EDotaClientMessages::DOTA_CM_BeginLastHitChallenge,
        EDotaClientMessages::DOTA_CM_UpdateQuickBuy,
        EDotaClientMessages::DOTA_CM_UpdateCoachListen,
        EDotaClientMessages::DOTA_CM_CoachHUDPing,
        EDotaClientMessages::DOTA_CM_RecordVote,
        EDotaClientMessages::DOTA_CM_UnitsAutoAttackAfterSpell,
        EDotaClientMessages::DOTA_CM_WillPurchaseAlert,
        EDotaClientMessages::DOTA_CM_PlayerShowCase,
        EDotaClientMessages::DOTA_CM_TeleportRequiresHalt,
        EDotaClientMessages::DOTA_CM_CameraZoomAmount,
        EDotaClientMessages::DOTA_CM_BroadcasterUsingCamerman,
        EDotaClientMessages::DOTA_CM_BroadcasterUsingAssistedCameraOperator,
        EDotaClientMessages::DOTA_CM_EnemyItemAlert,
        EDotaClientMessages::DOTA_CM_FreeInventory,
        EDotaClientMessages::DOTA_CM_BuyBackStateAlert,
        EDotaClientMessages::DOTA_CM_QuickBuyAlert,
        EDotaClientMessages::DOTA_CM_HeroStatueLike,
        EDotaClientMessages::DOTA_CM_ModifierAlert,
        EDotaClientMessages::DOTA_CM_TeamShowcaseEditor,
        EDotaClientMessages::DOTA_CM_HPManaAlert,
        EDotaClientMessages::DOTA_CM_GlyphAlert,
        EDotaClientMessages::DOTA_CM_TeamShowcaseClientData,
        EDotaClientMessages::DOTA_CM_PlayTeamShowcase,
        EDotaClientMessages::DOTA_CM_EventCNY2015Cmd,
        EDotaClientMessages::DOTA_CM_FillEmptySlotsWithBots,
        EDotaClientMessages::DOTA_CM_DemoHero,
        EDotaClientMessages::DOTA_CM_AbilityLearnModeToggled,
        EDotaClientMessages::DOTA_CM_AbilityStartUse,
        EDotaClientMessages::DOTA_CM_ChallengeSelect,
        EDotaClientMessages::DOTA_CM_ChallengeReroll,
        EDotaClientMessages::DOTA_CM_ClickedBuff,
        EDotaClientMessages::DOTA_CM_CoinWager,
        EDotaClientMessages::DOTA_CM_ExecuteOrders,
        EDotaClientMessages::DOTA_CM_XPAlert,
        EDotaClientMessages::DOTA_CM_EventPointsTip,
        EDotaClientMessages::DOTA_CM_KillMyHero,
        EDotaClientMessages::DOTA_CM_QuestStatus,
        EDotaClientMessages::DOTA_CM_ToggleAutoattack,
        EDotaClientMessages::DOTA_CM_SpecialAbility,
        EDotaClientMessages::DOTA_CM_KillcamDamageTaken,
        EDotaClientMessages::DOTA_CM_SetEnemyStartingPosition,
        EDotaClientMessages::DOTA_CM_SetDesiredWardPlacement,
        EDotaClientMessages::DOTA_CM_RollDice,
        EDotaClientMessages::DOTA_CM_FlipCoin,
        EDotaClientMessages::DOTA_CM_RequestItemSuggestions,
        EDotaClientMessages::DOTA_CM_MakeTeamCaptain,
        EDotaClientMessages::DOTA_CM_CoinWagerToken,
        EDotaClientMessages::DOTA_CM_RankWager,
        EDotaClientMessages::DOTA_CM_DismissAllStatPopups,
        EDotaClientMessages::DOTA_CM_HelpTipSystemStateChanged,
        EDotaClientMessages::DOTA_CM_ChannelRequiresHalt,
        EDotaClientMessages::DOTA_CM_RequestBulkCombatLog,
        EDotaClientMessages::DOTA_CM_AbilityDraftRequestAbility,
        EDotaClientMessages::DOTA_CM_GuideSelectOption,
        EDotaClientMessages::DOTA_CM_GuideSelected,
        EDotaClientMessages::DOTA_CM_DamageReport,
        EDotaClientMessages::DOTA_CM_SalutePlayer,
        EDotaClientMessages::DOTA_CM_SprayWheel,
        EDotaClientMessages::DOTA_CM_TipAlert,
        EDotaClientMessages::DOTA_CM_EmptyTeleportAlert,
        EDotaClientMessages::DOTA_CM_RadarAlert,
        EDotaClientMessages::DOTA_CM_TalentTreeAlert,
        EDotaClientMessages::DOTA_CM_SetCavernMapVariant,
        EDotaClientMessages::DOTA_CM_PauseGameOrder,
        EDotaClientMessages::DOTA_CM_VersusScene_PlayerBehavior,
        EDotaClientMessages::DOTA_CM_PlayerBounty,
        EDotaClientMessages::DOTA_CM_PlayerBountyCancel,
        EDotaClientMessages::DOTA_CM_EmptyItemSlotAlert,
        EDotaClientMessages::DOTA_CM_AddOverwatchReportMarker,
        EDotaClientMessages::DOTA_CM_AghsStatusAlert,
        EDotaClientMessages::DOTA_CM_PerfReport,
        EDotaClientMessages::DOTA_CM_ContextualTips_Subscribe,
        EDotaClientMessages::DOTA_CM_ChatMessage,
        EDotaClientMessages::DOTA_CM_AddCommunicationsReportMarker,
        EDotaClientMessages::DOTA_CM_AddCommunicationsBlockMarker,
        EDotaClientMessages::DOTA_CM_NeutralCampAlert,
        EDotaClientMessages::DOTA_CM_DuelAccepted,
        EDotaClientMessages::DOTA_CM_ChooseNeutralItem,
        EDotaClientMessages::DOTA_CM_PlayerDraftPick,
        EDotaClientMessages::DOTA_CM_PlayerDraftSuggest,
        EDotaClientMessages::DOTA_CM_PlayerDraftPreferRole,
        EDotaClientMessages::DOTA_CM_PlayerDraftPreferTeam,
        EDotaClientMessages::DOTA_CM_ChatWheelAlert,
        EDotaClientMessages::DOTA_CM_AbilityAlert,
        EDotaClientMessages::DOTA_CM_AllyAbilityAlert,
        EDotaClientMessages::DOTA_CM_GiftPlayer,
        EDotaClientMessages::DOTA_CM_GiftEveryone,
        EDotaClientMessages::DOTA_CM_SelectOverworldTokenRewards,
        EDotaClientMessages::DOTA_CM_FacetAlert,
        EDotaClientMessages::DOTA_CM_InnateAlert,
        EDotaClientMessages::DOTA_CM_SelectOverworldID,
        EDotaClientMessages::DOTA_CM_RerollNeutralItem,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EDotaClientMessages {
    fn default() -> Self {
        EDotaClientMessages::DOTA_CM_MapLine
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::dota_commonmessages::*;
#[allow(unused_imports)]
use crate::dota_shared_enums::*;
#[allow(unused_imports)]
use crate::base_gcmessages::*;
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_MapPing {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_ItemAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_EnemyItemAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_ModifierAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_ClickedBuff {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_HPManaAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_NeutralCampAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_GlyphAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_RadarAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_MapLine {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_AspectRatio {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_UnitsAutoAttackMode {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_UnitsAutoAttackAfterSpell {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_TeleportRequiresHalt {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_ChannelRequiresHalt {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_SearchString {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_Pause {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_ShopViewMode {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_SetUnitShareFlag {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_SwapRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_SwapAccept {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_WorldLine {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_RequestGraphUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_ChatWheel {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_SendStatPopup {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_DismissAllStatPopups {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_BeginLastHitChallenge {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_UpdateQuickBuyItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_UpdateQuickBuy {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_RecordVote {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_WillPurchaseAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_BuyBackStateAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_QuickBuyAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_PlayerShowCase {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_CameraZoomAmount {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_BroadcasterUsingCameraman {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CDOTAClientMsg_BroadcasterUsingAssistedCameraOperator {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_FillEmptySlotsWithBots {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_HeroStatueLike {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_EventCNY2015Cmd {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_DemoHero {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_ChallengeSelect {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_ChallengeReroll {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_CoinWager {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_CoinWagerToken {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_RankWager {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_PlayerBounty {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_EventPointsTip {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_ExecuteOrders {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_XPAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_TalentTreeAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_KillcamDamageTaken {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_KillMyHero {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_QuestStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_ToggleAutoattack {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_SpecialAbility {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_SetEnemyStartingPosition {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_SetDesiredWardPlacement {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_RollDice {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_FlipCoin {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_RequestItemSuggestions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_MakeTeamCaptain {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_HelpTipSystemStateChanged {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_RequestBulkCombatLog {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CDOTAClientMsg_AbilityDraftRequestAbility {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_GuideSelectOption {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_GuideSelected {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_DamageReport {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_SalutePlayer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_GiftPlayer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_GiftEveryone {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_TipAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_EmptyTeleportAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_SetCavernMapVariant {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_PauseGameOrder {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CDOTAClientMsg_VersusScene_PlayerBehavior {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_EmptyItemSlotAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_AddOverwatchReportMarker {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CDOTAClientMsg_AddCommunicationsReportMarker {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CDOTAClientMsg_AddCommunicationsBlockMarker {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_AghsStatusAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_PerfReport {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CDOTAClientMsg_ContextualTips_Subscribe_Entry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_ContextualTips_Subscribe {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_ChatMessage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_DuelAccepted {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_ChooseNeutralItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_RerollNeutralItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_PlayerDraftPick {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_PlayerDraftSuggest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_PlayerDraftPreferRole {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_PlayerDraftPreferTeam {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_AbilityAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CDOTAClientMsg_SelectOverworldTokenRewards {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_FacetAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_InnateAlert {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CDOTAClientMsg_SelectOverworldID {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
