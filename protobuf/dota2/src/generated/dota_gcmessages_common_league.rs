// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_common_league.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CMsgDOTALeagueNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueNode {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.node_id)
    pub node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.node_group_id)
    pub node_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.winning_node_id)
    pub winning_node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.losing_node_id)
    pub losing_node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.incoming_node_id_1)
    pub incoming_node_id_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.incoming_node_id_2)
    pub incoming_node_id_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.node_type)
    pub node_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ELeagueNodeType>>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.scheduled_time)
    pub scheduled_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.actual_time)
    pub actual_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.series_id)
    pub series_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.team_id_1)
    pub team_id_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.team_id_2)
    pub team_id_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.matches)
    pub matches: ::std::vec::Vec<cmsg_dotaleague_node::MatchDetails>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.team_1_wins)
    pub team_1_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.team_2_wins)
    pub team_2_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.has_started)
    pub has_started: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.is_completed)
    pub is_completed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.stream_ids)
    pub stream_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNode.vods)
    pub vods: ::std::vec::Vec<cmsg_dotaleague_node::VOD>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTALeagueNode.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueNode {
    fn default() -> &'a CMsgDOTALeagueNode {
        <CMsgDOTALeagueNode as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueNode {
    pub fn new() -> CMsgDOTALeagueNode {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 node_id = 2;

    pub fn node_id(&self) -> u32 {
        self.node_id.unwrap_or(0)
    }

    pub fn clear_node_id(&mut self) {
        self.node_id = ::std::option::Option::None;
    }

    pub fn has_node_id(&self) -> bool {
        self.node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u32) {
        self.node_id = ::std::option::Option::Some(v);
    }

    // optional uint32 node_group_id = 3;

    pub fn node_group_id(&self) -> u32 {
        self.node_group_id.unwrap_or(0)
    }

    pub fn clear_node_group_id(&mut self) {
        self.node_group_id = ::std::option::Option::None;
    }

    pub fn has_node_group_id(&self) -> bool {
        self.node_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_group_id(&mut self, v: u32) {
        self.node_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 winning_node_id = 4;

    pub fn winning_node_id(&self) -> u32 {
        self.winning_node_id.unwrap_or(0)
    }

    pub fn clear_winning_node_id(&mut self) {
        self.winning_node_id = ::std::option::Option::None;
    }

    pub fn has_winning_node_id(&self) -> bool {
        self.winning_node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winning_node_id(&mut self, v: u32) {
        self.winning_node_id = ::std::option::Option::Some(v);
    }

    // optional uint32 losing_node_id = 5;

    pub fn losing_node_id(&self) -> u32 {
        self.losing_node_id.unwrap_or(0)
    }

    pub fn clear_losing_node_id(&mut self) {
        self.losing_node_id = ::std::option::Option::None;
    }

    pub fn has_losing_node_id(&self) -> bool {
        self.losing_node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_losing_node_id(&mut self, v: u32) {
        self.losing_node_id = ::std::option::Option::Some(v);
    }

    // optional uint32 incoming_node_id_1 = 6;

    pub fn incoming_node_id_1(&self) -> u32 {
        self.incoming_node_id_1.unwrap_or(0)
    }

    pub fn clear_incoming_node_id_1(&mut self) {
        self.incoming_node_id_1 = ::std::option::Option::None;
    }

    pub fn has_incoming_node_id_1(&self) -> bool {
        self.incoming_node_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incoming_node_id_1(&mut self, v: u32) {
        self.incoming_node_id_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 incoming_node_id_2 = 7;

    pub fn incoming_node_id_2(&self) -> u32 {
        self.incoming_node_id_2.unwrap_or(0)
    }

    pub fn clear_incoming_node_id_2(&mut self) {
        self.incoming_node_id_2 = ::std::option::Option::None;
    }

    pub fn has_incoming_node_id_2(&self) -> bool {
        self.incoming_node_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incoming_node_id_2(&mut self, v: u32) {
        self.incoming_node_id_2 = ::std::option::Option::Some(v);
    }

    // optional .ELeagueNodeType node_type = 8;

    pub fn node_type(&self) -> ELeagueNodeType {
        match self.node_type {
            Some(e) => e.enum_value_or(ELeagueNodeType::INVALID_NODE_TYPE),
            None => ELeagueNodeType::INVALID_NODE_TYPE,
        }
    }

    pub fn clear_node_type(&mut self) {
        self.node_type = ::std::option::Option::None;
    }

    pub fn has_node_type(&self) -> bool {
        self.node_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_type(&mut self, v: ELeagueNodeType) {
        self.node_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 scheduled_time = 9;

    pub fn scheduled_time(&self) -> u32 {
        self.scheduled_time.unwrap_or(0)
    }

    pub fn clear_scheduled_time(&mut self) {
        self.scheduled_time = ::std::option::Option::None;
    }

    pub fn has_scheduled_time(&self) -> bool {
        self.scheduled_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheduled_time(&mut self, v: u32) {
        self.scheduled_time = ::std::option::Option::Some(v);
    }

    // optional uint32 actual_time = 19;

    pub fn actual_time(&self) -> u32 {
        self.actual_time.unwrap_or(0)
    }

    pub fn clear_actual_time(&mut self) {
        self.actual_time = ::std::option::Option::None;
    }

    pub fn has_actual_time(&self) -> bool {
        self.actual_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actual_time(&mut self, v: u32) {
        self.actual_time = ::std::option::Option::Some(v);
    }

    // optional uint32 series_id = 10;

    pub fn series_id(&self) -> u32 {
        self.series_id.unwrap_or(0)
    }

    pub fn clear_series_id(&mut self) {
        self.series_id = ::std::option::Option::None;
    }

    pub fn has_series_id(&self) -> bool {
        self.series_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_id(&mut self, v: u32) {
        self.series_id = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id_1 = 11;

    pub fn team_id_1(&self) -> u32 {
        self.team_id_1.unwrap_or(0)
    }

    pub fn clear_team_id_1(&mut self) {
        self.team_id_1 = ::std::option::Option::None;
    }

    pub fn has_team_id_1(&self) -> bool {
        self.team_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_1(&mut self, v: u32) {
        self.team_id_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id_2 = 12;

    pub fn team_id_2(&self) -> u32 {
        self.team_id_2.unwrap_or(0)
    }

    pub fn clear_team_id_2(&mut self) {
        self.team_id_2 = ::std::option::Option::None;
    }

    pub fn has_team_id_2(&self) -> bool {
        self.team_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_2(&mut self, v: u32) {
        self.team_id_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 team_1_wins = 14;

    pub fn team_1_wins(&self) -> u32 {
        self.team_1_wins.unwrap_or(0)
    }

    pub fn clear_team_1_wins(&mut self) {
        self.team_1_wins = ::std::option::Option::None;
    }

    pub fn has_team_1_wins(&self) -> bool {
        self.team_1_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_1_wins(&mut self, v: u32) {
        self.team_1_wins = ::std::option::Option::Some(v);
    }

    // optional uint32 team_2_wins = 15;

    pub fn team_2_wins(&self) -> u32 {
        self.team_2_wins.unwrap_or(0)
    }

    pub fn clear_team_2_wins(&mut self) {
        self.team_2_wins = ::std::option::Option::None;
    }

    pub fn has_team_2_wins(&self) -> bool {
        self.team_2_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_2_wins(&mut self, v: u32) {
        self.team_2_wins = ::std::option::Option::Some(v);
    }

    // optional bool has_started = 16;

    pub fn has_started(&self) -> bool {
        self.has_started.unwrap_or(false)
    }

    pub fn clear_has_started(&mut self) {
        self.has_started = ::std::option::Option::None;
    }

    pub fn has_has_started(&self) -> bool {
        self.has_started.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_started(&mut self, v: bool) {
        self.has_started = ::std::option::Option::Some(v);
    }

    // optional bool is_completed = 17;

    pub fn is_completed(&self) -> bool {
        self.is_completed.unwrap_or(false)
    }

    pub fn clear_is_completed(&mut self) {
        self.is_completed = ::std::option::Option::None;
    }

    pub fn has_is_completed(&self) -> bool {
        self.is_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_completed(&mut self, v: bool) {
        self.is_completed = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTALeagueNode {
    const NAME: &'static str = "CMsgDOTALeagueNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.node_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.winning_node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.losing_node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.incoming_node_id_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.incoming_node_id_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.node_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.scheduled_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.actual_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.series_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.team_id_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.team_id_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    self.matches.push(is.read_message()?);
                },
                112 => {
                    self.team_1_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.team_2_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.has_started = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.is_completed = ::std::option::Option::Some(is.read_bool()?);
                },
                146 => {
                    is.read_repeated_packed_uint32_into(&mut self.stream_ids)?;
                },
                144 => {
                    self.stream_ids.push(is.read_uint32()?);
                },
                162 => {
                    self.vods.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.node_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.node_group_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.winning_node_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.losing_node_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.incoming_node_id_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.incoming_node_id_2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.node_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.scheduled_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.actual_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.series_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.team_id_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.team_id_2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.team_1_wins {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.team_2_wins {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.has_started {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_completed {
            my_size += 2 + 1;
        }
        for value in &self.stream_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, *value);
        };
        for value in &self.vods {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.node_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.node_group_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.winning_node_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.losing_node_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.incoming_node_id_1 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.incoming_node_id_2 {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.node_type {
            os.write_enum(8, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.scheduled_time {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.actual_time {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.series_id {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.team_id_1 {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.team_id_2 {
            os.write_uint32(12, v)?;
        }
        for v in &self.matches {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if let Some(v) = self.team_1_wins {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.team_2_wins {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.has_started {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.is_completed {
            os.write_bool(17, v)?;
        }
        for v in &self.stream_ids {
            os.write_uint32(18, *v)?;
        };
        for v in &self.vods {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueNode {
        CMsgDOTALeagueNode::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.node_id = ::std::option::Option::None;
        self.node_group_id = ::std::option::Option::None;
        self.winning_node_id = ::std::option::Option::None;
        self.losing_node_id = ::std::option::Option::None;
        self.incoming_node_id_1 = ::std::option::Option::None;
        self.incoming_node_id_2 = ::std::option::Option::None;
        self.node_type = ::std::option::Option::None;
        self.scheduled_time = ::std::option::Option::None;
        self.actual_time = ::std::option::Option::None;
        self.series_id = ::std::option::Option::None;
        self.team_id_1 = ::std::option::Option::None;
        self.team_id_2 = ::std::option::Option::None;
        self.matches.clear();
        self.team_1_wins = ::std::option::Option::None;
        self.team_2_wins = ::std::option::Option::None;
        self.has_started = ::std::option::Option::None;
        self.is_completed = ::std::option::Option::None;
        self.stream_ids.clear();
        self.vods.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueNode {
        static instance: CMsgDOTALeagueNode = CMsgDOTALeagueNode {
            name: ::std::option::Option::None,
            node_id: ::std::option::Option::None,
            node_group_id: ::std::option::Option::None,
            winning_node_id: ::std::option::Option::None,
            losing_node_id: ::std::option::Option::None,
            incoming_node_id_1: ::std::option::Option::None,
            incoming_node_id_2: ::std::option::Option::None,
            node_type: ::std::option::Option::None,
            scheduled_time: ::std::option::Option::None,
            actual_time: ::std::option::Option::None,
            series_id: ::std::option::Option::None,
            team_id_1: ::std::option::Option::None,
            team_id_2: ::std::option::Option::None,
            matches: ::std::vec::Vec::new(),
            team_1_wins: ::std::option::Option::None,
            team_2_wins: ::std::option::Option::None,
            has_started: ::std::option::Option::None,
            is_completed: ::std::option::Option::None,
            stream_ids: ::std::vec::Vec::new(),
            vods: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTALeagueNode`
pub mod cmsg_dotaleague_node {
    // @@protoc_insertion_point(message:CMsgDOTALeagueNode.MatchDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MatchDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTALeagueNode.MatchDetails.match_id)
        pub match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNode.MatchDetails.winning_team_id)
        pub winning_team_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTALeagueNode.MatchDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MatchDetails {
        fn default() -> &'a MatchDetails {
            <MatchDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl MatchDetails {
        pub fn new() -> MatchDetails {
            ::std::default::Default::default()
        }

        // optional uint64 match_id = 1;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        // optional uint32 winning_team_id = 2;

        pub fn winning_team_id(&self) -> u32 {
            self.winning_team_id.unwrap_or(0)
        }

        pub fn clear_winning_team_id(&mut self) {
            self.winning_team_id = ::std::option::Option::None;
        }

        pub fn has_winning_team_id(&self) -> bool {
            self.winning_team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_winning_team_id(&mut self, v: u32) {
            self.winning_team_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for MatchDetails {
        const NAME: &'static str = "MatchDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.winning_team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.match_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.winning_team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.match_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.winning_team_id {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MatchDetails {
            MatchDetails::new()
        }

        fn clear(&mut self) {
            self.match_id = ::std::option::Option::None;
            self.winning_team_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MatchDetails {
            static instance: MatchDetails = MatchDetails {
                match_id: ::std::option::Option::None,
                winning_team_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTALeagueNode.VOD)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct VOD {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTALeagueNode.VOD.series_game)
        pub series_game: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNode.VOD.stream_id)
        pub stream_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNode.VOD.url)
        pub url: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTALeagueNode.VOD.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a VOD {
        fn default() -> &'a VOD {
            <VOD as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl VOD {
        pub fn new() -> VOD {
            ::std::default::Default::default()
        }

        // optional uint32 series_game = 1;

        pub fn series_game(&self) -> u32 {
            self.series_game.unwrap_or(0)
        }

        pub fn clear_series_game(&mut self) {
            self.series_game = ::std::option::Option::None;
        }

        pub fn has_series_game(&self) -> bool {
            self.series_game.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series_game(&mut self, v: u32) {
            self.series_game = ::std::option::Option::Some(v);
        }

        // optional uint32 stream_id = 2;

        pub fn stream_id(&self) -> u32 {
            self.stream_id.unwrap_or(0)
        }

        pub fn clear_stream_id(&mut self) {
            self.stream_id = ::std::option::Option::None;
        }

        pub fn has_stream_id(&self) -> bool {
            self.stream_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stream_id(&mut self, v: u32) {
            self.stream_id = ::std::option::Option::Some(v);
        }

        // optional string url = 3;

        pub fn url(&self) -> &str {
            match self.url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_url(&mut self) {
            self.url = ::std::option::Option::None;
        }

        pub fn has_url(&self) -> bool {
            self.url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_url(&mut self, v: ::std::string::String) {
            self.url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_url(&mut self) -> &mut ::std::string::String {
            if self.url.is_none() {
                self.url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.url.as_mut().unwrap()
        }

        // Take field
        pub fn take_url(&mut self) -> ::std::string::String {
            self.url.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for VOD {
        const NAME: &'static str = "VOD";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.series_game = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.stream_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.url = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.series_game {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.stream_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.url.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.series_game {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stream_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.url.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> VOD {
            VOD::new()
        }

        fn clear(&mut self) {
            self.series_game = ::std::option::Option::None;
            self.stream_id = ::std::option::Option::None;
            self.url = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static VOD {
            static instance: VOD = VOD {
                series_game: ::std::option::Option::None,
                stream_id: ::std::option::Option::None,
                url: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTALeagueNodeGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueNodeGroup {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.node_group_id)
    pub node_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.parent_node_group_id)
    pub parent_node_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.incoming_node_group_ids)
    pub incoming_node_group_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.advancing_node_group_id)
    pub advancing_node_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.advancing_team_count)
    pub advancing_team_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.team_count)
    pub team_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.node_group_type)
    pub node_group_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ELeagueNodeGroupType>>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.default_node_type)
    pub default_node_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ELeagueNodeType>>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.round)
    pub round: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.max_rounds)
    pub max_rounds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.is_tiebreaker)
    pub is_tiebreaker: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.is_final_group)
    pub is_final_group: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.is_completed)
    pub is_completed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.phase)
    pub phase: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::ELeaguePhase>>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.region)
    pub region: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::ELeagueRegion>>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.end_time)
    pub end_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.secondary_advancing_node_group_id)
    pub secondary_advancing_node_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.secondary_advancing_team_count)
    pub secondary_advancing_team_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.tertiary_advancing_node_group_id)
    pub tertiary_advancing_node_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.tertiary_advancing_team_count)
    pub tertiary_advancing_team_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.elimination_dpc_points)
    pub elimination_dpc_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.team_standings)
    pub team_standings: ::std::vec::Vec<cmsg_dotaleague_node_group::TeamStanding>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.nodes)
    pub nodes: ::std::vec::Vec<CMsgDOTALeagueNode>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.node_groups)
    pub node_groups: ::std::vec::Vec<CMsgDOTALeagueNodeGroup>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTALeagueNodeGroup.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueNodeGroup {
    fn default() -> &'a CMsgDOTALeagueNodeGroup {
        <CMsgDOTALeagueNodeGroup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueNodeGroup {
    pub fn new() -> CMsgDOTALeagueNodeGroup {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 node_group_id = 2;

    pub fn node_group_id(&self) -> u32 {
        self.node_group_id.unwrap_or(0)
    }

    pub fn clear_node_group_id(&mut self) {
        self.node_group_id = ::std::option::Option::None;
    }

    pub fn has_node_group_id(&self) -> bool {
        self.node_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_group_id(&mut self, v: u32) {
        self.node_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 parent_node_group_id = 3;

    pub fn parent_node_group_id(&self) -> u32 {
        self.parent_node_group_id.unwrap_or(0)
    }

    pub fn clear_parent_node_group_id(&mut self) {
        self.parent_node_group_id = ::std::option::Option::None;
    }

    pub fn has_parent_node_group_id(&self) -> bool {
        self.parent_node_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_node_group_id(&mut self, v: u32) {
        self.parent_node_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 advancing_node_group_id = 5;

    pub fn advancing_node_group_id(&self) -> u32 {
        self.advancing_node_group_id.unwrap_or(0)
    }

    pub fn clear_advancing_node_group_id(&mut self) {
        self.advancing_node_group_id = ::std::option::Option::None;
    }

    pub fn has_advancing_node_group_id(&self) -> bool {
        self.advancing_node_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_advancing_node_group_id(&mut self, v: u32) {
        self.advancing_node_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 advancing_team_count = 6;

    pub fn advancing_team_count(&self) -> u32 {
        self.advancing_team_count.unwrap_or(0)
    }

    pub fn clear_advancing_team_count(&mut self) {
        self.advancing_team_count = ::std::option::Option::None;
    }

    pub fn has_advancing_team_count(&self) -> bool {
        self.advancing_team_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_advancing_team_count(&mut self, v: u32) {
        self.advancing_team_count = ::std::option::Option::Some(v);
    }

    // optional uint32 team_count = 7;

    pub fn team_count(&self) -> u32 {
        self.team_count.unwrap_or(0)
    }

    pub fn clear_team_count(&mut self) {
        self.team_count = ::std::option::Option::None;
    }

    pub fn has_team_count(&self) -> bool {
        self.team_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_count(&mut self, v: u32) {
        self.team_count = ::std::option::Option::Some(v);
    }

    // optional .ELeagueNodeGroupType node_group_type = 8;

    pub fn node_group_type(&self) -> ELeagueNodeGroupType {
        match self.node_group_type {
            Some(e) => e.enum_value_or(ELeagueNodeGroupType::INVALID_GROUP_TYPE),
            None => ELeagueNodeGroupType::INVALID_GROUP_TYPE,
        }
    }

    pub fn clear_node_group_type(&mut self) {
        self.node_group_type = ::std::option::Option::None;
    }

    pub fn has_node_group_type(&self) -> bool {
        self.node_group_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_group_type(&mut self, v: ELeagueNodeGroupType) {
        self.node_group_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .ELeagueNodeType default_node_type = 9;

    pub fn default_node_type(&self) -> ELeagueNodeType {
        match self.default_node_type {
            Some(e) => e.enum_value_or(ELeagueNodeType::INVALID_NODE_TYPE),
            None => ELeagueNodeType::INVALID_NODE_TYPE,
        }
    }

    pub fn clear_default_node_type(&mut self) {
        self.default_node_type = ::std::option::Option::None;
    }

    pub fn has_default_node_type(&self) -> bool {
        self.default_node_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_node_type(&mut self, v: ELeagueNodeType) {
        self.default_node_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 round = 10;

    pub fn round(&self) -> u32 {
        self.round.unwrap_or(0)
    }

    pub fn clear_round(&mut self) {
        self.round = ::std::option::Option::None;
    }

    pub fn has_round(&self) -> bool {
        self.round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: u32) {
        self.round = ::std::option::Option::Some(v);
    }

    // optional uint32 max_rounds = 11;

    pub fn max_rounds(&self) -> u32 {
        self.max_rounds.unwrap_or(0)
    }

    pub fn clear_max_rounds(&mut self) {
        self.max_rounds = ::std::option::Option::None;
    }

    pub fn has_max_rounds(&self) -> bool {
        self.max_rounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_rounds(&mut self, v: u32) {
        self.max_rounds = ::std::option::Option::Some(v);
    }

    // optional bool is_tiebreaker = 12;

    pub fn is_tiebreaker(&self) -> bool {
        self.is_tiebreaker.unwrap_or(false)
    }

    pub fn clear_is_tiebreaker(&mut self) {
        self.is_tiebreaker = ::std::option::Option::None;
    }

    pub fn has_is_tiebreaker(&self) -> bool {
        self.is_tiebreaker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_tiebreaker(&mut self, v: bool) {
        self.is_tiebreaker = ::std::option::Option::Some(v);
    }

    // optional bool is_final_group = 13;

    pub fn is_final_group(&self) -> bool {
        self.is_final_group.unwrap_or(false)
    }

    pub fn clear_is_final_group(&mut self) {
        self.is_final_group = ::std::option::Option::None;
    }

    pub fn has_is_final_group(&self) -> bool {
        self.is_final_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_final_group(&mut self, v: bool) {
        self.is_final_group = ::std::option::Option::Some(v);
    }

    // optional bool is_completed = 14;

    pub fn is_completed(&self) -> bool {
        self.is_completed.unwrap_or(false)
    }

    pub fn clear_is_completed(&mut self) {
        self.is_completed = ::std::option::Option::None;
    }

    pub fn has_is_completed(&self) -> bool {
        self.is_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_completed(&mut self, v: bool) {
        self.is_completed = ::std::option::Option::Some(v);
    }

    // optional .ELeaguePhase phase = 18;

    pub fn phase(&self) -> super::dota_shared_enums::ELeaguePhase {
        match self.phase {
            Some(e) => e.enum_value_or(super::dota_shared_enums::ELeaguePhase::LEAGUE_PHASE_UNSET),
            None => super::dota_shared_enums::ELeaguePhase::LEAGUE_PHASE_UNSET,
        }
    }

    pub fn clear_phase(&mut self) {
        self.phase = ::std::option::Option::None;
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: super::dota_shared_enums::ELeaguePhase) {
        self.phase = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .ELeagueRegion region = 19;

    pub fn region(&self) -> super::dota_shared_enums::ELeagueRegion {
        match self.region {
            Some(e) => e.enum_value_or(super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET),
            None => super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET,
        }
    }

    pub fn clear_region(&mut self) {
        self.region = ::std::option::Option::None;
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: super::dota_shared_enums::ELeagueRegion) {
        self.region = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 start_time = 20;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 end_time = 21;

    pub fn end_time(&self) -> u32 {
        self.end_time.unwrap_or(0)
    }

    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: u32) {
        self.end_time = ::std::option::Option::Some(v);
    }

    // optional uint32 secondary_advancing_node_group_id = 22;

    pub fn secondary_advancing_node_group_id(&self) -> u32 {
        self.secondary_advancing_node_group_id.unwrap_or(0)
    }

    pub fn clear_secondary_advancing_node_group_id(&mut self) {
        self.secondary_advancing_node_group_id = ::std::option::Option::None;
    }

    pub fn has_secondary_advancing_node_group_id(&self) -> bool {
        self.secondary_advancing_node_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary_advancing_node_group_id(&mut self, v: u32) {
        self.secondary_advancing_node_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 secondary_advancing_team_count = 23;

    pub fn secondary_advancing_team_count(&self) -> u32 {
        self.secondary_advancing_team_count.unwrap_or(0)
    }

    pub fn clear_secondary_advancing_team_count(&mut self) {
        self.secondary_advancing_team_count = ::std::option::Option::None;
    }

    pub fn has_secondary_advancing_team_count(&self) -> bool {
        self.secondary_advancing_team_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary_advancing_team_count(&mut self, v: u32) {
        self.secondary_advancing_team_count = ::std::option::Option::Some(v);
    }

    // optional uint32 tertiary_advancing_node_group_id = 24;

    pub fn tertiary_advancing_node_group_id(&self) -> u32 {
        self.tertiary_advancing_node_group_id.unwrap_or(0)
    }

    pub fn clear_tertiary_advancing_node_group_id(&mut self) {
        self.tertiary_advancing_node_group_id = ::std::option::Option::None;
    }

    pub fn has_tertiary_advancing_node_group_id(&self) -> bool {
        self.tertiary_advancing_node_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tertiary_advancing_node_group_id(&mut self, v: u32) {
        self.tertiary_advancing_node_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tertiary_advancing_team_count = 25;

    pub fn tertiary_advancing_team_count(&self) -> u32 {
        self.tertiary_advancing_team_count.unwrap_or(0)
    }

    pub fn clear_tertiary_advancing_team_count(&mut self) {
        self.tertiary_advancing_team_count = ::std::option::Option::None;
    }

    pub fn has_tertiary_advancing_team_count(&self) -> bool {
        self.tertiary_advancing_team_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tertiary_advancing_team_count(&mut self, v: u32) {
        self.tertiary_advancing_team_count = ::std::option::Option::Some(v);
    }

    // optional uint32 elimination_dpc_points = 26;

    pub fn elimination_dpc_points(&self) -> u32 {
        self.elimination_dpc_points.unwrap_or(0)
    }

    pub fn clear_elimination_dpc_points(&mut self) {
        self.elimination_dpc_points = ::std::option::Option::None;
    }

    pub fn has_elimination_dpc_points(&self) -> bool {
        self.elimination_dpc_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elimination_dpc_points(&mut self, v: u32) {
        self.elimination_dpc_points = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTALeagueNodeGroup {
    const NAME: &'static str = "CMsgDOTALeagueNodeGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.node_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.parent_node_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.incoming_node_group_ids)?;
                },
                32 => {
                    self.incoming_node_group_ids.push(is.read_uint32()?);
                },
                40 => {
                    self.advancing_node_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.advancing_team_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.team_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.node_group_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.default_node_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.round = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.max_rounds = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.is_tiebreaker = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.is_final_group = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.is_completed = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.phase = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                152 => {
                    self.region = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                160 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.end_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.secondary_advancing_node_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.secondary_advancing_team_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.tertiary_advancing_node_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.tertiary_advancing_team_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.elimination_dpc_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    self.team_standings.push(is.read_message()?);
                },
                130 => {
                    self.nodes.push(is.read_message()?);
                },
                138 => {
                    self.node_groups.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.node_group_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.parent_node_group_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.incoming_node_group_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, *value);
        };
        if let Some(v) = self.advancing_node_group_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.advancing_team_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.team_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.node_group_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.default_node_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.round {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.max_rounds {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.is_tiebreaker {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_final_group {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_completed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.phase {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(18, v.value());
        }
        if let Some(v) = self.region {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(19, v.value());
        }
        if let Some(v) = self.start_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.end_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.secondary_advancing_node_group_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.secondary_advancing_team_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.tertiary_advancing_node_group_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.tertiary_advancing_team_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.elimination_dpc_points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(26, v);
        }
        for value in &self.team_standings {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.node_groups {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.node_group_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.parent_node_group_id {
            os.write_uint32(3, v)?;
        }
        for v in &self.incoming_node_group_ids {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.advancing_node_group_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.advancing_team_count {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.team_count {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.node_group_type {
            os.write_enum(8, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.default_node_type {
            os.write_enum(9, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.round {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.max_rounds {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.is_tiebreaker {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.is_final_group {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.is_completed {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.phase {
            os.write_enum(18, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.region {
            os.write_enum(19, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.secondary_advancing_node_group_id {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.secondary_advancing_team_count {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.tertiary_advancing_node_group_id {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.tertiary_advancing_team_count {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.elimination_dpc_points {
            os.write_uint32(26, v)?;
        }
        for v in &self.team_standings {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        for v in &self.nodes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        for v in &self.node_groups {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueNodeGroup {
        CMsgDOTALeagueNodeGroup::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.node_group_id = ::std::option::Option::None;
        self.parent_node_group_id = ::std::option::Option::None;
        self.incoming_node_group_ids.clear();
        self.advancing_node_group_id = ::std::option::Option::None;
        self.advancing_team_count = ::std::option::Option::None;
        self.team_count = ::std::option::Option::None;
        self.node_group_type = ::std::option::Option::None;
        self.default_node_type = ::std::option::Option::None;
        self.round = ::std::option::Option::None;
        self.max_rounds = ::std::option::Option::None;
        self.is_tiebreaker = ::std::option::Option::None;
        self.is_final_group = ::std::option::Option::None;
        self.is_completed = ::std::option::Option::None;
        self.phase = ::std::option::Option::None;
        self.region = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.end_time = ::std::option::Option::None;
        self.secondary_advancing_node_group_id = ::std::option::Option::None;
        self.secondary_advancing_team_count = ::std::option::Option::None;
        self.tertiary_advancing_node_group_id = ::std::option::Option::None;
        self.tertiary_advancing_team_count = ::std::option::Option::None;
        self.elimination_dpc_points = ::std::option::Option::None;
        self.team_standings.clear();
        self.nodes.clear();
        self.node_groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueNodeGroup {
        static instance: CMsgDOTALeagueNodeGroup = CMsgDOTALeagueNodeGroup {
            name: ::std::option::Option::None,
            node_group_id: ::std::option::Option::None,
            parent_node_group_id: ::std::option::Option::None,
            incoming_node_group_ids: ::std::vec::Vec::new(),
            advancing_node_group_id: ::std::option::Option::None,
            advancing_team_count: ::std::option::Option::None,
            team_count: ::std::option::Option::None,
            node_group_type: ::std::option::Option::None,
            default_node_type: ::std::option::Option::None,
            round: ::std::option::Option::None,
            max_rounds: ::std::option::Option::None,
            is_tiebreaker: ::std::option::Option::None,
            is_final_group: ::std::option::Option::None,
            is_completed: ::std::option::Option::None,
            phase: ::std::option::Option::None,
            region: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            end_time: ::std::option::Option::None,
            secondary_advancing_node_group_id: ::std::option::Option::None,
            secondary_advancing_team_count: ::std::option::Option::None,
            tertiary_advancing_node_group_id: ::std::option::Option::None,
            tertiary_advancing_team_count: ::std::option::Option::None,
            elimination_dpc_points: ::std::option::Option::None,
            team_standings: ::std::vec::Vec::new(),
            nodes: ::std::vec::Vec::new(),
            node_groups: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTALeagueNodeGroup`
pub mod cmsg_dotaleague_node_group {
    // @@protoc_insertion_point(message:CMsgDOTALeagueNodeGroup.TeamStanding)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamStanding {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.TeamStanding.standing)
        pub standing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.TeamStanding.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.TeamStanding.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.TeamStanding.team_tag)
        pub team_tag: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.TeamStanding.team_logo)
        pub team_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url)
        pub team_logo_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.TeamStanding.wins)
        pub wins: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.TeamStanding.losses)
        pub losses: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.TeamStanding.score)
        pub score: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.TeamStanding.team_abbreviation)
        pub team_abbreviation: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.TeamStanding.score_tiebreak_group)
        pub score_tiebreak_group: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.TeamStanding.score_tiebreak_below)
        pub score_tiebreak_below: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.TeamStanding.score_tiebreak_random)
        pub score_tiebreak_random: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeGroup.TeamStanding.is_pro)
        pub is_pro: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTALeagueNodeGroup.TeamStanding.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamStanding {
        fn default() -> &'a TeamStanding {
            <TeamStanding as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TeamStanding {
        pub fn new() -> TeamStanding {
            ::std::default::Default::default()
        }

        // optional uint32 standing = 1;

        pub fn standing(&self) -> u32 {
            self.standing.unwrap_or(0)
        }

        pub fn clear_standing(&mut self) {
            self.standing = ::std::option::Option::None;
        }

        pub fn has_standing(&self) -> bool {
            self.standing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_standing(&mut self, v: u32) {
            self.standing = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id = 2;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 3;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string team_tag = 4;

        pub fn team_tag(&self) -> &str {
            match self.team_tag.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_tag(&mut self) {
            self.team_tag = ::std::option::Option::None;
        }

        pub fn has_team_tag(&self) -> bool {
            self.team_tag.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_tag(&mut self, v: ::std::string::String) {
            self.team_tag = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_tag(&mut self) -> &mut ::std::string::String {
            if self.team_tag.is_none() {
                self.team_tag = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_tag.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_tag(&mut self) -> ::std::string::String {
            self.team_tag.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 team_logo = 5;

        pub fn team_logo(&self) -> u64 {
            self.team_logo.unwrap_or(0)
        }

        pub fn clear_team_logo(&mut self) {
            self.team_logo = ::std::option::Option::None;
        }

        pub fn has_team_logo(&self) -> bool {
            self.team_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo(&mut self, v: u64) {
            self.team_logo = ::std::option::Option::Some(v);
        }

        // optional string team_logo_url = 6;

        pub fn team_logo_url(&self) -> &str {
            match self.team_logo_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_logo_url(&mut self) {
            self.team_logo_url = ::std::option::Option::None;
        }

        pub fn has_team_logo_url(&self) -> bool {
            self.team_logo_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo_url(&mut self, v: ::std::string::String) {
            self.team_logo_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_logo_url(&mut self) -> &mut ::std::string::String {
            if self.team_logo_url.is_none() {
                self.team_logo_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_logo_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_logo_url(&mut self) -> ::std::string::String {
            self.team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 wins = 7;

        pub fn wins(&self) -> u32 {
            self.wins.unwrap_or(0)
        }

        pub fn clear_wins(&mut self) {
            self.wins = ::std::option::Option::None;
        }

        pub fn has_wins(&self) -> bool {
            self.wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wins(&mut self, v: u32) {
            self.wins = ::std::option::Option::Some(v);
        }

        // optional uint32 losses = 8;

        pub fn losses(&self) -> u32 {
            self.losses.unwrap_or(0)
        }

        pub fn clear_losses(&mut self) {
            self.losses = ::std::option::Option::None;
        }

        pub fn has_losses(&self) -> bool {
            self.losses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_losses(&mut self, v: u32) {
            self.losses = ::std::option::Option::Some(v);
        }

        // optional int64 score = 9;

        pub fn score(&self) -> i64 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: i64) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional string team_abbreviation = 10;

        pub fn team_abbreviation(&self) -> &str {
            match self.team_abbreviation.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_abbreviation(&mut self) {
            self.team_abbreviation = ::std::option::Option::None;
        }

        pub fn has_team_abbreviation(&self) -> bool {
            self.team_abbreviation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_abbreviation(&mut self, v: ::std::string::String) {
            self.team_abbreviation = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_abbreviation(&mut self) -> &mut ::std::string::String {
            if self.team_abbreviation.is_none() {
                self.team_abbreviation = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_abbreviation.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_abbreviation(&mut self) -> ::std::string::String {
            self.team_abbreviation.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int64 score_tiebreak_group = 11;

        pub fn score_tiebreak_group(&self) -> i64 {
            self.score_tiebreak_group.unwrap_or(0)
        }

        pub fn clear_score_tiebreak_group(&mut self) {
            self.score_tiebreak_group = ::std::option::Option::None;
        }

        pub fn has_score_tiebreak_group(&self) -> bool {
            self.score_tiebreak_group.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score_tiebreak_group(&mut self, v: i64) {
            self.score_tiebreak_group = ::std::option::Option::Some(v);
        }

        // optional int64 score_tiebreak_below = 12;

        pub fn score_tiebreak_below(&self) -> i64 {
            self.score_tiebreak_below.unwrap_or(0)
        }

        pub fn clear_score_tiebreak_below(&mut self) {
            self.score_tiebreak_below = ::std::option::Option::None;
        }

        pub fn has_score_tiebreak_below(&self) -> bool {
            self.score_tiebreak_below.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score_tiebreak_below(&mut self, v: i64) {
            self.score_tiebreak_below = ::std::option::Option::Some(v);
        }

        // optional int64 score_tiebreak_random = 13;

        pub fn score_tiebreak_random(&self) -> i64 {
            self.score_tiebreak_random.unwrap_or(0)
        }

        pub fn clear_score_tiebreak_random(&mut self) {
            self.score_tiebreak_random = ::std::option::Option::None;
        }

        pub fn has_score_tiebreak_random(&self) -> bool {
            self.score_tiebreak_random.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score_tiebreak_random(&mut self, v: i64) {
            self.score_tiebreak_random = ::std::option::Option::Some(v);
        }

        // optional bool is_pro = 14;

        pub fn is_pro(&self) -> bool {
            self.is_pro.unwrap_or(false)
        }

        pub fn clear_is_pro(&mut self) {
            self.is_pro = ::std::option::Option::None;
        }

        pub fn has_is_pro(&self) -> bool {
            self.is_pro.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_pro(&mut self, v: bool) {
            self.is_pro = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TeamStanding {
        const NAME: &'static str = "TeamStanding";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.standing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.team_tag = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.team_logo = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    50 => {
                        self.team_logo_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    56 => {
                        self.wins = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.losses = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.score = ::std::option::Option::Some(is.read_int64()?);
                    },
                    82 => {
                        self.team_abbreviation = ::std::option::Option::Some(is.read_string()?);
                    },
                    88 => {
                        self.score_tiebreak_group = ::std::option::Option::Some(is.read_int64()?);
                    },
                    96 => {
                        self.score_tiebreak_below = ::std::option::Option::Some(is.read_int64()?);
                    },
                    104 => {
                        self.score_tiebreak_random = ::std::option::Option::Some(is.read_int64()?);
                    },
                    112 => {
                        self.is_pro = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.standing {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.team_tag.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.team_logo {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.wins {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.losses {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.score {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(9, v);
            }
            if let Some(v) = self.team_abbreviation.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
            }
            if let Some(v) = self.score_tiebreak_group {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(11, v);
            }
            if let Some(v) = self.score_tiebreak_below {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(12, v);
            }
            if let Some(v) = self.score_tiebreak_random {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(13, v);
            }
            if let Some(v) = self.is_pro {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.standing {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.team_tag.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.team_logo {
                os.write_uint64(5, v)?;
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.wins {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.losses {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.score {
                os.write_int64(9, v)?;
            }
            if let Some(v) = self.team_abbreviation.as_ref() {
                os.write_string(10, v)?;
            }
            if let Some(v) = self.score_tiebreak_group {
                os.write_int64(11, v)?;
            }
            if let Some(v) = self.score_tiebreak_below {
                os.write_int64(12, v)?;
            }
            if let Some(v) = self.score_tiebreak_random {
                os.write_int64(13, v)?;
            }
            if let Some(v) = self.is_pro {
                os.write_bool(14, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamStanding {
            TeamStanding::new()
        }

        fn clear(&mut self) {
            self.standing = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.team_tag = ::std::option::Option::None;
            self.team_logo = ::std::option::Option::None;
            self.team_logo_url = ::std::option::Option::None;
            self.wins = ::std::option::Option::None;
            self.losses = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.team_abbreviation = ::std::option::Option::None;
            self.score_tiebreak_group = ::std::option::Option::None;
            self.score_tiebreak_below = ::std::option::Option::None;
            self.score_tiebreak_random = ::std::option::Option::None;
            self.is_pro = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamStanding {
            static instance: TeamStanding = TeamStanding {
                standing: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                team_tag: ::std::option::Option::None,
                team_logo: ::std::option::Option::None,
                team_logo_url: ::std::option::Option::None,
                wins: ::std::option::Option::None,
                losses: ::std::option::Option::None,
                score: ::std::option::Option::None,
                team_abbreviation: ::std::option::Option::None,
                score_tiebreak_group: ::std::option::Option::None,
                score_tiebreak_below: ::std::option::Option::None,
                score_tiebreak_random: ::std::option::Option::None,
                is_pro: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTALeague)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeague {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTALeague.info)
    pub info: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotaleague::Info>,
    // @@protoc_insertion_point(field:CMsgDOTALeague.prize_pool)
    pub prize_pool: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotaleague::PrizePool>,
    // @@protoc_insertion_point(field:CMsgDOTALeague.admins)
    pub admins: ::std::vec::Vec<cmsg_dotaleague::Admin>,
    // @@protoc_insertion_point(field:CMsgDOTALeague.streams)
    pub streams: ::std::vec::Vec<cmsg_dotaleague::Stream>,
    // @@protoc_insertion_point(field:CMsgDOTALeague.node_groups)
    pub node_groups: ::std::vec::Vec<CMsgDOTALeagueNodeGroup>,
    // @@protoc_insertion_point(field:CMsgDOTALeague.series_infos)
    pub series_infos: ::std::vec::Vec<cmsg_dotaleague::SeriesInfo>,
    // @@protoc_insertion_point(field:CMsgDOTALeague.registered_players)
    pub registered_players: ::std::vec::Vec<cmsg_dotaleague::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTALeague.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeague {
    fn default() -> &'a CMsgDOTALeague {
        <CMsgDOTALeague as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeague {
    pub fn new() -> CMsgDOTALeague {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTALeague {
    const NAME: &'static str = "CMsgDOTALeague";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.prize_pool)?;
                },
                26 => {
                    self.admins.push(is.read_message()?);
                },
                34 => {
                    self.streams.push(is.read_message()?);
                },
                42 => {
                    self.node_groups.push(is.read_message()?);
                },
                50 => {
                    self.series_infos.push(is.read_message()?);
                },
                58 => {
                    self.registered_players.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.prize_pool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.admins {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.streams {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.node_groups {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.series_infos {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.registered_players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.info.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.prize_pool.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.admins {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.streams {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.node_groups {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.series_infos {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.registered_players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeague {
        CMsgDOTALeague::new()
    }

    fn clear(&mut self) {
        self.info.clear();
        self.prize_pool.clear();
        self.admins.clear();
        self.streams.clear();
        self.node_groups.clear();
        self.series_infos.clear();
        self.registered_players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeague {
        static instance: CMsgDOTALeague = CMsgDOTALeague {
            info: ::steam_vent_proto_common::protobuf::MessageField::none(),
            prize_pool: ::steam_vent_proto_common::protobuf::MessageField::none(),
            admins: ::std::vec::Vec::new(),
            streams: ::std::vec::Vec::new(),
            node_groups: ::std::vec::Vec::new(),
            series_infos: ::std::vec::Vec::new(),
            registered_players: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTALeague`
pub mod cmsg_dotaleague {
    // @@protoc_insertion_point(message:CMsgDOTALeague.Info)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Info {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTALeague.Info.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Info.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Info.tier)
        pub tier: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueTier>>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Info.region)
        pub region: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueRegion>>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Info.url)
        pub url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Info.description)
        pub description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Info.notes)
        pub notes: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Info.start_timestamp)
        pub start_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Info.end_timestamp)
        pub end_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Info.pro_circuit_points)
        pub pro_circuit_points: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Info.image_bits)
        pub image_bits: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Info.status)
        pub status: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueStatus>>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Info.most_recent_activity)
        pub most_recent_activity: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Info.registration_period)
        pub registration_period: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTALeague.Info.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Info {
        fn default() -> &'a Info {
            <Info as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Info {
        pub fn new() -> Info {
            ::std::default::Default::default()
        }

        // optional uint32 league_id = 1;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .ELeagueTier tier = 3;

        pub fn tier(&self) -> super::super::dota_shared_enums::ELeagueTier {
            match self.tier {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueTier::LEAGUE_TIER_UNSET),
                None => super::super::dota_shared_enums::ELeagueTier::LEAGUE_TIER_UNSET,
            }
        }

        pub fn clear_tier(&mut self) {
            self.tier = ::std::option::Option::None;
        }

        pub fn has_tier(&self) -> bool {
            self.tier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tier(&mut self, v: super::super::dota_shared_enums::ELeagueTier) {
            self.tier = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional .ELeagueRegion region = 4;

        pub fn region(&self) -> super::super::dota_shared_enums::ELeagueRegion {
            match self.region {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET),
                None => super::super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET,
            }
        }

        pub fn clear_region(&mut self) {
            self.region = ::std::option::Option::None;
        }

        pub fn has_region(&self) -> bool {
            self.region.is_some()
        }

        // Param is passed by value, moved
        pub fn set_region(&mut self, v: super::super::dota_shared_enums::ELeagueRegion) {
            self.region = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional string url = 5;

        pub fn url(&self) -> &str {
            match self.url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_url(&mut self) {
            self.url = ::std::option::Option::None;
        }

        pub fn has_url(&self) -> bool {
            self.url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_url(&mut self, v: ::std::string::String) {
            self.url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_url(&mut self) -> &mut ::std::string::String {
            if self.url.is_none() {
                self.url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.url.as_mut().unwrap()
        }

        // Take field
        pub fn take_url(&mut self) -> ::std::string::String {
            self.url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string description = 6;

        pub fn description(&self) -> &str {
            match self.description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_description(&mut self) {
            self.description = ::std::option::Option::None;
        }

        pub fn has_description(&self) -> bool {
            self.description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_description(&mut self, v: ::std::string::String) {
            self.description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_description(&mut self) -> &mut ::std::string::String {
            if self.description.is_none() {
                self.description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.description.as_mut().unwrap()
        }

        // Take field
        pub fn take_description(&mut self) -> ::std::string::String {
            self.description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string notes = 7;

        pub fn notes(&self) -> &str {
            match self.notes.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_notes(&mut self) {
            self.notes = ::std::option::Option::None;
        }

        pub fn has_notes(&self) -> bool {
            self.notes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notes(&mut self, v: ::std::string::String) {
            self.notes = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_notes(&mut self) -> &mut ::std::string::String {
            if self.notes.is_none() {
                self.notes = ::std::option::Option::Some(::std::string::String::new());
            }
            self.notes.as_mut().unwrap()
        }

        // Take field
        pub fn take_notes(&mut self) -> ::std::string::String {
            self.notes.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 start_timestamp = 8;

        pub fn start_timestamp(&self) -> u32 {
            self.start_timestamp.unwrap_or(0)
        }

        pub fn clear_start_timestamp(&mut self) {
            self.start_timestamp = ::std::option::Option::None;
        }

        pub fn has_start_timestamp(&self) -> bool {
            self.start_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_timestamp(&mut self, v: u32) {
            self.start_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 end_timestamp = 9;

        pub fn end_timestamp(&self) -> u32 {
            self.end_timestamp.unwrap_or(0)
        }

        pub fn clear_end_timestamp(&mut self) {
            self.end_timestamp = ::std::option::Option::None;
        }

        pub fn has_end_timestamp(&self) -> bool {
            self.end_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end_timestamp(&mut self, v: u32) {
            self.end_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 pro_circuit_points = 10;

        pub fn pro_circuit_points(&self) -> u32 {
            self.pro_circuit_points.unwrap_or(0)
        }

        pub fn clear_pro_circuit_points(&mut self) {
            self.pro_circuit_points = ::std::option::Option::None;
        }

        pub fn has_pro_circuit_points(&self) -> bool {
            self.pro_circuit_points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pro_circuit_points(&mut self, v: u32) {
            self.pro_circuit_points = ::std::option::Option::Some(v);
        }

        // optional uint32 image_bits = 11;

        pub fn image_bits(&self) -> u32 {
            self.image_bits.unwrap_or(0)
        }

        pub fn clear_image_bits(&mut self) {
            self.image_bits = ::std::option::Option::None;
        }

        pub fn has_image_bits(&self) -> bool {
            self.image_bits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_bits(&mut self, v: u32) {
            self.image_bits = ::std::option::Option::Some(v);
        }

        // optional .ELeagueStatus status = 12;

        pub fn status(&self) -> super::super::dota_shared_enums::ELeagueStatus {
            match self.status {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueStatus::LEAGUE_STATUS_UNSET),
                None => super::super::dota_shared_enums::ELeagueStatus::LEAGUE_STATUS_UNSET,
            }
        }

        pub fn clear_status(&mut self) {
            self.status = ::std::option::Option::None;
        }

        pub fn has_status(&self) -> bool {
            self.status.is_some()
        }

        // Param is passed by value, moved
        pub fn set_status(&mut self, v: super::super::dota_shared_enums::ELeagueStatus) {
            self.status = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 most_recent_activity = 13;

        pub fn most_recent_activity(&self) -> u32 {
            self.most_recent_activity.unwrap_or(0)
        }

        pub fn clear_most_recent_activity(&mut self) {
            self.most_recent_activity = ::std::option::Option::None;
        }

        pub fn has_most_recent_activity(&self) -> bool {
            self.most_recent_activity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_most_recent_activity(&mut self, v: u32) {
            self.most_recent_activity = ::std::option::Option::Some(v);
        }

        // optional uint32 registration_period = 14;

        pub fn registration_period(&self) -> u32 {
            self.registration_period.unwrap_or(0)
        }

        pub fn clear_registration_period(&mut self) {
            self.registration_period = ::std::option::Option::None;
        }

        pub fn has_registration_period(&self) -> bool {
            self.registration_period.is_some()
        }

        // Param is passed by value, moved
        pub fn set_registration_period(&mut self, v: u32) {
            self.registration_period = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Info {
        const NAME: &'static str = "Info";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.tier = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    32 => {
                        self.region = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    42 => {
                        self.url = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.description = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        self.notes = ::std::option::Option::Some(is.read_string()?);
                    },
                    64 => {
                        self.start_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.end_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.pro_circuit_points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.image_bits = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    104 => {
                        self.most_recent_activity = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.registration_period = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.league_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.tier {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.region {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
            }
            if let Some(v) = self.url.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.description.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.notes.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.start_timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.end_timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.pro_circuit_points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.image_bits {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.status {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(12, v.value());
            }
            if let Some(v) = self.most_recent_activity {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.registration_period {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.league_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.tier {
                os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.region {
                os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.url.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.description.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.notes.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.start_timestamp {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.end_timestamp {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.pro_circuit_points {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.image_bits {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.status {
                os.write_enum(12, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.most_recent_activity {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.registration_period {
                os.write_uint32(14, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Info {
            Info::new()
        }

        fn clear(&mut self) {
            self.league_id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.tier = ::std::option::Option::None;
            self.region = ::std::option::Option::None;
            self.url = ::std::option::Option::None;
            self.description = ::std::option::Option::None;
            self.notes = ::std::option::Option::None;
            self.start_timestamp = ::std::option::Option::None;
            self.end_timestamp = ::std::option::Option::None;
            self.pro_circuit_points = ::std::option::Option::None;
            self.image_bits = ::std::option::Option::None;
            self.status = ::std::option::Option::None;
            self.most_recent_activity = ::std::option::Option::None;
            self.registration_period = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Info {
            static instance: Info = Info {
                league_id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                tier: ::std::option::Option::None,
                region: ::std::option::Option::None,
                url: ::std::option::Option::None,
                description: ::std::option::Option::None,
                notes: ::std::option::Option::None,
                start_timestamp: ::std::option::Option::None,
                end_timestamp: ::std::option::Option::None,
                pro_circuit_points: ::std::option::Option::None,
                image_bits: ::std::option::Option::None,
                status: ::std::option::Option::None,
                most_recent_activity: ::std::option::Option::None,
                registration_period: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTALeague.Admin)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Admin {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTALeague.Admin.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Admin.is_primary)
        pub is_primary: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Admin.email_address)
        pub email_address: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTALeague.Admin.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Admin {
        fn default() -> &'a Admin {
            <Admin as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Admin {
        pub fn new() -> Admin {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional bool is_primary = 2;

        pub fn is_primary(&self) -> bool {
            self.is_primary.unwrap_or(false)
        }

        pub fn clear_is_primary(&mut self) {
            self.is_primary = ::std::option::Option::None;
        }

        pub fn has_is_primary(&self) -> bool {
            self.is_primary.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_primary(&mut self, v: bool) {
            self.is_primary = ::std::option::Option::Some(v);
        }

        // optional string email_address = 3;

        pub fn email_address(&self) -> &str {
            match self.email_address.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_email_address(&mut self) {
            self.email_address = ::std::option::Option::None;
        }

        pub fn has_email_address(&self) -> bool {
            self.email_address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_email_address(&mut self, v: ::std::string::String) {
            self.email_address = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_email_address(&mut self) -> &mut ::std::string::String {
            if self.email_address.is_none() {
                self.email_address = ::std::option::Option::Some(::std::string::String::new());
            }
            self.email_address.as_mut().unwrap()
        }

        // Take field
        pub fn take_email_address(&mut self) -> ::std::string::String {
            self.email_address.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Admin {
        const NAME: &'static str = "Admin";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.is_primary = ::std::option::Option::Some(is.read_bool()?);
                    },
                    26 => {
                        self.email_address = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.is_primary {
                my_size += 1 + 1;
            }
            if let Some(v) = self.email_address.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.is_primary {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.email_address.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Admin {
            Admin::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.is_primary = ::std::option::Option::None;
            self.email_address = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Admin {
            static instance: Admin = Admin {
                account_id: ::std::option::Option::None,
                is_primary: ::std::option::Option::None,
                email_address: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTALeague.PrizePoolItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PrizePoolItem {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTALeague.PrizePoolItem.item_def)
        pub item_def: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.PrizePoolItem.sales_stop_timestamp)
        pub sales_stop_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.PrizePoolItem.revenue_pct)
        pub revenue_pct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.PrizePoolItem.revenue_cents_per_sale)
        pub revenue_cents_per_sale: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTALeague.PrizePoolItem.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PrizePoolItem {
        fn default() -> &'a PrizePoolItem {
            <PrizePoolItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PrizePoolItem {
        pub fn new() -> PrizePoolItem {
            ::std::default::Default::default()
        }

        // optional uint32 item_def = 1;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }

        // optional uint32 sales_stop_timestamp = 2;

        pub fn sales_stop_timestamp(&self) -> u32 {
            self.sales_stop_timestamp.unwrap_or(0)
        }

        pub fn clear_sales_stop_timestamp(&mut self) {
            self.sales_stop_timestamp = ::std::option::Option::None;
        }

        pub fn has_sales_stop_timestamp(&self) -> bool {
            self.sales_stop_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sales_stop_timestamp(&mut self, v: u32) {
            self.sales_stop_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 revenue_pct = 3;

        pub fn revenue_pct(&self) -> u32 {
            self.revenue_pct.unwrap_or(0)
        }

        pub fn clear_revenue_pct(&mut self) {
            self.revenue_pct = ::std::option::Option::None;
        }

        pub fn has_revenue_pct(&self) -> bool {
            self.revenue_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_pct(&mut self, v: u32) {
            self.revenue_pct = ::std::option::Option::Some(v);
        }

        // optional uint32 revenue_cents_per_sale = 4;

        pub fn revenue_cents_per_sale(&self) -> u32 {
            self.revenue_cents_per_sale.unwrap_or(0)
        }

        pub fn clear_revenue_cents_per_sale(&mut self) {
            self.revenue_cents_per_sale = ::std::option::Option::None;
        }

        pub fn has_revenue_cents_per_sale(&self) -> bool {
            self.revenue_cents_per_sale.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_cents_per_sale(&mut self, v: u32) {
            self.revenue_cents_per_sale = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PrizePoolItem {
        const NAME: &'static str = "PrizePoolItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.sales_stop_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.revenue_pct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.revenue_cents_per_sale = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.sales_stop_timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.revenue_pct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.revenue_cents_per_sale {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_def {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.sales_stop_timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.revenue_pct {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.revenue_cents_per_sale {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PrizePoolItem {
            PrizePoolItem::new()
        }

        fn clear(&mut self) {
            self.item_def = ::std::option::Option::None;
            self.sales_stop_timestamp = ::std::option::Option::None;
            self.revenue_pct = ::std::option::Option::None;
            self.revenue_cents_per_sale = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PrizePoolItem {
            static instance: PrizePoolItem = PrizePoolItem {
                item_def: ::std::option::Option::None,
                sales_stop_timestamp: ::std::option::Option::None,
                revenue_pct: ::std::option::Option::None,
                revenue_cents_per_sale: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTALeague.PrizePool)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PrizePool {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTALeague.PrizePool.base_prize_pool)
        pub base_prize_pool: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.PrizePool.total_prize_pool)
        pub total_prize_pool: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.PrizePool.prize_split_pct_x100)
        pub prize_split_pct_x100: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.PrizePool.prize_pool_items)
        pub prize_pool_items: ::std::vec::Vec<PrizePoolItem>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTALeague.PrizePool.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PrizePool {
        fn default() -> &'a PrizePool {
            <PrizePool as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PrizePool {
        pub fn new() -> PrizePool {
            ::std::default::Default::default()
        }

        // optional uint32 base_prize_pool = 1;

        pub fn base_prize_pool(&self) -> u32 {
            self.base_prize_pool.unwrap_or(0)
        }

        pub fn clear_base_prize_pool(&mut self) {
            self.base_prize_pool = ::std::option::Option::None;
        }

        pub fn has_base_prize_pool(&self) -> bool {
            self.base_prize_pool.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_prize_pool(&mut self, v: u32) {
            self.base_prize_pool = ::std::option::Option::Some(v);
        }

        // optional uint32 total_prize_pool = 2;

        pub fn total_prize_pool(&self) -> u32 {
            self.total_prize_pool.unwrap_or(0)
        }

        pub fn clear_total_prize_pool(&mut self) {
            self.total_prize_pool = ::std::option::Option::None;
        }

        pub fn has_total_prize_pool(&self) -> bool {
            self.total_prize_pool.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_prize_pool(&mut self, v: u32) {
            self.total_prize_pool = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PrizePool {
        const NAME: &'static str = "PrizePool";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.base_prize_pool = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total_prize_pool = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        is.read_repeated_packed_uint32_into(&mut self.prize_split_pct_x100)?;
                    },
                    24 => {
                        self.prize_split_pct_x100.push(is.read_uint32()?);
                    },
                    34 => {
                        self.prize_pool_items.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.base_prize_pool {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total_prize_pool {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            for value in &self.prize_split_pct_x100 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
            };
            for value in &self.prize_pool_items {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.base_prize_pool {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total_prize_pool {
                os.write_uint32(2, v)?;
            }
            for v in &self.prize_split_pct_x100 {
                os.write_uint32(3, *v)?;
            };
            for v in &self.prize_pool_items {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PrizePool {
            PrizePool::new()
        }

        fn clear(&mut self) {
            self.base_prize_pool = ::std::option::Option::None;
            self.total_prize_pool = ::std::option::Option::None;
            self.prize_split_pct_x100.clear();
            self.prize_pool_items.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PrizePool {
            static instance: PrizePool = PrizePool {
                base_prize_pool: ::std::option::Option::None,
                total_prize_pool: ::std::option::Option::None,
                prize_split_pct_x100: ::std::vec::Vec::new(),
                prize_pool_items: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTALeague.Stream)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stream {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTALeague.Stream.stream_id)
        pub stream_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Stream.language)
        pub language: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Stream.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Stream.broadcast_provider)
        pub broadcast_provider: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueBroadcastProvider>>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Stream.stream_url)
        pub stream_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Stream.vod_url)
        pub vod_url: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTALeague.Stream.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stream {
        fn default() -> &'a Stream {
            <Stream as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Stream {
        pub fn new() -> Stream {
            ::std::default::Default::default()
        }

        // optional uint32 stream_id = 1;

        pub fn stream_id(&self) -> u32 {
            self.stream_id.unwrap_or(0)
        }

        pub fn clear_stream_id(&mut self) {
            self.stream_id = ::std::option::Option::None;
        }

        pub fn has_stream_id(&self) -> bool {
            self.stream_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stream_id(&mut self, v: u32) {
            self.stream_id = ::std::option::Option::Some(v);
        }

        // optional uint32 language = 2;

        pub fn language(&self) -> u32 {
            self.language.unwrap_or(0)
        }

        pub fn clear_language(&mut self) {
            self.language = ::std::option::Option::None;
        }

        pub fn has_language(&self) -> bool {
            self.language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language(&mut self, v: u32) {
            self.language = ::std::option::Option::Some(v);
        }

        // optional string name = 3;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .ELeagueBroadcastProvider broadcast_provider = 4;

        pub fn broadcast_provider(&self) -> super::super::dota_shared_enums::ELeagueBroadcastProvider {
            match self.broadcast_provider {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueBroadcastProvider::LEAGUE_BROADCAST_UNKNOWN),
                None => super::super::dota_shared_enums::ELeagueBroadcastProvider::LEAGUE_BROADCAST_UNKNOWN,
            }
        }

        pub fn clear_broadcast_provider(&mut self) {
            self.broadcast_provider = ::std::option::Option::None;
        }

        pub fn has_broadcast_provider(&self) -> bool {
            self.broadcast_provider.is_some()
        }

        // Param is passed by value, moved
        pub fn set_broadcast_provider(&mut self, v: super::super::dota_shared_enums::ELeagueBroadcastProvider) {
            self.broadcast_provider = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional string stream_url = 5;

        pub fn stream_url(&self) -> &str {
            match self.stream_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_stream_url(&mut self) {
            self.stream_url = ::std::option::Option::None;
        }

        pub fn has_stream_url(&self) -> bool {
            self.stream_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stream_url(&mut self, v: ::std::string::String) {
            self.stream_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_stream_url(&mut self) -> &mut ::std::string::String {
            if self.stream_url.is_none() {
                self.stream_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.stream_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_stream_url(&mut self) -> ::std::string::String {
            self.stream_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string vod_url = 6;

        pub fn vod_url(&self) -> &str {
            match self.vod_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_vod_url(&mut self) {
            self.vod_url = ::std::option::Option::None;
        }

        pub fn has_vod_url(&self) -> bool {
            self.vod_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vod_url(&mut self, v: ::std::string::String) {
            self.vod_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vod_url(&mut self) -> &mut ::std::string::String {
            if self.vod_url.is_none() {
                self.vod_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.vod_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_vod_url(&mut self) -> ::std::string::String {
            self.vod_url.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Stream {
        const NAME: &'static str = "Stream";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.stream_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.language = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.broadcast_provider = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    42 => {
                        self.stream_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.vod_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.stream_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.language {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.broadcast_provider {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
            }
            if let Some(v) = self.stream_url.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.vod_url.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.stream_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.language {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.broadcast_provider {
                os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.stream_url.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.vod_url.as_ref() {
                os.write_string(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stream {
            Stream::new()
        }

        fn clear(&mut self) {
            self.stream_id = ::std::option::Option::None;
            self.language = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.broadcast_provider = ::std::option::Option::None;
            self.stream_url = ::std::option::Option::None;
            self.vod_url = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stream {
            static instance: Stream = Stream {
                stream_id: ::std::option::Option::None,
                language: ::std::option::Option::None,
                name: ::std::option::Option::None,
                broadcast_provider: ::std::option::Option::None,
                stream_url: ::std::option::Option::None,
                vod_url: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTALeague.SeriesInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SeriesInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTALeague.SeriesInfo.series_id)
        pub series_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.SeriesInfo.series_type)
        pub series_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.SeriesInfo.start_time)
        pub start_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.SeriesInfo.match_ids)
        pub match_ids: ::std::vec::Vec<u64>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.SeriesInfo.team_id_1)
        pub team_id_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.SeriesInfo.team_id_2)
        pub team_id_2: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTALeague.SeriesInfo.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SeriesInfo {
        fn default() -> &'a SeriesInfo {
            <SeriesInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SeriesInfo {
        pub fn new() -> SeriesInfo {
            ::std::default::Default::default()
        }

        // optional uint32 series_id = 1;

        pub fn series_id(&self) -> u32 {
            self.series_id.unwrap_or(0)
        }

        pub fn clear_series_id(&mut self) {
            self.series_id = ::std::option::Option::None;
        }

        pub fn has_series_id(&self) -> bool {
            self.series_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series_id(&mut self, v: u32) {
            self.series_id = ::std::option::Option::Some(v);
        }

        // optional uint32 series_type = 2;

        pub fn series_type(&self) -> u32 {
            self.series_type.unwrap_or(0)
        }

        pub fn clear_series_type(&mut self) {
            self.series_type = ::std::option::Option::None;
        }

        pub fn has_series_type(&self) -> bool {
            self.series_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series_type(&mut self, v: u32) {
            self.series_type = ::std::option::Option::Some(v);
        }

        // optional uint32 start_time = 3;

        pub fn start_time(&self) -> u32 {
            self.start_time.unwrap_or(0)
        }

        pub fn clear_start_time(&mut self) {
            self.start_time = ::std::option::Option::None;
        }

        pub fn has_start_time(&self) -> bool {
            self.start_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_time(&mut self, v: u32) {
            self.start_time = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id_1 = 5;

        pub fn team_id_1(&self) -> u32 {
            self.team_id_1.unwrap_or(0)
        }

        pub fn clear_team_id_1(&mut self) {
            self.team_id_1 = ::std::option::Option::None;
        }

        pub fn has_team_id_1(&self) -> bool {
            self.team_id_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id_1(&mut self, v: u32) {
            self.team_id_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id_2 = 6;

        pub fn team_id_2(&self) -> u32 {
            self.team_id_2.unwrap_or(0)
        }

        pub fn clear_team_id_2(&mut self) {
            self.team_id_2 = ::std::option::Option::None;
        }

        pub fn has_team_id_2(&self) -> bool {
            self.team_id_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id_2(&mut self, v: u32) {
            self.team_id_2 = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SeriesInfo {
        const NAME: &'static str = "SeriesInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.series_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.series_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        is.read_repeated_packed_uint64_into(&mut self.match_ids)?;
                    },
                    32 => {
                        self.match_ids.push(is.read_uint64()?);
                    },
                    40 => {
                        self.team_id_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.team_id_2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.series_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.series_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.start_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            for value in &self.match_ids {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, *value);
            };
            if let Some(v) = self.team_id_1 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.team_id_2 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.series_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.series_type {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.start_time {
                os.write_uint32(3, v)?;
            }
            for v in &self.match_ids {
                os.write_uint64(4, *v)?;
            };
            if let Some(v) = self.team_id_1 {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.team_id_2 {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SeriesInfo {
            SeriesInfo::new()
        }

        fn clear(&mut self) {
            self.series_id = ::std::option::Option::None;
            self.series_type = ::std::option::Option::None;
            self.start_time = ::std::option::Option::None;
            self.match_ids.clear();
            self.team_id_1 = ::std::option::Option::None;
            self.team_id_2 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SeriesInfo {
            static instance: SeriesInfo = SeriesInfo {
                series_id: ::std::option::Option::None,
                series_type: ::std::option::Option::None,
                start_time: ::std::option::Option::None,
                match_ids: ::std::vec::Vec::new(),
                team_id_1: ::std::option::Option::None,
                team_id_2: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTALeague.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTALeague.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Player.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeague.Player.team_id)
        pub team_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTALeague.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team_id = 3;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTALeagueList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueList {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTALeagueList.leagues)
    pub leagues: ::std::vec::Vec<CMsgDOTALeague>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTALeagueList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueList {
    fn default() -> &'a CMsgDOTALeagueList {
        <CMsgDOTALeagueList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueList {
    pub fn new() -> CMsgDOTALeagueList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTALeagueList {
    const NAME: &'static str = "CMsgDOTALeagueList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.leagues.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.leagues {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.leagues {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueList {
        CMsgDOTALeagueList::new()
    }

    fn clear(&mut self) {
        self.leagues.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueList {
        static instance: CMsgDOTALeagueList = CMsgDOTALeagueList {
            leagues: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTALeagueInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTALeagueInfo.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueInfo.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueInfo.tier)
    pub tier: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::ELeagueTier>>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueInfo.region)
    pub region: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::ELeagueRegion>>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueInfo.most_recent_activity)
    pub most_recent_activity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueInfo.total_prize_pool)
    pub total_prize_pool: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueInfo.start_timestamp)
    pub start_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueInfo.end_timestamp)
    pub end_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeagueInfo.status)
    pub status: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTALeagueInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueInfo {
    fn default() -> &'a CMsgDOTALeagueInfo {
        <CMsgDOTALeagueInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueInfo {
    pub fn new() -> CMsgDOTALeagueInfo {
        ::std::default::Default::default()
    }

    // optional uint32 league_id = 1;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ELeagueTier tier = 3;

    pub fn tier(&self) -> super::dota_shared_enums::ELeagueTier {
        match self.tier {
            Some(e) => e.enum_value_or(super::dota_shared_enums::ELeagueTier::LEAGUE_TIER_UNSET),
            None => super::dota_shared_enums::ELeagueTier::LEAGUE_TIER_UNSET,
        }
    }

    pub fn clear_tier(&mut self) {
        self.tier = ::std::option::Option::None;
    }

    pub fn has_tier(&self) -> bool {
        self.tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tier(&mut self, v: super::dota_shared_enums::ELeagueTier) {
        self.tier = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .ELeagueRegion region = 4;

    pub fn region(&self) -> super::dota_shared_enums::ELeagueRegion {
        match self.region {
            Some(e) => e.enum_value_or(super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET),
            None => super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET,
        }
    }

    pub fn clear_region(&mut self) {
        self.region = ::std::option::Option::None;
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: super::dota_shared_enums::ELeagueRegion) {
        self.region = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 most_recent_activity = 5;

    pub fn most_recent_activity(&self) -> u32 {
        self.most_recent_activity.unwrap_or(0)
    }

    pub fn clear_most_recent_activity(&mut self) {
        self.most_recent_activity = ::std::option::Option::None;
    }

    pub fn has_most_recent_activity(&self) -> bool {
        self.most_recent_activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_most_recent_activity(&mut self, v: u32) {
        self.most_recent_activity = ::std::option::Option::Some(v);
    }

    // optional uint32 total_prize_pool = 6;

    pub fn total_prize_pool(&self) -> u32 {
        self.total_prize_pool.unwrap_or(0)
    }

    pub fn clear_total_prize_pool(&mut self) {
        self.total_prize_pool = ::std::option::Option::None;
    }

    pub fn has_total_prize_pool(&self) -> bool {
        self.total_prize_pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_prize_pool(&mut self, v: u32) {
        self.total_prize_pool = ::std::option::Option::Some(v);
    }

    // optional uint32 start_timestamp = 7;

    pub fn start_timestamp(&self) -> u32 {
        self.start_timestamp.unwrap_or(0)
    }

    pub fn clear_start_timestamp(&mut self) {
        self.start_timestamp = ::std::option::Option::None;
    }

    pub fn has_start_timestamp(&self) -> bool {
        self.start_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_timestamp(&mut self, v: u32) {
        self.start_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 end_timestamp = 8;

    pub fn end_timestamp(&self) -> u32 {
        self.end_timestamp.unwrap_or(0)
    }

    pub fn clear_end_timestamp(&mut self) {
        self.end_timestamp = ::std::option::Option::None;
    }

    pub fn has_end_timestamp(&self) -> bool {
        self.end_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_timestamp(&mut self, v: u32) {
        self.end_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 status = 9;

    pub fn status(&self) -> u32 {
        self.status.unwrap_or(0)
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTALeagueInfo {
    const NAME: &'static str = "CMsgDOTALeagueInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.tier = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.region = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.most_recent_activity = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.total_prize_pool = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.start_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.end_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.status = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.tier {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.region {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.most_recent_activity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.total_prize_pool {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.start_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.end_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.status {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.tier {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.region {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.most_recent_activity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.total_prize_pool {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.start_timestamp {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.end_timestamp {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.status {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueInfo {
        CMsgDOTALeagueInfo::new()
    }

    fn clear(&mut self) {
        self.league_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.tier = ::std::option::Option::None;
        self.region = ::std::option::Option::None;
        self.most_recent_activity = ::std::option::Option::None;
        self.total_prize_pool = ::std::option::Option::None;
        self.start_timestamp = ::std::option::Option::None;
        self.end_timestamp = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueInfo {
        static instance: CMsgDOTALeagueInfo = CMsgDOTALeagueInfo {
            league_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            tier: ::std::option::Option::None,
            region: ::std::option::Option::None,
            most_recent_activity: ::std::option::Option::None,
            total_prize_pool: ::std::option::Option::None,
            start_timestamp: ::std::option::Option::None,
            end_timestamp: ::std::option::Option::None,
            status: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTALeagueInfoList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueInfoList {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTALeagueInfoList.infos)
    pub infos: ::std::vec::Vec<CMsgDOTALeagueInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTALeagueInfoList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueInfoList {
    fn default() -> &'a CMsgDOTALeagueInfoList {
        <CMsgDOTALeagueInfoList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueInfoList {
    pub fn new() -> CMsgDOTALeagueInfoList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTALeagueInfoList {
    const NAME: &'static str = "CMsgDOTALeagueInfoList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.infos.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.infos {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.infos {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueInfoList {
        CMsgDOTALeagueInfoList::new()
    }

    fn clear(&mut self) {
        self.infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueInfoList {
        static instance: CMsgDOTALeagueInfoList = CMsgDOTALeagueInfoList {
            infos: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTALeagueLiveGames)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueLiveGames {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTALeagueLiveGames.games)
    pub games: ::std::vec::Vec<cmsg_dotaleague_live_games::LiveGame>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTALeagueLiveGames.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueLiveGames {
    fn default() -> &'a CMsgDOTALeagueLiveGames {
        <CMsgDOTALeagueLiveGames as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueLiveGames {
    pub fn new() -> CMsgDOTALeagueLiveGames {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTALeagueLiveGames {
    const NAME: &'static str = "CMsgDOTALeagueLiveGames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.games.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.games {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueLiveGames {
        CMsgDOTALeagueLiveGames::new()
    }

    fn clear(&mut self) {
        self.games.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueLiveGames {
        static instance: CMsgDOTALeagueLiveGames = CMsgDOTALeagueLiveGames {
            games: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTALeagueLiveGames`
pub mod cmsg_dotaleague_live_games {
    // @@protoc_insertion_point(message:CMsgDOTALeagueLiveGames.LiveGame)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LiveGame {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTALeagueLiveGames.LiveGame.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueLiveGames.LiveGame.server_steam_id)
        pub server_steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueLiveGames.LiveGame.radiant_name)
        pub radiant_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueLiveGames.LiveGame.radiant_logo)
        pub radiant_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueLiveGames.LiveGame.radiant_team_id)
        pub radiant_team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueLiveGames.LiveGame.dire_name)
        pub dire_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueLiveGames.LiveGame.dire_logo)
        pub dire_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueLiveGames.LiveGame.dire_team_id)
        pub dire_team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueLiveGames.LiveGame.time)
        pub time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueLiveGames.LiveGame.spectators)
        pub spectators: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueLiveGames.LiveGame.league_node_id)
        pub league_node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueLiveGames.LiveGame.series_id)
        pub series_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueLiveGames.LiveGame.match_id)
        pub match_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTALeagueLiveGames.LiveGame.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LiveGame {
        fn default() -> &'a LiveGame {
            <LiveGame as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl LiveGame {
        pub fn new() -> LiveGame {
            ::std::default::Default::default()
        }

        // optional uint32 league_id = 1;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional uint64 server_steam_id = 2;

        pub fn server_steam_id(&self) -> u64 {
            self.server_steam_id.unwrap_or(0)
        }

        pub fn clear_server_steam_id(&mut self) {
            self.server_steam_id = ::std::option::Option::None;
        }

        pub fn has_server_steam_id(&self) -> bool {
            self.server_steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_steam_id(&mut self, v: u64) {
            self.server_steam_id = ::std::option::Option::Some(v);
        }

        // optional string radiant_name = 3;

        pub fn radiant_name(&self) -> &str {
            match self.radiant_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_radiant_name(&mut self) {
            self.radiant_name = ::std::option::Option::None;
        }

        pub fn has_radiant_name(&self) -> bool {
            self.radiant_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radiant_name(&mut self, v: ::std::string::String) {
            self.radiant_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_radiant_name(&mut self) -> &mut ::std::string::String {
            if self.radiant_name.is_none() {
                self.radiant_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.radiant_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_radiant_name(&mut self) -> ::std::string::String {
            self.radiant_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 radiant_logo = 4;

        pub fn radiant_logo(&self) -> u64 {
            self.radiant_logo.unwrap_or(0)
        }

        pub fn clear_radiant_logo(&mut self) {
            self.radiant_logo = ::std::option::Option::None;
        }

        pub fn has_radiant_logo(&self) -> bool {
            self.radiant_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radiant_logo(&mut self, v: u64) {
            self.radiant_logo = ::std::option::Option::Some(v);
        }

        // optional uint32 radiant_team_id = 9;

        pub fn radiant_team_id(&self) -> u32 {
            self.radiant_team_id.unwrap_or(0)
        }

        pub fn clear_radiant_team_id(&mut self) {
            self.radiant_team_id = ::std::option::Option::None;
        }

        pub fn has_radiant_team_id(&self) -> bool {
            self.radiant_team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radiant_team_id(&mut self, v: u32) {
            self.radiant_team_id = ::std::option::Option::Some(v);
        }

        // optional string dire_name = 5;

        pub fn dire_name(&self) -> &str {
            match self.dire_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_dire_name(&mut self) {
            self.dire_name = ::std::option::Option::None;
        }

        pub fn has_dire_name(&self) -> bool {
            self.dire_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dire_name(&mut self, v: ::std::string::String) {
            self.dire_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_dire_name(&mut self) -> &mut ::std::string::String {
            if self.dire_name.is_none() {
                self.dire_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.dire_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_dire_name(&mut self) -> ::std::string::String {
            self.dire_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 dire_logo = 6;

        pub fn dire_logo(&self) -> u64 {
            self.dire_logo.unwrap_or(0)
        }

        pub fn clear_dire_logo(&mut self) {
            self.dire_logo = ::std::option::Option::None;
        }

        pub fn has_dire_logo(&self) -> bool {
            self.dire_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dire_logo(&mut self, v: u64) {
            self.dire_logo = ::std::option::Option::Some(v);
        }

        // optional uint32 dire_team_id = 10;

        pub fn dire_team_id(&self) -> u32 {
            self.dire_team_id.unwrap_or(0)
        }

        pub fn clear_dire_team_id(&mut self) {
            self.dire_team_id = ::std::option::Option::None;
        }

        pub fn has_dire_team_id(&self) -> bool {
            self.dire_team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dire_team_id(&mut self, v: u32) {
            self.dire_team_id = ::std::option::Option::Some(v);
        }

        // optional uint32 time = 7;

        pub fn time(&self) -> u32 {
            self.time.unwrap_or(0)
        }

        pub fn clear_time(&mut self) {
            self.time = ::std::option::Option::None;
        }

        pub fn has_time(&self) -> bool {
            self.time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time(&mut self, v: u32) {
            self.time = ::std::option::Option::Some(v);
        }

        // optional uint32 spectators = 8;

        pub fn spectators(&self) -> u32 {
            self.spectators.unwrap_or(0)
        }

        pub fn clear_spectators(&mut self) {
            self.spectators = ::std::option::Option::None;
        }

        pub fn has_spectators(&self) -> bool {
            self.spectators.is_some()
        }

        // Param is passed by value, moved
        pub fn set_spectators(&mut self, v: u32) {
            self.spectators = ::std::option::Option::Some(v);
        }

        // optional uint32 league_node_id = 11;

        pub fn league_node_id(&self) -> u32 {
            self.league_node_id.unwrap_or(0)
        }

        pub fn clear_league_node_id(&mut self) {
            self.league_node_id = ::std::option::Option::None;
        }

        pub fn has_league_node_id(&self) -> bool {
            self.league_node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_node_id(&mut self, v: u32) {
            self.league_node_id = ::std::option::Option::Some(v);
        }

        // optional uint32 series_id = 12;

        pub fn series_id(&self) -> u32 {
            self.series_id.unwrap_or(0)
        }

        pub fn clear_series_id(&mut self) {
            self.series_id = ::std::option::Option::None;
        }

        pub fn has_series_id(&self) -> bool {
            self.series_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series_id(&mut self, v: u32) {
            self.series_id = ::std::option::Option::Some(v);
        }

        // optional uint64 match_id = 13;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for LiveGame {
        const NAME: &'static str = "LiveGame";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.server_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    26 => {
                        self.radiant_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.radiant_logo = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    72 => {
                        self.radiant_team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        self.dire_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.dire_logo = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    80 => {
                        self.dire_team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.spectators = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.league_node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.series_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.league_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.server_steam_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.radiant_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.radiant_logo {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.radiant_team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.dire_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.dire_logo {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(6, v);
            }
            if let Some(v) = self.dire_team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.spectators {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.league_node_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.series_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.match_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(13, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.league_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.server_steam_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.radiant_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.radiant_logo {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.radiant_team_id {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.dire_name.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.dire_logo {
                os.write_uint64(6, v)?;
            }
            if let Some(v) = self.dire_team_id {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.time {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.spectators {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.league_node_id {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.series_id {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.match_id {
                os.write_uint64(13, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LiveGame {
            LiveGame::new()
        }

        fn clear(&mut self) {
            self.league_id = ::std::option::Option::None;
            self.server_steam_id = ::std::option::Option::None;
            self.radiant_name = ::std::option::Option::None;
            self.radiant_logo = ::std::option::Option::None;
            self.radiant_team_id = ::std::option::Option::None;
            self.dire_name = ::std::option::Option::None;
            self.dire_logo = ::std::option::Option::None;
            self.dire_team_id = ::std::option::Option::None;
            self.time = ::std::option::Option::None;
            self.spectators = ::std::option::Option::None;
            self.league_node_id = ::std::option::Option::None;
            self.series_id = ::std::option::Option::None;
            self.match_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LiveGame {
            static instance: LiveGame = LiveGame {
                league_id: ::std::option::Option::None,
                server_steam_id: ::std::option::Option::None,
                radiant_name: ::std::option::Option::None,
                radiant_logo: ::std::option::Option::None,
                radiant_team_id: ::std::option::Option::None,
                dire_name: ::std::option::Option::None,
                dire_logo: ::std::option::Option::None,
                dire_team_id: ::std::option::Option::None,
                time: ::std::option::Option::None,
                spectators: ::std::option::Option::None,
                league_node_id: ::std::option::Option::None,
                series_id: ::std::option::Option::None,
                match_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTALeagueMessages)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueMessages {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTALeagueMessages.messages)
    pub messages: ::std::vec::Vec<cmsg_dotaleague_messages::Message>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTALeagueMessages.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueMessages {
    fn default() -> &'a CMsgDOTALeagueMessages {
        <CMsgDOTALeagueMessages as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueMessages {
    pub fn new() -> CMsgDOTALeagueMessages {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTALeagueMessages {
    const NAME: &'static str = "CMsgDOTALeagueMessages";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.messages {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueMessages {
        CMsgDOTALeagueMessages::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueMessages {
        static instance: CMsgDOTALeagueMessages = CMsgDOTALeagueMessages {
            messages: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTALeagueMessages`
pub mod cmsg_dotaleague_messages {
    // @@protoc_insertion_point(message:CMsgDOTALeagueMessages.Message)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Message {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTALeagueMessages.Message.author_account_id)
        pub author_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueMessages.Message.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueMessages.Message.message)
        pub message: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTALeagueMessages.Message.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Message {
        fn default() -> &'a Message {
            <Message as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Message {
        pub fn new() -> Message {
            ::std::default::Default::default()
        }

        // optional uint32 author_account_id = 1;

        pub fn author_account_id(&self) -> u32 {
            self.author_account_id.unwrap_or(0)
        }

        pub fn clear_author_account_id(&mut self) {
            self.author_account_id = ::std::option::Option::None;
        }

        pub fn has_author_account_id(&self) -> bool {
            self.author_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_author_account_id(&mut self, v: u32) {
            self.author_account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 2;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional string message = 3;

        pub fn message(&self) -> &str {
            match self.message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_message(&mut self) {
            self.message = ::std::option::Option::None;
        }

        pub fn has_message(&self) -> bool {
            self.message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message(&mut self, v: ::std::string::String) {
            self.message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_message(&mut self) -> &mut ::std::string::String {
            if self.message.is_none() {
                self.message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.message.as_mut().unwrap()
        }

        // Take field
        pub fn take_message(&mut self) -> ::std::string::String {
            self.message.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Message {
        const NAME: &'static str = "Message";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.author_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.message = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.author_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.message.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.author_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.message.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Message {
            Message::new()
        }

        fn clear(&mut self) {
            self.author_account_id = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.message = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Message {
            static instance: Message = Message {
                author_account_id: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                message: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTALeaguePrizePool)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeaguePrizePool {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTALeaguePrizePool.prize_pool)
    pub prize_pool: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALeaguePrizePool.increment_per_second)
    pub increment_per_second: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTALeaguePrizePool.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeaguePrizePool {
    fn default() -> &'a CMsgDOTALeaguePrizePool {
        <CMsgDOTALeaguePrizePool as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeaguePrizePool {
    pub fn new() -> CMsgDOTALeaguePrizePool {
        ::std::default::Default::default()
    }

    // optional uint32 prize_pool = 1;

    pub fn prize_pool(&self) -> u32 {
        self.prize_pool.unwrap_or(0)
    }

    pub fn clear_prize_pool(&mut self) {
        self.prize_pool = ::std::option::Option::None;
    }

    pub fn has_prize_pool(&self) -> bool {
        self.prize_pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prize_pool(&mut self, v: u32) {
        self.prize_pool = ::std::option::Option::Some(v);
    }

    // optional float increment_per_second = 2;

    pub fn increment_per_second(&self) -> f32 {
        self.increment_per_second.unwrap_or(0.)
    }

    pub fn clear_increment_per_second(&mut self) {
        self.increment_per_second = ::std::option::Option::None;
    }

    pub fn has_increment_per_second(&self) -> bool {
        self.increment_per_second.is_some()
    }

    // Param is passed by value, moved
    pub fn set_increment_per_second(&mut self, v: f32) {
        self.increment_per_second = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTALeaguePrizePool {
    const NAME: &'static str = "CMsgDOTALeaguePrizePool";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.prize_pool = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.increment_per_second = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.prize_pool {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.increment_per_second {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.prize_pool {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.increment_per_second {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeaguePrizePool {
        CMsgDOTALeaguePrizePool::new()
    }

    fn clear(&mut self) {
        self.prize_pool = ::std::option::Option::None;
        self.increment_per_second = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeaguePrizePool {
        static instance: CMsgDOTALeaguePrizePool = CMsgDOTALeaguePrizePool {
            prize_pool: ::std::option::Option::None,
            increment_per_second: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTALeagueInfoListAdminsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueInfoListAdminsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTALeagueInfoListAdminsRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueInfoListAdminsRequest {
    fn default() -> &'a CMsgDOTALeagueInfoListAdminsRequest {
        <CMsgDOTALeagueInfoListAdminsRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueInfoListAdminsRequest {
    pub fn new() -> CMsgDOTALeagueInfoListAdminsRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTALeagueInfoListAdminsRequest {
    const NAME: &'static str = "CMsgDOTALeagueInfoListAdminsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueInfoListAdminsRequest {
        CMsgDOTALeagueInfoListAdminsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueInfoListAdminsRequest {
        static instance: CMsgDOTALeagueInfoListAdminsRequest = CMsgDOTALeagueInfoListAdminsRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTALeagueAvailableLobbyNodesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueAvailableLobbyNodesRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTALeagueAvailableLobbyNodesRequest.league_id)
    pub league_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTALeagueAvailableLobbyNodesRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueAvailableLobbyNodesRequest {
    fn default() -> &'a CMsgDOTALeagueAvailableLobbyNodesRequest {
        <CMsgDOTALeagueAvailableLobbyNodesRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueAvailableLobbyNodesRequest {
    pub fn new() -> CMsgDOTALeagueAvailableLobbyNodesRequest {
        ::std::default::Default::default()
    }

    // optional uint32 league_id = 1;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTALeagueAvailableLobbyNodesRequest {
    const NAME: &'static str = "CMsgDOTALeagueAvailableLobbyNodesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueAvailableLobbyNodesRequest {
        CMsgDOTALeagueAvailableLobbyNodesRequest::new()
    }

    fn clear(&mut self) {
        self.league_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueAvailableLobbyNodesRequest {
        static instance: CMsgDOTALeagueAvailableLobbyNodesRequest = CMsgDOTALeagueAvailableLobbyNodesRequest {
            league_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTALeagueAvailableLobbyNodes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueAvailableLobbyNodes {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTALeagueAvailableLobbyNodes.node_infos)
    pub node_infos: ::std::vec::Vec<cmsg_dotaleague_available_lobby_nodes::NodeInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTALeagueAvailableLobbyNodes.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueAvailableLobbyNodes {
    fn default() -> &'a CMsgDOTALeagueAvailableLobbyNodes {
        <CMsgDOTALeagueAvailableLobbyNodes as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueAvailableLobbyNodes {
    pub fn new() -> CMsgDOTALeagueAvailableLobbyNodes {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTALeagueAvailableLobbyNodes {
    const NAME: &'static str = "CMsgDOTALeagueAvailableLobbyNodes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.node_infos.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.node_infos {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.node_infos {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueAvailableLobbyNodes {
        CMsgDOTALeagueAvailableLobbyNodes::new()
    }

    fn clear(&mut self) {
        self.node_infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueAvailableLobbyNodes {
        static instance: CMsgDOTALeagueAvailableLobbyNodes = CMsgDOTALeagueAvailableLobbyNodes {
            node_infos: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTALeagueAvailableLobbyNodes`
pub mod cmsg_dotaleague_available_lobby_nodes {
    // @@protoc_insertion_point(message:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct NodeInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_id)
        pub node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name)
        pub node_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name)
        pub node_group_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.team_id_1)
        pub team_id_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.team_id_2)
        pub team_id_2: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NodeInfo {
        fn default() -> &'a NodeInfo {
            <NodeInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl NodeInfo {
        pub fn new() -> NodeInfo {
            ::std::default::Default::default()
        }

        // optional uint32 node_id = 1;

        pub fn node_id(&self) -> u32 {
            self.node_id.unwrap_or(0)
        }

        pub fn clear_node_id(&mut self) {
            self.node_id = ::std::option::Option::None;
        }

        pub fn has_node_id(&self) -> bool {
            self.node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_node_id(&mut self, v: u32) {
            self.node_id = ::std::option::Option::Some(v);
        }

        // optional string node_name = 2;

        pub fn node_name(&self) -> &str {
            match self.node_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_node_name(&mut self) {
            self.node_name = ::std::option::Option::None;
        }

        pub fn has_node_name(&self) -> bool {
            self.node_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_node_name(&mut self, v: ::std::string::String) {
            self.node_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_node_name(&mut self) -> &mut ::std::string::String {
            if self.node_name.is_none() {
                self.node_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.node_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_node_name(&mut self) -> ::std::string::String {
            self.node_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string node_group_name = 3;

        pub fn node_group_name(&self) -> &str {
            match self.node_group_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_node_group_name(&mut self) {
            self.node_group_name = ::std::option::Option::None;
        }

        pub fn has_node_group_name(&self) -> bool {
            self.node_group_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_node_group_name(&mut self, v: ::std::string::String) {
            self.node_group_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_node_group_name(&mut self) -> &mut ::std::string::String {
            if self.node_group_name.is_none() {
                self.node_group_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.node_group_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_node_group_name(&mut self) -> ::std::string::String {
            self.node_group_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team_id_1 = 4;

        pub fn team_id_1(&self) -> u32 {
            self.team_id_1.unwrap_or(0)
        }

        pub fn clear_team_id_1(&mut self) {
            self.team_id_1 = ::std::option::Option::None;
        }

        pub fn has_team_id_1(&self) -> bool {
            self.team_id_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id_1(&mut self, v: u32) {
            self.team_id_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id_2 = 5;

        pub fn team_id_2(&self) -> u32 {
            self.team_id_2.unwrap_or(0)
        }

        pub fn clear_team_id_2(&mut self) {
            self.team_id_2 = ::std::option::Option::None;
        }

        pub fn has_team_id_2(&self) -> bool {
            self.team_id_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id_2(&mut self, v: u32) {
            self.team_id_2 = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for NodeInfo {
        const NAME: &'static str = "NodeInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.node_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.node_group_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.team_id_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.team_id_2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.node_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.node_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.node_group_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.team_id_1 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.team_id_2 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.node_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.node_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.node_group_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.team_id_1 {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.team_id_2 {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NodeInfo {
            NodeInfo::new()
        }

        fn clear(&mut self) {
            self.node_id = ::std::option::Option::None;
            self.node_name = ::std::option::Option::None;
            self.node_group_name = ::std::option::Option::None;
            self.team_id_1 = ::std::option::Option::None;
            self.team_id_2 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NodeInfo {
            static instance: NodeInfo = NodeInfo {
                node_id: ::std::option::Option::None,
                node_name: ::std::option::Option::None,
                node_group_name: ::std::option::Option::None,
                team_id_1: ::std::option::Option::None,
                team_id_2: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTALeagueNodeResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALeagueNodeResults {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.node_results)
    pub node_results: ::std::vec::Vec<cmsg_dotaleague_node_results::Result>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTALeagueNodeResults.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALeagueNodeResults {
    fn default() -> &'a CMsgDOTALeagueNodeResults {
        <CMsgDOTALeagueNodeResults as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALeagueNodeResults {
    pub fn new() -> CMsgDOTALeagueNodeResults {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTALeagueNodeResults {
    const NAME: &'static str = "CMsgDOTALeagueNodeResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.node_results.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.node_results {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.node_results {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALeagueNodeResults {
        CMsgDOTALeagueNodeResults::new()
    }

    fn clear(&mut self) {
        self.node_results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALeagueNodeResults {
        static instance: CMsgDOTALeagueNodeResults = CMsgDOTALeagueNodeResults {
            node_results: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTALeagueNodeResults`
pub mod cmsg_dotaleague_node_results {
    // @@protoc_insertion_point(message:CMsgDOTALeagueNodeResults.Result)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Result {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.node_id)
        pub node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.winning_node_id)
        pub winning_node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.losing_node_id)
        pub losing_node_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.incoming_node_id_1)
        pub incoming_node_id_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.incoming_node_id_2)
        pub incoming_node_id_2: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.team_id_1)
        pub team_id_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.team_id_2)
        pub team_id_2: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.team_1_name)
        pub team_1_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.team_2_name)
        pub team_2_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.team_1_wins)
        pub team_1_wins: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.team_2_wins)
        pub team_2_wins: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.winning_team_id)
        pub winning_team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.losing_team_id)
        pub losing_team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.has_started)
        pub has_started: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.is_completed)
        pub is_completed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.scheduled_time)
        pub scheduled_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALeagueNodeResults.Result.match_ids)
        pub match_ids: ::std::vec::Vec<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTALeagueNodeResults.Result.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Result {
        fn default() -> &'a Result {
            <Result as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Result {
        pub fn new() -> Result {
            ::std::default::Default::default()
        }

        // optional uint32 node_id = 1;

        pub fn node_id(&self) -> u32 {
            self.node_id.unwrap_or(0)
        }

        pub fn clear_node_id(&mut self) {
            self.node_id = ::std::option::Option::None;
        }

        pub fn has_node_id(&self) -> bool {
            self.node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_node_id(&mut self, v: u32) {
            self.node_id = ::std::option::Option::Some(v);
        }

        // optional uint32 winning_node_id = 2;

        pub fn winning_node_id(&self) -> u32 {
            self.winning_node_id.unwrap_or(0)
        }

        pub fn clear_winning_node_id(&mut self) {
            self.winning_node_id = ::std::option::Option::None;
        }

        pub fn has_winning_node_id(&self) -> bool {
            self.winning_node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_winning_node_id(&mut self, v: u32) {
            self.winning_node_id = ::std::option::Option::Some(v);
        }

        // optional uint32 losing_node_id = 3;

        pub fn losing_node_id(&self) -> u32 {
            self.losing_node_id.unwrap_or(0)
        }

        pub fn clear_losing_node_id(&mut self) {
            self.losing_node_id = ::std::option::Option::None;
        }

        pub fn has_losing_node_id(&self) -> bool {
            self.losing_node_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_losing_node_id(&mut self, v: u32) {
            self.losing_node_id = ::std::option::Option::Some(v);
        }

        // optional uint32 incoming_node_id_1 = 4;

        pub fn incoming_node_id_1(&self) -> u32 {
            self.incoming_node_id_1.unwrap_or(0)
        }

        pub fn clear_incoming_node_id_1(&mut self) {
            self.incoming_node_id_1 = ::std::option::Option::None;
        }

        pub fn has_incoming_node_id_1(&self) -> bool {
            self.incoming_node_id_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_incoming_node_id_1(&mut self, v: u32) {
            self.incoming_node_id_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 incoming_node_id_2 = 5;

        pub fn incoming_node_id_2(&self) -> u32 {
            self.incoming_node_id_2.unwrap_or(0)
        }

        pub fn clear_incoming_node_id_2(&mut self) {
            self.incoming_node_id_2 = ::std::option::Option::None;
        }

        pub fn has_incoming_node_id_2(&self) -> bool {
            self.incoming_node_id_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_incoming_node_id_2(&mut self, v: u32) {
            self.incoming_node_id_2 = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id_1 = 6;

        pub fn team_id_1(&self) -> u32 {
            self.team_id_1.unwrap_or(0)
        }

        pub fn clear_team_id_1(&mut self) {
            self.team_id_1 = ::std::option::Option::None;
        }

        pub fn has_team_id_1(&self) -> bool {
            self.team_id_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id_1(&mut self, v: u32) {
            self.team_id_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id_2 = 7;

        pub fn team_id_2(&self) -> u32 {
            self.team_id_2.unwrap_or(0)
        }

        pub fn clear_team_id_2(&mut self) {
            self.team_id_2 = ::std::option::Option::None;
        }

        pub fn has_team_id_2(&self) -> bool {
            self.team_id_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id_2(&mut self, v: u32) {
            self.team_id_2 = ::std::option::Option::Some(v);
        }

        // optional string team_1_name = 8;

        pub fn team_1_name(&self) -> &str {
            match self.team_1_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_1_name(&mut self) {
            self.team_1_name = ::std::option::Option::None;
        }

        pub fn has_team_1_name(&self) -> bool {
            self.team_1_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_1_name(&mut self, v: ::std::string::String) {
            self.team_1_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_1_name(&mut self) -> &mut ::std::string::String {
            if self.team_1_name.is_none() {
                self.team_1_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_1_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_1_name(&mut self) -> ::std::string::String {
            self.team_1_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string team_2_name = 9;

        pub fn team_2_name(&self) -> &str {
            match self.team_2_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_2_name(&mut self) {
            self.team_2_name = ::std::option::Option::None;
        }

        pub fn has_team_2_name(&self) -> bool {
            self.team_2_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_2_name(&mut self, v: ::std::string::String) {
            self.team_2_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_2_name(&mut self) -> &mut ::std::string::String {
            if self.team_2_name.is_none() {
                self.team_2_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_2_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_2_name(&mut self) -> ::std::string::String {
            self.team_2_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 team_1_wins = 10;

        pub fn team_1_wins(&self) -> u32 {
            self.team_1_wins.unwrap_or(0)
        }

        pub fn clear_team_1_wins(&mut self) {
            self.team_1_wins = ::std::option::Option::None;
        }

        pub fn has_team_1_wins(&self) -> bool {
            self.team_1_wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_1_wins(&mut self, v: u32) {
            self.team_1_wins = ::std::option::Option::Some(v);
        }

        // optional uint32 team_2_wins = 11;

        pub fn team_2_wins(&self) -> u32 {
            self.team_2_wins.unwrap_or(0)
        }

        pub fn clear_team_2_wins(&mut self) {
            self.team_2_wins = ::std::option::Option::None;
        }

        pub fn has_team_2_wins(&self) -> bool {
            self.team_2_wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_2_wins(&mut self, v: u32) {
            self.team_2_wins = ::std::option::Option::Some(v);
        }

        // optional uint32 winning_team_id = 12;

        pub fn winning_team_id(&self) -> u32 {
            self.winning_team_id.unwrap_or(0)
        }

        pub fn clear_winning_team_id(&mut self) {
            self.winning_team_id = ::std::option::Option::None;
        }

        pub fn has_winning_team_id(&self) -> bool {
            self.winning_team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_winning_team_id(&mut self, v: u32) {
            self.winning_team_id = ::std::option::Option::Some(v);
        }

        // optional uint32 losing_team_id = 13;

        pub fn losing_team_id(&self) -> u32 {
            self.losing_team_id.unwrap_or(0)
        }

        pub fn clear_losing_team_id(&mut self) {
            self.losing_team_id = ::std::option::Option::None;
        }

        pub fn has_losing_team_id(&self) -> bool {
            self.losing_team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_losing_team_id(&mut self, v: u32) {
            self.losing_team_id = ::std::option::Option::Some(v);
        }

        // optional bool has_started = 14;

        pub fn has_started(&self) -> bool {
            self.has_started.unwrap_or(false)
        }

        pub fn clear_has_started(&mut self) {
            self.has_started = ::std::option::Option::None;
        }

        pub fn has_has_started(&self) -> bool {
            self.has_started.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_started(&mut self, v: bool) {
            self.has_started = ::std::option::Option::Some(v);
        }

        // optional bool is_completed = 15;

        pub fn is_completed(&self) -> bool {
            self.is_completed.unwrap_or(false)
        }

        pub fn clear_is_completed(&mut self) {
            self.is_completed = ::std::option::Option::None;
        }

        pub fn has_is_completed(&self) -> bool {
            self.is_completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_completed(&mut self, v: bool) {
            self.is_completed = ::std::option::Option::Some(v);
        }

        // optional uint32 scheduled_time = 16;

        pub fn scheduled_time(&self) -> u32 {
            self.scheduled_time.unwrap_or(0)
        }

        pub fn clear_scheduled_time(&mut self) {
            self.scheduled_time = ::std::option::Option::None;
        }

        pub fn has_scheduled_time(&self) -> bool {
            self.scheduled_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scheduled_time(&mut self, v: u32) {
            self.scheduled_time = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Result {
        const NAME: &'static str = "Result";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.winning_node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.losing_node_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.incoming_node_id_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.incoming_node_id_2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.team_id_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.team_id_2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    66 => {
                        self.team_1_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    74 => {
                        self.team_2_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    80 => {
                        self.team_1_wins = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.team_2_wins = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.winning_team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.losing_team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.has_started = ::std::option::Option::Some(is.read_bool()?);
                    },
                    120 => {
                        self.is_completed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    128 => {
                        self.scheduled_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    138 => {
                        is.read_repeated_packed_uint64_into(&mut self.match_ids)?;
                    },
                    136 => {
                        self.match_ids.push(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.node_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.winning_node_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.losing_node_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.incoming_node_id_1 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.incoming_node_id_2 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.team_id_1 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.team_id_2 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.team_1_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.team_2_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(9, &v);
            }
            if let Some(v) = self.team_1_wins {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.team_2_wins {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.winning_team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.losing_team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.has_started {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_completed {
                my_size += 1 + 1;
            }
            if let Some(v) = self.scheduled_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
            }
            for value in &self.match_ids {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(17, *value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.node_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.winning_node_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.losing_node_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.incoming_node_id_1 {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.incoming_node_id_2 {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.team_id_1 {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.team_id_2 {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.team_1_name.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.team_2_name.as_ref() {
                os.write_string(9, v)?;
            }
            if let Some(v) = self.team_1_wins {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.team_2_wins {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.winning_team_id {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.losing_team_id {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.has_started {
                os.write_bool(14, v)?;
            }
            if let Some(v) = self.is_completed {
                os.write_bool(15, v)?;
            }
            if let Some(v) = self.scheduled_time {
                os.write_uint32(16, v)?;
            }
            for v in &self.match_ids {
                os.write_uint64(17, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Result {
            Result::new()
        }

        fn clear(&mut self) {
            self.node_id = ::std::option::Option::None;
            self.winning_node_id = ::std::option::Option::None;
            self.losing_node_id = ::std::option::Option::None;
            self.incoming_node_id_1 = ::std::option::Option::None;
            self.incoming_node_id_2 = ::std::option::Option::None;
            self.team_id_1 = ::std::option::Option::None;
            self.team_id_2 = ::std::option::Option::None;
            self.team_1_name = ::std::option::Option::None;
            self.team_2_name = ::std::option::Option::None;
            self.team_1_wins = ::std::option::Option::None;
            self.team_2_wins = ::std::option::Option::None;
            self.winning_team_id = ::std::option::Option::None;
            self.losing_team_id = ::std::option::Option::None;
            self.has_started = ::std::option::Option::None;
            self.is_completed = ::std::option::Option::None;
            self.scheduled_time = ::std::option::Option::None;
            self.match_ids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Result {
            static instance: Result = Result {
                node_id: ::std::option::Option::None,
                winning_node_id: ::std::option::Option::None,
                losing_node_id: ::std::option::Option::None,
                incoming_node_id_1: ::std::option::Option::None,
                incoming_node_id_2: ::std::option::Option::None,
                team_id_1: ::std::option::Option::None,
                team_id_2: ::std::option::Option::None,
                team_1_name: ::std::option::Option::None,
                team_2_name: ::std::option::Option::None,
                team_1_wins: ::std::option::Option::None,
                team_2_wins: ::std::option::Option::None,
                winning_team_id: ::std::option::Option::None,
                losing_team_id: ::std::option::Option::None,
                has_started: ::std::option::Option::None,
                is_completed: ::std::option::Option::None,
                scheduled_time: ::std::option::Option::None,
                match_ids: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTADPCLeagueResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTADPCLeagueResults {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTADPCLeagueResults.results)
    pub results: ::std::vec::Vec<cmsg_dotadpcleague_results::Result>,
    // @@protoc_insertion_point(field:CMsgDOTADPCLeagueResults.points)
    pub points: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgDOTADPCLeagueResults.dollars)
    pub dollars: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTADPCLeagueResults.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTADPCLeagueResults {
    fn default() -> &'a CMsgDOTADPCLeagueResults {
        <CMsgDOTADPCLeagueResults as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTADPCLeagueResults {
    pub fn new() -> CMsgDOTADPCLeagueResults {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTADPCLeagueResults {
    const NAME: &'static str = "CMsgDOTADPCLeagueResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.points)?;
                },
                16 => {
                    self.points.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.dollars)?;
                },
                24 => {
                    self.dollars.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.dollars {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.results {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.points {
            os.write_uint32(2, *v)?;
        };
        for v in &self.dollars {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTADPCLeagueResults {
        CMsgDOTADPCLeagueResults::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.points.clear();
        self.dollars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTADPCLeagueResults {
        static instance: CMsgDOTADPCLeagueResults = CMsgDOTADPCLeagueResults {
            results: ::std::vec::Vec::new(),
            points: ::std::vec::Vec::new(),
            dollars: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTADPCLeagueResults`
pub mod cmsg_dotadpcleague_results {
    // @@protoc_insertion_point(message:CMsgDOTADPCLeagueResults.Result)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Result {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTADPCLeagueResults.Result.standing)
        pub standing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCLeagueResults.Result.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCLeagueResults.Result.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTADPCLeagueResults.Result.team_logo)
        pub team_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTADPCLeagueResults.Result.team_logo_url)
        pub team_logo_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTADPCLeagueResults.Result.points)
        pub points: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCLeagueResults.Result.earnings)
        pub earnings: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCLeagueResults.Result.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCLeagueResults.Result.phase)
        pub phase: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeaguePhase>>,
        // @@protoc_insertion_point(field:CMsgDOTADPCLeagueResults.Result.team_abbreviation)
        pub team_abbreviation: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTADPCLeagueResults.Result.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Result {
        fn default() -> &'a Result {
            <Result as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Result {
        pub fn new() -> Result {
            ::std::default::Default::default()
        }

        // optional uint32 standing = 1;

        pub fn standing(&self) -> u32 {
            self.standing.unwrap_or(0)
        }

        pub fn clear_standing(&mut self) {
            self.standing = ::std::option::Option::None;
        }

        pub fn has_standing(&self) -> bool {
            self.standing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_standing(&mut self, v: u32) {
            self.standing = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id = 2;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 3;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 team_logo = 4;

        pub fn team_logo(&self) -> u64 {
            self.team_logo.unwrap_or(0)
        }

        pub fn clear_team_logo(&mut self) {
            self.team_logo = ::std::option::Option::None;
        }

        pub fn has_team_logo(&self) -> bool {
            self.team_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo(&mut self, v: u64) {
            self.team_logo = ::std::option::Option::Some(v);
        }

        // optional string team_logo_url = 5;

        pub fn team_logo_url(&self) -> &str {
            match self.team_logo_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_logo_url(&mut self) {
            self.team_logo_url = ::std::option::Option::None;
        }

        pub fn has_team_logo_url(&self) -> bool {
            self.team_logo_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo_url(&mut self, v: ::std::string::String) {
            self.team_logo_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_logo_url(&mut self) -> &mut ::std::string::String {
            if self.team_logo_url.is_none() {
                self.team_logo_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_logo_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_logo_url(&mut self) -> ::std::string::String {
            self.team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 points = 6;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }

        // optional uint32 earnings = 7;

        pub fn earnings(&self) -> u32 {
            self.earnings.unwrap_or(0)
        }

        pub fn clear_earnings(&mut self) {
            self.earnings = ::std::option::Option::None;
        }

        pub fn has_earnings(&self) -> bool {
            self.earnings.is_some()
        }

        // Param is passed by value, moved
        pub fn set_earnings(&mut self, v: u32) {
            self.earnings = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 8;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional .ELeaguePhase phase = 9;

        pub fn phase(&self) -> super::super::dota_shared_enums::ELeaguePhase {
            match self.phase {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeaguePhase::LEAGUE_PHASE_UNSET),
                None => super::super::dota_shared_enums::ELeaguePhase::LEAGUE_PHASE_UNSET,
            }
        }

        pub fn clear_phase(&mut self) {
            self.phase = ::std::option::Option::None;
        }

        pub fn has_phase(&self) -> bool {
            self.phase.is_some()
        }

        // Param is passed by value, moved
        pub fn set_phase(&mut self, v: super::super::dota_shared_enums::ELeaguePhase) {
            self.phase = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional string team_abbreviation = 10;

        pub fn team_abbreviation(&self) -> &str {
            match self.team_abbreviation.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_abbreviation(&mut self) {
            self.team_abbreviation = ::std::option::Option::None;
        }

        pub fn has_team_abbreviation(&self) -> bool {
            self.team_abbreviation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_abbreviation(&mut self, v: ::std::string::String) {
            self.team_abbreviation = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_abbreviation(&mut self) -> &mut ::std::string::String {
            if self.team_abbreviation.is_none() {
                self.team_abbreviation = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_abbreviation.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_abbreviation(&mut self) -> ::std::string::String {
            self.team_abbreviation.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Result {
        const NAME: &'static str = "Result";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.standing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.team_logo = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    42 => {
                        self.team_logo_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.earnings = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.phase = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    82 => {
                        self.team_abbreviation = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.standing {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.team_logo {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.earnings {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.phase {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v.value());
            }
            if let Some(v) = self.team_abbreviation.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.standing {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.team_logo {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.earnings {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.phase {
                os.write_enum(9, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.team_abbreviation.as_ref() {
                os.write_string(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Result {
            Result::new()
        }

        fn clear(&mut self) {
            self.standing = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.team_logo = ::std::option::Option::None;
            self.team_logo_url = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.earnings = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.phase = ::std::option::Option::None;
            self.team_abbreviation = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Result {
            static instance: Result = Result {
                standing: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                team_logo: ::std::option::Option::None,
                team_logo_url: ::std::option::Option::None,
                points: ::std::option::Option::None,
                earnings: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                phase: ::std::option::Option::None,
                team_abbreviation: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTADPCTeamResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTADPCTeamResults {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTADPCTeamResults.results)
    pub results: ::std::vec::Vec<cmsg_dotadpcteam_results::Result>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTADPCTeamResults.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTADPCTeamResults {
    fn default() -> &'a CMsgDOTADPCTeamResults {
        <CMsgDOTADPCTeamResults as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTADPCTeamResults {
    pub fn new() -> CMsgDOTADPCTeamResults {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTADPCTeamResults {
    const NAME: &'static str = "CMsgDOTADPCTeamResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.results {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTADPCTeamResults {
        CMsgDOTADPCTeamResults::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTADPCTeamResults {
        static instance: CMsgDOTADPCTeamResults = CMsgDOTADPCTeamResults {
            results: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTADPCTeamResults`
pub mod cmsg_dotadpcteam_results {
    // @@protoc_insertion_point(message:CMsgDOTADPCTeamResults.Result)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Result {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTADPCTeamResults.Result.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCTeamResults.Result.standing)
        pub standing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCTeamResults.Result.points)
        pub points: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCTeamResults.Result.earnings)
        pub earnings: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCTeamResults.Result.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTADPCTeamResults.Result.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Result {
        fn default() -> &'a Result {
            <Result as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Result {
        pub fn new() -> Result {
            ::std::default::Default::default()
        }

        // optional uint32 league_id = 1;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional uint32 standing = 2;

        pub fn standing(&self) -> u32 {
            self.standing.unwrap_or(0)
        }

        pub fn clear_standing(&mut self) {
            self.standing = ::std::option::Option::None;
        }

        pub fn has_standing(&self) -> bool {
            self.standing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_standing(&mut self, v: u32) {
            self.standing = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 3;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }

        // optional uint32 earnings = 4;

        pub fn earnings(&self) -> u32 {
            self.earnings.unwrap_or(0)
        }

        pub fn clear_earnings(&mut self) {
            self.earnings = ::std::option::Option::None;
        }

        pub fn has_earnings(&self) -> bool {
            self.earnings.is_some()
        }

        // Param is passed by value, moved
        pub fn set_earnings(&mut self, v: u32) {
            self.earnings = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 5;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Result {
        const NAME: &'static str = "Result";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.standing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.earnings = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.league_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.standing {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.earnings {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.league_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.standing {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.earnings {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Result {
            Result::new()
        }

        fn clear(&mut self) {
            self.league_id = ::std::option::Option::None;
            self.standing = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.earnings = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Result {
            static instance: Result = Result {
                league_id: ::std::option::Option::None,
                standing: ::std::option::Option::None,
                points: ::std::option::Option::None,
                earnings: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTADPCSeasonResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTADPCSeasonResults {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.results)
    pub results: ::std::vec::Vec<cmsg_dotadpcseason_results::TeamResult>,
    // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.standings)
    pub standings: ::std::vec::Vec<cmsg_dotadpcseason_results::Standing>,
    // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.major_wildcard_standings)
    pub major_wildcard_standings: ::std::vec::Vec<cmsg_dotadpcseason_results::StandingEntry>,
    // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.major_group_standings)
    pub major_group_standings: ::std::vec::Vec<cmsg_dotadpcseason_results::StandingEntry>,
    // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.major_playoff_standings)
    pub major_playoff_standings: ::std::vec::Vec<cmsg_dotadpcseason_results::StandingEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTADPCSeasonResults.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTADPCSeasonResults {
    fn default() -> &'a CMsgDOTADPCSeasonResults {
        <CMsgDOTADPCSeasonResults as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTADPCSeasonResults {
    pub fn new() -> CMsgDOTADPCSeasonResults {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTADPCSeasonResults {
    const NAME: &'static str = "CMsgDOTADPCSeasonResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                18 => {
                    self.standings.push(is.read_message()?);
                },
                26 => {
                    self.major_wildcard_standings.push(is.read_message()?);
                },
                34 => {
                    self.major_group_standings.push(is.read_message()?);
                },
                42 => {
                    self.major_playoff_standings.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.standings {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.major_wildcard_standings {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.major_group_standings {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.major_playoff_standings {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.results {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.standings {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.major_wildcard_standings {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.major_group_standings {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.major_playoff_standings {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTADPCSeasonResults {
        CMsgDOTADPCSeasonResults::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.standings.clear();
        self.major_wildcard_standings.clear();
        self.major_group_standings.clear();
        self.major_playoff_standings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTADPCSeasonResults {
        static instance: CMsgDOTADPCSeasonResults = CMsgDOTADPCSeasonResults {
            results: ::std::vec::Vec::new(),
            standings: ::std::vec::Vec::new(),
            major_wildcard_standings: ::std::vec::Vec::new(),
            major_group_standings: ::std::vec::Vec::new(),
            major_playoff_standings: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTADPCSeasonResults`
pub mod cmsg_dotadpcseason_results {
    // @@protoc_insertion_point(message:CMsgDOTADPCSeasonResults.TeamLeagueResult)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamLeagueResult {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.TeamLeagueResult.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.TeamLeagueResult.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.TeamLeagueResult.standing)
        pub standing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.TeamLeagueResult.points)
        pub points: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.TeamLeagueResult.earnings)
        pub earnings: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.TeamLeagueResult.audit_action)
        pub audit_action: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.TeamLeagueResult.audit_data)
        pub audit_data: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTADPCSeasonResults.TeamLeagueResult.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamLeagueResult {
        fn default() -> &'a TeamLeagueResult {
            <TeamLeagueResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TeamLeagueResult {
        pub fn new() -> TeamLeagueResult {
            ::std::default::Default::default()
        }

        // optional uint32 timestamp = 1;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 league_id = 2;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional uint32 standing = 3;

        pub fn standing(&self) -> u32 {
            self.standing.unwrap_or(0)
        }

        pub fn clear_standing(&mut self) {
            self.standing = ::std::option::Option::None;
        }

        pub fn has_standing(&self) -> bool {
            self.standing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_standing(&mut self, v: u32) {
            self.standing = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 4;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }

        // optional uint32 earnings = 5;

        pub fn earnings(&self) -> u32 {
            self.earnings.unwrap_or(0)
        }

        pub fn clear_earnings(&mut self) {
            self.earnings = ::std::option::Option::None;
        }

        pub fn has_earnings(&self) -> bool {
            self.earnings.is_some()
        }

        // Param is passed by value, moved
        pub fn set_earnings(&mut self, v: u32) {
            self.earnings = ::std::option::Option::Some(v);
        }

        // optional uint32 audit_action = 6;

        pub fn audit_action(&self) -> u32 {
            self.audit_action.unwrap_or(0)
        }

        pub fn clear_audit_action(&mut self) {
            self.audit_action = ::std::option::Option::None;
        }

        pub fn has_audit_action(&self) -> bool {
            self.audit_action.is_some()
        }

        // Param is passed by value, moved
        pub fn set_audit_action(&mut self, v: u32) {
            self.audit_action = ::std::option::Option::Some(v);
        }

        // optional uint32 audit_data = 7;

        pub fn audit_data(&self) -> u32 {
            self.audit_data.unwrap_or(0)
        }

        pub fn clear_audit_data(&mut self) {
            self.audit_data = ::std::option::Option::None;
        }

        pub fn has_audit_data(&self) -> bool {
            self.audit_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_audit_data(&mut self, v: u32) {
            self.audit_data = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TeamLeagueResult {
        const NAME: &'static str = "TeamLeagueResult";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.standing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.earnings = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.audit_action = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.audit_data = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.league_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.standing {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.earnings {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.audit_action {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.audit_data {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.timestamp {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.league_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.standing {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.earnings {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.audit_action {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.audit_data {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamLeagueResult {
            TeamLeagueResult::new()
        }

        fn clear(&mut self) {
            self.timestamp = ::std::option::Option::None;
            self.league_id = ::std::option::Option::None;
            self.standing = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.earnings = ::std::option::Option::None;
            self.audit_action = ::std::option::Option::None;
            self.audit_data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamLeagueResult {
            static instance: TeamLeagueResult = TeamLeagueResult {
                timestamp: ::std::option::Option::None,
                league_id: ::std::option::Option::None,
                standing: ::std::option::Option::None,
                points: ::std::option::Option::None,
                earnings: ::std::option::Option::None,
                audit_action: ::std::option::Option::None,
                audit_data: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTADPCSeasonResults.TeamResult)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamResult {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.TeamResult.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.TeamResult.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.TeamResult.team_abbreviation)
        pub team_abbreviation: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.TeamResult.team_logo)
        pub team_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.TeamResult.team_logo_url)
        pub team_logo_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.TeamResult.total_points)
        pub total_points: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.TeamResult.total_earnings)
        pub total_earnings: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.TeamResult.league_results)
        pub league_results: ::std::vec::Vec<TeamLeagueResult>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTADPCSeasonResults.TeamResult.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamResult {
        fn default() -> &'a TeamResult {
            <TeamResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TeamResult {
        pub fn new() -> TeamResult {
            ::std::default::Default::default()
        }

        // optional uint32 team_id = 1;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 2;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string team_abbreviation = 8;

        pub fn team_abbreviation(&self) -> &str {
            match self.team_abbreviation.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_abbreviation(&mut self) {
            self.team_abbreviation = ::std::option::Option::None;
        }

        pub fn has_team_abbreviation(&self) -> bool {
            self.team_abbreviation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_abbreviation(&mut self, v: ::std::string::String) {
            self.team_abbreviation = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_abbreviation(&mut self) -> &mut ::std::string::String {
            if self.team_abbreviation.is_none() {
                self.team_abbreviation = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_abbreviation.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_abbreviation(&mut self) -> ::std::string::String {
            self.team_abbreviation.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 team_logo = 3;

        pub fn team_logo(&self) -> u64 {
            self.team_logo.unwrap_or(0)
        }

        pub fn clear_team_logo(&mut self) {
            self.team_logo = ::std::option::Option::None;
        }

        pub fn has_team_logo(&self) -> bool {
            self.team_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo(&mut self, v: u64) {
            self.team_logo = ::std::option::Option::Some(v);
        }

        // optional string team_logo_url = 4;

        pub fn team_logo_url(&self) -> &str {
            match self.team_logo_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_logo_url(&mut self) {
            self.team_logo_url = ::std::option::Option::None;
        }

        pub fn has_team_logo_url(&self) -> bool {
            self.team_logo_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo_url(&mut self, v: ::std::string::String) {
            self.team_logo_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_logo_url(&mut self) -> &mut ::std::string::String {
            if self.team_logo_url.is_none() {
                self.team_logo_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_logo_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_logo_url(&mut self) -> ::std::string::String {
            self.team_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 total_points = 5;

        pub fn total_points(&self) -> u32 {
            self.total_points.unwrap_or(0)
        }

        pub fn clear_total_points(&mut self) {
            self.total_points = ::std::option::Option::None;
        }

        pub fn has_total_points(&self) -> bool {
            self.total_points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_points(&mut self, v: u32) {
            self.total_points = ::std::option::Option::Some(v);
        }

        // optional uint32 total_earnings = 6;

        pub fn total_earnings(&self) -> u32 {
            self.total_earnings.unwrap_or(0)
        }

        pub fn clear_total_earnings(&mut self) {
            self.total_earnings = ::std::option::Option::None;
        }

        pub fn has_total_earnings(&self) -> bool {
            self.total_earnings.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_earnings(&mut self, v: u32) {
            self.total_earnings = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TeamResult {
        const NAME: &'static str = "TeamResult";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.team_abbreviation = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.team_logo = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    34 => {
                        self.team_logo_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.total_points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.total_earnings = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    58 => {
                        self.league_results.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.team_abbreviation.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.team_logo {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.total_points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.total_earnings {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            for value in &self.league_results {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.team_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.team_abbreviation.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.team_logo {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.team_logo_url.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.total_points {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.total_earnings {
                os.write_uint32(6, v)?;
            }
            for v in &self.league_results {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamResult {
            TeamResult::new()
        }

        fn clear(&mut self) {
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.team_abbreviation = ::std::option::Option::None;
            self.team_logo = ::std::option::Option::None;
            self.team_logo_url = ::std::option::Option::None;
            self.total_points = ::std::option::Option::None;
            self.total_earnings = ::std::option::Option::None;
            self.league_results.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamResult {
            static instance: TeamResult = TeamResult {
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                team_abbreviation: ::std::option::Option::None,
                team_logo: ::std::option::Option::None,
                team_logo_url: ::std::option::Option::None,
                total_points: ::std::option::Option::None,
                total_earnings: ::std::option::Option::None,
                league_results: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTADPCSeasonResults.StandingEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StandingEntry {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.StandingEntry.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.StandingEntry.wins)
        pub wins: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.StandingEntry.losses)
        pub losses: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.StandingEntry.team_url)
        pub team_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.StandingEntry.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.StandingEntry.team_abbreviation)
        pub team_abbreviation: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTADPCSeasonResults.StandingEntry.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StandingEntry {
        fn default() -> &'a StandingEntry {
            <StandingEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl StandingEntry {
        pub fn new() -> StandingEntry {
            ::std::default::Default::default()
        }

        // optional uint32 team_id = 1;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional uint32 wins = 2;

        pub fn wins(&self) -> u32 {
            self.wins.unwrap_or(0)
        }

        pub fn clear_wins(&mut self) {
            self.wins = ::std::option::Option::None;
        }

        pub fn has_wins(&self) -> bool {
            self.wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wins(&mut self, v: u32) {
            self.wins = ::std::option::Option::Some(v);
        }

        // optional uint32 losses = 3;

        pub fn losses(&self) -> u32 {
            self.losses.unwrap_or(0)
        }

        pub fn clear_losses(&mut self) {
            self.losses = ::std::option::Option::None;
        }

        pub fn has_losses(&self) -> bool {
            self.losses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_losses(&mut self, v: u32) {
            self.losses = ::std::option::Option::Some(v);
        }

        // optional string team_url = 4;

        pub fn team_url(&self) -> &str {
            match self.team_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_url(&mut self) {
            self.team_url = ::std::option::Option::None;
        }

        pub fn has_team_url(&self) -> bool {
            self.team_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_url(&mut self, v: ::std::string::String) {
            self.team_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_url(&mut self) -> &mut ::std::string::String {
            if self.team_url.is_none() {
                self.team_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_url(&mut self) -> ::std::string::String {
            self.team_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string team_name = 5;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string team_abbreviation = 6;

        pub fn team_abbreviation(&self) -> &str {
            match self.team_abbreviation.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_abbreviation(&mut self) {
            self.team_abbreviation = ::std::option::Option::None;
        }

        pub fn has_team_abbreviation(&self) -> bool {
            self.team_abbreviation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_abbreviation(&mut self, v: ::std::string::String) {
            self.team_abbreviation = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_abbreviation(&mut self) -> &mut ::std::string::String {
            if self.team_abbreviation.is_none() {
                self.team_abbreviation = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_abbreviation.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_abbreviation(&mut self) -> ::std::string::String {
            self.team_abbreviation.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for StandingEntry {
        const NAME: &'static str = "StandingEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.wins = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.losses = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.team_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.team_abbreviation = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.wins {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.losses {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.team_url.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.team_abbreviation.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.team_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.wins {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.losses {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.team_url.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.team_abbreviation.as_ref() {
                os.write_string(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StandingEntry {
            StandingEntry::new()
        }

        fn clear(&mut self) {
            self.team_id = ::std::option::Option::None;
            self.wins = ::std::option::Option::None;
            self.losses = ::std::option::Option::None;
            self.team_url = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.team_abbreviation = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StandingEntry {
            static instance: StandingEntry = StandingEntry {
                team_id: ::std::option::Option::None,
                wins: ::std::option::Option::None,
                losses: ::std::option::Option::None,
                team_url: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                team_abbreviation: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTADPCSeasonResults.Standing)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Standing {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.Standing.region)
        pub region: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueRegion>>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.Standing.division)
        pub division: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::ELeagueDivision>>,
        // @@protoc_insertion_point(field:CMsgDOTADPCSeasonResults.Standing.entries)
        pub entries: ::std::vec::Vec<StandingEntry>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTADPCSeasonResults.Standing.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Standing {
        fn default() -> &'a Standing {
            <Standing as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Standing {
        pub fn new() -> Standing {
            ::std::default::Default::default()
        }

        // optional .ELeagueRegion region = 1;

        pub fn region(&self) -> super::super::dota_shared_enums::ELeagueRegion {
            match self.region {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET),
                None => super::super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET,
            }
        }

        pub fn clear_region(&mut self) {
            self.region = ::std::option::Option::None;
        }

        pub fn has_region(&self) -> bool {
            self.region.is_some()
        }

        // Param is passed by value, moved
        pub fn set_region(&mut self, v: super::super::dota_shared_enums::ELeagueRegion) {
            self.region = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional .ELeagueDivision division = 2;

        pub fn division(&self) -> super::super::dota_shared_enums::ELeagueDivision {
            match self.division {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::ELeagueDivision::LEAGUE_DIVISION_UNSET),
                None => super::super::dota_shared_enums::ELeagueDivision::LEAGUE_DIVISION_UNSET,
            }
        }

        pub fn clear_division(&mut self) {
            self.division = ::std::option::Option::None;
        }

        pub fn has_division(&self) -> bool {
            self.division.is_some()
        }

        // Param is passed by value, moved
        pub fn set_division(&mut self, v: super::super::dota_shared_enums::ELeagueDivision) {
            self.division = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Standing {
        const NAME: &'static str = "Standing";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.region = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.division = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    26 => {
                        self.entries.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.region {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.division {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            for value in &self.entries {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.region {
                os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.division {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            for v in &self.entries {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Standing {
            Standing::new()
        }

        fn clear(&mut self) {
            self.region = ::std::option::Option::None;
            self.division = ::std::option::Option::None;
            self.entries.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Standing {
            static instance: Standing = Standing {
                region: ::std::option::Option::None,
                division: ::std::option::Option::None,
                entries: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTADPCSeasonSpoilerResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTADPCSeasonSpoilerResults {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTADPCSeasonSpoilerResults.time_last_updated)
    pub time_last_updated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTADPCSeasonSpoilerResults.saved_results)
    pub saved_results: ::steam_vent_proto_common::protobuf::MessageField<CMsgDOTADPCSeasonResults>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTADPCSeasonSpoilerResults.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTADPCSeasonSpoilerResults {
    fn default() -> &'a CMsgDOTADPCSeasonSpoilerResults {
        <CMsgDOTADPCSeasonSpoilerResults as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTADPCSeasonSpoilerResults {
    pub fn new() -> CMsgDOTADPCSeasonSpoilerResults {
        ::std::default::Default::default()
    }

    // optional uint32 time_last_updated = 1;

    pub fn time_last_updated(&self) -> u32 {
        self.time_last_updated.unwrap_or(0)
    }

    pub fn clear_time_last_updated(&mut self) {
        self.time_last_updated = ::std::option::Option::None;
    }

    pub fn has_time_last_updated(&self) -> bool {
        self.time_last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_updated(&mut self, v: u32) {
        self.time_last_updated = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTADPCSeasonSpoilerResults {
    const NAME: &'static str = "CMsgDOTADPCSeasonSpoilerResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.time_last_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.saved_results)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.time_last_updated {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.saved_results.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.time_last_updated {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.saved_results.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTADPCSeasonSpoilerResults {
        CMsgDOTADPCSeasonSpoilerResults::new()
    }

    fn clear(&mut self) {
        self.time_last_updated = ::std::option::Option::None;
        self.saved_results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTADPCSeasonSpoilerResults {
        static instance: CMsgDOTADPCSeasonSpoilerResults = CMsgDOTADPCSeasonSpoilerResults {
            time_last_updated: ::std::option::Option::None,
            saved_results: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ELeagueNodeGroupType)
pub enum ELeagueNodeGroupType {
    // @@protoc_insertion_point(enum_value:ELeagueNodeGroupType.INVALID_GROUP_TYPE)
    INVALID_GROUP_TYPE = 0,
    // @@protoc_insertion_point(enum_value:ELeagueNodeGroupType.ORGANIZATIONAL)
    ORGANIZATIONAL = 1,
    // @@protoc_insertion_point(enum_value:ELeagueNodeGroupType.ROUND_ROBIN)
    ROUND_ROBIN = 2,
    // @@protoc_insertion_point(enum_value:ELeagueNodeGroupType.SWISS)
    SWISS = 3,
    // @@protoc_insertion_point(enum_value:ELeagueNodeGroupType.BRACKET_SINGLE)
    BRACKET_SINGLE = 4,
    // @@protoc_insertion_point(enum_value:ELeagueNodeGroupType.BRACKET_DOUBLE_SEED_LOSER)
    BRACKET_DOUBLE_SEED_LOSER = 5,
    // @@protoc_insertion_point(enum_value:ELeagueNodeGroupType.BRACKET_DOUBLE_ALL_WINNER)
    BRACKET_DOUBLE_ALL_WINNER = 6,
    // @@protoc_insertion_point(enum_value:ELeagueNodeGroupType.SHOWMATCH)
    SHOWMATCH = 7,
    // @@protoc_insertion_point(enum_value:ELeagueNodeGroupType.GSL)
    GSL = 8,
    // @@protoc_insertion_point(enum_value:ELeagueNodeGroupType.PLACEMENT)
    PLACEMENT = 9,
}

impl ::steam_vent_proto_common::protobuf::Enum for ELeagueNodeGroupType {
    const NAME: &'static str = "ELeagueNodeGroupType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueNodeGroupType> {
        match value {
            0 => ::std::option::Option::Some(ELeagueNodeGroupType::INVALID_GROUP_TYPE),
            1 => ::std::option::Option::Some(ELeagueNodeGroupType::ORGANIZATIONAL),
            2 => ::std::option::Option::Some(ELeagueNodeGroupType::ROUND_ROBIN),
            3 => ::std::option::Option::Some(ELeagueNodeGroupType::SWISS),
            4 => ::std::option::Option::Some(ELeagueNodeGroupType::BRACKET_SINGLE),
            5 => ::std::option::Option::Some(ELeagueNodeGroupType::BRACKET_DOUBLE_SEED_LOSER),
            6 => ::std::option::Option::Some(ELeagueNodeGroupType::BRACKET_DOUBLE_ALL_WINNER),
            7 => ::std::option::Option::Some(ELeagueNodeGroupType::SHOWMATCH),
            8 => ::std::option::Option::Some(ELeagueNodeGroupType::GSL),
            9 => ::std::option::Option::Some(ELeagueNodeGroupType::PLACEMENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueNodeGroupType> {
        match str {
            "INVALID_GROUP_TYPE" => ::std::option::Option::Some(ELeagueNodeGroupType::INVALID_GROUP_TYPE),
            "ORGANIZATIONAL" => ::std::option::Option::Some(ELeagueNodeGroupType::ORGANIZATIONAL),
            "ROUND_ROBIN" => ::std::option::Option::Some(ELeagueNodeGroupType::ROUND_ROBIN),
            "SWISS" => ::std::option::Option::Some(ELeagueNodeGroupType::SWISS),
            "BRACKET_SINGLE" => ::std::option::Option::Some(ELeagueNodeGroupType::BRACKET_SINGLE),
            "BRACKET_DOUBLE_SEED_LOSER" => ::std::option::Option::Some(ELeagueNodeGroupType::BRACKET_DOUBLE_SEED_LOSER),
            "BRACKET_DOUBLE_ALL_WINNER" => ::std::option::Option::Some(ELeagueNodeGroupType::BRACKET_DOUBLE_ALL_WINNER),
            "SHOWMATCH" => ::std::option::Option::Some(ELeagueNodeGroupType::SHOWMATCH),
            "GSL" => ::std::option::Option::Some(ELeagueNodeGroupType::GSL),
            "PLACEMENT" => ::std::option::Option::Some(ELeagueNodeGroupType::PLACEMENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueNodeGroupType] = &[
        ELeagueNodeGroupType::INVALID_GROUP_TYPE,
        ELeagueNodeGroupType::ORGANIZATIONAL,
        ELeagueNodeGroupType::ROUND_ROBIN,
        ELeagueNodeGroupType::SWISS,
        ELeagueNodeGroupType::BRACKET_SINGLE,
        ELeagueNodeGroupType::BRACKET_DOUBLE_SEED_LOSER,
        ELeagueNodeGroupType::BRACKET_DOUBLE_ALL_WINNER,
        ELeagueNodeGroupType::SHOWMATCH,
        ELeagueNodeGroupType::GSL,
        ELeagueNodeGroupType::PLACEMENT,
    ];
}

impl ::std::default::Default for ELeagueNodeGroupType {
    fn default() -> Self {
        ELeagueNodeGroupType::INVALID_GROUP_TYPE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ELeagueNodeType)
pub enum ELeagueNodeType {
    // @@protoc_insertion_point(enum_value:ELeagueNodeType.INVALID_NODE_TYPE)
    INVALID_NODE_TYPE = 0,
    // @@protoc_insertion_point(enum_value:ELeagueNodeType.BEST_OF_ONE)
    BEST_OF_ONE = 1,
    // @@protoc_insertion_point(enum_value:ELeagueNodeType.BEST_OF_THREE)
    BEST_OF_THREE = 2,
    // @@protoc_insertion_point(enum_value:ELeagueNodeType.BEST_OF_FIVE)
    BEST_OF_FIVE = 3,
    // @@protoc_insertion_point(enum_value:ELeagueNodeType.BEST_OF_TWO)
    BEST_OF_TWO = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for ELeagueNodeType {
    const NAME: &'static str = "ELeagueNodeType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELeagueNodeType> {
        match value {
            0 => ::std::option::Option::Some(ELeagueNodeType::INVALID_NODE_TYPE),
            1 => ::std::option::Option::Some(ELeagueNodeType::BEST_OF_ONE),
            2 => ::std::option::Option::Some(ELeagueNodeType::BEST_OF_THREE),
            3 => ::std::option::Option::Some(ELeagueNodeType::BEST_OF_FIVE),
            4 => ::std::option::Option::Some(ELeagueNodeType::BEST_OF_TWO),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELeagueNodeType> {
        match str {
            "INVALID_NODE_TYPE" => ::std::option::Option::Some(ELeagueNodeType::INVALID_NODE_TYPE),
            "BEST_OF_ONE" => ::std::option::Option::Some(ELeagueNodeType::BEST_OF_ONE),
            "BEST_OF_THREE" => ::std::option::Option::Some(ELeagueNodeType::BEST_OF_THREE),
            "BEST_OF_FIVE" => ::std::option::Option::Some(ELeagueNodeType::BEST_OF_FIVE),
            "BEST_OF_TWO" => ::std::option::Option::Some(ELeagueNodeType::BEST_OF_TWO),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELeagueNodeType] = &[
        ELeagueNodeType::INVALID_NODE_TYPE,
        ELeagueNodeType::BEST_OF_ONE,
        ELeagueNodeType::BEST_OF_THREE,
        ELeagueNodeType::BEST_OF_FIVE,
        ELeagueNodeType::BEST_OF_TWO,
    ];
}

impl ::std::default::Default for ELeagueNodeType {
    fn default() -> Self {
        ELeagueNodeType::INVALID_NODE_TYPE
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::dota_shared_enums::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTALeagueNode {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTALeagueNodeGroup {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTALeague {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTALeagueList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTALeagueInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTALeagueInfoList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTALeagueLiveGames {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTALeagueMessages {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTALeaguePrizePool {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTALeagueInfoListAdminsRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTALeagueAvailableLobbyNodesRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTALeagueAvailableLobbyNodes {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTALeagueNodeResults {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTADPCLeagueResults {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTADPCTeamResults {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTADPCSeasonResults {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTADPCSeasonSpoilerResults {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
